<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","marcel","Documents","pendulum","node","build.rs"],"content":"use substrate_build_script_utils::{generate_cargo_keys, rerun_if_git_head_changed};\n\nfn main() {\n\tgenerate_cargo_keys();\n\n\trerun_if_git_head_changed();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","chain_spec.rs"],"content":"use cumulus_primitives_core::ParaId;\nuse runtime_common::{\n\tAccountId, AuraId, Balance, BlockNumber, Signature, EXISTENTIAL_DEPOSIT, UNIT,\n};\nuse sc_chain_spec::{ChainSpecExtension, ChainSpecGroup};\nuse sc_service::ChainType;\nuse serde::{Deserialize, Serialize};\nuse sp_core::{\n\tcrypto::{Ss58Codec, UncheckedInto},\n\tsr25519, Pair, Public,\n};\nuse sp_runtime::{\n\ttraits::{IdentifyAccount, Verify},\n\tFixedPointNumber, FixedU128, Perquintill,\n};\nuse spacewalk_primitives::{oracle::Key, Asset, CurrencyId, CurrencyId::XCM, VaultCurrencyPair};\n\nuse crate::constants::{\n\tamplitude, foucoco, pendulum, MAINNET_BRL_CURRENCY_ID, MAINNET_TZS_CURRENCY_ID,\n\tMAINNET_USDC_CURRENCY_ID,\n};\n\n/// Specialized `ChainSpec` for the normal parachain runtime.\npub type AmplitudeChainSpec =\n\tsc_service::GenericChainSpec\u003camplitude_runtime::GenesisConfig, ParachainExtensions\u003e;\n\npub type FoucocoChainSpec =\n\tsc_service::GenericChainSpec\u003cfoucoco_runtime::GenesisConfig, ParachainExtensions\u003e;\n\npub type PendulumChainSpec =\n\tsc_service::GenericChainSpec\u003cpendulum_runtime::GenesisConfig, ParachainExtensions\u003e;\n\npub type DevelopmentChainSpec =\n\tsc_service::GenericChainSpec\u003cdevelopment_runtime::GenesisConfig, ParachainExtensions\u003e;\n\n/// The default XCM version to set in genesis config.\nconst SAFE_XCM_VERSION: u32 = xcm::prelude::XCM_VERSION;\n\n/// Helper function to generate a crypto pair from seed\npub fn get_public_from_seed\u003cTPublic: Public\u003e(seed: \u0026str) -\u003e \u003cTPublic::Pair as Pair\u003e::Public {\n\t\u003cTPublic::Pair as Pair\u003e::from_string(\u0026format!(\"//{}\", seed), None)\n\t\t.expect(\"static values are valid; qed\")\n\t\t.public()\n}\n\npub fn create_pendulum_multisig_account(id: \u0026str) -\u003e AccountId {\n\tlet mut signatories: Vec\u003c_\u003e = pendulum::SUDO_SIGNATORIES\n\t\t.iter()\n\t\t.chain(vec![id].iter())\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\tsignatories.sort();\n\n\tpallet_multisig::Pallet::\u003cpendulum_runtime::Runtime\u003e::multi_account_id(\u0026signatories[..], 4)\n}\n\n/// The extensions for the [`ChainSpec`].\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, ChainSpecGroup, ChainSpecExtension)]\n#[serde(deny_unknown_fields)]\npub struct ParachainExtensions {\n\t/// The relay chain of the Parachain.\n\tpub relay_chain: String,\n\t/// The id of the Parachain.\n\tpub para_id: u32,\n}\n\nimpl ParachainExtensions {\n\t/// Try to get the extension from the given `ChainSpec`.\n\tpub fn try_get(chain_spec: \u0026dyn sc_service::ChainSpec) -\u003e Option\u003c\u0026Self\u003e {\n\t\tsc_chain_spec::get_extension(chain_spec.extensions())\n\t}\n}\n\ntype AccountPublic = \u003cSignature as Verify\u003e::Signer;\n\n/// Generate collator keys from seed.\n///\n/// This function's return type must always match the session keys of the chain in tuple format.\npub fn get_collator_keys_from_seed(seed: \u0026str) -\u003e AuraId {\n\tget_public_from_seed::\u003cAuraId\u003e(seed)\n}\n\n/// Helper function to generate an account ID from seed\npub fn get_account_id_from_seed\u003cTPublic: Public\u003e(seed: \u0026str) -\u003e AccountId\nwhere\n\tAccountPublic: From\u003c\u003cTPublic::Pair as Pair\u003e::Public\u003e,\n{\n\tAccountPublic::from(get_public_from_seed::\u003cTPublic\u003e(seed)).into_account()\n}\n\n/// Generate the session keys from individual elements.\n///\n/// The input must be a tuple of individual keys (a single arg for now since we have just one key).\npub fn get_amplitude_session_keys(keys: AuraId) -\u003e amplitude_runtime::SessionKeys {\n\tamplitude_runtime::SessionKeys { aura: keys }\n}\n\npub fn get_foucoco_session_keys(keys: AuraId) -\u003e foucoco_runtime::SessionKeys {\n\tfoucoco_runtime::SessionKeys { aura: keys }\n}\n\npub fn get_pendulum_session_keys(keys: AuraId) -\u003e pendulum_runtime::SessionKeys {\n\tpendulum_runtime::SessionKeys { aura: keys }\n}\n\npub fn get_development_session_keys(keys: AuraId) -\u003e development_runtime::SessionKeys {\n\tdevelopment_runtime::SessionKeys { aura: keys }\n}\n\npub fn amplitude_config() -\u003e AmplitudeChainSpec {\n\tsp_core::crypto::set_default_ss58_version(amplitude_runtime::SS58Prefix::get().into());\n\n\t// Give your base currency a unit name and decimal places\n\tlet mut properties = sc_chain_spec::Properties::new();\n\tproperties.insert(\"tokenSymbol\".into(), \"AMPE\".into());\n\tproperties.insert(\"tokenDecimals\".into(), amplitude::TOKEN_DECIMALS.into());\n\tproperties.insert(\"ss58Format\".into(), amplitude_runtime::SS58Prefix::get().into());\n\n\tlet mut signatories: Vec\u003c_\u003e = amplitude::INITIAL_SUDO_SIGNATORIES\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\tsignatories.sort();\n\n\tlet invulnerables: Vec\u003c_\u003e = amplitude::INITIAL_COLLATORS\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\n\tlet sudo_account = pallet_multisig::Pallet::\u003camplitude_runtime::Runtime\u003e::multi_account_id(\n\t\t\u0026signatories[..],\n\t\t3,\n\t);\n\n\tAmplitudeChainSpec::from_genesis(\n\t\t// Name\n\t\t\"Amplitude\",\n\t\t// ID\n\t\t\"amplitude\",\n\t\tChainType::Live,\n\t\tmove || {\n\t\t\tamplitude_genesis(\n\t\t\t\t// initial collators.\n\t\t\t\tinvulnerables.clone(),\n\t\t\t\tsignatories.clone(),\n\t\t\t\tvec![sudo_account.clone()],\n\t\t\t\tsudo_account.clone(),\n\t\t\t\tamplitude::PARACHAIN_ID.into(),\n\t\t\t\tfalse,\n\t\t\t)\n\t\t},\n\t\t// Bootnodes\n\t\tVec::new(),\n\t\t// Telemetry\n\t\tNone,\n\t\t// Protocol ID\n\t\tSome(\"amplitude\"),\n\t\t// Fork ID\n\t\tNone,\n\t\t// Properties\n\t\tSome(properties),\n\t\t// Extensions\n\t\tParachainExtensions {\n\t\t\trelay_chain: \"kusama\".into(), // You MUST set this to the correct network!\n\t\t\tpara_id: amplitude::PARACHAIN_ID,\n\t\t},\n\t)\n}\n\npub fn foucoco_config() -\u003e FoucocoChainSpec {\n\tsp_core::crypto::set_default_ss58_version(foucoco_runtime::SS58Prefix::get().into());\n\n\t// Give your base currency a unit name and decimal places\n\tlet mut properties = sc_chain_spec::Properties::new();\n\tproperties.insert(\"tokenSymbol\".into(), \"AMPE\".into());\n\tproperties.insert(\"tokenDecimals\".into(), foucoco::TOKEN_DECIMALS.into());\n\tproperties.insert(\"ss58Format\".into(), foucoco_runtime::SS58Prefix::get().into());\n\n\tlet mut signatories: Vec\u003c_\u003e = foucoco::INITIAL_SUDO_SIGNATORIES\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\tsignatories.sort();\n\n\tlet invulnerables: Vec\u003c_\u003e = foucoco::INITIAL_COLLATORS\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\n\tlet sudo_account =\n\t\tpallet_multisig::Pallet::\u003cfoucoco_runtime::Runtime\u003e::multi_account_id(\u0026signatories[..], 3);\n\n\tlet offchain_worker_price_feeder =\n\t\tAccountId::from_ss58check(foucoco::OFF_CHAIN_WORKER_ADDRESS).unwrap();\n\n\tFoucocoChainSpec::from_genesis(\n\t\t// Name\n\t\t\"Foucoco\",\n\t\t// ID\n\t\t\"foucoco\",\n\t\tChainType::Live,\n\t\tmove || {\n\t\t\tfoucoco_genesis(\n\t\t\t\t// initial collators.\n\t\t\t\tinvulnerables.clone(),\n\t\t\t\tsignatories.clone(),\n\t\t\t\tvec![sudo_account.clone(), offchain_worker_price_feeder.clone()],\n\t\t\t\tsudo_account.clone(),\n\t\t\t\tfoucoco::PARACHAIN_ID.into(),\n\t\t\t\tfalse,\n\t\t\t)\n\t\t},\n\t\t// Bootnodes\n\t\tVec::new(),\n\t\t// Telemetry\n\t\tNone,\n\t\t// Protocol ID\n\t\tSome(\"foucoco\"),\n\t\t// Fork ID\n\t\tNone,\n\t\t// Properties\n\t\tSome(properties),\n\t\t// Extensions\n\t\tParachainExtensions {\n\t\t\trelay_chain: \"kusama\".into(), // You MUST set this to the correct network!\n\t\t\tpara_id: foucoco::PARACHAIN_ID,\n\t\t},\n\t)\n}\n\npub fn pendulum_config() -\u003e PendulumChainSpec {\n\t// Give your base currency a unit name and decimal places\n\n\tsp_core::crypto::set_default_ss58_version(pendulum_runtime::SS58Prefix::get().into());\n\n\tlet mut properties = sc_chain_spec::Properties::new();\n\tproperties.insert(\"tokenSymbol\".into(), \"PEN\".into());\n\tproperties.insert(\"tokenDecimals\".into(), pendulum::TOKEN_DECIMALS.into());\n\tproperties.insert(\"ss58Format\".into(), pendulum_runtime::SS58Prefix::get().into());\n\n\tlet multisig_genesis = create_pendulum_multisig_account(pendulum::MULTISIG_ID_GENESIS);\n\tlet multisig_cl_reserves = create_pendulum_multisig_account(pendulum::MULTISIG_ID_CL_RESERVES);\n\tlet multisig_incentives = create_pendulum_multisig_account(pendulum::MULTISIG_ID_INCENTIVES);\n\tlet multisig_marketing = create_pendulum_multisig_account(pendulum::MULTISIG_ID_MARKETING);\n\n\tlet collators: Vec\u003c_\u003e = pendulum::INITIAL_COLLATORS\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\n\tlet mut vesting_schedules = vec![];\n\tlet mut balances = vec![];\n\tlet blocks_per_year = pendulum_runtime::BLOCKS_PER_YEAR;\n\n\tlet treasury = pallet_treasury::Pallet::\u003cpendulum_runtime::Runtime\u003e::account_id();\n\n\tfor pendulum::Allocation { address, amount } in pendulum::ALLOCATIONS_10_24 {\n\t\tlet account_id = AccountId::from_ss58check(address).unwrap();\n\t\tbalances.push((account_id.clone(), amount * UNIT));\n\t\tvesting_schedules.push((account_id, 0, blocks_per_year * 2, amount * UNIT / 10))\n\t}\n\n\tfor pendulum::Allocation { address, amount } in pendulum::ALLOCATIONS_12_36 {\n\t\tlet account_id = AccountId::from_ss58check(address).unwrap();\n\t\tbalances.push((account_id.clone(), amount * UNIT));\n\t\tvesting_schedules.push((account_id.clone(), blocks_per_year, 1, amount * UNIT * 2 / 3));\n\t\tvesting_schedules.push((\n\t\t\taccount_id,\n\t\t\tblocks_per_year,\n\t\t\tblocks_per_year * 2,\n\t\t\tamount * UNIT / 3,\n\t\t));\n\t}\n\n\tfor collator in collators.clone() {\n\t\tbalances\n\t\t\t.push((collator, pendulum::INITIAL_COLLATOR_STAKING + pendulum::COLLATOR_ADDITIONAL));\n\t}\n\n\tbalances.push((multisig_cl_reserves.clone(), pendulum::CL_RESERVES_ALLOCATION));\n\tvesting_schedules.push((multisig_cl_reserves, 0, blocks_per_year * 22 / 12, 0));\n\n\tbalances.push((multisig_incentives.clone(), pendulum::INCENTIVES_ALLOCATION));\n\tvesting_schedules.push((\n\t\tmultisig_incentives,\n\t\t0,\n\t\tblocks_per_year * 3,\n\t\tpendulum::INCENTIVES_ALLOCATION * 30 / 100,\n\t));\n\n\tbalances.push((multisig_marketing.clone(), pendulum::MARKETING_ALLOCATION));\n\tvesting_schedules.push((\n\t\tmultisig_marketing,\n\t\t0,\n\t\tblocks_per_year * 3,\n\t\tpendulum::MARKETING_ALLOCATION * 10 / 100,\n\t));\n\n\tbalances.push((treasury.clone(), pendulum::TREASURY_ALLOCATION));\n\tvesting_schedules.push((\n\t\ttreasury,\n\t\t0,\n\t\tblocks_per_year * 3,\n\t\tpendulum::TREASURY_ALLOCATION * 20 / 100,\n\t));\n\n\tlet multisig_identifiers = vec![\n\t\tpendulum::MULTISIG_ID_GENESIS,\n\t\tpendulum::MULTISIG_ID_TEAM,\n\t\tpendulum::MULTISIG_ID_CL_RESERVES,\n\t\tpendulum::MULTISIG_ID_INCENTIVES,\n\t\tpendulum::MULTISIG_ID_MARKETING,\n\t];\n\n\tfor signatory in pendulum::SUDO_SIGNATORIES.iter().chain(multisig_identifiers.iter()) {\n\t\tlet account_id = AccountId::from_ss58check(signatory).unwrap();\n\t\tbalances.push((account_id, pendulum::INITIAL_ISSUANCE_PER_SIGNATORY));\n\t}\n\n\tPendulumChainSpec::from_genesis(\n\t\t// Name\n\t\t\"Pendulum\",\n\t\t// ID\n\t\t\"pendulum\",\n\t\tChainType::Live,\n\t\tmove || {\n\t\t\tpendulum_genesis(\n\t\t\t\t// initial collators.\n\t\t\t\tcollators.clone(),\n\t\t\t\tbalances.clone(),\n\t\t\t\tvesting_schedules.clone(),\n\t\t\t\tmultisig_genesis.clone(),\n\t\t\t\tpendulum::PARACHAIN_ID.into(),\n\t\t\t)\n\t\t},\n\t\t// Bootnodes\n\t\tVec::new(),\n\t\t// Telemetry\n\t\tNone,\n\t\t// Protocol ID\n\t\tSome(\"pendulum\"),\n\t\t// Fork ID\n\t\tNone,\n\t\t// Properties\n\t\tSome(properties),\n\t\t// Extensions\n\t\tParachainExtensions {\n\t\t\trelay_chain: \"polkadot\".into(), // You MUST set this to the correct network!\n\t\t\tpara_id: pendulum::PARACHAIN_ID,\n\t\t},\n\t)\n}\n\npub fn development_config() -\u003e DevelopmentChainSpec {\n\t// Give your base currency a unit name and decimal places\n\tlet mut properties = sc_chain_spec::Properties::new();\n\tproperties.insert(\"tokenSymbol\".into(), \"UNIT\".into());\n\tproperties.insert(\"tokenDecimals\".into(), foucoco::TOKEN_DECIMALS.into());\n\tproperties.insert(\"ss58Format\".into(), 42.into());\n\n\tDevelopmentChainSpec::from_genesis(\n\t\t// Name\n\t\t\"Development\",\n\t\t// ID\n\t\t\"dev\",\n\t\tChainType::Development,\n\t\tmove || {\n\t\t\ttestnet_genesis(\n\t\t\t\t// initial collators.\n\t\t\t\tvec![\n\t\t\t\t\t(\n\t\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Alice\"),\n\t\t\t\t\t\tget_collator_keys_from_seed(\"Alice\"),\n\t\t\t\t\t),\n\t\t\t\t\t(\n\t\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Bob\"),\n\t\t\t\t\t\tget_collator_keys_from_seed(\"Bob\"),\n\t\t\t\t\t),\n\t\t\t\t],\n\t\t\t\tvec![\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Alice\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Bob\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Charlie\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Dave\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Eve\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Ferdie\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Alice//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Bob//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Charlie//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Dave//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Eve//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Ferdie//stash\"),\n\t\t\t\t],\n\t\t\t\t1000.into(),\n\t\t\t)\n\t\t},\n\t\t// Bootnodes\n\t\tVec::new(),\n\t\t// Telemetry\n\t\tNone,\n\t\t// Protocol ID\n\t\tSome(\"pendulum-development\"),\n\t\t// Fork ID\n\t\tNone,\n\t\t// Properties\n\t\tSome(properties),\n\t\t// Extensions\n\t\tParachainExtensions {\n\t\t\trelay_chain: \"rococo-local\".into(), // You MUST set this to the correct network!\n\t\t\tpara_id: 1000,\n\t\t},\n\t)\n}\n\nfn amplitude_genesis(\n\tinvulnerables: Vec\u003cAccountId\u003e,\n\tsignatories: Vec\u003cAccountId\u003e,\n\tauthorized_oracles: Vec\u003cAccountId\u003e,\n\tsudo_account: AccountId,\n\tid: ParaId,\n\tstart_shutdown: bool,\n) -\u003e amplitude_runtime::GenesisConfig {\n\tfn default_pair(currency_id: CurrencyId) -\u003e VaultCurrencyPair\u003cCurrencyId\u003e {\n\t\tVaultCurrencyPair { collateral: currency_id, wrapped: MAINNET_USDC_CURRENCY_ID }\n\t}\n\n\tlet mut balances: Vec\u003c_\u003e = signatories\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|k| (k, amplitude::INITIAL_ISSUANCE_PER_SIGNATORY))\n\t\t.chain(\n\t\t\tinvulnerables\n\t\t\t\t.iter()\n\t\t\t\t.cloned()\n\t\t\t\t.map(|k| (k, amplitude::INITIAL_COLLATOR_STAKING + amplitude::COLLATOR_ADDITIONAL)),\n\t\t)\n\t\t.collect();\n\n\tbalances.push((\n\t\tsudo_account.clone(),\n\t\tamplitude::INITIAL_ISSUANCE\n\t\t\t.saturating_sub(\n\t\t\t\tamplitude::INITIAL_ISSUANCE_PER_SIGNATORY\n\t\t\t\t\t.saturating_mul(balances.len().try_into().unwrap()),\n\t\t\t)\n\t\t\t.saturating_sub(\n\t\t\t\tamplitude::INITIAL_COLLATOR_STAKING\n\t\t\t\t\t.saturating_mul(invulnerables.len().try_into().unwrap()),\n\t\t\t),\n\t));\n\n\tlet token_balances = vec![];\n\n\tlet stakers: Vec\u003c_\u003e = invulnerables\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|account_id| (account_id, None, amplitude::INITIAL_COLLATOR_STAKING))\n\t\t.collect();\n\n\tlet inflation_config = amplitude_runtime::InflationInfo::new(\n\t\tamplitude_runtime::BLOCKS_PER_YEAR.into(),\n\t\tPerquintill::from_percent(10),\n\t\tPerquintill::from_percent(11),\n\t\tPerquintill::from_percent(40),\n\t\tPerquintill::from_percent(9),\n\t);\n\n\tamplitude_runtime::GenesisConfig {\n\t\tasset_registry: Default::default(),\n\t\tsystem: amplitude_runtime::SystemConfig {\n\t\t\tcode: amplitude_runtime::WASM_BINARY\n\t\t\t\t.expect(\"WASM binary was not build, please build it!\")\n\t\t\t\t.to_vec(),\n\t\t},\n\t\tbalances: amplitude_runtime::BalancesConfig { balances },\n\t\tparachain_info: amplitude_runtime::ParachainInfoConfig { parachain_id: id },\n\t\tparachain_staking: amplitude_runtime::ParachainStakingConfig {\n\t\t\tstakers,\n\t\t\tinflation_config,\n\t\t\tmax_candidate_stake: 400_000 * UNIT,\n\t\t\tmax_selected_candidates: 40,\n\t\t},\n\t\tsession: amplitude_runtime::SessionConfig {\n\t\t\tkeys: invulnerables\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|acc| {\n\t\t\t\t\t(\n\t\t\t\t\t\tacc.clone(),\n\t\t\t\t\t\tacc.clone(),\n\t\t\t\t\t\tget_amplitude_session_keys(Into::\u003c[u8; 32]\u003e::into(acc).unchecked_into()),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.collect(),\n\t\t},\n\t\t// no need to pass anything to aura, in fact it will panic if we do. Session will take care\n\t\t// of this.\n\t\taura: Default::default(),\n\t\taura_ext: Default::default(),\n\t\tparachain_system: Default::default(),\n\t\tpolkadot_xcm: amplitude_runtime::PolkadotXcmConfig {\n\t\t\tsafe_xcm_version: Some(SAFE_XCM_VERSION),\n\t\t},\n\t\tcouncil: amplitude_runtime::CouncilConfig {\n\t\t\tmembers: signatories.clone(),\n\t\t\t..Default::default()\n\t\t},\n\t\tdemocracy: Default::default(),\n\t\ttechnical_committee: amplitude_runtime::TechnicalCommitteeConfig {\n\t\t\tmembers: signatories.clone(),\n\t\t\t..Default::default()\n\t\t},\n\t\ttokens: amplitude_runtime::TokensConfig {\n\t\t\t// Configure the initial token supply\n\t\t\tbalances: token_balances,\n\t\t},\n\t\tissue: amplitude_runtime::IssueConfig {\n\t\t\tissue_period: amplitude_runtime::DAYS,\n\t\t\tissue_minimum_transfer_amount: 1000,\n\t\t\tlimit_volume_amount: None,\n\t\t\tlimit_volume_currency_id: XCM(0),\n\t\t\tcurrent_volume_amount: 0u32.into(),\n\t\t\tinterval_length: (60u32 * 60 * 24).into(),\n\t\t\tlast_interval_index: 0u32.into(),\n\t\t},\n\t\tredeem: amplitude_runtime::RedeemConfig {\n\t\t\tredeem_period: foucoco_runtime::DAYS,\n\t\t\tredeem_minimum_transfer_amount: 1000,\n\t\t\tlimit_volume_amount: None,\n\t\t\tlimit_volume_currency_id: XCM(0),\n\t\t\tcurrent_volume_amount: 0u32.into(),\n\t\t\tinterval_length: (60u32 * 60 * 24).into(),\n\t\t\tlast_interval_index: 0u32.into(),\n\t\t},\n\t\treplace: amplitude_runtime::ReplaceConfig {\n\t\t\treplace_period: foucoco_runtime::DAYS,\n\t\t\treplace_minimum_transfer_amount: 1000,\n\t\t},\n\t\tsecurity: amplitude_runtime::SecurityConfig {\n\t\t\tinitial_status: if start_shutdown {\n\t\t\t\tamplitude_runtime::StatusCode::Shutdown\n\t\t\t} else {\n\t\t\t\tamplitude_runtime::StatusCode::Error\n\t\t\t},\n\t\t},\n\t\toracle: amplitude_runtime::OracleConfig {\n\t\t\tmax_delay: u32::MAX,\n\t\t\toracle_keys: vec![\n\t\t\t\tKey::ExchangeRate(CurrencyId::XCM(0)),\n\t\t\t\tKey::ExchangeRate(MAINNET_USDC_CURRENCY_ID),\n\t\t\t],\n\t\t},\n\t\tvault_registry: amplitude_runtime::VaultRegistryConfig {\n\t\t\tminimum_collateral_vault: vec![(XCM(0), 0)],\n\t\t\tpunishment_delay: foucoco_runtime::DAYS,\n\t\t\tsecure_collateral_threshold: vec![(\n\t\t\t\tdefault_pair(XCM(0)),\n\t\t\t\tFixedU128::checked_from_rational(150, 100).unwrap(),\n\t\t\t)],\n\t\t\t/* 150% */\n\t\t\tpremium_redeem_threshold: vec![(\n\t\t\t\tdefault_pair(XCM(0)),\n\t\t\t\tFixedU128::checked_from_rational(130, 100).unwrap(),\n\t\t\t)],\n\t\t\t/* 130% */\n\t\t\tliquidation_collateral_threshold: vec![(\n\t\t\t\tdefault_pair(XCM(0)),\n\t\t\t\tFixedU128::checked_from_rational(120, 100).unwrap(),\n\t\t\t)],\n\t\t\t/* 120% */\n\t\t\tsystem_collateral_ceiling: vec![(\n\t\t\t\tdefault_pair(XCM(0)),\n\t\t\t\t60_000 * 10u128.pow(amplitude::TOKEN_DECIMALS),\n\t\t\t)],\n\t\t},\n\t\tstellar_relay: amplitude_runtime::StellarRelayConfig::default(),\n\t\tfee: amplitude_runtime::FeeConfig {\n\t\t\tissue_fee: FixedU128::checked_from_rational(15, 10000).unwrap(), // 0.15%\n\t\t\tissue_griefing_collateral: FixedU128::checked_from_rational(5, 100000).unwrap(), // 0.005%\n\t\t\tredeem_fee: FixedU128::checked_from_rational(5, 1000).unwrap(),  // 0.5%\n\t\t\tpremium_redeem_fee: FixedU128::checked_from_rational(5, 100).unwrap(), // 5%\n\t\t\tpunishment_fee: FixedU128::checked_from_rational(1, 10).unwrap(), // 10%\n\t\t\treplace_griefing_collateral: FixedU128::checked_from_rational(1, 10).unwrap(), // 10%\n\t\t},\n\t\tnomination: amplitude_runtime::NominationConfig { is_nomination_enabled: false },\n\t\tdia_oracle_module: amplitude_runtime::DiaOracleModuleConfig {\n\t\t\tauthorized_accounts: authorized_oracles,\n\t\t\tsupported_currencies: vec![foucoco_runtime::AssetId::new(\n\t\t\t\tb\"Polkadot\".to_vec(),\n\t\t\t\tb\"DOT\".to_vec(),\n\t\t\t)],\n\t\t\tbatching_api: b\"http://dia-00.pendulumchain.tech:8070/currencies\".to_vec(),\n\t\t\tcoin_infos_map: vec![],\n\t\t},\n\t}\n}\n\nfn foucoco_genesis(\n\tinvulnerables: Vec\u003cAccountId\u003e,\n\tsignatories: Vec\u003cAccountId\u003e,\n\tauthorized_oracles: Vec\u003cAccountId\u003e,\n\tsudo_account: AccountId,\n\tid: ParaId,\n\tstart_shutdown: bool,\n) -\u003e foucoco_runtime::GenesisConfig {\n\tfn get_vault_currency_pair(\n\t\tcollateral: CurrencyId,\n\t\twrapped: CurrencyId,\n\t) -\u003e VaultCurrencyPair\u003cCurrencyId\u003e {\n\t\tVaultCurrencyPair { collateral, wrapped }\n\t}\n\n\tlet mut balances: Vec\u003c_\u003e = signatories\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|k| (k, foucoco::INITIAL_ISSUANCE_PER_SIGNATORY))\n\t\t.chain(\n\t\t\tinvulnerables\n\t\t\t\t.iter()\n\t\t\t\t.cloned()\n\t\t\t\t.map(|k| (k, foucoco::INITIAL_COLLATOR_STAKING + foucoco::COLLATOR_ADDITIONAL)),\n\t\t)\n\t\t.collect();\n\n\tbalances.push((\n\t\tsudo_account.clone(),\n\t\tfoucoco::INITIAL_ISSUANCE\n\t\t\t.saturating_sub(\n\t\t\t\tfoucoco::INITIAL_ISSUANCE_PER_SIGNATORY\n\t\t\t\t\t.saturating_mul(balances.len().try_into().unwrap()),\n\t\t\t)\n\t\t\t.saturating_sub(\n\t\t\t\tfoucoco::INITIAL_COLLATOR_STAKING\n\t\t\t\t\t.saturating_mul(invulnerables.len().try_into().unwrap()),\n\t\t\t),\n\t));\n\n\tlet token_balances = balances\n\t\t.iter()\n\t\t.flat_map(|k| vec![(k.0.clone(), XCM(0), u128::pow(10, 18))])\n\t\t.collect();\n\n\tlet stakers: Vec\u003c_\u003e = invulnerables\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|account_id| (account_id, None, foucoco::INITIAL_COLLATOR_STAKING))\n\t\t.collect();\n\n\tlet inflation_config = foucoco_runtime::InflationInfo::new(\n\t\tfoucoco_runtime::BLOCKS_PER_YEAR.into(),\n\t\tPerquintill::from_percent(10),\n\t\tPerquintill::from_percent(11),\n\t\tPerquintill::from_percent(40),\n\t\tPerquintill::from_percent(9),\n\t);\n\n\tfoucoco_runtime::GenesisConfig {\n\t\tasset_registry: Default::default(),\n\t\tsystem: foucoco_runtime::SystemConfig {\n\t\t\tcode: foucoco_runtime::WASM_BINARY\n\t\t\t\t.expect(\"WASM binary was not build, please build it!\")\n\t\t\t\t.to_vec(),\n\t\t},\n\t\tbalances: foucoco_runtime::BalancesConfig { balances },\n\t\tparachain_info: foucoco_runtime::ParachainInfoConfig { parachain_id: id },\n\t\tparachain_staking: foucoco_runtime::ParachainStakingConfig {\n\t\t\tstakers,\n\t\t\tinflation_config,\n\t\t\tmax_candidate_stake: 400_000 * UNIT,\n\t\t\tmax_selected_candidates: 40,\n\t\t},\n\t\tsession: foucoco_runtime::SessionConfig {\n\t\t\tkeys: invulnerables\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|acc| {\n\t\t\t\t\t(\n\t\t\t\t\t\tacc.clone(),\n\t\t\t\t\t\tacc.clone(),\n\t\t\t\t\t\tget_foucoco_session_keys(Into::\u003c[u8; 32]\u003e::into(acc).unchecked_into()),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.collect(),\n\t\t},\n\t\t// no need to pass anything to aura, in fact it will panic if we do. Session will take care\n\t\t// of this.\n\t\taura: Default::default(),\n\t\taura_ext: Default::default(),\n\t\tparachain_system: Default::default(),\n\t\tpolkadot_xcm: foucoco_runtime::PolkadotXcmConfig {\n\t\t\tsafe_xcm_version: Some(SAFE_XCM_VERSION),\n\t\t},\n\t\tcouncil: foucoco_runtime::CouncilConfig {\n\t\t\tmembers: signatories.clone(),\n\t\t\t..Default::default()\n\t\t},\n\t\tdemocracy: Default::default(),\n\t\tsudo: foucoco_runtime::SudoConfig { key: Some(sudo_account.clone()) },\n\t\ttechnical_committee: foucoco_runtime::TechnicalCommitteeConfig {\n\t\t\tmembers: signatories.clone(),\n\t\t\t..Default::default()\n\t\t},\n\t\ttokens: foucoco_runtime::TokensConfig {\n\t\t\t// Configure the initial token supply for the native currency and USDC asset\n\t\t\tbalances: token_balances,\n\t\t},\n\t\tissue: foucoco_runtime::IssueConfig {\n\t\t\tissue_period: foucoco_runtime::DAYS,\n\t\t\tissue_minimum_transfer_amount: 1_000_000_000,\n\t\t\tlimit_volume_amount: None,\n\t\t\tlimit_volume_currency_id: XCM(0),\n\t\t\tcurrent_volume_amount: 0u32.into(),\n\t\t\tinterval_length: (60u32 * 60 * 24).into(),\n\t\t\tlast_interval_index: 0u32.into(),\n\t\t},\n\t\tredeem: foucoco_runtime::RedeemConfig {\n\t\t\tredeem_period: foucoco_runtime::DAYS,\n\t\t\tredeem_minimum_transfer_amount: 1_000_000_000,\n\t\t\tlimit_volume_amount: None,\n\t\t\tlimit_volume_currency_id: XCM(0),\n\t\t\tcurrent_volume_amount: 0u32.into(),\n\t\t\tinterval_length: (60u32 * 60 * 24).into(),\n\t\t\tlast_interval_index: 0u32.into(),\n\t\t},\n\t\treplace: foucoco_runtime::ReplaceConfig {\n\t\t\treplace_period: foucoco_runtime::DAYS,\n\t\t\treplace_minimum_transfer_amount: 1_000_000_000,\n\t\t},\n\t\tsecurity: foucoco_runtime::SecurityConfig {\n\t\t\tinitial_status: if start_shutdown {\n\t\t\t\tfoucoco_runtime::StatusCode::Shutdown\n\t\t\t} else {\n\t\t\t\tfoucoco_runtime::StatusCode::Error\n\t\t\t},\n\t\t},\n\t\toracle: foucoco_runtime::OracleConfig {\n\t\t\tmax_delay: 604_800_000, // 7 days\n\t\t\toracle_keys: vec![\n\t\t\t\tKey::ExchangeRate(CurrencyId::XCM(0)),\n\t\t\t\tKey::ExchangeRate(CurrencyId::Native),\n\t\t\t\tKey::ExchangeRate(CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\tKey::ExchangeRate(MAINNET_USDC_CURRENCY_ID),\n\t\t\t\tKey::ExchangeRate(MAINNET_BRL_CURRENCY_ID),\n\t\t\t\tKey::ExchangeRate(MAINNET_TZS_CURRENCY_ID),\n\t\t\t],\n\t\t},\n\t\tvault_registry: foucoco_runtime::VaultRegistryConfig {\n\t\t\tminimum_collateral_vault: vec![(XCM(0), 3_000_000_000_000)],\n\t\t\tpunishment_delay: foucoco_runtime::DAYS * 2,\n\t\t\tsecure_collateral_threshold: vec![\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_USDC_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(160, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_BRL_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(160, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_TZS_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(160, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\t\tFixedU128::checked_from_rational(160, 100).unwrap(),\n\t\t\t\t),\n\t\t\t],\n\t\t\t/* 140% */\n\t\t\tpremium_redeem_threshold: vec![\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_USDC_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(140, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_BRL_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(140, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_TZS_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(140, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\t\tFixedU128::checked_from_rational(140, 100).unwrap(),\n\t\t\t\t),\n\t\t\t],\n\t\t\t/* 125% */\n\t\t\tliquidation_collateral_threshold: vec![\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_USDC_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(125, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_BRL_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(125, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_TZS_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(125, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\t\tFixedU128::checked_from_rational(125, 100).unwrap(),\n\t\t\t\t),\n\t\t\t],\n\t\t\tsystem_collateral_ceiling: vec![\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_USDC_CURRENCY_ID),\n\t\t\t\t\t50 * 10u128.pow(foucoco::TOKEN_DECIMALS),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_BRL_CURRENCY_ID),\n\t\t\t\t\t25 * 10u128.pow(foucoco::TOKEN_DECIMALS),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_TZS_CURRENCY_ID),\n\t\t\t\t\t25 * 10u128.pow(foucoco::TOKEN_DECIMALS),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\t\t50 * 10u128.pow(foucoco::TOKEN_DECIMALS),\n\t\t\t\t),\n\t\t\t],\n\t\t},\n\t\tstellar_relay: foucoco_runtime::StellarRelayConfig::default(),\n\t\tfee: foucoco_runtime::FeeConfig {\n\t\t\tissue_fee: FixedU128::checked_from_rational(1, 1000).unwrap(), // 0.1%\n\t\t\tissue_griefing_collateral: FixedU128::checked_from_rational(5, 1000).unwrap(), // 0.5%\n\t\t\tredeem_fee: FixedU128::checked_from_rational(1, 1000).unwrap(), // 0.1%\n\t\t\tpremium_redeem_fee: FixedU128::checked_from_rational(5, 100).unwrap(), // 5%\n\t\t\tpunishment_fee: FixedU128::checked_from_rational(1, 10).unwrap(), // 10%\n\t\t\treplace_griefing_collateral: FixedU128::checked_from_rational(1, 10).unwrap(), // 10%\n\t\t},\n\t\tnomination: foucoco_runtime::NominationConfig { is_nomination_enabled: false },\n\t\tdia_oracle_module: foucoco_runtime::DiaOracleModuleConfig {\n\t\t\tauthorized_accounts: authorized_oracles,\n\t\t\tsupported_currencies: vec![\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"Kusama\".to_vec(), b\"KSM\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"Stellar\".to_vec(), b\"XLM\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"FIAT\".to_vec(), b\"BRL-USD\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"FIAT\".to_vec(), b\"USD-USD\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"FIAT\".to_vec(), b\"TZS-USD\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"FIAT\".to_vec(), b\"MXN-USD\".to_vec()),\n\t\t\t],\n\t\t\tbatching_api: b\"https://dia-00.pendulumchain.tech/currencies\".to_vec(),\n\t\t\tcoin_infos_map: vec![],\n\t\t},\n\t}\n}\n\nfn pendulum_genesis(\n\tcollators: Vec\u003cAccountId\u003e,\n\tmut balances: Vec\u003c(AccountId, Balance)\u003e,\n\tvesting_schedules: Vec\u003c(AccountId, BlockNumber, BlockNumber, Balance)\u003e,\n\tsudo_account: AccountId,\n\tid: ParaId,\n) -\u003e pendulum_runtime::GenesisConfig {\n\tlet mut genesis_issuance = pendulum::TOTAL_INITIAL_ISSUANCE;\n\tfor balance in balances.clone() {\n\t\tgenesis_issuance -= balance.1;\n\t}\n\n\tbalances.push((sudo_account.clone(), genesis_issuance));\n\n\tlet stakers: Vec\u003c_\u003e = collators\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|account_id| (account_id, None, pendulum::INITIAL_COLLATOR_STAKING))\n\t\t.collect();\n\n\tlet inflation_config = pendulum_runtime::InflationInfo::new(\n\t\tpendulum_runtime::BLOCKS_PER_YEAR.into(),\n\t\tPerquintill::from_percent(10),\n\t\tPerquintill::from_percent(11),\n\t\tPerquintill::from_percent(30),\n\t\tPerquintill::from_percent(8),\n\t);\n\n\tlet council: Vec\u003c_\u003e = pendulum::SUDO_SIGNATORIES\n\t\t.iter()\n\t\t.map(|address| AccountId::from_ss58check(address).unwrap())\n\t\t.collect();\n\n\tpendulum_runtime::GenesisConfig {\n\t\tasset_registry: Default::default(),\n\t\tsystem: pendulum_runtime::SystemConfig {\n\t\t\tcode: pendulum_runtime::WASM_BINARY\n\t\t\t\t.expect(\"WASM binary was not build, please build it!\")\n\t\t\t\t.to_vec(),\n\t\t},\n\t\tbalances: pendulum_runtime::BalancesConfig { balances },\n\t\tparachain_info: pendulum_runtime::ParachainInfoConfig { parachain_id: id },\n\t\tparachain_staking: pendulum_runtime::ParachainStakingConfig {\n\t\t\tstakers,\n\t\t\tinflation_config,\n\t\t\tmax_candidate_stake: 400_000 * UNIT,\n\t\t\tmax_selected_candidates: 40,\n\t\t},\n\t\tsession: pendulum_runtime::SessionConfig {\n\t\t\tkeys: collators\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|account| {\n\t\t\t\t\t(\n\t\t\t\t\t\taccount.clone(),\n\t\t\t\t\t\taccount.clone(),\n\t\t\t\t\t\tget_pendulum_session_keys(Into::\u003c[u8; 32]\u003e::into(account).unchecked_into()),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.collect(),\n\t\t},\n\t\t// no need to pass anything to aura, in fact it will panic if we do. Session will take care\n\t\t// of this.\n\t\taura: Default::default(),\n\t\taura_ext: Default::default(),\n\t\tparachain_system: Default::default(),\n\t\tpolkadot_xcm: pendulum_runtime::PolkadotXcmConfig {\n\t\t\tsafe_xcm_version: Some(SAFE_XCM_VERSION),\n\t\t},\n\t\tcouncil: pendulum_runtime::CouncilConfig { members: council.clone(), ..Default::default() },\n\t\tdemocracy: Default::default(),\n\t\ttechnical_committee: pendulum_runtime::TechnicalCommitteeConfig {\n\t\t\tmembers: council,\n\t\t\t..Default::default()\n\t\t},\n\t\tvesting: pendulum_runtime::VestingConfig { vesting: vesting_schedules },\n\t}\n}\n\nfn testnet_genesis(\n\tinvulnerables: Vec\u003c(AccountId, AuraId)\u003e,\n\tendowed_accounts: Vec\u003cAccountId\u003e,\n\tid: ParaId,\n) -\u003e development_runtime::GenesisConfig {\n\tdevelopment_runtime::GenesisConfig {\n\t\tsystem: development_runtime::SystemConfig {\n\t\t\tcode: development_runtime::WASM_BINARY\n\t\t\t\t.expect(\"WASM binary was not build, please build it!\")\n\t\t\t\t.to_vec(),\n\t\t},\n\t\tbalances: development_runtime::BalancesConfig {\n\t\t\tbalances: endowed_accounts.iter().cloned().map(|k| (k, 1 \u003c\u003c 60)).collect(),\n\t\t},\n\t\tparachain_info: development_runtime::ParachainInfoConfig { parachain_id: id },\n\t\tcollator_selection: development_runtime::CollatorSelectionConfig {\n\t\t\tinvulnerables: invulnerables.iter().cloned().map(|(acc, _)| acc).collect(),\n\t\t\tcandidacy_bond: EXISTENTIAL_DEPOSIT * 16,\n\t\t\t..Default::default()\n\t\t},\n\t\tsession: development_runtime::SessionConfig {\n\t\t\tkeys: invulnerables\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|(acc, aura)| {\n\t\t\t\t\t(\n\t\t\t\t\t\tacc.clone(),                        // account id\n\t\t\t\t\t\tacc,                                // validator id\n\t\t\t\t\t\tget_development_session_keys(aura), // session keys\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.collect(),\n\t\t},\n\t\t// no need to pass anything to aura, in fact it will panic if we do. Session will take care\n\t\t// of this.\n\t\taura: Default::default(),\n\t\taura_ext: Default::default(),\n\t\tparachain_system: Default::default(),\n\t\tpolkadot_xcm: amplitude_runtime::PolkadotXcmConfig {\n\t\t\tsafe_xcm_version: Some(SAFE_XCM_VERSION),\n\t\t},\n\t}\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","marcel","Documents","pendulum","node","src","cli.rs"],"content":"use std::path::PathBuf;\n\n/// Sub-commands supported by the collator.\n#[derive(Debug, clap::Subcommand)]\npub enum Subcommand {\n\t/// Build a chain specification.\n\tBuildSpec(sc_cli::BuildSpecCmd),\n\n\t/// Validate blocks.\n\tCheckBlock(sc_cli::CheckBlockCmd),\n\n\t/// Export blocks.\n\tExportBlocks(sc_cli::ExportBlocksCmd),\n\n\t/// Export the state of a given block into a chain spec.\n\tExportState(sc_cli::ExportStateCmd),\n\n\t/// Import blocks.\n\tImportBlocks(sc_cli::ImportBlocksCmd),\n\n\t/// Revert the chain to a previous state.\n\tRevert(sc_cli::RevertCmd),\n\n\t/// Remove the whole chain.\n\tPurgeChain(cumulus_client_cli::PurgeChainCmd),\n\n\t/// Export the genesis state of the parachain.\n\tExportGenesisState(cumulus_client_cli::ExportGenesisStateCommand),\n\n\t/// Export the genesis wasm of the parachain.\n\tExportGenesisWasm(cumulus_client_cli::ExportGenesisWasmCommand),\n\n\t/// Sub-commands concerned with benchmarking.\n\t/// The pallet benchmarking moved to the `pallet` sub-command.\n\t#[command(subcommand)]\n\tBenchmark(frame_benchmarking_cli::BenchmarkCmd),\n\n\t/// Try some command against runtime state.\n\t#[cfg(feature = \"try-runtime\")]\n\tTryRuntime(try_runtime_cli::TryRuntimeCmd),\n}\n\n#[derive(Debug, clap::Parser)]\n#[command(\n\tpropagate_version = true,\n\targs_conflicts_with_subcommands = true,\n\tsubcommand_negates_reqs = true\n)]\npub struct Cli {\n\t#[command(subcommand)]\n\tpub subcommand: Option\u003cSubcommand\u003e,\n\n\t#[command(flatten)]\n\tpub run: cumulus_client_cli::RunCmd,\n\n\t/// Disable automatic hardware benchmarks.\n\t///\n\t/// By default these benchmarks are automatically ran at startup and measure\n\t/// the CPU speed, the memory bandwidth and the disk speed.\n\t///\n\t/// The results are then printed out in the logs, and also sent as part of\n\t/// telemetry, if telemetry is enabled.\n\t#[arg(long)]\n\tpub no_hardware_benchmarks: bool,\n\n\t/// Relay chain arguments\n\t#[arg(raw = true)]\n\tpub relay_chain_args: Vec\u003cString\u003e,\n}\n\n#[derive(Debug)]\npub struct RelayChainCli {\n\t/// The actual relay chain cli object.\n\tpub base: polkadot_cli::RunCmd,\n\n\t/// Optional chain id that should be passed to the relay chain.\n\tpub chain_id: Option\u003cString\u003e,\n\n\t/// The base path that should be used by the relay chain.\n\tpub base_path: Option\u003cPathBuf\u003e,\n}\n\nimpl RelayChainCli {\n\t/// Parse the relay chain CLI parameters using the para chain `Configuration`.\n\tpub fn new\u003c'a\u003e(\n\t\tpara_config: \u0026sc_service::Configuration,\n\t\trelay_chain_args: impl Iterator\u003cItem = \u0026'a String\u003e,\n\t) -\u003e Self {\n\t\tlet extension = crate::chain_spec::ParachainExtensions::try_get(\u0026*para_config.chain_spec);\n\t\tlet chain_id = extension.map(|e| e.relay_chain.clone());\n\t\tlet base_path = para_config.base_path.as_ref().map(|x| x.path().join(\"polkadot\"));\n\t\tSelf { base_path, chain_id, base: clap::Parser::parse_from(relay_chain_args) }\n\t}\n}\n","traces":[{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","Users","marcel","Documents","pendulum","node","src","command.rs"],"content":"use std::net::SocketAddr;\n\nuse codec::Encode;\nuse cumulus_client_cli::generate_genesis_block;\nuse cumulus_primitives_core::ParaId;\nuse frame_benchmarking_cli::{BenchmarkCmd, SUBSTRATE_REFERENCE_HARDWARE};\nuse log::{info, warn};\nuse runtime_common::opaque::Block;\nuse sc_chain_spec::GenericChainSpec;\nuse sc_cli::{\n\tChainSpec, CliConfiguration, DefaultConfigurationValues, ImportParams, KeystoreParams,\n\tNetworkParams, Result, RuntimeVersion, SharedParams, SubstrateCli,\n};\nuse sc_service::config::{BasePath, PrometheusConfig};\nuse sp_core::hexdisplay::HexDisplay;\nuse sp_runtime::traits::{AccountIdConversion, Block as BlockT};\n\nuse crate::{\n\tchain_spec::{self, ParachainExtensions},\n\tcli::{Cli, RelayChainCli, Subcommand},\n\tservice::{\n\t\tnew_partial, AmplitudeRuntimeExecutor, DevelopmentRuntimeExecutor, FoucocoRuntimeExecutor,\n\t\tPendulumRuntimeExecutor,\n\t},\n};\n\n#[derive(PartialEq, Eq)]\nenum ChainIdentity {\n\tAmplitude,\n\tFoucoco,\n\tPendulum,\n\tDevelopment,\n}\n\nimpl ChainIdentity {\n\tfn identify(id: \u0026str) -\u003e Option\u003cSelf\u003e {\n\t\tmatch id {\n\t\t\t\"amplitude\" =\u003e Some(ChainIdentity::Amplitude),\n\t\t\t\"foucoco\" =\u003e Some(ChainIdentity::Foucoco),\n\t\t\t\"pendulum\" =\u003e Some(ChainIdentity::Pendulum),\n\t\t\t\"\" | \"dev\" =\u003e Some(ChainIdentity::Development),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n\n\tfn from_json_file(path: \u0026str) -\u003e std::result::Result\u003cSelf, String\u003e {\n\t\tGenericChainSpec::\u003c(), ParachainExtensions\u003e::from_json_file(path.into())\n\t\t\t.map(|chain_spec| chain_spec.identify())\n\t\t\t.or_else(|_| {\n\t\t\t\tGenericChainSpec::\u003c()\u003e::from_json_file(path.into())\n\t\t\t\t\t.map(|chain_spec| chain_spec.identify())\n\t\t\t})\n\t}\n\n\tfn get_runtime_version(\u0026self) -\u003e \u0026'static RuntimeVersion {\n\t\tmatch self {\n\t\t\tChainIdentity::Amplitude =\u003e \u0026amplitude_runtime::VERSION,\n\t\t\tChainIdentity::Foucoco =\u003e \u0026foucoco_runtime::VERSION,\n\t\t\tChainIdentity::Pendulum =\u003e \u0026pendulum_runtime::VERSION,\n\t\t\tChainIdentity::Development =\u003e \u0026development_runtime::VERSION,\n\t\t}\n\t}\n\n\tfn create_chain_spec(\u0026self) -\u003e Box\u003cdyn ChainSpec\u003e {\n\t\tmatch self {\n\t\t\tChainIdentity::Amplitude =\u003e Box::new(chain_spec::amplitude_config()),\n\t\t\tChainIdentity::Foucoco =\u003e Box::new(chain_spec::foucoco_config()),\n\t\t\tChainIdentity::Pendulum =\u003e Box::new(chain_spec::pendulum_config()),\n\t\t\tChainIdentity::Development =\u003e Box::new(chain_spec::development_config()),\n\t\t}\n\t}\n\n\tfn load_chain_spec_from_json_file(\n\t\t\u0026self,\n\t\tpath: \u0026str,\n\t) -\u003e std::result::Result\u003cBox\u003cdyn ChainSpec\u003e, String\u003e {\n\t\tOk(match self {\n\t\t\tChainIdentity::Amplitude =\u003e\n\t\t\t\tBox::new(chain_spec::AmplitudeChainSpec::from_json_file(path.into())?),\n\t\t\tChainIdentity::Foucoco =\u003e\n\t\t\t\tBox::new(chain_spec::FoucocoChainSpec::from_json_file(path.into())?),\n\t\t\tChainIdentity::Pendulum =\u003e\n\t\t\t\tBox::new(chain_spec::PendulumChainSpec::from_json_file(path.into())?),\n\t\t\tChainIdentity::Development =\u003e\n\t\t\t\tBox::new(chain_spec::DevelopmentChainSpec::from_json_file(path.into())?),\n\t\t})\n\t}\n}\n\ntrait IdentifyChain {\n\tfn identify(\u0026self) -\u003e ChainIdentity;\n}\n\nimpl IdentifyChain for dyn sc_service::ChainSpec {\n\tfn identify(\u0026self) -\u003e ChainIdentity {\n\t\tChainIdentity::identify(self.id()).unwrap_or(ChainIdentity::Development)\n\t}\n}\n\nimpl\u003cT: sc_service::ChainSpec + 'static\u003e IdentifyChain for T {\n\tfn identify(\u0026self) -\u003e ChainIdentity {\n\t\t\u003cdyn sc_service::ChainSpec\u003e::identify(self)\n\t}\n}\n\nimpl SubstrateCli for Cli {\n\tfn impl_name() -\u003e String {\n\t\t\"Pendulum Collator\".into()\n\t}\n\n\tfn impl_version() -\u003e String {\n\t\tenv!(\"SUBSTRATE_CLI_IMPL_VERSION\").into()\n\t}\n\n\tfn description() -\u003e String {\n\t\tformat!(\n\t\t\t\"Pendulum Collator\\n\\nThe command-line arguments provided first will be \\\n\t\tpassed to the parachain node, while the arguments provided after -- will be passed \\\n\t\tto the relay chain node.\\n\\n\\\n\t\t{} \u003cparachain-args\u003e -- \u003crelay-chain-args\u003e\",\n\t\t\tSelf::executable_name()\n\t\t)\n\t}\n\n\tfn author() -\u003e String {\n\t\tenv!(\"CARGO_PKG_AUTHORS\").into()\n\t}\n\n\tfn support_url() -\u003e String {\n\t\t\"https://github.com/pendulum-chain/pendulum/issues/new\".into()\n\t}\n\n\tfn copyright_start_year() -\u003e i32 {\n\t\t2022\n\t}\n\n\tfn load_spec(\u0026self, id: \u0026str) -\u003e std::result::Result\u003cBox\u003cdyn sc_service::ChainSpec\u003e, String\u003e {\n\t\tOk(match ChainIdentity::identify(id) {\n\t\t\tSome(identitiy) =\u003e identitiy.create_chain_spec(),\n\t\t\tNone =\u003e ChainIdentity::from_json_file(id)?.load_chain_spec_from_json_file(id)?,\n\t\t})\n\t}\n\n\tfn native_runtime_version(spec: \u0026Box\u003cdyn ChainSpec\u003e) -\u003e \u0026'static RuntimeVersion {\n\t\tspec.identify().get_runtime_version()\n\t}\n}\n\nimpl SubstrateCli for RelayChainCli {\n\tfn impl_name() -\u003e String {\n\t\t\"Pendulum Collator\".into()\n\t}\n\n\tfn impl_version() -\u003e String {\n\t\tenv!(\"SUBSTRATE_CLI_IMPL_VERSION\").into()\n\t}\n\n\tfn description() -\u003e String {\n\t\tformat!(\n\t\t\t\"Pendulum Collator\\n\\nThe command-line arguments provided first will be \\\n\t\tpassed to the parachain node, while the arguments provided after -- will be passed \\\n\t\tto the relay chain node.\\n\\n\\\n\t\t{} \u003cparachain-args\u003e -- \u003crelay-chain-args\u003e\",\n\t\t\tSelf::executable_name()\n\t\t)\n\t}\n\n\tfn author() -\u003e String {\n\t\tenv!(\"CARGO_PKG_AUTHORS\").into()\n\t}\n\n\tfn support_url() -\u003e String {\n\t\t\"https://github.com/pendulum-chain/pendulum/issues/new\".into()\n\t}\n\n\tfn copyright_start_year() -\u003e i32 {\n\t\t2022\n\t}\n\n\tfn load_spec(\u0026self, id: \u0026str) -\u003e std::result::Result\u003cBox\u003cdyn sc_service::ChainSpec\u003e, String\u003e {\n\t\tpolkadot_cli::Cli::from_iter([RelayChainCli::executable_name()].iter()).load_spec(id)\n\t}\n\n\tfn native_runtime_version(chain_spec: \u0026Box\u003cdyn ChainSpec\u003e) -\u003e \u0026'static RuntimeVersion {\n\t\tpolkadot_cli::Cli::native_runtime_version(chain_spec)\n\t}\n}\n\nmacro_rules! construct_sync_run {\n\t(|$components:ident, $cli:ident, $cmd:ident, $config:ident| $code:expr ) =\u003e {{\n\t\tlet runner = $cli.create_runner($cmd)?;\n\n\t\tmatch runner.config().chain_spec.identify() {\n\t\t\tChainIdentity::Amplitude =\u003e runner.sync_run(|$config| {\n\t\t\t\tlet $components = new_partial::\u003c\n\t\t\t\t\tamplitude_runtime::RuntimeApi,\n\t\t\t\t\tAmplitudeRuntimeExecutor,\n\t\t\t\t\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Foucoco =\u003e runner.sync_run(|$config| {\n\t\t\t\tlet $components =\n\t\t\t\t\tnew_partial::\u003cfoucoco_runtime::RuntimeApi, FoucocoRuntimeExecutor\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Pendulum =\u003e runner.sync_run(|$config| {\n\t\t\t\tlet $components =\n\t\t\t\t\tnew_partial::\u003cpendulum_runtime::RuntimeApi, PendulumRuntimeExecutor\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Development =\u003e runner.sync_run(|$config| {\n\t\t\t\tlet $components = new_partial::\u003c\n\t\t\t\t\tdevelopment_runtime::RuntimeApi,\n\t\t\t\t\tDevelopmentRuntimeExecutor,\n\t\t\t\t\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t}\n\t}};\n}\n\nmacro_rules! construct_generic_async_run {\n\t(|$components:ident, $cli:ident, $cmd:ident, $config:ident| $code:expr ) =\u003e {{\n\t\tlet runner = $cli.create_runner($cmd)?;\n\n\t\tmatch runner.config().chain_spec.identify() {\n\t\t\tChainIdentity::Amplitude =\u003e runner.async_run(|$config| {\n\t\t\t\tlet $components = new_partial::\u003c\n\t\t\t\t\tamplitude_runtime::RuntimeApi,\n\t\t\t\t\tAmplitudeRuntimeExecutor,\n\t\t\t\t\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Foucoco =\u003e runner.async_run(|$config| {\n\t\t\t\tlet $components =\n\t\t\t\t\tnew_partial::\u003cfoucoco_runtime::RuntimeApi, FoucocoRuntimeExecutor\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Pendulum =\u003e runner.async_run(|$config| {\n\t\t\t\tlet $components =\n\t\t\t\t\tnew_partial::\u003cpendulum_runtime::RuntimeApi, PendulumRuntimeExecutor\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Development =\u003e runner.async_run(|$config| {\n\t\t\t\tlet $components = new_partial::\u003c\n\t\t\t\t\tdevelopment_runtime::RuntimeApi,\n\t\t\t\t\tDevelopmentRuntimeExecutor,\n\t\t\t\t\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t}\n\t}};\n}\n\nmacro_rules! construct_async_run {\n\t(|$components:ident, $cli:ident, $cmd:ident, $config:ident| $( $code:tt )* ) =\u003e {{\n\t\tconstruct_generic_async_run!(|$components, $cli, $cmd, $config| {\n\t\t\tlet task_manager = $components.task_manager;\n\t\t\t\t\t{ $( $code )* }.map(|v| (v, task_manager))\n\t\t})\n\t}}\n}\n\n/// Parse command line arguments into service configuration.\npub fn run() -\u003e Result\u003c()\u003e {\n\tlet cli = Cli::from_args();\n\n\tmatch \u0026cli.subcommand {\n\t\tSome(Subcommand::BuildSpec(cmd)) =\u003e {\n\t\t\tlet runner = cli.create_runner(cmd)?;\n\t\t\trunner.sync_run(|config| cmd.run(config.chain_spec, config.network))\n\t\t},\n\t\tSome(Subcommand::CheckBlock(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, components.import_queue))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ExportBlocks(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, config.database))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ExportState(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, config.chain_spec))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ImportBlocks(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, components.import_queue))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::Revert(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, components.backend, None))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::PurgeChain(cmd)) =\u003e {\n\t\t\tlet runner = cli.create_runner(cmd)?;\n\n\t\t\trunner.sync_run(|config| {\n\t\t\t\tlet polkadot_cli = RelayChainCli::new(\n\t\t\t\t\t\u0026config,\n\t\t\t\t\t[RelayChainCli::executable_name()].iter().chain(cli.relay_chain_args.iter()),\n\t\t\t\t);\n\n\t\t\t\tlet polkadot_config = SubstrateCli::create_configuration(\n\t\t\t\t\t\u0026polkadot_cli,\n\t\t\t\t\t\u0026polkadot_cli,\n\t\t\t\t\tconfig.tokio_handle.clone(),\n\t\t\t\t)\n\t\t\t\t.map_err(|err| format!(\"Relay chain argument error: {}\", err))?;\n\n\t\t\t\tcmd.run(config, polkadot_config)\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ExportGenesisState(cmd)) =\u003e {\n\t\t\tlet runner = cli.create_runner(cmd)?;\n\t\t\trunner.sync_run(|_config| {\n\t\t\t\tlet spec = cli.load_spec(\u0026cmd.shared_params.chain.clone().unwrap_or_default())?;\n\t\t\t\tlet state_version = Cli::native_runtime_version(\u0026spec).state_version();\n\t\t\t\tcmd.run::\u003cBlock\u003e(\u0026*spec, state_version)\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ExportGenesisWasm(cmd)) =\u003e {\n\t\t\tlet runner = cli.create_runner(cmd)?;\n\t\t\trunner.sync_run(|_config| {\n\t\t\t\tlet spec = cli.load_spec(\u0026cmd.shared_params.chain.clone().unwrap_or_default())?;\n\t\t\t\tcmd.run(\u0026*spec)\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::Benchmark(bench_cmd)) =\u003e match bench_cmd {\n\t\t\tBenchmarkCmd::Pallet(cmd) =\u003e\n\t\t\t\tif cfg!(feature = \"runtime-benchmarks\") {\n\t\t\t\t\tlet runner = cli.create_runner(cmd)?;\n\n\t\t\t\t\tmatch runner.config().chain_spec.identify() {\n\t\t\t\t\t\tChainIdentity::Amplitude =\u003e runner\n\t\t\t\t\t\t\t.sync_run(|config| cmd.run::\u003cBlock, AmplitudeRuntimeExecutor\u003e(config)),\n\t\t\t\t\t\tChainIdentity::Foucoco =\u003e runner\n\t\t\t\t\t\t\t.sync_run(|config| cmd.run::\u003cBlock, FoucocoRuntimeExecutor\u003e(config)),\n\t\t\t\t\t\tChainIdentity::Pendulum =\u003e runner\n\t\t\t\t\t\t\t.sync_run(|config| cmd.run::\u003cBlock, PendulumRuntimeExecutor\u003e(config)),\n\t\t\t\t\t\tChainIdentity::Development =\u003e runner.sync_run(|config| {\n\t\t\t\t\t\t\tcmd.run::\u003cBlock, DevelopmentRuntimeExecutor\u003e(config)\n\t\t\t\t\t\t}),\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tErr(\"Benchmarking wasn't enabled when building the node. \\\n\t\t\t\tYou can enable it with `--features runtime-benchmarks`.\"\n\t\t\t\t\t\t.into())\n\t\t\t\t},\n\t\t\tBenchmarkCmd::Block(cmd) =\u003e {\n\t\t\t\tconstruct_sync_run!(|components, cli, cmd, config| cmd.run(components.client))\n\t\t\t},\n\t\t\t#[cfg(not(feature = \"runtime-benchmarks\"))]\n\t\t\tBenchmarkCmd::Storage(_) =\u003e\n\t\t\t\treturn Err(sc_cli::Error::Input(\n\t\t\t\t\t\"Compile with --features=runtime-benchmarks \\\n\t\t\t\t\t\tto enable storage benchmarks.\"\n\t\t\t\t\t\t.into(),\n\t\t\t\t)\n\t\t\t\t.into()),\n\t\t\t#[cfg(feature = \"runtime-benchmarks\")]\n\t\t\tBenchmarkCmd::Storage(cmd) =\u003e {\n\t\t\t\tconstruct_sync_run!(|components, cli, cmd, config| {\n\t\t\t\t\tlet db = components.backend.expose_db();\n\t\t\t\t\tlet storage = components.backend.expose_storage();\n\n\t\t\t\t\tcmd.run(config, components.client.clone(), db, storage)\n\t\t\t\t})\n\t\t\t},\n\t\t\tBenchmarkCmd::Machine(cmd) =\u003e {\n\t\t\t\tlet runner = cli.create_runner(cmd)?;\n\t\t\t\trunner.sync_run(|config| cmd.run(\u0026config, SUBSTRATE_REFERENCE_HARDWARE.clone()))\n\t\t\t},\n\t\t\t// NOTE: this allows the Client to leniently implement\n\t\t\t// new benchmark commands without requiring a companion MR.\n\t\t\t#[allow(unreachable_patterns)]\n\t\t\t_ =\u003e Err(\"Benchmarking sub-command unsupported\".into()),\n\t\t},\n\t\t#[cfg(feature = \"try-runtime\")]\n\t\tSome(Subcommand::TryRuntime(cmd)) =\u003e {\n\t\t\tif cfg!(feature = \"try-runtime\") {\n\t\t\t\tlet runner = cli.create_runner(cmd)?;\n\n\t\t\t\t// grab the task manager.\n\t\t\t\tlet registry = \u0026runner.config().prometheus_config.as_ref().map(|cfg| \u0026cfg.registry);\n\t\t\t\tlet task_manager =\n\t\t\t\t\tTaskManager::new(runner.config().tokio_handle.clone(), *registry)\n\t\t\t\t\t\t.map_err(|e| format!(\"Error: {:?}\", e))?;\n\n\t\t\t\tmatch runner.config().chain_spec.identify() {\n\t\t\t\t\tChainIdentity::Amplitude =\u003e runner.async_run(|config| {\n\t\t\t\t\t\tOk((cmd.run::\u003cBlock, AmplitudeRuntimeExecutor\u003e(config), task_manager))\n\t\t\t\t\t}),\n\t\t\t\t\tChainIdentity::Foucoco =\u003e runner.async_run(|config| {\n\t\t\t\t\t\tOk((cmd.run::\u003cBlock, FoucocoRuntimeExecutor\u003e(config), task_manager))\n\t\t\t\t\t}),\n\t\t\t\t\tChainIdentity::Pendulum =\u003e runner.async_run(|config| {\n\t\t\t\t\t\tOk((cmd.run::\u003cBlock, PendulumRuntimeExecutor\u003e(config), task_manager))\n\t\t\t\t\t}),\n\t\t\t\t\tChainIdentity::Development =\u003e runner.async_run(|config| {\n\t\t\t\t\t\tOk((cmd.run::\u003cBlock, DevelopmentRuntimeExecutor\u003e(config), task_manager))\n\t\t\t\t\t}),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tErr(\"Try-runtime must be enabled by `--features try-runtime`.\".into())\n\t\t\t}\n\t\t},\n\t\tNone =\u003e {\n\t\t\tlet runner = cli.create_runner(\u0026cli.run.normalize())?;\n\t\t\tlet collator_options = cli.run.collator_options();\n\n\t\t\trunner.run_node_until_exit(|config| async move {\n\t\t\t\tlet hwbench = if !cli.no_hardware_benchmarks {\n\t\t\t\t\tconfig.database.path().map(|database_path| {\n\t\t\t\t\t\tlet _ = std::fs::create_dir_all(\u0026database_path);\n\t\t\t\t\t\tsc_sysinfo::gather_hwbench(Some(database_path))\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tNone\n\t\t\t\t};\n\n\t\t\t\tlet para_id = chain_spec::ParachainExtensions::try_get(\u0026*config.chain_spec)\n\t\t\t\t\t.map(|e| e.para_id)\n\t\t\t\t\t.ok_or_else(|| \"Could not find parachain ID in chain-spec.\")?;\n\n\t\t\t\tlet polkadot_cli = RelayChainCli::new(\n\t\t\t\t\t\u0026config,\n\t\t\t\t\t[RelayChainCli::executable_name()].iter().chain(cli.relay_chain_args.iter()),\n\t\t\t\t);\n\n\t\t\t\tlet id = ParaId::from(para_id);\n\n\t\t\t\tlet parachain_account =\n\t\t\t\t\tAccountIdConversion::\u003cpolkadot_primitives::v2::AccountId\u003e::into_account_truncating(\u0026id);\n\n\t\t\t\tlet state_version = Cli::native_runtime_version(\u0026config.chain_spec).state_version();\n\t\t\t\tlet block: Block = generate_genesis_block(\u0026*config.chain_spec, state_version)\n\t\t\t\t\t.map_err(|e| format!(\"{:?}\", e))?;\n\t\t\t\tlet genesis_state = format!(\"0x{:?}\", HexDisplay::from(\u0026block.header().encode()));\n\n\t\t\t\tlet tokio_handle = config.tokio_handle.clone();\n\t\t\t\tlet polkadot_config =\n\t\t\t\t\tSubstrateCli::create_configuration(\u0026polkadot_cli, \u0026polkadot_cli, tokio_handle)\n\t\t\t\t\t\t.map_err(|err| format!(\"Relay chain argument error: {}\", err))?;\n\n\t\t\t\tinfo!(\"Parachain id: {:?}\", id);\n\t\t\t\tinfo!(\"Parachain Account: {}\", parachain_account);\n\t\t\t\tinfo!(\"Parachain genesis state: {}\", genesis_state);\n\t\t\t\tinfo!(\"Is collating: {}\", if config.role.is_authority() { \"yes\" } else { \"no\" });\n\n\t\t\t\tif !collator_options.relay_chain_rpc_urls.is_empty() \u0026\u0026 cli.relay_chain_args.len() \u003e 0 {\n\t\t\t\t\twarn!(\"Detected relay chain node arguments together with --relay-chain-rpc-url. This command starts a minimal Polkadot node that only uses a network-related subset of all relay chain CLI options.\");\n\t\t\t\t}\n\n\t\t\t\tlet res = match config.chain_spec.identify() {\n\t\t\t\t\tChainIdentity::Amplitude =\u003e {\n\t\t\t\t\t\tsp_core::crypto::set_default_ss58_version(\n\t\t\t\t\t\t\tamplitude_runtime::SS58Prefix::get().into(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcrate::service::start_parachain_node_spacewalk_amplitude(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tpolkadot_config,\n\t\t\t\t\t\t\tcollator_options,\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\thwbench,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.await\n\t\t\t\t\t\t.map(|r| r.0)\n\t\t\t\t\t\t.map_err(Into::into)\n\t\t\t\t\t},\n\t\t\t\t\tChainIdentity::Foucoco =\u003e {\n\t\t\t\t\t\tsp_core::crypto::set_default_ss58_version(\n\t\t\t\t\t\t\tfoucoco_runtime::SS58Prefix::get().into(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcrate::service::start_parachain_node_spacewalk_foucoco(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tpolkadot_config,\n\t\t\t\t\t\t\tcollator_options,\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\thwbench,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.await\n\t\t\t\t\t\t.map(|r| r.0)\n\t\t\t\t\t\t.map_err(Into::into)\n\t\t\t\t\t},\n\t\t\t\t\tChainIdentity::Pendulum =\u003e {\n\t\t\t\t\t\tsp_core::crypto::set_default_ss58_version(\n\t\t\t\t\t\t\tpendulum_runtime::SS58Prefix::get().into(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcrate::service::start_parachain_node_pendulum(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tpolkadot_config,\n\t\t\t\t\t\t\tcollator_options,\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\thwbench,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.await\n\t\t\t\t\t\t.map(|r| r.0)\n\t\t\t\t\t\t.map_err(Into::into)\n\t\t\t\t\t},\n\n\t\t\t\t\tChainIdentity::Development =\u003e crate::service::start_parachain_node_development(\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tpolkadot_config,\n\t\t\t\t\t\tcollator_options,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\thwbench,\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t.map(|r| r.0)\n\t\t\t\t\t.map_err(Into::into),\n\t\t\t\t};\n\n\t\t\t\tres\n\t\t\t})\n\t\t},\n\t}\n}\n\nimpl DefaultConfigurationValues for RelayChainCli {\n\tfn p2p_listen_port() -\u003e u16 {\n\t\t30334\n\t}\n\n\tfn rpc_ws_listen_port() -\u003e u16 {\n\t\t9945\n\t}\n\n\tfn rpc_http_listen_port() -\u003e u16 {\n\t\t9934\n\t}\n\n\tfn prometheus_listen_port() -\u003e u16 {\n\t\t9616\n\t}\n}\n\nimpl CliConfiguration\u003cSelf\u003e for RelayChainCli {\n\tfn shared_params(\u0026self) -\u003e \u0026SharedParams {\n\t\tself.base.base.shared_params()\n\t}\n\n\tfn import_params(\u0026self) -\u003e Option\u003c\u0026ImportParams\u003e {\n\t\tself.base.base.import_params()\n\t}\n\n\tfn network_params(\u0026self) -\u003e Option\u003c\u0026NetworkParams\u003e {\n\t\tself.base.base.network_params()\n\t}\n\n\tfn keystore_params(\u0026self) -\u003e Option\u003c\u0026KeystoreParams\u003e {\n\t\tself.base.base.keystore_params()\n\t}\n\n\tfn base_path(\u0026self) -\u003e Result\u003cOption\u003cBasePath\u003e\u003e {\n\t\tOk(self\n\t\t\t.shared_params()\n\t\t\t.base_path()?\n\t\t\t.or_else(|| self.base_path.clone().map(Into::into)))\n\t}\n\n\tfn rpc_http(\u0026self, default_listen_port: u16) -\u003e Result\u003cOption\u003cSocketAddr\u003e\u003e {\n\t\tself.base.base.rpc_http(default_listen_port)\n\t}\n\n\tfn rpc_ipc(\u0026self) -\u003e Result\u003cOption\u003cString\u003e\u003e {\n\t\tself.base.base.rpc_ipc()\n\t}\n\n\tfn rpc_ws(\u0026self, default_listen_port: u16) -\u003e Result\u003cOption\u003cSocketAddr\u003e\u003e {\n\t\tself.base.base.rpc_ws(default_listen_port)\n\t}\n\n\tfn prometheus_config(\n\t\t\u0026self,\n\t\tdefault_listen_port: u16,\n\t\tchain_spec: \u0026Box\u003cdyn ChainSpec\u003e,\n\t) -\u003e Result\u003cOption\u003cPrometheusConfig\u003e\u003e {\n\t\tself.base.base.prometheus_config(default_listen_port, chain_spec)\n\t}\n\n\tfn init\u003cF\u003e(\n\t\t\u0026self,\n\t\t_support_url: \u0026String,\n\t\t_impl_version: \u0026String,\n\t\t_logger_hook: F,\n\t\t_config: \u0026sc_service::Configuration,\n\t) -\u003e Result\u003c()\u003e\n\twhere\n\t\tF: FnOnce(\u0026mut sc_cli::LoggerBuilder, \u0026sc_service::Configuration),\n\t{\n\t\tunreachable!(\"PolkadotCli is never initialized; qed\");\n\t}\n\n\tfn chain_id(\u0026self, is_dev: bool) -\u003e Result\u003cString\u003e {\n\t\tlet chain_id = self.base.base.chain_id(is_dev)?;\n\n\t\tOk(if chain_id.is_empty() { self.chain_id.clone().unwrap_or_default() } else { chain_id })\n\t}\n\n\tfn role(\u0026self, is_dev: bool) -\u003e Result\u003csc_service::Role\u003e {\n\t\tself.base.base.role(is_dev)\n\t}\n\n\tfn transaction_pool(\u0026self, is_dev: bool) -\u003e Result\u003csc_service::config::TransactionPoolOptions\u003e {\n\t\tself.base.base.transaction_pool(is_dev)\n\t}\n\n\tfn trie_cache_maximum_size(\u0026self) -\u003e Result\u003cOption\u003cusize\u003e\u003e {\n\t\tself.base.base.trie_cache_maximum_size()\n\t}\n\n\tfn rpc_methods(\u0026self) -\u003e Result\u003csc_service::config::RpcMethods\u003e {\n\t\tself.base.base.rpc_methods()\n\t}\n\n\tfn rpc_ws_max_connections(\u0026self) -\u003e Result\u003cOption\u003cusize\u003e\u003e {\n\t\tself.base.base.rpc_ws_max_connections()\n\t}\n\n\tfn rpc_cors(\u0026self, is_dev: bool) -\u003e Result\u003cOption\u003cVec\u003cString\u003e\u003e\u003e {\n\t\tself.base.base.rpc_cors(is_dev)\n\t}\n\n\tfn default_heap_pages(\u0026self) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n\t\tself.base.base.default_heap_pages()\n\t}\n\n\tfn force_authoring(\u0026self) -\u003e Result\u003cbool\u003e {\n\t\tself.base.base.force_authoring()\n\t}\n\n\tfn disable_grandpa(\u0026self) -\u003e Result\u003cbool\u003e {\n\t\tself.base.base.disable_grandpa()\n\t}\n\n\tfn max_runtime_instances(\u0026self) -\u003e Result\u003cOption\u003cusize\u003e\u003e {\n\t\tself.base.base.max_runtime_instances()\n\t}\n\n\tfn announce_block(\u0026self) -\u003e Result\u003cbool\u003e {\n\t\tself.base.base.announce_block()\n\t}\n\n\tfn telemetry_endpoints(\n\t\t\u0026self,\n\t\tchain_spec: \u0026Box\u003cdyn ChainSpec\u003e,\n\t) -\u003e Result\u003cOption\u003csc_telemetry::TelemetryEndpoints\u003e\u003e {\n\t\tself.base.base.telemetry_endpoints(chain_spec)\n\t}\n\n\tfn node_name(\u0026self) -\u003e Result\u003cString\u003e {\n\t\tself.base.base.node_name()\n\t}\n}\n","traces":[{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","marcel","Documents","pendulum","node","src","constants","amplitude.rs"],"content":"use runtime_common::{Balance, UNIT};\n\npub const PARACHAIN_ID: u32 = 2124;\npub const INITIAL_ISSUANCE: Balance = 200_000_000 * UNIT;\n\npub const INITIAL_ISSUANCE_PER_SIGNATORY: Balance = 200 * UNIT;\n\npub const INITIAL_COLLATOR_STAKING: Balance = 10_000 * UNIT;\npub const COLLATOR_ADDITIONAL: Balance = 10 * UNIT;\n\npub const TOKEN_DECIMALS: u32 = 12;\n\npub const INITIAL_SUDO_SIGNATORIES: [\u0026str; 5] = [\n\t\"6nJwMD3gk36fe6pMRL2UpbwAEjDdjjxdngQGShe753pyAvCT\",\n\t\"6i4xDEE1Q2Bv8tnJtgD4jse4YTAzzCwCJVUehRQ93hCqKp8f\",\n\t\"6n62KZWvmZHgeyEXTvQFmoHRMqjKfFWvQVsApkePekuNfek5\",\n\t\"6kwxQBRKMadrY9Lq3K8gZXkw1UkjacpqYhcqvX3AqmN9DofF\",\n\t\"6kKHwcpCVC18KepwvdMSME8Q7ZTNr1RoRUrFDH9AdAmhL3Pt\",\n];\n\npub const INITIAL_COLLATORS: [\u0026str; 8] = [\n\t\"6mTATq7Ug9RPk4s8aMv5H7WVZ7RvwrJ1JitbYMXWPhanzqiv\",\n\t\"6n8WiWqjEB8nCNRo5mxXc89FqhuMd2dgXNSrzuPxoZSnatnL\",\n\t\"6ic56zZmjqo746yifWzcNxxzxLe3pRo8WNitotniUQvgKnyU\",\n\t\"6gvFApEyYj4EavJP26mwbVu7YxFBYZ9gaJFB7gv5gA6vNfze\",\n\t\"6mz3ymVAsfHotEhHphVRvLLBhMZ2frnwbuvW5QZiMRwJghxE\",\n\t\"6mpD3zcHcUBkxCjTsGg2tMTfmQZdXLVYZnk4UkN2XAUTLkRe\",\n\t\"6mGcZntk59RK2JfxfdmprgDJeByVUgaffMQYkp1ZeoEKeBJA\",\n\t\"6jq7obxC7AxhWeJNzopwYidKNNe48cLrbGSgB2zs2SuRTWGA\",\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","constants","foucoco.rs"],"content":"use runtime_common::{Balance, UNIT};\n\npub const PARACHAIN_ID: u32 = 2124;\npub const INITIAL_ISSUANCE: Balance = 200_000_000 * UNIT;\n\npub const INITIAL_ISSUANCE_PER_SIGNATORY: Balance = 200 * UNIT;\n\npub const INITIAL_COLLATOR_STAKING: Balance = 10_000 * UNIT;\npub const COLLATOR_ADDITIONAL: Balance = 10 * UNIT;\n\npub const OFF_CHAIN_WORKER_ADDRESS: \u0026str = \"6m69vWMouLarYCbJGJisVaDDpfNGETkD5hsDWf2T7osW4Cn1\";\n\npub const TOKEN_DECIMALS: u32 = 12;\n\npub const INITIAL_SUDO_SIGNATORIES: [\u0026str; 5] = [\n\t\"6mSy3qQKgAez9zpqY1JSnYW7d1njMNX93P4mkkQvsmPXmehB\",\n\t\"6mrdgs7NsHwceSPQRcXCagYzZiB4hoMBGmpMPLA4rS4BGyo7\",\n\t\"6jBUR27UemaZBF2aYrEbMuN3u76aANEpA3uxLrQcWP8jNDtf\",\n\t\"6hcDDb1nV6zrqfiB7dgQ5DbzuLkPmxkvSZ5LSA9kcE3gxNs8\",\n\t\"6k4NQX2KepBkeexrWVNabnWG9GZxvQTYi4ytHHCNwPhLZMnE\",\n];\n\npub const INITIAL_COLLATORS: [\u0026str; 4] = [\n\t\"6ihktBwyFJYjE1LKdqoAWzo5VDPJJGso9D5iASZyhuN5JvGH\",\n\t\"6mbXa9Qca6B6cX51cbtfWWLhup84rMoMFCxNHjso15GBFyGh\",\n\t\"6mMdv2wmb4Cp8PAtDLF1WTh1wLPwPbETwtcjqgJLskdB8EYo\",\n\t\"6kL1dzcBJiLgMdAT1qDFD79CLupX1gCCF8RSg5Dh5qRgQeCx\",\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","constants","mod.rs"],"content":"use spacewalk_primitives::{Asset, CurrencyId};\n\npub mod amplitude;\npub mod foucoco;\npub mod pendulum;\n\n// For Mainnet USDC issued by the testnet issuer\npub const MAINNET_USDC_CURRENCY_ID: CurrencyId = CurrencyId::Stellar(Asset::AlphaNum4 {\n\tcode: *b\"USDC\",\n\tissuer: [\n\t\t59, 153, 17, 56, 14, 254, 152, 139, 160, 168, 144, 14, 177, 207, 228, 79, 54, 111, 125,\n\t\t190, 148, 107, 237, 7, 114, 64, 247, 246, 36, 223, 21, 197,\n\t],\n});\n\n// For Mainnet BRL issued by the testnet issuer\npub const MAINNET_BRL_CURRENCY_ID: CurrencyId = CurrencyId::Stellar(Asset::AlphaNum4 {\n\tcode: *b\"BRL\\0\",\n\tissuer: [\n\t\t234, 172, 104, 212, 208, 227, 123, 76, 36, 194, 83, 105, 22, 232, 48, 115, 95, 3, 45, 13,\n\t\t107, 42, 28, 143, 202, 59, 197, 162, 94, 8, 62, 58,\n\t],\n});\n\n// For Mainnet TZS issued by the testnet issuer\npub const MAINNET_TZS_CURRENCY_ID: CurrencyId = CurrencyId::Stellar(Asset::AlphaNum4 {\n\tcode: *b\"TZS\\0\",\n\tissuer: [\n\t\t52, 201, 75, 42, 75, 169, 232, 181, 123, 34, 84, 125, 203, 179, 15, 68, 60, 76, 176, 45,\n\t\t163, 130, 154, 137, 170, 27, 212, 120, 14, 68, 102, 186,\n\t],\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","constants","pendulum.rs"],"content":"use runtime_common::{Balance, UNIT};\n\npub const PARACHAIN_ID: u32 = 2094;\npub const TOTAL_INITIAL_ISSUANCE: Balance = 160_000_000 * UNIT;\n\npub const INITIAL_ISSUANCE_PER_SIGNATORY: Balance = 200 * UNIT;\n\npub const INITIAL_COLLATOR_STAKING: Balance = 5_000 * UNIT;\npub const COLLATOR_ADDITIONAL: Balance = 10 * UNIT;\n\npub const TOKEN_DECIMALS: u32 = 12;\n\npub const SUDO_SIGNATORIES: [\u0026str; 5] = [\n\t\"6bgxxegcuBCYngSkJqp7bzgVZWd7brVrABEQetFq1R5dNa7T\",\n\t\"6cm5M5JVknj4NQdWpdayqwm92wzvSzjgE5SCRS7HM1EoauLm\",\n\t\"6gkRvy75f8gngVgtbJ72WHWPf17xgFGHuE2h2vKce5cnBidw\",\n\t\"6eD6Ep2GxAsPrCLNMtPNEv2Nj9D3EzJsPzMBGz8R8JGgNXg3\",\n\t\"6fvm48ZH2NYvBasbFLm8r2t33K9tVL6y9Z14HWiaoAYr4WNi\",\n];\n\npub const MULTISIG_ID_GENESIS: \u0026str = \"6ce4KspfCTmRnDzpQ3JYFYGPDgoqph6NYnqNTe58b86tusEn\";\npub const MULTISIG_ID_TEAM: \u0026str = \"6diKWq553r9jYkuyeWLd7YLU36ovc71puFKEq4ayqChBUQAL\";\npub const MULTISIG_ID_CL_RESERVES: \u0026str = \"6fMjg9qf8r6wZNJB71k3x7Gm7QRkFkjUsJq9ZuhQucav3sBZ\";\npub const MULTISIG_ID_INCENTIVES: \u0026str = \"6dzVMr6dud6Qt5ztG9T3iscv7f5jN9N26PfGAqJq8EjHGkcd\";\npub const MULTISIG_ID_MARKETING: \u0026str = \"6dxAdKt9zGDjUeHHcsi5U1fgxT1HKcHVjwoTANRPWjHd7Q1U\";\n\npub const CL_RESERVES_ALLOCATION: Balance = 10_000_000 * UNIT;\npub const INCENTIVES_ALLOCATION: Balance = 8_000_000 * UNIT;\npub const MARKETING_ALLOCATION: Balance = 10_000_000 * UNIT;\npub const TREASURY_ALLOCATION: Balance = 26_000_000 * UNIT;\n\npub const INITIAL_COLLATORS: [\u0026str; 8] = [\n\t\"6gUmMnikYxEkk4H7RdnsLRrzNRuDrGAh8JgSiCghG39qenX9\",\n\t\"6cgKZANaeUJ42VC7iAXrTzX8NC2gdn4WmYAHRo1RBjBfVvnk\",\n\t\"6bh2t6KMJ9BKgCs1B6qcrp5BjMyv2azmgBC6ySwZ3wrTeW5s\",\n\t\"6bBH94XAkscX5Q1oswuPSenUzjb9f2iPcfhTKdu1XCK1uwVS\",\n\t\"6emSrvAgGZXGBu255njQg3pBxDyQN47T7H2XDZuS5V5epHaX\",\n\t\"6fciE2ek1AMFUaFm4nizaHEZtXBy6eRxEcoygr3SFKfddBBK\",\n\t\"6ftBtHvYrThAv1xHYDnYrm2qQLFcj2rhkaU5GqNuqvKp57v6\",\n\t\"6feqfoP5htFpSriTd9oomDa1dZDmcM4XpjKEq8dfdcADCfGt\",\n];\n\npub struct Allocation {\n\tpub address: \u0026'static str,\n\tpub amount: Balance,\n}\n\npub const ALLOCATIONS_10_24: [Allocation; 33] = [\n\tAllocation { address: \"16LZddCHy8Td5p1T7hN52k1yPgS5Kvi4FbcN1qmgpEDLrmxW\", amount: 200000 },\n\tAllocation { address: \"124pJ5gdqKDXL3VjryYZiPBTTmtia6rEAGfUbHaf8LNToqZE\", amount: 2000000 },\n\tAllocation { address: \"15SvDT9AEzWbZU96Ea6KtPgFVvH1R1DqFDmUi9pYPr1ZymLG\", amount: 280000 },\n\tAllocation { address: \"16Zm7ctGjbVsADdPP8x8M6X6KXQxdzwjncWXbhFmQgGVQ1k6\", amount: 1200000 },\n\tAllocation { address: \"1kM6D9EgjD6VZQTZoEEVdANhaQFFeVtvowzVFpgv5DbqySk\", amount: 553480 },\n\tAllocation { address: \"13QdwVMsKiN8DVvjhwUSg3zrfFAPKvd1nPP3FbtKacwZGZW3\", amount: 2960000 },\n\tAllocation { address: \"1RyThWA1SCv3EGayyC2n74Cz28Prh7cYHZih5Hc1eCk157N\", amount: 1900000 },\n\tAllocation { address: \"15uXmzkjdBh9oJzBea1cTK1jw79djMwfw6845DyCiFQJzr17\", amount: 400000 },\n\tAllocation { address: \"4sVT7n5xGBq4X4Nyr1oPmw7qyKpxFZfB3PyuSPa44uFwh2oa\", amount: 1080000 },\n\tAllocation { address: \"13wbnsaCot1JqtP7HS3ASjgs5n2X2fzGC2TswSjyEmThFkjv\", amount: 1000000 },\n\tAllocation { address: \"12xmShQ49VKcmWNoMovChvUP3ar3muvFtkcf7PvPwkAk2V31\", amount: 64000 },\n\tAllocation { address: \"14s3dQEfCB9yaexpQFN4C5ZmkvkXwEdxrv9NToSsBP7rCegG\", amount: 100000 },\n\tAllocation { address: \"5EhUWtF2ZJpHMbG9G65LUjAtBA48zCV5PCWXibZKwZvzNKQa\", amount: 160000 },\n\tAllocation { address: \"1nHjrXTmso9AuGnssYRYxJnBf8NbwFQyhrb7Svk7FcvrvH3\", amount: 276800 },\n\tAllocation { address: \"5DhWaXkGNJVg1FU15myWRcSLEpotK4wz4fjBp7qtcmnDtSJ6\", amount: 800000 },\n\tAllocation { address: \"136X6NEWZEBQscsCaocy5DT328KHpxFWwR6Z54fHPLRVuVu3\", amount: 800000 },\n\tAllocation { address: \"1254xvMjWNvYGn7vB1vcSLS4gL1VUiJL8BHu8NWsrG1jkHi8\", amount: 200000 },\n\tAllocation { address: \"5CAR4QkAD2pxc9uXT2SzLJjpKPGDfxqFVVeQKGB4ixXVL74c\", amount: 800000 },\n\tAllocation { address: \"14uUXVDrEjUSv9Ec22w6GQ3keXRxNu98RZ39z5Xz2FWHzwCC\", amount: 1840000 },\n\tAllocation { address: \"16XjrAX12Drvcz3daqjoLJmCTP3dBC8zxS286Zx9G9am66qm\", amount: 440000 },\n\tAllocation { address: \"158kU5QMgc74aQniPbBZwaezXD62GbHLv59CSqB3KnjNy8sV\", amount: 160000 },\n\tAllocation { address: \"5CaosCeDNkCMGV4CQHy2YNia5zmvV4EmVv2aTg2jzNcxejFn\", amount: 960000 },\n\tAllocation { address: \"15Dg5uQM8fuckTSfLnEC5cTyyBMbNbkwx4FJSoFshwQwqvRr\", amount: 1200000 },\n\tAllocation { address: \"15E56zSiZXmZNyaLAmhwo8icCqQWgWJpunytkideS9ZQSNLT\", amount: 1200000 },\n\tAllocation { address: \"5GVtKE3KP2pJpK8HjeDTsSMMYgciHZpP4HNj8E2bL2wHmtvW\", amount: 120000 },\n\tAllocation { address: \"12gmcL9eej9jRBFT26vZLF4b7aAe4P9aEYHGHFzJdmf5arPi\", amount: 200000 },\n\tAllocation { address: \"152ryYwv8LaNCEA5v1kr5hPQF8LLCEq1xuJmykMD2dbbDBiM\", amount: 200000 },\n\tAllocation { address: \"5EHtSzWCq4aaC2XzPRmbPEdwV4Uty7pKqukVTdeEygVpEJxf\", amount: 400000 },\n\tAllocation { address: \"153GQ6MRcZiSwRy7xEy3X8kQybdFMov9TWvQr8NDmJLzoFan\", amount: 80000 },\n\tAllocation { address: \"12KdQaJLMovA6q6j6jGbooMuCuDPz1PWtTLtT5ExCmwKbNJ6\", amount: 80000 },\n\tAllocation { address: \"5ELsgzLeCyCBBPQ5yimZ9aXiLBmvHkcTTK6iP9TdtaS3BvMp\", amount: 80000 },\n\tAllocation { address: \"5G45b78emoZ1eLmu4FCarmhhaxsRNmLZKuQmXE6tLnUGyFSC\", amount: 80000 },\n\tAllocation { address: \"156DACh3KCPcFbxQmdQeWZD7B1TywvRviSQwcE8TxHkDij4b\", amount: 160000 },\n];\n\npub const ALLOCATIONS_12_36: [Allocation; 2] = [\n\tAllocation { address: \"1xhckCAgNsFFTCeSN1VX7xMG6zrpL2dQqJDKqjt1mPmEAut\", amount: 500000 },\n\tAllocation { address: \"6gPTQUcQBM9xdmo3tfXDLuUNoZbERAdGHNhW3JeFDHuLfUBY\", amount: 500000 },\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","main.rs"],"content":"//! Pendulum/Amplitude Collator CLI\n\n#![warn(missing_docs)]\n\nmod chain_spec;\n#[macro_use]\nmod service;\nmod cli;\nmod command;\nmod constants;\nmod rpc;\n\nfn main() -\u003e sc_cli::Result\u003c()\u003e {\n\tcommand::run()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","rpc.rs"],"content":"//! A collection of node-specific RPC methods.\n//! Substrate provides the `sc-rpc` crate, which defines the core RPC layer\n//! used by Substrate nodes. This file extends those RPC definitions with\n//! capabilities that are specific to this project's runtime configuration.\n\n#![warn(missing_docs)]\n\nuse std::sync::Arc;\n\npub use sc_rpc::{DenyUnsafe, SubscriptionTaskExecutor};\nuse sc_transaction_pool_api::TransactionPool;\n\nuse bifrost_farming_rpc_api::{FarmingRpc, FarmingRpcApiServer};\n\nuse zenlink_protocol_rpc::{ZenlinkProtocol, ZenlinkProtocolApiServer};\n\nuse module_issue_rpc::{Issue, IssueApiServer};\nuse module_oracle_rpc::{Oracle, OracleApiServer};\nuse module_redeem_rpc::{Redeem, RedeemApiServer};\nuse module_replace_rpc::{Replace, ReplaceApiServer};\nuse module_vault_registry_rpc::{VaultRegistry, VaultRegistryApiServer};\nuse pallet_transaction_payment_rpc::{TransactionPayment, TransactionPaymentApiServer};\nuse substrate_frame_rpc_system::{System, SystemApiServer};\n\nuse crate::service::{AmplitudeClient, DevelopmentClient, FoucocoClient, PendulumClient};\n\n/// A type representing all RPC extensions.\npub type RpcExtension = jsonrpsee::RpcModule\u003c()\u003e;\n\n/// Full client dependencies\npub struct FullDeps\u003cC, P\u003e {\n\t/// The client instance to use.\n\tpub client: Arc\u003cC\u003e,\n\t/// Transaction pool instance.\n\tpub pool: Arc\u003cP\u003e,\n\t/// Whether to deny unsafe calls\n\tpub deny_unsafe: DenyUnsafe,\n}\n\n/// Instantiate all RPC extensions.\npub fn create_full_pendulum\u003cP\u003e(\n\tdeps: FullDeps\u003cPendulumClient, P\u003e,\n) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\nwhere\n\tP: TransactionPool + Sync + Send + 'static,\n{\n\tlet mut module = RpcExtension::new(());\n\tlet FullDeps { client, pool, deny_unsafe } = deps;\n\n\tmodule.merge(System::new(client.clone(), pool, deny_unsafe).into_rpc())?;\n\tmodule.merge(TransactionPayment::new(client.clone()).into_rpc())?;\n\tmodule.merge(ZenlinkProtocol::new(client).into_rpc())?;\n\tOk(module)\n}\n\n/// Instantiate all RPC extensions.\npub fn create_full_development\u003cP\u003e(\n\tdeps: FullDeps\u003cDevelopmentClient, P\u003e,\n) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\nwhere\n\tP: TransactionPool + Sync + Send + 'static,\n{\n\tlet mut module = RpcExtension::new(());\n\tlet FullDeps { client, pool, deny_unsafe } = deps;\n\n\tmodule.merge(System::new(client.clone(), pool, deny_unsafe).into_rpc())?;\n\tmodule.merge(TransactionPayment::new(client).into_rpc())?;\n\tOk(module)\n}\n\npub fn create_full_amplitude\u003cP\u003e(\n\tdeps: FullDeps\u003cAmplitudeClient, P\u003e,\n) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\nwhere\n\tP: TransactionPool + Sync + Send + 'static,\n{\n\tlet mut module = RpcExtension::new(());\n\tlet FullDeps { client, pool, deny_unsafe } = deps;\n\n\tmodule.merge(System::new(client.clone(), pool, deny_unsafe).into_rpc())?;\n\tmodule.merge(TransactionPayment::new(client.clone()).into_rpc())?;\n\tmodule.merge(Issue::new(client.clone()).into_rpc())?;\n\tmodule.merge(Redeem::new(client.clone()).into_rpc())?;\n\tmodule.merge(Replace::new(client.clone()).into_rpc())?;\n\tmodule.merge(VaultRegistry::new(client.clone()).into_rpc())?;\n\tmodule.merge(Oracle::new(client.clone()).into_rpc())?;\n\tmodule.merge(FarmingRpc::new(client.clone()).into_rpc())?;\n\tmodule.merge(ZenlinkProtocol::new(client).into_rpc())?;\n\n\tOk(module)\n}\n\npub fn create_full_foucoco\u003cP\u003e(\n\tdeps: FullDeps\u003cFoucocoClient, P\u003e,\n) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\nwhere\n\tP: TransactionPool + Sync + Send + 'static,\n{\n\tlet mut module = RpcExtension::new(());\n\tlet FullDeps { client, pool, deny_unsafe } = deps;\n\n\tmodule.merge(System::new(client.clone(), pool, deny_unsafe).into_rpc())?;\n\tmodule.merge(TransactionPayment::new(client.clone()).into_rpc())?;\n\tmodule.merge(Issue::new(client.clone()).into_rpc())?;\n\tmodule.merge(Redeem::new(client.clone()).into_rpc())?;\n\tmodule.merge(Replace::new(client.clone()).into_rpc())?;\n\tmodule.merge(VaultRegistry::new(client.clone()).into_rpc())?;\n\tmodule.merge(Oracle::new(client.clone()).into_rpc())?;\n\tmodule.merge(FarmingRpc::new(client.clone()).into_rpc())?;\n\tmodule.merge(ZenlinkProtocol::new(client).into_rpc())?;\n\n\tOk(module)\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":35},{"path":["/","Users","marcel","Documents","pendulum","node","src","service.rs"],"content":"//! Service and ServiceFactory implementation. Specialized wrapper over substrate service.\n\n// std\nuse std::{sync::Arc, time::Duration};\n\nuse cumulus_client_cli::CollatorOptions;\n// Local Runtime Types\nuse runtime_common::{opaque::Block, AccountId, Balance, Index as Nonce};\n\n// Cumulus Imports\nuse cumulus_client_consensus_aura::{AuraConsensus, BuildAuraConsensusParams, SlotProportion};\nuse cumulus_client_consensus_common::{\n\tParachainBlockImport as TParachainBlockImport, ParachainConsensus,\n};\nuse cumulus_client_network::BlockAnnounceValidator;\nuse cumulus_client_service::{\n\tprepare_node_config, start_collator, start_full_node, StartCollatorParams, StartFullNodeParams,\n};\nuse cumulus_primitives_core::ParaId;\nuse cumulus_relay_chain_inprocess_interface::build_inprocess_relay_chain;\nuse cumulus_relay_chain_interface::{RelayChainInterface, RelayChainResult};\nuse cumulus_relay_chain_minimal_node::build_minimal_relay_chain_node;\n\n// Substrate Imports\nuse sc_executor::NativeElseWasmExecutor;\nuse sc_network::NetworkBlock;\nuse sc_network_sync::SyncingService;\n\nuse sc_service::{Configuration, PartialComponents, TFullBackend, TFullClient, TaskManager};\nuse sc_telemetry::{Telemetry, TelemetryHandle, TelemetryWorker, TelemetryWorkerHandle};\nuse sp_api::ConstructRuntimeApi;\nuse sp_consensus_aura::{sr25519::AuthorityId, AuraApi};\nuse sp_keystore::SyncCryptoStorePtr;\nuse sp_runtime::traits::BlakeTwo256;\nuse substrate_prometheus_endpoint::Registry;\n\nuse polkadot_service::CollatorPair;\nuse sc_consensus::ImportQueue;\n\nuse crate::rpc::{\n\tcreate_full_amplitude, create_full_development, create_full_foucoco, create_full_pendulum,\n\tFullDeps, RpcExtension,\n};\n\npub use amplitude_runtime::RuntimeApi as AmplitudeRuntimeApi;\npub use development_runtime::RuntimeApi as DevelopmentRuntimeApi;\npub use foucoco_runtime::RuntimeApi as FoucocoRuntimeApi;\npub use pendulum_runtime::RuntimeApi as PendulumRuntimeApi;\n\npub type AmplitudeClient =\n\tTFullClient\u003cBlock, AmplitudeRuntimeApi, NativeElseWasmExecutor\u003cAmplitudeRuntimeExecutor\u003e\u003e;\npub type FoucocoClient =\n\tTFullClient\u003cBlock, FoucocoRuntimeApi, NativeElseWasmExecutor\u003cFoucocoRuntimeExecutor\u003e\u003e;\npub type PendulumClient =\n\tTFullClient\u003cBlock, PendulumRuntimeApi, NativeElseWasmExecutor\u003cPendulumRuntimeExecutor\u003e\u003e;\npub type DevelopmentClient =\n\tTFullClient\u003cBlock, DevelopmentRuntimeApi, NativeElseWasmExecutor\u003cDevelopmentRuntimeExecutor\u003e\u003e;\n\ntype ParachainBlockImport\u003cRuntimeApi, Executor\u003e = TParachainBlockImport\u003c\n\tBlock,\n\tArc\u003cTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e,\n\tTFullBackend\u003cBlock\u003e,\n\u003e;\n\npub trait ParachainRuntimeApiImpl:\n\tsp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e\n\t+ sp_api::Metadata\u003cBlock\u003e\n\t+ sp_session::SessionKeys\u003cBlock\u003e\n\t+ sp_api::ApiExt\u003cBlock, StateBackend = sc_client_api::StateBackendFor\u003cTFullBackend\u003cBlock\u003e, Block\u003e\u003e\n\t+ sp_offchain::OffchainWorkerApi\u003cBlock\u003e\n\t+ sp_block_builder::BlockBuilder\u003cBlock\u003e\n\t+ cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e\n\t+ pallet_transaction_payment_rpc::TransactionPaymentRuntimeApi\u003cBlock, Balance\u003e\n\t+ substrate_frame_rpc_system::AccountNonceApi\u003cBlock, AccountId, Nonce\u003e\n\t+ AuraApi\u003cBlock, AuthorityId\u003e\n{\n}\n\nimpl ParachainRuntimeApiImpl for amplitude_runtime::RuntimeApiImpl\u003cBlock, AmplitudeClient\u003e {}\nimpl ParachainRuntimeApiImpl for pendulum_runtime::RuntimeApiImpl\u003cBlock, PendulumClient\u003e {}\nimpl ParachainRuntimeApiImpl for foucoco_runtime::RuntimeApiImpl\u003cBlock, FoucocoClient\u003e {}\nimpl ParachainRuntimeApiImpl for development_runtime::RuntimeApiImpl\u003cBlock, DevelopmentClient\u003e {}\n\n/// Amplitude executor type.\npub struct AmplitudeRuntimeExecutor;\n\nimpl sc_executor::NativeExecutionDispatch for AmplitudeRuntimeExecutor {\n\ttype ExtendHostFunctions = frame_benchmarking::benchmarking::HostFunctions;\n\n\tfn dispatch(method: \u0026str, data: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n\t\tamplitude_runtime::api::dispatch(method, data)\n\t}\n\n\tfn native_version() -\u003e sc_executor::NativeVersion {\n\t\tamplitude_runtime::native_version()\n\t}\n}\n\n/// Foucoco executor type.\npub struct FoucocoRuntimeExecutor;\n\nimpl sc_executor::NativeExecutionDispatch for FoucocoRuntimeExecutor {\n\ttype ExtendHostFunctions = frame_benchmarking::benchmarking::HostFunctions;\n\n\tfn dispatch(method: \u0026str, data: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n\t\tfoucoco_runtime::api::dispatch(method, data)\n\t}\n\n\tfn native_version() -\u003e sc_executor::NativeVersion {\n\t\tfoucoco_runtime::native_version()\n\t}\n}\n\n/// Pendulum executor type.\npub struct PendulumRuntimeExecutor;\n\nimpl sc_executor::NativeExecutionDispatch for PendulumRuntimeExecutor {\n\ttype ExtendHostFunctions = frame_benchmarking::benchmarking::HostFunctions;\n\n\tfn dispatch(method: \u0026str, data: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n\t\tpendulum_runtime::api::dispatch(method, data)\n\t}\n\n\tfn native_version() -\u003e sc_executor::NativeVersion {\n\t\tpendulum_runtime::native_version()\n\t}\n}\n\n/// Development executor instance.\npub struct DevelopmentRuntimeExecutor;\n\nimpl sc_executor::NativeExecutionDispatch for DevelopmentRuntimeExecutor {\n\ttype ExtendHostFunctions = frame_benchmarking::benchmarking::HostFunctions;\n\n\tfn dispatch(method: \u0026str, data: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n\t\tdevelopment_runtime::api::dispatch(method, data)\n\t}\n\n\tfn native_version() -\u003e sc_executor::NativeVersion {\n\t\tdevelopment_runtime::native_version()\n\t}\n}\n\n/// Starts a `ServiceBuilder` for a full service.\n///\n/// Use this macro if you don't actually need the full service, but just the builder in order to\n/// be able to perform chain operations.\npub fn new_partial\u003cRuntimeApi, Executor\u003e(\n\tconfig: \u0026Configuration,\n) -\u003e Result\u003c\n\tPartialComponents\u003c\n\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\tTFullBackend\u003cBlock\u003e,\n\t\t(),\n\t\tsc_consensus::DefaultImportQueue\u003c\n\t\t\tBlock,\n\t\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\t\u003e,\n\t\tsc_transaction_pool::FullPool\u003c\n\t\t\tBlock,\n\t\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\t\u003e,\n\t\t(\n\t\t\tParachainBlockImport\u003cRuntimeApi, Executor\u003e,\n\t\t\tOption\u003cTelemetry\u003e,\n\t\t\tOption\u003cTelemetryWorkerHandle\u003e,\n\t\t),\n\t\u003e,\n\tsc_service::Error,\n\u003e\nwhere\n\tRuntimeApi: ConstructRuntimeApi\u003cBlock, TFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e\n\t\t+ Send\n\t\t+ Sync\n\t\t+ 'static,\n\tRuntimeApi::RuntimeApi: ParachainRuntimeApiImpl,\n\tExecutor: sc_executor::NativeExecutionDispatch + 'static,\n{\n\tlet telemetry = config\n\t\t.telemetry_endpoints\n\t\t.clone()\n\t\t.filter(|x| !x.is_empty())\n\t\t.map(|endpoints| -\u003e Result\u003c_, sc_telemetry::Error\u003e {\n\t\t\tlet worker = TelemetryWorker::new(16)?;\n\t\t\tlet telemetry = worker.handle().new_telemetry(endpoints);\n\t\t\tOk((worker, telemetry))\n\t\t})\n\t\t.transpose()?;\n\n\tlet executor = NativeElseWasmExecutor::\u003cExecutor\u003e::new(\n\t\tconfig.wasm_method,\n\t\tconfig.default_heap_pages,\n\t\tconfig.max_runtime_instances,\n\t\tconfig.runtime_cache_size,\n\t);\n\n\tlet (client, backend, keystore_container, task_manager) =\n\t\tsc_service::new_full_parts::\u003cBlock, RuntimeApi, _\u003e(\n\t\t\tconfig,\n\t\t\ttelemetry.as_ref().map(|(_, telemetry)| telemetry.handle()),\n\t\t\texecutor,\n\t\t)?;\n\tlet client = Arc::new(client);\n\n\tlet telemetry_worker_handle = telemetry.as_ref().map(|(worker, _)| worker.handle());\n\n\tlet telemetry = telemetry.map(|(worker, telemetry)| {\n\t\ttask_manager.spawn_handle().spawn(\"telemetry\", None, worker.run());\n\t\ttelemetry\n\t});\n\n\tlet transaction_pool = sc_transaction_pool::BasicPool::new_full(\n\t\tconfig.transaction_pool.clone(),\n\t\tconfig.role.is_authority().into(),\n\t\tconfig.prometheus_registry(),\n\t\ttask_manager.spawn_essential_handle(),\n\t\tclient.clone(),\n\t);\n\n\tlet block_import = ParachainBlockImport::new(client.clone(), backend.clone());\n\n\tlet import_queue = build_import_queue(\n\t\tclient.clone(),\n\t\tblock_import.clone(),\n\t\tconfig,\n\t\ttelemetry.as_ref().map(|telemetry| telemetry.handle()),\n\t\t\u0026task_manager,\n\t)?;\n\n\tOk(PartialComponents {\n\t\tbackend,\n\t\tclient,\n\t\timport_queue,\n\t\tkeystore_container,\n\t\ttask_manager,\n\t\ttransaction_pool,\n\t\tselect_chain: (),\n\t\tother: (block_import, telemetry, telemetry_worker_handle),\n\t})\n}\n\nasync fn build_relay_chain_interface(\n\tpolkadot_config: Configuration,\n\tparachain_config: \u0026Configuration,\n\ttelemetry_worker_handle: Option\u003cTelemetryWorkerHandle\u003e,\n\ttask_manager: \u0026mut TaskManager,\n\tcollator_options: CollatorOptions,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e RelayChainResult\u003c(Arc\u003c(dyn RelayChainInterface + 'static)\u003e, Option\u003cCollatorPair\u003e)\u003e {\n\tif !collator_options.relay_chain_rpc_urls.is_empty() {\n\t\tbuild_minimal_relay_chain_node(\n\t\t\tpolkadot_config,\n\t\t\ttask_manager,\n\t\t\tcollator_options.relay_chain_rpc_urls,\n\t\t)\n\t\t.await\n\t} else {\n\t\tbuild_inprocess_relay_chain(\n\t\t\tpolkadot_config,\n\t\t\tparachain_config,\n\t\t\ttelemetry_worker_handle,\n\t\t\ttask_manager,\n\t\t\thwbench,\n\t\t)\n\t}\n}\n\ntype FullDepsOf\u003cRuntimeApi, Executor\u003e = FullDeps\u003c\n\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\tsc_transaction_pool::FullPool\u003c\n\t\tBlock,\n\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\u003e,\n\u003e;\n\n#[sc_tracing::logging::prefix_logs_with(\"Parachain\")]\nasync fn start_node_impl\u003cRuntimeApi, Executor\u003e(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n\tcreate_full_rpc: fn(\n\t\tdeps: FullDepsOf\u003cRuntimeApi, Executor\u003e,\n\t) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e,\n) -\u003e sc_service::error::Result\u003c(\n\tTaskManager,\n\tArc\u003cTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e,\n)\u003e\nwhere\n\tRuntimeApi: ConstructRuntimeApi\u003cBlock, TFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e\n\t\t+ Send\n\t\t+ Sync\n\t\t+ 'static,\n\tRuntimeApi::RuntimeApi: ParachainRuntimeApiImpl,\n\tsc_client_api::StateBackendFor\u003cTFullBackend\u003cBlock\u003e, Block\u003e: sp_api::StateBackend\u003cBlakeTwo256\u003e,\n\tExecutor: sc_executor::NativeExecutionDispatch + 'static,\n{\n\tlet parachain_config = prepare_node_config(parachain_config);\n\n\tlet params = new_partial(\u0026parachain_config)?;\n\tlet (block_import, mut telemetry, telemetry_worker_handle) = params.other;\n\n\tlet client = params.client.clone();\n\tlet backend = params.backend.clone();\n\tlet mut task_manager = params.task_manager;\n\n\tlet (relay_chain_interface, collator_key) = build_relay_chain_interface(\n\t\tpolkadot_config,\n\t\t\u0026parachain_config,\n\t\ttelemetry_worker_handle,\n\t\t\u0026mut task_manager,\n\t\tcollator_options.clone(),\n\t\thwbench.clone(),\n\t)\n\t.await\n\t.map_err(|e| sc_service::Error::Application(Box::new(e)))?;\n\n\tlet block_announce_validator = BlockAnnounceValidator::new(relay_chain_interface.clone(), id);\n\n\tlet force_authoring = parachain_config.force_authoring;\n\tlet validator = parachain_config.role.is_authority();\n\tlet prometheus_registry = parachain_config.prometheus_registry().cloned();\n\tlet transaction_pool = params.transaction_pool.clone();\n\tlet import_queue_service = params.import_queue.service();\n\n\tlet (network, system_rpc_tx, tx_handler_controller, start_network, sync_service) =\n\t\tsc_service::build_network(sc_service::BuildNetworkParams {\n\t\t\tconfig: \u0026parachain_config,\n\t\t\tclient: client.clone(),\n\t\t\ttransaction_pool: transaction_pool.clone(),\n\t\t\tspawn_handle: task_manager.spawn_handle(),\n\t\t\timport_queue: params.import_queue,\n\t\t\tblock_announce_validator_builder: Some(Box::new(|_| {\n\t\t\t\tBox::new(block_announce_validator)\n\t\t\t})),\n\t\t\twarp_sync_params: None,\n\t\t})?;\n\n\tif parachain_config.offchain_worker.enabled {\n\t\tsc_service::build_offchain_workers(\n\t\t\t\u0026parachain_config,\n\t\t\ttask_manager.spawn_handle(),\n\t\t\tclient.clone(),\n\t\t\tnetwork.clone(),\n\t\t);\n\t}\n\n\tlet rpc_builder = {\n\t\tlet client = client.clone();\n\t\tlet transaction_pool = transaction_pool.clone();\n\n\t\tBox::new(move |deny_unsafe, _| {\n\t\t\tlet deps =\n\t\t\t\tFullDeps { client: client.clone(), pool: transaction_pool.clone(), deny_unsafe };\n\n\t\t\tcreate_full_rpc(deps).map_err(Into::into)\n\t\t})\n\t};\n\n\tsc_service::spawn_tasks(sc_service::SpawnTasksParams {\n\t\trpc_builder,\n\t\tclient: client.clone(),\n\t\ttransaction_pool: transaction_pool.clone(),\n\t\ttask_manager: \u0026mut task_manager,\n\t\tconfig: parachain_config,\n\t\tkeystore: params.keystore_container.sync_keystore(),\n\t\tbackend: backend.clone(),\n\t\tnetwork: network.clone(),\n\t\tsystem_rpc_tx,\n\t\ttx_handler_controller,\n\t\tsync_service: sync_service.clone(),\n\t\ttelemetry: telemetry.as_mut(),\n\t})?;\n\n\tif let Some(hwbench) = hwbench {\n\t\tsc_sysinfo::print_hwbench(\u0026hwbench);\n\n\t\tif let Some(ref mut telemetry) = telemetry {\n\t\t\tlet telemetry_handle = telemetry.handle();\n\t\t\ttask_manager.spawn_handle().spawn(\n\t\t\t\t\"telemetry_hwbench\",\n\t\t\t\tNone,\n\t\t\t\tsc_sysinfo::initialize_hwbench_telemetry(telemetry_handle, hwbench),\n\t\t\t);\n\t\t}\n\t}\n\n\tlet announce_block = {\n\t\tlet sync_service = sync_service.clone();\n\t\tArc::new(move |hash, data| sync_service.announce_block(hash, data))\n\t};\n\n\tlet relay_chain_slot_duration = Duration::from_secs(6);\n\n\tlet overseer_handle = relay_chain_interface\n\t\t.overseer_handle()\n\t\t.map_err(|e| sc_service::Error::Application(Box::new(e)))?;\n\n\tif validator {\n\t\tlet parachain_consensus = build_consensus(\n\t\t\tclient.clone(),\n\t\t\tblock_import,\n\t\t\tprometheus_registry.as_ref(),\n\t\t\ttelemetry.as_ref().map(|t| t.handle()),\n\t\t\t\u0026task_manager,\n\t\t\trelay_chain_interface.clone(),\n\t\t\ttransaction_pool,\n\t\t\tsync_service.clone(),\n\t\t\tparams.keystore_container.sync_keystore(),\n\t\t\tforce_authoring,\n\t\t\tid,\n\t\t)?;\n\n\t\tlet spawner = task_manager.spawn_handle();\n\t\tlet params = StartCollatorParams {\n\t\t\tpara_id: id,\n\t\t\tblock_status: client.clone(),\n\t\t\tannounce_block,\n\t\t\tclient: client.clone(),\n\t\t\ttask_manager: \u0026mut task_manager,\n\t\t\trelay_chain_interface,\n\t\t\tspawner,\n\t\t\tparachain_consensus,\n\t\t\timport_queue: import_queue_service,\n\t\t\tcollator_key: collator_key.expect(\"Command line arguments do not allow this. qed\"),\n\t\t\trelay_chain_slot_duration,\n\t\t\trecovery_handle: Box::new(overseer_handle),\n\t\t};\n\n\t\tstart_collator(params).await?;\n\t} else {\n\t\tlet params = StartFullNodeParams {\n\t\t\tclient: client.clone(),\n\t\t\tannounce_block,\n\t\t\ttask_manager: \u0026mut task_manager,\n\t\t\tpara_id: id,\n\t\t\trelay_chain_interface,\n\t\t\trelay_chain_slot_duration,\n\t\t\timport_queue: import_queue_service,\n\t\t\trecovery_handle: Box::new(overseer_handle),\n\t\t};\n\n\t\tstart_full_node(params)?;\n\t}\n\n\tstart_network.start_network();\n\n\tOk((task_manager, client))\n}\n\n/// Build the import queue for the parachain runtime.\nfn build_import_queue\u003cRuntimeApi, Executor\u003e(\n\tclient: Arc\u003cTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e,\n\tblock_import: ParachainBlockImport\u003cRuntimeApi, Executor\u003e,\n\tconfig: \u0026Configuration,\n\ttelemetry: Option\u003cTelemetryHandle\u003e,\n\ttask_manager: \u0026TaskManager,\n) -\u003e Result\u003c\n\tsc_consensus::DefaultImportQueue\u003c\n\t\tBlock,\n\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\u003e,\n\tsc_service::Error,\n\u003e\nwhere\n\tRuntimeApi: ConstructRuntimeApi\u003cBlock, TFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e\n\t\t+ Send\n\t\t+ Sync\n\t\t+ 'static,\n\tRuntimeApi::RuntimeApi: ParachainRuntimeApiImpl,\n\tExecutor: sc_executor::NativeExecutionDispatch + 'static,\n{\n\tlet slot_duration = cumulus_client_consensus_aura::slot_duration(\u0026*client)?;\n\n\tcumulus_client_consensus_aura::import_queue::\u003c\n\t\tsp_consensus_aura::sr25519::AuthorityPair,\n\t\t_,\n\t\t_,\n\t\t_,\n\t\t_,\n\t\t_,\n\t\u003e(cumulus_client_consensus_aura::ImportQueueParams {\n\t\tblock_import,\n\t\tclient,\n\t\tcreate_inherent_data_providers: move |_, _| async move {\n\t\t\tlet timestamp = sp_timestamp::InherentDataProvider::from_system_time();\n\n\t\t\tlet slot =\n\t\t\t\tsp_consensus_aura::inherents::InherentDataProvider::from_timestamp_and_slot_duration(\n\t\t\t\t\t*timestamp,\n\t\t\t\t\tslot_duration,\n\t\t\t\t);\n\n\t\t\tOk((slot, timestamp))\n\t\t},\n\t\tregistry: config.prometheus_registry(),\n\t\tspawner: \u0026task_manager.spawn_essential_handle(),\n\t\ttelemetry,\n\t})\n\t.map_err(Into::into)\n}\n\nfn build_consensus\u003cRuntimeApi, Executor\u003e(\n\tclient: Arc\u003cTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e,\n\tblock_import: ParachainBlockImport\u003cRuntimeApi, Executor\u003e,\n\tprometheus_registry: Option\u003c\u0026Registry\u003e,\n\ttelemetry: Option\u003cTelemetryHandle\u003e,\n\ttask_manager: \u0026TaskManager,\n\trelay_chain_interface: Arc\u003cdyn RelayChainInterface\u003e,\n\ttransaction_pool: Arc\u003c\n\t\tsc_transaction_pool::FullPool\u003c\n\t\t\tBlock,\n\t\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\t\u003e,\n\t\u003e,\n\tsync_oracle: Arc\u003cSyncingService\u003cBlock\u003e\u003e,\n\tkeystore: SyncCryptoStorePtr,\n\tforce_authoring: bool,\n\tid: ParaId,\n) -\u003e Result\u003cBox\u003cdyn ParachainConsensus\u003cBlock\u003e\u003e, sc_service::Error\u003e\nwhere\n\tRuntimeApi: ConstructRuntimeApi\u003cBlock, TFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e\n\t\t+ Send\n\t\t+ Sync\n\t\t+ 'static,\n\tRuntimeApi::RuntimeApi: ParachainRuntimeApiImpl,\n\tsc_client_api::StateBackendFor\u003cTFullBackend\u003cBlock\u003e, Block\u003e: sp_api::StateBackend\u003cBlakeTwo256\u003e,\n\tExecutor: sc_executor::NativeExecutionDispatch + 'static,\n{\n\tlet slot_duration = cumulus_client_consensus_aura::slot_duration(\u0026*client)?;\n\n\tlet proposer_factory = sc_basic_authorship::ProposerFactory::with_proof_recording(\n\t\ttask_manager.spawn_handle(),\n\t\tclient.clone(),\n\t\ttransaction_pool,\n\t\tprometheus_registry,\n\t\ttelemetry.clone(),\n\t);\n\n\tlet params = BuildAuraConsensusParams {\n\t\tproposer_factory,\n\t\tcreate_inherent_data_providers: move |_, (relay_parent, validation_data)| {\n\t\t\tlet relay_chain_interface = relay_chain_interface.clone();\n\t\t\tasync move {\n\t\t\t\tlet parachain_inherent =\n\t\t\t\t\tcumulus_primitives_parachain_inherent::ParachainInherentData::create_at(\n\t\t\t\t\t\trelay_parent,\n\t\t\t\t\t\t\u0026relay_chain_interface,\n\t\t\t\t\t\t\u0026validation_data,\n\t\t\t\t\t\tid,\n\t\t\t\t\t)\n\t\t\t\t\t.await;\n\t\t\t\tlet timestamp = sp_timestamp::InherentDataProvider::from_system_time();\n\n\t\t\t\tlet slot =\n\t\t\t\t\t\tsp_consensus_aura::inherents::InherentDataProvider::from_timestamp_and_slot_duration(\n\t\t\t\t\t\t\t*timestamp,\n\t\t\t\t\t\t\tslot_duration,\n\t\t\t\t\t\t);\n\n\t\t\t\tlet parachain_inherent = parachain_inherent.ok_or_else(|| {\n\t\t\t\t\tBox::\u003cdyn std::error::Error + Send + Sync\u003e::from(\n\t\t\t\t\t\t\"Failed to create parachain inherent\",\n\t\t\t\t\t)\n\t\t\t\t})?;\n\t\t\t\tOk((slot, timestamp, parachain_inherent))\n\t\t\t}\n\t\t},\n\t\tblock_import,\n\t\tpara_client: client,\n\t\tbackoff_authoring_blocks: Option::\u003c()\u003e::None,\n\t\tsync_oracle,\n\t\tkeystore,\n\t\tforce_authoring,\n\t\tslot_duration,\n\t\t// We got around 500ms for proposing\n\t\tblock_proposal_slot_portion: SlotProportion::new(1f32 / 24f32),\n\t\t// And a maximum of 750ms if slots are skipped\n\t\tmax_block_proposal_slot_portion: Some(SlotProportion::new(1f32 / 16f32)),\n\t\ttelemetry,\n\t};\n\n\tOk(AuraConsensus::build::\u003csp_consensus_aura::sr25519::AuthorityPair, _, _, _, _, _, _\u003e(params))\n}\n\n/// Start a parachain node.\npub async fn start_parachain_node_pendulum(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e sc_service::error::Result\u003c(TaskManager, Arc\u003cPendulumClient\u003e)\u003e {\n\tstart_node_impl(\n\t\tparachain_config,\n\t\tpolkadot_config,\n\t\tcollator_options,\n\t\tid,\n\t\thwbench,\n\t\tcreate_full_pendulum,\n\t)\n\t.await\n}\n\n/// Start a parachain node.\npub async fn start_parachain_node_development(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e sc_service::error::Result\u003c(TaskManager, Arc\u003cDevelopmentClient\u003e)\u003e {\n\tstart_node_impl(\n\t\tparachain_config,\n\t\tpolkadot_config,\n\t\tcollator_options,\n\t\tid,\n\t\thwbench,\n\t\tcreate_full_development,\n\t)\n\t.await\n}\n\n/// Start a parachain node with the Spacewalk RPC exposed using the foucoco runtime definitions.\npub async fn start_parachain_node_spacewalk_foucoco(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e sc_service::error::Result\u003c(TaskManager, Arc\u003cFoucocoClient\u003e)\u003e {\n\tstart_node_impl(\n\t\tparachain_config,\n\t\tpolkadot_config,\n\t\tcollator_options,\n\t\tid,\n\t\thwbench,\n\t\tcreate_full_foucoco,\n\t)\n\t.await\n}\n\n/// Start a parachain node with the Spacewalk RPC exposed using the amplitude runtime definitions.\npub async fn start_parachain_node_spacewalk_amplitude(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e sc_service::error::Result\u003c(TaskManager, Arc\u003cAmplitudeClient\u003e)\u003e {\n\tstart_node_impl(\n\t\tparachain_config,\n\t\tpolkadot_config,\n\t\tcollator_options,\n\t\tid,\n\t\thwbench,\n\t\tcreate_full_amplitude,\n\t)\n\t.await\n}\n","traces":[{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":158},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","benchmarking.rs"],"content":"#![allow(warnings)]\nuse super::{Pallet as TokenAllowance, *};\nuse frame_benchmarking::{account, benchmarks, impl_benchmark_test_suite};\nuse frame_system::RawOrigin;\nuse sp_std::prelude::*;\n\nbenchmarks! {\n\tadd_allowed_currencies {\n\t\t// This has to come first. Ranges are inclusive on both sides so we start from 1, see\n\t\t// [here](https://tidelabs.github.io/tidechain/frame_benchmarking/v1/macro.benchmarks.html)\n\t\tlet n in 1..T::MaxAllowedCurrencies::get();\n\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\n\t\t// It does not really matter that it's the same currency as the loop of the extrinsic\n\t\t// will iterate over it the same amount of times.\n\t\tlet added_currencies = vec![native_currency_id; n as usize];\n\t}: add_allowed_currencies(RawOrigin::Root, added_currencies)\n\tverify {\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tassert_eq!(AllowedCurrencies::\u003cT\u003e::get(native_currency_id), Some(()));\n\t}\n\n\tremove_allowed_currencies {\n\t\t// This has to come first. Ranges are inclusive on both sides so we start from 1, see\n\t\t// [here](https://tidelabs.github.io/tidechain/frame_benchmarking/v1/macro.benchmarks.html)\n\t\tlet n in 1..T::MaxAllowedCurrencies::get();\n\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tAllowedCurrencies::\u003cT\u003e::insert(native_currency_id, ());\n\n\t\tlet removed_currencies = vec![native_currency_id; n as usize];\n\t}: remove_allowed_currencies(RawOrigin::Root, removed_currencies)\n\tverify {\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tassert_eq!(AllowedCurrencies::\u003cT\u003e::get(native_currency_id), None);\n\t}\n\n\tapprove {\n\t\t//allow currency\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tAllowedCurrencies::\u003cT\u003e::insert(native_currency_id, ());\n\n\t\t//initialize accounts\n\t\tlet owner: T::AccountId = account(\"Alice\", 0, 0);\n\t\tlet delegate: T::AccountId = account(\"Bob\", 0, 0);\n\n\t\t//fund account\n\t\tlet amount =  BalanceOf::\u003cT\u003e::from(1_000_000_000u32);\n\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::deposit(native_currency_id, \u0026owner, amount);\n\n\t}: approve(RawOrigin::Signed(owner), native_currency_id, delegate, amount)\n\tverify {\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tlet owner: T::AccountId = account(\"Alice\", 0, 0);\n\t\tlet delegate: T::AccountId = account(\"Bob\", 0, 0);\n\t\tlet amount =  BalanceOf::\u003cT\u003e::from(1_000_000_000u32);\n\n\t\t//check that the allowance was updated\n\t\tassert_eq!(TokenAllowance::\u003cT\u003e::allowance(native_currency_id, \u0026owner, \u0026delegate), amount);\n\t}\n\n\ttransfer_from {\n\t\t//allow currency\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tAllowedCurrencies::\u003cT\u003e::insert(native_currency_id, ());\n\n\t\t//initialize accounts\n\t\tlet owner: T::AccountId = account(\"Alice\", 0, 0);\n\t\tlet delegate: T::AccountId = account(\"Bob\", 0, 0);\n\t\tlet destination: T::AccountId = account(\"Charlie\", 0, 0);\n\n\t\t//fund accounts\n\t\tlet amount =  BalanceOf::\u003cT\u003e::from(1_000_000_000u32);\n\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::deposit(native_currency_id, \u0026owner, amount);\n\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::deposit(native_currency_id, \u0026delegate, amount);\n\n\t\t//approve\n\t\tTokenAllowance::\u003cT\u003e::do_approve_transfer(native_currency_id, \u0026owner, \u0026delegate, amount);\n\n\t}: transfer_from(RawOrigin::Signed(delegate), native_currency_id, owner, destination, amount)\n\tverify {\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tlet owner: T::AccountId = account(\"Alice\", 0, 0);\n\t\tlet delegate: T::AccountId = account(\"Bob\", 0, 0);\n\t\tlet destination: T::AccountId = account(\"Charlie\", 0, 0);\n\t\tlet amount =  BalanceOf::\u003cT\u003e::from(1_000_000_000u32);\n\n\t\t//check that the allowance was updated\n\t\tassert_eq!(TokenAllowance::\u003cT\u003e::allowance(native_currency_id, \u0026owner, \u0026delegate), BalanceOf::\u003cT\u003e::from(0u32));\n\n\t\t//check that the balance was updated\n\t\tlet destination_balance = \u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::free_balance(native_currency_id, \u0026destination);\n\t\tassert_eq!(destination_balance, amount);\n\t}\n}\n\nimpl_benchmark_test_suite!(TokenAllowance, crate::mock::ExtBuilder::build(), crate::mock::Test);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","default_weights.rs"],"content":"\n//! Autogenerated weights for orml_currencies_allowance_extension\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-07-24, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Marcels-MBP`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"foucoco\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// foucoco\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet\n// orml-currencies-allowance-extension\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// pallets/orml-currencies-allowance-extension/src/default_weights.rs\n// --template\n// .maintain/frame-weight-template.hbs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n#![allow(missing_docs)]\n\nuse frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};\nuse core::marker::PhantomData;\n\n/// Weight functions needed for orml_currencies_allowance_extension.\npub trait WeightInfo {\n\tfn add_allowed_currencies(n: u32, ) -\u003e Weight;\n\tfn remove_allowed_currencies(n: u32, ) -\u003e Weight;\n\tfn approve() -\u003e Weight;\n\tfn transfer_from() -\u003e Weight;\n}\n\n/// Weights for orml_currencies_allowance_extension using the Substrate node and recommended hardware.\npub struct SubstrateWeight\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e WeightInfo for SubstrateWeight\u003cT\u003e {\n\t/// Storage: TokenAllowance AllowedCurrencies (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// The range of component `n` is `[1, 256]`.\n\tfn add_allowed_currencies(n: u32, ) -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(10_797_953, 0)\n\t\t\t// Standard Error: 1_712\n\t\t\t.saturating_add(Weight::from_parts(1_078_644, 0).saturating_mul(n.into()))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// The range of component `n` is `[1, 256]`.\n\tfn remove_allowed_currencies(n: u32, ) -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_672_163, 0)\n\t\t\t// Standard Error: 1_724\n\t\t\t.saturating_add(Weight::from_parts(1_085_251, 0).saturating_mul(n.into()))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:1 w:0)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: TokenAllowance Approvals (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance Approvals (max_values: None, max_size: None, mode: Measured)\n\tfn approve() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `184`\n\t\t//  Estimated: `3833`\n\t\t// Minimum execution time: 15_000_000 picoseconds.\n\t\tWeight::from_parts(16_000_000, 3833)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1_u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:1 w:0)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: TokenAllowance Approvals (r:1 w:1)\n\t/// Proof Skipped: TokenAllowance Approvals (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: System Account (r:2 w:2)\n\t/// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: MaxEncodedLen)\n\tfn transfer_from() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `561`\n\t\t//  Estimated: `14248`\n\t\t// Minimum execution time: 44_000_000 picoseconds.\n\t\tWeight::from_parts(46_000_000, 14248)\n\t\t\t.saturating_add(T::DbWeight::get().reads(4_u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3_u64))\n\t}\n}\n\n// For backwards compatibility and tests\nimpl WeightInfo for () {\n\t/// Storage: TokenAllowance AllowedCurrencies (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// The range of component `n` is `[1, 256]`.\n\tfn add_allowed_currencies(n: u32, ) -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(10_797_953, 0)\n\t\t\t// Standard Error: 1_712\n\t\t\t.saturating_add(Weight::from_parts(1_078_644, 0).saturating_mul(n.into()))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// The range of component `n` is `[1, 256]`.\n\tfn remove_allowed_currencies(n: u32, ) -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_672_163, 0)\n\t\t\t// Standard Error: 1_724\n\t\t\t.saturating_add(Weight::from_parts(1_085_251, 0).saturating_mul(n.into()))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:1 w:0)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: TokenAllowance Approvals (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance Approvals (max_values: None, max_size: None, mode: Measured)\n\tfn approve() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `184`\n\t\t//  Estimated: `3833`\n\t\t// Minimum execution time: 15_000_000 picoseconds.\n\t\tWeight::from_parts(16_000_000, 3833)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1_u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:1 w:0)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: TokenAllowance Approvals (r:1 w:1)\n\t/// Proof Skipped: TokenAllowance Approvals (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: System Account (r:2 w:2)\n\t/// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: MaxEncodedLen)\n\tfn transfer_from() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `561`\n\t\t//  Estimated: `14248`\n\t\t// Minimum execution time: 44_000_000 picoseconds.\n\t\tWeight::from_parts(46_000_000, 14248)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(4_u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(3_u64))\n\t}\n}","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","lib.rs"],"content":"#![deny(warnings)]\n#![cfg_attr(test, feature(proc_macro_hygiene))]\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\n#[cfg(test)]\nextern crate mocktopus;\n\nuse frame_support::{dispatch::DispatchResult, ensure};\n\n#[cfg(test)]\nuse mocktopus::macros::mockable;\nuse orml_traits::MultiCurrency;\nuse sp_runtime::traits::*;\nuse sp_std::{convert::TryInto, prelude::*, vec};\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benchmarking;\n\npub mod default_weights;\n\n#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod tests;\n\npub use pallet::*;\n\npub(crate) type BalanceOf\u003cT\u003e =\n\t\u003c\u003cT as orml_currencies::Config\u003e::MultiCurrency as orml_traits::MultiCurrency\u003c\n\t\t\u003cT as frame_system::Config\u003e::AccountId,\n\t\u003e\u003e::Balance;\n\npub(crate) type CurrencyOf\u003cT\u003e =\n\t\u003c\u003cT as orml_currencies::Config\u003e::MultiCurrency as orml_traits::MultiCurrency\u003c\n\t\t\u003cT as frame_system::Config\u003e::AccountId,\n\t\u003e\u003e::CurrencyId;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse crate::default_weights::WeightInfo;\n\tuse frame_support::{pallet_prelude::*, transactional};\n\tuse frame_system::{ensure_root, ensure_signed, pallet_prelude::OriginFor};\n\n\tuse super::*;\n\n\t/// ## Configuration\n\t/// The pallet's configuration trait.\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config + orml_tokens::Config + orml_currencies::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\n\t\t/// Weight information for the extrinsics in this module.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// The maximum number of allowed currencies.\n\t\t#[pallet::constant]\n\t\ttype MaxAllowedCurrencies: Get\u003cu32\u003e;\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\tAllowedCurrenciesAdded {\n\t\t\tcurrencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t\t},\n\t\tAllowedCurrenciesDeleted {\n\t\t\tcurrencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t\t},\n\t\t/// (Additional) funds have been approved for transfer to a destination account.\n\t\tTransferApproved {\n\t\t\tcurrency_id: CurrencyOf\u003cT\u003e,\n\t\t\tsource: T::AccountId,\n\t\t\tdelegate: T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t},\n\t}\n\n\t#[pallet::error]\n\tpub enum Error\u003cT\u003e {\n\t\tUnapproved,\n\t\tCurrencyNotLive,\n\t\tExceedsNumberOfAllowedCurrencies,\n\t}\n\n\t/// Approved balance transfers. Balance is the amount approved for transfer.\n\t/// First key is the currency ID, second key is the owner and third key is the delegate.\n\t#[pallet::storage]\n\tpub type Approvals\u003cT: Config\u003e = StorageNMap\u003c\n\t\t_,\n\t\t(\n\t\t\tNMapKey\u003cBlake2_128Concat, CurrencyOf\u003cT\u003e\u003e,\n\t\t\tNMapKey\u003cBlake2_128Concat, T::AccountId\u003e, // owner\n\t\t\tNMapKey\u003cBlake2_128Concat, T::AccountId\u003e, // delegate\n\t\t),\n\t\tBalanceOf\u003cT\u003e,\n\t\u003e;\n\n\t/// Currencies that can be used in chain extension\n\t#[pallet::storage]\n\tpub(super) type AllowedCurrencies\u003cT: Config\u003e =\n\t\tStorageMap\u003c_, Blake2_128Concat, CurrencyOf\u003cT\u003e, ()\u003e;\n\n\t#[pallet::hooks]\n\timpl\u003cT: Config\u003e Hooks\u003cT::BlockNumber\u003e for Pallet\u003cT\u003e {}\n\n\t#[pallet::genesis_config]\n\tpub struct GenesisConfig\u003cT: Config\u003e {\n\t\tpub allowed_currencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t}\n\n\t#[cfg(feature = \"std\")]\n\timpl\u003cT: Config\u003e Default for GenesisConfig\u003cT\u003e {\n\t\tfn default() -\u003e Self {\n\t\t\tSelf { allowed_currencies: vec![] }\n\t\t}\n\t}\n\n\t#[pallet::genesis_build]\n\timpl\u003cT: Config\u003e GenesisBuild\u003cT\u003e for GenesisConfig\u003cT\u003e {\n\t\tfn build(\u0026self) {\n\t\t\tfor i in \u0026self.allowed_currencies.clone() {\n\t\t\t\tAllowedCurrencies::\u003cT\u003e::insert(i, ());\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::pallet]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet\u003cT\u003e(_);\n\n\t// The pallet's dispatchable functions.\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Added allowed currencies that possible to use chain extension\n\t\t///\n\t\t/// # Arguments\n\t\t/// * `currencies` - list of currency id allowed to use in chain extension\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::add_allowed_currencies(T::MaxAllowedCurrencies::get()))]\n\t\t#[transactional]\n\t\tpub fn add_allowed_currencies(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcurrencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\n\t\t\t// Check if the supplied amount of currencies is less than the maximum allowed\n\t\t\tlet max_allowed_currencies: usize = T::MaxAllowedCurrencies::get() as usize;\n\t\t\tensure!(\n\t\t\t\tcurrencies.len() \u003c= max_allowed_currencies,\n\t\t\t\tError::\u003cT\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t\t);\n\n\t\t\tfor i in currencies.clone() {\n\t\t\t\tAllowedCurrencies::\u003cT\u003e::insert(i, ());\n\t\t\t}\n\n\t\t\t// Check if the resulting vector of allowed currencies is less than the maximum allowed.\n\t\t\t// We check after the insertion to avoid counting duplicates.\n\t\t\tlet allowed_currencies_len: usize = AllowedCurrencies::\u003cT\u003e::iter().count();\n\t\t\tensure!(\n\t\t\t\tallowed_currencies_len \u003c= max_allowed_currencies,\n\t\t\t\tError::\u003cT\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t\t);\n\n\t\t\tSelf::deposit_event(Event::AllowedCurrenciesAdded { currencies });\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove allowed currencies that possible to use chain extension\n\t\t///\n\t\t/// # Arguments\n\t\t/// * `currencies` - list of currency id allowed to use in chain extension\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::remove_allowed_currencies(T::MaxAllowedCurrencies::get()))]\n\t\t#[transactional]\n\t\tpub fn remove_allowed_currencies(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcurrencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\n\t\t\t// Check if the supplied amount of currencies is less than the maximum allowed\n\t\t\t// Although this is not strictly necessary, it is a good sanity check and prevents callers\n\t\t\t// from using too large currency vectors.\n\t\t\tlet max_allowed_currencies: usize = T::MaxAllowedCurrencies::get() as usize;\n\t\t\tensure!(\n\t\t\t\tcurrencies.len() \u003c= max_allowed_currencies,\n\t\t\t\tError::\u003cT\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t\t);\n\n\t\t\tfor i in currencies.clone() {\n\t\t\t\tAllowedCurrencies::\u003cT\u003e::remove(i);\n\t\t\t}\n\n\t\t\tSelf::deposit_event(Event::AllowedCurrenciesDeleted { currencies });\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Approve an amount for another account to spend on owner's behalf.\n\t\t///\n\t\t/// # Arguments\n\t\t/// * `id` - the currency_id of the asset to approve\n\t\t/// * `delegate` - the spender account to approve the asset for\n\t\t/// * `amount` - the amount of the asset to approve\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::approve())]\n\t\t#[transactional]\n\t\tpub fn approve(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tid: CurrencyOf\u003cT\u003e,\n\t\t\tdelegate: T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet owner = ensure_signed(origin)?;\n\t\t\tSelf::do_approve_transfer(id, \u0026owner, \u0026delegate, amount)\n\t\t}\n\n\t\t/// Execute a pre-approved transfer from another account\n\t\t///\n\t\t/// # Arguments\n\t\t/// * `id` - the currency_id of the asset to transfer\n\t\t/// * `owner` - the owner account of the asset to transfer\n\t\t/// * `destination` - the destination account to transfer to\n\t\t/// * `amount` - the amount of the asset to transfer\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::transfer_from())]\n\t\t#[transactional]\n\t\tpub fn transfer_from(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tid: CurrencyOf\u003cT\u003e,\n\t\t\towner: T::AccountId,\n\t\t\tdestination: T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet delegate = ensure_signed(origin)?;\n\t\t\tSelf::do_transfer_approved(id, \u0026owner, \u0026delegate, \u0026destination, amount)\n\t\t}\n\t}\n}\n\n#[allow(clippy::forget_non_drop, clippy::swap_ptr_to_ref, clippy::forget_ref, clippy::forget_copy)]\n#[cfg_attr(test, mockable)]\nimpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t// Check the amount approved to be spent by an owner to a delegate\n\tpub fn is_allowed_currency(asset: CurrencyOf\u003cT\u003e) -\u003e bool {\n\t\treturn AllowedCurrencies::\u003cT\u003e::get(asset) == Some(())\n\t}\n\n\t// Check the amount approved to be spent by an owner to a delegate\n\tpub fn allowance(\n\t\tasset: CurrencyOf\u003cT\u003e,\n\t\towner: \u0026T::AccountId,\n\t\tdelegate: \u0026T::AccountId,\n\t) -\u003e BalanceOf\u003cT\u003e {\n\t\tApprovals::\u003cT\u003e::get((asset, \u0026owner, \u0026delegate)).unwrap_or_else(Zero::zero)\n\t}\n\n\t/// Creates an approval from `owner` to spend `amount` of asset `id` tokens by 'delegate'\n\t/// while reserving `T::ApprovalDeposit` from owner\n\t///\n\t/// If an approval already exists, the new amount is added to such existing approval\n\tpub fn do_approve_transfer(\n\t\tid: CurrencyOf\u003cT\u003e,\n\t\towner: \u0026T::AccountId,\n\t\tdelegate: \u0026T::AccountId,\n\t\tamount: BalanceOf\u003cT\u003e,\n\t) -\u003e DispatchResult {\n\t\tensure!(Self::is_allowed_currency(id), Error::\u003cT\u003e::CurrencyNotLive);\n\t\tApprovals::\u003cT\u003e::set((id, \u0026owner, \u0026delegate), Some(amount));\n\t\tSelf::deposit_event(Event::TransferApproved {\n\t\t\tcurrency_id: id,\n\t\t\tsource: owner.clone(),\n\t\t\tdelegate: delegate.clone(),\n\t\t\tamount,\n\t\t});\n\n\t\tOk(())\n\t}\n\n\t/// Reduces the asset `id` balance of `owner` by some `amount` and increases the balance of\n\t/// `dest` by (similar) amount, checking that 'delegate' has an existing approval from `owner`\n\t/// to spend`amount`.\n\t///\n\t/// Will fail if `amount` is greater than the approval from `owner` to 'delegate'\n\t/// Will unreserve the deposit from `owner` if the entire approved `amount` is spent by\n\t/// 'delegate'\n\tpub fn do_transfer_approved(\n\t\tid: CurrencyOf\u003cT\u003e,\n\t\towner: \u0026T::AccountId,\n\t\tdelegate: \u0026T::AccountId,\n\t\tdestination: \u0026T::AccountId,\n\t\tamount: BalanceOf\u003cT\u003e,\n\t) -\u003e DispatchResult {\n\t\tensure!(Self::is_allowed_currency(id), Error::\u003cT\u003e::CurrencyNotLive);\n\t\tApprovals::\u003cT\u003e::try_mutate_exists(\n\t\t\t(id, \u0026owner, delegate),\n\t\t\t|maybe_approved| -\u003e DispatchResult {\n\t\t\t\tlet approved = maybe_approved.take().ok_or(Error::\u003cT\u003e::Unapproved)?;\n\t\t\t\tlet remaining = approved.checked_sub(\u0026amount).ok_or(Error::\u003cT\u003e::Unapproved)?;\n\n\t\t\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::transfer(\n\t\t\t\t\tid,\n\t\t\t\t\t\u0026owner,\n\t\t\t\t\t\u0026destination,\n\t\t\t\t\tamount,\n\t\t\t\t)?;\n\n\t\t\t\t// Don't decrement allowance if it is set to the max value (which acts as infinite allowance)\n\t\t\t\tif approved == BalanceOf::\u003cT\u003e::max_value() {\n\t\t\t\t\t*maybe_approved = Some(approved);\n\t\t\t\t} else if remaining.is_zero() {\n\t\t\t\t\t*maybe_approved = None;\n\t\t\t\t} else {\n\t\t\t\t\t*maybe_approved = Some(remaining);\n\t\t\t\t}\n\t\t\t\tOk(())\n\t\t\t},\n\t\t)?;\n\t\tOk(())\n\t}\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1560},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":775},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":511},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":49,"coverable":67},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","mock.rs"],"content":"use crate::{self as token_allowance, Config};\nuse frame_support::{\n\tparameter_types,\n\ttraits::{ConstU32, Everything},\n};\nuse orml_currencies::BasicCurrencyAdapter;\nuse orml_traits::parameter_type_with_key;\nuse sp_core::H256;\nuse sp_runtime::{\n\ttesting::Header,\n\ttraits::{BlakeTwo256, IdentityLookup},\n};\ntype UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic\u003cTest\u003e;\ntype Block = frame_system::mocking::MockBlock\u003cTest\u003e;\n\n// Configure a mock runtime to test the pallet.\nframe_support::construct_runtime!(\n\tpub enum Test where\n\t\tBlock = Block,\n\t\tNodeBlock = Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Storage, Config, Event\u003cT\u003e},\n\t\tTokens: orml_tokens::{Pallet, Storage, Config\u003cT\u003e, Event\u003cT\u003e},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Event\u003cT\u003e},\n\t\tCurrencies: orml_currencies::{Pallet, Call},\n\t\tTokenAllowance: token_allowance::{Pallet, Storage, Call, Event\u003cT\u003e},\n\t}\n);\n\npub type AccountId = u64;\npub type Balance = u128;\npub type BlockNumber = u64;\npub type Index = u64;\npub type Amount = i64;\npub type CurrencyId = u64;\n\nparameter_types! {\n\tpub const BlockHashCount: u64 = 250;\n\tpub const SS58Prefix: u8 = 42;\n}\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = Everything;\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype DbWeight = ();\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Index = Index;\n\ttype BlockNumber = BlockNumber;\n\ttype Hash = H256;\n\ttype Hashing = BlakeTwo256;\n\ttype AccountId = AccountId;\n\ttype Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n\ttype Header = Header;\n\ttype RuntimeEvent = TestEvent;\n\ttype BlockHashCount = BlockHashCount;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype SS58Prefix = SS58Prefix;\n\ttype OnSetCode = ();\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\npub type TestEvent = RuntimeEvent;\n\nparameter_types! {\n\tpub const GetCollateralCurrencyId: CurrencyId = 1;\n\tpub const MaxLocks: u32 = 50;\n\tpub const GetNativeCurrencyId: CurrencyId = 1;\n}\n\nparameter_type_with_key! {\n\tpub ExistentialDeposits: |_currency_id: CurrencyId| -\u003e Balance {\n\t\t0\n\t};\n}\n\npub struct CurrencyHooks\u003cT\u003e(sp_std::marker::PhantomData\u003cT\u003e);\nimpl\u003cT: orml_tokens::Config\u003e\n\torml_traits::currency::MutationHooks\u003cT::AccountId, T::CurrencyId, T::Balance\u003e for CurrencyHooks\u003cT\u003e\n{\n\ttype OnDust = orml_tokens::BurnDust\u003cT\u003e;\n\ttype OnSlash = ();\n\ttype PreDeposit = ();\n\ttype PostDeposit = ();\n\ttype PreTransfer = ();\n\ttype PostTransfer = ();\n\ttype OnNewTokenAccount = ();\n\ttype OnKilledTokenAccount = ();\n}\n\nimpl orml_tokens::Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype Amount = Amount;\n\ttype CurrencyId = CurrencyId;\n\ttype WeightInfo = ();\n\ttype ExistentialDeposits = ExistentialDeposits;\n\ttype CurrencyHooks = CurrencyHooks\u003cSelf\u003e;\n\ttype MaxLocks = MaxLocks;\n\ttype MaxReserves = ConstU32\u003c0\u003e;\n\ttype ReserveIdentifier = ();\n\ttype DustRemovalWhitelist = Everything;\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = 1000;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Test {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cTest\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = ();\n}\n\nimpl orml_currencies::Config for Test {\n\ttype MultiCurrency = Tokens;\n\ttype NativeCurrency = BasicCurrencyAdapter\u003cTest, Balances, Amount, BlockNumber\u003e;\n\ttype GetNativeCurrencyId = GetNativeCurrencyId;\n\ttype WeightInfo = ();\n}\n\nimpl Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = token_allowance::default_weights::SubstrateWeight\u003cTest\u003e;\n\ttype MaxAllowedCurrencies = ConstU32\u003c256\u003e;\n}\n\npub struct ExtBuilder;\n\nimpl ExtBuilder {\n\tpub fn build() -\u003e sp_io::TestExternalities {\n\t\tlet storage = frame_system::GenesisConfig::default().build_storage::\u003cTest\u003e().unwrap();\n\n\t\tsp_io::TestExternalities::from(storage)\n\t}\n}\n\npub fn run_test\u003cT\u003e(test: T)\nwhere\n\tT: FnOnce(),\n{\n\tExtBuilder::build().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\t\ttest();\n\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","tests.rs"],"content":"use frame_support::{assert_err, assert_ok, error::BadOrigin, traits::Get};\nuse orml_traits::MultiCurrency;\n\nuse crate::{mock::*, AllowedCurrencies, Config, CurrencyOf, Error};\n\n#[test]\nfn should_add_allowed_currencies() {\n\trun_test(|| {\n\t\tlet max_allowed_currencies: u32 = \u003cTest as Config\u003e::MaxAllowedCurrencies::get();\n\t\tlet max_allowed_currencies: u64 = max_allowed_currencies as u64;\n\t\tlet added_currencies = (0..max_allowed_currencies).collect::\u003cVec\u003cu64\u003e\u003e();\n\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(RuntimeOrigin::root(), added_currencies));\n\t\tfor i in 0..max_allowed_currencies {\n\t\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(i), Some(()));\n\t\t}\n\t})\n}\n\n#[test]\nfn should_remove_allowed_currencies() {\n\trun_test(|| {\n\t\tlet max_allowed_currencies: u32 = \u003cTest as Config\u003e::MaxAllowedCurrencies::get();\n\t\tlet max_allowed_currencies: u64 = max_allowed_currencies as u64;\n\t\tlet mut added_currencies = (0..max_allowed_currencies).collect::\u003cVec\u003cu64\u003e\u003e();\n\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tadded_currencies.clone()\n\t\t));\n\t\tfor i in 0..max_allowed_currencies {\n\t\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(i), Some(()));\n\t\t}\n\n\t\tlet existing_currency: CurrencyOf\u003cTest\u003e =\n\t\t\tadded_currencies.pop().expect(\"Should have a currency\");\n\t\tassert_ok!(TokenAllowance::remove_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tadded_currencies.clone()\n\t\t));\n\n\t\tfor i in 0..added_currencies.len() as u64 {\n\t\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(i), None);\n\t\t}\n\t\t// The existing currency should remain\n\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(existing_currency), Some(()));\n\t})\n}\n\n#[test]\nfn should_not_exceed_allowed_currencies() {\n\trun_test(|| {\n\t\tlet max_allowed_currencies: u32 = \u003cTest as Config\u003e::MaxAllowedCurrencies::get();\n\t\tlet max_allowed_currencies: u64 = max_allowed_currencies as u64;\n\t\tlet too_many_currencies = (0..max_allowed_currencies + 1).collect::\u003cVec\u003cu64\u003e\u003e();\n\n\t\t// We can't add more than the maximum allowed currencies\n\t\tassert_err!(\n\t\t\tTokenAllowance::add_allowed_currencies(\n\t\t\t\tRuntimeOrigin::root(),\n\t\t\t\ttoo_many_currencies.clone()\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t);\n\n\t\tassert_err!(\n\t\t\tTokenAllowance::remove_allowed_currencies(RuntimeOrigin::root(), too_many_currencies),\n\t\t\tError::\u003cTest\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t);\n\n\t\t// Fill the allowed currencies to the maximum\n\t\tlet added_currencies = (0..max_allowed_currencies).collect::\u003cVec\u003cu64\u003e\u003e();\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tadded_currencies.clone()\n\t\t));\n\t\tfor i in 0..max_allowed_currencies {\n\t\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(i), Some(()));\n\t\t}\n\n\t\t// Try to add a duplicate currency (should not fail because we don't store duplicates)\n\t\tlet already_added_currency = added_currencies[0];\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![already_added_currency]\n\t\t));\n\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(already_added_currency), Some(()));\n\n\t\t// Try to add a new distinct currency (should fail since we reached the maximum)\n\t\tlet illegal_currency: CurrencyOf\u003cTest\u003e = max_allowed_currencies;\n\t\tassert_err!(\n\t\t\tTokenAllowance::add_allowed_currencies(RuntimeOrigin::root(), vec![illegal_currency]),\n\t\t\tError::\u003cTest\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t);\n\t})\n}\n\n#[test]\nfn should_not_add_allowed_currencies_with_non_root_origin() {\n\trun_test(|| {\n\t\tlet native_currency_id = \u003cTest as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tlet added_currencies: Vec\u003cCurrencyOf\u003cTest\u003e\u003e = vec![native_currency_id];\n\t\tassert_err!(\n\t\t\tTokenAllowance::add_allowed_currencies(\n\t\t\t\tRuntimeOrigin::signed(1),\n\t\t\t\tadded_currencies.clone()\n\t\t\t),\n\t\t\tBadOrigin\n\t\t);\n\t\tassert_err!(\n\t\t\tTokenAllowance::add_allowed_currencies(RuntimeOrigin::none(), added_currencies),\n\t\t\tBadOrigin\n\t\t);\n\t})\n}\n\n#[test]\nfn should_not_remove_allowed_currencies_with_non_root_origin() {\n\trun_test(|| {\n\t\tlet native_currency_id = \u003cTest as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tlet added_currencies: Vec\u003cCurrencyOf\u003cTest\u003e\u003e = vec![native_currency_id];\n\t\tassert_err!(\n\t\t\tTokenAllowance::remove_allowed_currencies(\n\t\t\t\tRuntimeOrigin::signed(1),\n\t\t\t\tadded_currencies.clone()\n\t\t\t),\n\t\t\tBadOrigin\n\t\t);\n\t\tassert_err!(\n\t\t\tTokenAllowance::remove_allowed_currencies(RuntimeOrigin::none(), added_currencies),\n\t\t\tBadOrigin\n\t\t);\n\t})\n}\n\n#[test]\nfn should_return_allowance() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Check allowance\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), 0);\n\n\t\t// Approve the amount\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Check allowance again\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), amount);\n\t})\n}\n\n#[test]\nfn should_approve_transfer() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\t// Will not work yet\n\t\tassert_err!(\n\t\t\tTokenAllowance::approve(\n\t\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\t\tcurrency_id,\n\t\t\t\tdelegate.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::CurrencyNotLive\n\t\t);\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Should work now\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Check allowance\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), amount);\n\t})\n}\n\n#[test]\nfn should_transfer_from_for_approved_transfer() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\t// Mint some tokens\n\t\tassert_ok!(Tokens::deposit(currency_id, \u0026owner, amount));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), 0);\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Approve the amount\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Transfer all of the approved amount\n\t\tassert_ok!(TokenAllowance::transfer_from(\n\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\tcurrency_id,\n\t\t\towner.clone(),\n\t\t\tdestination.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), amount);\n\t\t// Check that the allowance is now empty since we transferred the whole amount\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), 0);\n\n\t\t// Test again but this time only using a partial amount of what was approved\n\t\tlet partial_amount = amount / 2;\n\t\tassert_ok!(Tokens::deposit(currency_id, \u0026owner, amount));\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\t\tassert_ok!(TokenAllowance::transfer_from(\n\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\tcurrency_id,\n\t\t\towner.clone(),\n\t\t\tdestination.clone(),\n\t\t\tpartial_amount\n\t\t));\n\n\t\t// Check the balances again\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), amount - partial_amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), amount + partial_amount);\n\t\t// Check that the allowance is now reduced by the partial amount\n\t\tassert_eq!(\n\t\t\tTokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate),\n\t\t\tamount - partial_amount\n\t\t);\n\t})\n}\n\n#[test]\nfn should_not_transfer_from_without_approved_transfer() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\t// Mint some tokens\n\t\tassert_ok!(Tokens::deposit(currency_id, \u0026owner, amount));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), 0);\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Try to `transfer_from` without having approved the transfer\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::Unapproved\n\t\t);\n\n\t\t// Approve the amount\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Try to `transfer_from` for amount larger than what was approved\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount + 1\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::Unapproved\n\t\t);\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), 0);\n\t})\n}\n\n#[test]\nfn should_transfer_from_while_keeping_infinite_allowance() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\t// We use the max value of u128 as the amount to approve because it represents an infinite allowance\n\t\tlet allowance_amount: \u003cTest as orml_tokens::Config\u003e::Balance =\n\t\t\t\u003cTest as orml_tokens::Config\u003e::Balance::max_value();\n\n\t\t// Mint some tokens\n\t\tassert_ok!(Tokens::deposit(currency_id, \u0026owner, allowance_amount));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), allowance_amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), 0);\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Approve infinite spending\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tallowance_amount,\n\t\t));\n\n\t\t// Check the allowance of the delegate\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), allowance_amount);\n\n\t\t// Transfer the approved amount once\n\t\tassert_ok!(TokenAllowance::transfer_from(\n\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\tcurrency_id,\n\t\t\towner.clone(),\n\t\t\tdestination.clone(),\n\t\t\tallowance_amount\n\t\t));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), allowance_amount);\n\n\t\t// Check that the allowance of the delegate is still the same since it should be infinite\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), allowance_amount);\n\n\t\t// Move the tokens from `destination` to the `owner` again to avoid overflow but allow for testing the same amount again\n\t\tassert_ok!(Tokens::transfer(\n\t\t\tRuntimeOrigin::signed(destination.clone()),\n\t\t\towner,\n\t\t\tcurrency_id,\n\t\t\tallowance_amount\n\t\t));\n\n\t\t// Transfer the approved amount again\n\t\tassert_ok!(TokenAllowance::transfer_from(\n\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\tcurrency_id,\n\t\t\towner.clone(),\n\t\t\tdestination.clone(),\n\t\t\tallowance_amount\n\t\t));\n\n\t\t// Check the balances again\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), allowance_amount);\n\t})\n}\n\n#[test]\nfn should_not_transfer_from_for_invalid_origin() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::none(),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tBadOrigin\n\t\t);\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::root(),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tBadOrigin\n\t\t);\n\t})\n}\n\n#[test]\nfn should_not_transfer_from_for_invalid_currency() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::CurrencyNotLive\n\t\t);\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","benchmarking.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n#![cfg(feature = \"runtime-benchmarks\")]\n\n//! Benchmarking\nuse crate::{types::RoundInfo, *};\nuse frame_benchmarking::{account, benchmarks, impl_benchmark_test_suite, Zero};\nuse frame_support::{\n\tassert_ok,\n\ttraits::{Currency, Get, OnInitialize},\n};\nuse frame_system::{Pallet as System, RawOrigin};\nuse pallet_session::Pallet as Session;\nuse sp_runtime::{\n\ttraits::{One, SaturatedConversion, StaticLookup},\n\tPerquintill,\n};\nuse sp_std::{convert::TryInto, vec::Vec};\n\nconst COLLATOR_ACCOUNT_SEED: u32 = 0;\nconst DELEGATOR_ACCOUNT_SEED: u32 = 1;\n\n/// Fills the candidate pool up to `num_candidates`.\nfn setup_collator_candidates\u003cT: Config\u003e(\n\tnum_candidates: u32,\n\tdefault_amount: Option\u003cT::CurrencyBalance\u003e,\n) -\u003e Vec\u003cT::AccountId\u003e {\n\tlet current_collator_count = TopCandidates::\u003cT\u003e::get().len().saturated_into::\u003cu32\u003e();\n\tlet collators: Vec\u003cT::AccountId\u003e = (current_collator_count..num_candidates)\n\t\t.map(|i| account(\"collator\", i.saturated_into::\u003cu32\u003e(), COLLATOR_ACCOUNT_SEED))\n\t\t.collect();\n\tlet amount: T::CurrencyBalance =\n\t\tdefault_amount.unwrap_or_else(T::MinCollatorCandidateStake::get);\n\n\tfor acc in collators.iter() {\n\t\tT::Currency::make_free_balance_be(acc, amount);\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_candidates(\n\t\t\tT::RuntimeOrigin::from(Some(acc.clone()).into()),\n\t\t\tamount,\n\t\t));\n\t\tassert_eq!(\u003cCandidatePool\u003cT\u003e\u003e::get(acc).unwrap().stake, amount);\n\t}\n\n\tTopCandidates::\u003cT\u003e::get()\n\t\t.into_bounded_vec()\n\t\t.into_inner()\n\t\t.drain(..)\n\t\t.map(|c| c.owner)\n\t\t.collect()\n}\n\nfn fill_delegators\u003cT: Config\u003e(\n\tnum_delegators: u32,\n\tcollator: T::AccountId,\n\tcollator_seed: u32,\n) -\u003e Vec\u003cT::AccountId\u003e {\n\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\tlet current_delegators = state.delegators.len().saturated_into::\u003cu32\u003e();\n\n\tlet delegators: Vec\u003cT::AccountId\u003e = (current_delegators..num_delegators)\n\t\t.map(|i| {\n\t\t\taccount(\n\t\t\t\t\"delegator\",\n\t\t\t\ti.saturated_into::\u003cu32\u003e(),\n\t\t\t\tDELEGATOR_ACCOUNT_SEED * 1000 + collator_seed,\n\t\t\t)\n\t\t})\n\t\t.collect();\n\n\tfor acc in delegators.iter() {\n\t\tT::Currency::make_free_balance_be(acc, T::MinDelegatorStake::get());\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_delegators(\n\t\t\tT::RuntimeOrigin::from(Some(acc.clone()).into()),\n\t\t\tT::Lookup::unlookup(collator.clone()),\n\t\t\tT::MinDelegatorStake::get(),\n\t\t));\n\t}\n\n\tdelegators\n}\n\n// fills unstake BTreeMap by unstaked many entries of 1\nfn fill_unstaking\u003cT: Config\u003e(\n\tcollator: \u0026T::AccountId,\n\tdelegator: Option\u003c\u0026T::AccountId\u003e,\n\tunstaked: u64,\n) where\n\tu64: Into\u003c\u003cT as frame_system::Config\u003e::BlockNumber\u003e,\n{\n\tlet who = delegator.unwrap_or(collator);\n\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(who).len(), 0);\n\twhile System::\u003cT\u003e::block_number() \u003c unstaked.into() {\n\t\tif let Some(delegator) = delegator {\n\t\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_less(\n\t\t\t\tRawOrigin::Signed(delegator.clone()).into(),\n\t\t\t\tT::Lookup::unlookup(collator.clone()),\n\t\t\t\tT::CurrencyBalance::one()\n\t\t\t));\n\t\t} else {\n\t\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::candidate_stake_less(\n\t\t\t\tRawOrigin::Signed(collator.clone()).into(),\n\t\t\t\tT::CurrencyBalance::one()\n\t\t\t));\n\t\t}\n\t\tSystem::\u003cT\u003e::set_block_number(System::\u003cT\u003e::block_number() + T::BlockNumber::one());\n\t}\n\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(who).len() as u64, unstaked);\n\tassert!(\u003cUnstaking\u003cT\u003e\u003e::get(who).len() \u003c= T::MaxUnstakeRequests::get().try_into().unwrap());\n}\n\nbenchmarks! {\n\twhere_clause { where u64: Into\u003c\u003cT as frame_system::Config\u003e::BlockNumber\u003e }\n\n\ton_initialize_no_action {\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get().current, 0u32);\n\t\tlet block = T::BlockNumber::one();\n\t}: { Pallet::\u003cT\u003e::on_initialize(block) }\n\tverify {\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get().current, 0u32);\n\t}\n\n\ton_initialize_round_update {\n\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\t\tassert_eq!(round.current, 0u32);\n\t}: { Pallet::\u003cT\u003e::on_initialize(round.length) }\n\tverify {\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get().current, 1u32);\n\t}\n\n\ton_initialize_network_rewards {\n\t\tlet issuance = T::Currency::total_issuance();\n\t\t// if we only add by one, we also initialize a new year\n\t\tlet block = T::NetworkRewardStart::get() + T::BlockNumber::one() * 2_u64.into();\n\t}: { Pallet::\u003cT\u003e::on_initialize(block) }\n\tverify {\n\t\tlet new_issuance = T::Currency::total_issuance();\n\t\tlet max_col_reward = InflationConfig::\u003cT\u003e::get().collator.reward_rate.per_block * MaxCollatorCandidateStake::\u003cT\u003e::get() * MaxSelectedCandidates::\u003cT\u003e::get().into();\n\t\tlet network_block_reward = T::NetworkRewardRate::get() * max_col_reward;\n\t\tassert!(new_issuance \u003e issuance);\n\t\tassert_eq!(new_issuance - issuance, network_block_reward)\n\t}\n\n\tforce_new_round {\n\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\t\tlet now = System::\u003cT\u003e::block_number();\n\t\tassert_eq!(round.current, 0);\n\t\tassert_eq!(Session::\u003cT\u003e::current_index(), 0);\n\t\tassert!(!\u003cForceNewRound\u003cT\u003e\u003e::get());\n\t}: _(RawOrigin::Root)\n\tverify {\n\t\tassert!(\u003cForceNewRound\u003cT\u003e\u003e::get());\n\t\tassert_eq!(Session::\u003cT\u003e::current_index(), 0);\n\n\t\t// jump to next block to trigger new round\n\t\tlet now = now + T::BlockNumber::one();\n\t\tSystem::\u003cT\u003e::set_block_number(now);\n\t\tSession::\u003cT\u003e::on_initialize(now);\n\t\tassert_eq!(Session::\u003cT\u003e::current_index(), 1);\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get(), RoundInfo {\n\t\t\tcurrent: 1,\n\t\t\tfirst: now,\n\t\t\tlength: round.length,\n\t\t});\n\t\tassert!(!\u003cForceNewRound\u003cT\u003e\u003e::get());\n\t}\n\n\tset_inflation {\n\t\tlet n in 0 .. T::MaxTopCandidates::get();\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t\tRewards::\u003cT\u003e::insert(\u0026c, T::CurrencyBalance::one());\n\t\t}\n\n\t\tlet inflation = InflationInfo::new(\n\t\t\tT::BLOCKS_PER_YEAR.saturated_into(),\n\t\t\tPerquintill::from_percent(10),\n\t\t\tPerquintill::from_percent(15),\n\t\t\tPerquintill::from_percent(40),\n\t\t\tPerquintill::from_percent(10)\n\t\t);\n\t}: _(RawOrigin::Root, inflation.collator.max_rate, inflation.collator.reward_rate.annual, inflation.delegator.max_rate, inflation.delegator.reward_rate.annual)\n\tverify {\n\t\tassert_eq!(InflationConfig::\u003cT\u003e::get(), inflation);\n\t\tcandidates.into_iter().for_each(|candidate| {\n\t\t\tassert!(!Rewards::\u003cT\u003e::get(\u0026candidate).is_zero());\n\t\t});\n\t}\n\n\tset_max_selected_candidates {\n\t\tlet n in (T::MinCollators::get()) .. T::MaxTopCandidates::get();\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet old_candidate = candidates[0].clone();\n\t}: _(RawOrigin::Root, n)\n\tverify {\n\t\tassert_eq!(\u003cMaxSelectedCandidates\u003cT\u003e\u003e::get(), n);\n\t}\n\n\tset_blocks_per_round {\n\t\tlet bpr: T::BlockNumber = T::MinBlocksPerRound::get() + T::BlockNumber::one();\n\t}: _(RawOrigin::Root, bpr)\n\tverify {\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get().length, bpr);\n\t}\n\n\tforce_remove_candidate {\n\t\tlet n in (T::MinCollators::get() + 1) .. T::MaxTopCandidates::get();\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet candidate = candidates[0].clone();\n\t\tlet unlookup_candidate = T::Lookup::unlookup(candidate.clone());\n\t}: _(RawOrigin::Root, unlookup_candidate)\n\tverify {\n\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\t\tassert!(!candidates.into_iter().any(|other| other.owner == candidate));\n\t}\n\n\tjoin_candidates {\n\t\tlet n in 1 .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet min_candidate_stake = T::MinCollatorCandidateStake::get();\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\n\t\tlet new_candidate = account(\"new_collator\", u32::MAX , COLLATOR_ACCOUNT_SEED);\n\t\tT::Currency::make_free_balance_be(\u0026new_candidate, min_candidate_stake);\n\n\t\tlet origin = RawOrigin::Signed(new_candidate.clone());\n\t}: _(origin, min_candidate_stake)\n\tverify {\n\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\t\tassert!(candidates.into_iter().any(|other| other.owner == new_candidate));\n\t}\n\n\tinit_leave_candidates {\n\t\tlet n in (T::MinCollators::get() + 1) .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\n\t\tlet now = \u003cRound\u003cT\u003e\u003e::get().current;\n\t\tlet candidate = candidates[0].clone();\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin)\n\tverify {\n\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\t\tassert!(!candidates.into_iter().any(|other| other.owner == candidate));\n\t\tlet unlocking_at = now.saturating_add(T::ExitQueueDelay::get());\n\t\tassert!(\u003cCandidatePool\u003cT\u003e\u003e::get(candidate).unwrap().can_exit(unlocking_at));\n\t}\n\n\tcancel_leave_candidates {\n\t\tlet n in (T::MinCollators::get() + 1) .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\n\t\tlet candidate = candidates[0].clone();\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::init_leave_candidates(RawOrigin::Signed(candidate.clone()).into()));\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin)\n\tverify {\n\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\t\tassert!(candidates.into_iter().any(|other| other.owner == candidate));\n\t}\n\n\texecute_leave_candidates {\n\t\tlet n in (T::MinCollators::get() + 1) .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet u = T::MaxUnstakeRequests::get() as u32 - 1;\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet candidate = candidates[0].clone();\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tlet more_stake = T::MinCollatorCandidateStake::get();\n\t\tT::Currency::make_free_balance_be(\u0026candidate, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::candidate_stake_more(RawOrigin::Signed(candidate.clone()).into(), more_stake));\n\n\t\t// fill unstake BTreeMap by unstaked many entries of 1\n\t\tfill_unstaking::\u003cT\u003e(\u0026candidate, None, u as u64);\n\n\t\t// go to block in which we can exit\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::init_leave_candidates(RawOrigin::Signed(candidate.clone()).into()));\n\n\t\tfor i in 1..=T::ExitQueueDelay::get() {\n\t\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\t\t\tlet now = round.first + round.length;\n\t\t\tSystem::\u003cT\u003e::set_block_number(now);\n\t\t\tPallet::\u003cT\u003e::on_initialize(now);\n\t\t}\n\t\tlet unlookup_candidate = T::Lookup::unlookup(candidate.clone());\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin, unlookup_candidate)\n\tverify {\n\t\t// should have one more entry in Unstaking\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026candidate).len().saturated_into::\u003cu32\u003e(), u.saturating_add(1u32));\n\t}\n\n\tcandidate_stake_more {\n\t\tlet n in 1 .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\t\tlet u in 0 .. (T::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e() - 1);\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet candidate = candidates[0].clone();\n\n\t\tlet old_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tlet more_stake = T::MinCollatorCandidateStake::get();\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tT::Currency::make_free_balance_be(\u0026candidate, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::candidate_stake_more(RawOrigin::Signed(candidate.clone()).into(), more_stake));\n\n\t\t// fill unstake BTreeMap by unstaked many entries of 1\n\t\tfill_unstaking::\u003cT\u003e(\u0026candidate, None, u as u64);\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin, more_stake)\n\tverify {\n\t\tlet new_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tassert!(\u003cUnstaking\u003cT\u003e\u003e::get(candidate).is_empty());\n\t\tassert_eq!(new_stake, old_stake + more_stake + more_stake - T::CurrencyBalance::from(u as u64));\n\t}\n\n\tcandidate_stake_less {\n\t\tlet n in 1 .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet candidate = candidates[0].clone();\n\n\t\t// increase stake of candidate to later decrease it again\n\t\tlet old_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tlet more_stake = T::MinCollatorCandidateStake::get();\n\n\t\tT::Currency::make_free_balance_be(\u0026candidate, T::CurrencyBalance::from(u128::MAX));\n\t\tPallet::\u003cT\u003e::candidate_stake_more(RawOrigin::Signed(candidate.clone()).into(), more_stake).expect(\"should increase stake\");\n\n\t\tlet new_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tassert_eq!(new_stake, old_stake + more_stake);\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin, more_stake)\n\tverify {\n\t\tlet new_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tassert_eq!(new_stake, old_stake);\n\t}\n\n\tjoin_delegators {\n\t\tlet n in 1 .. T::MaxTopCandidates::get();\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get() - 1;\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\t\tlet delegator = account(\"new-delegator\", 0, DELEGATOR_ACCOUNT_SEED);\n\t\tlet amount = T::MinDelegatorStake::get();\n\t\tT::Currency::make_free_balance_be(\u0026delegator, amount + amount + amount + amount);\n\t\tlet unlookup_collator = T::Lookup::unlookup(collator.clone());\n\n\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin, unlookup_collator, amount)\n\tverify {\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tassert!(state.delegators.into_iter().any(|x| x.owner == delegator));\n\t}\n\n\tdelegator_stake_more {\n\t\t// we need at least 1 collators\n\t\tlet n in 1 .. T::MaxTopCandidates::get();\n\t\t// we need at least 1 delegator\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get() - 1;\n\t\tlet u in 1 .. (T::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e() - 1);\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\t\tlet amount = T::MinDelegatorStake::get();\n\n\t\t// make sure delegator collated to collator\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tlet delegator = state.delegators.into_bounded_vec()[0].owner.clone();\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, amount);\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tT::Currency::make_free_balance_be(\u0026delegator, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_more(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), T::CurrencyBalance::from(u as u64)));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, amount + T::CurrencyBalance::from(u as u64));\n\n\t\t// fill unstake BTreeMap by unstaked many entries of 1\n\t\tfill_unstaking::\u003cT\u003e(\u0026collator, Some(\u0026delegator), u as u64);\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, amount);\n\t\tlet unlookup_collator = T::Lookup::unlookup(collator.clone());\n\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin, unlookup_collator, amount)\n\tverify {\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tassert!(state.delegators.into_iter().any(|x| x.owner == delegator));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, amount + amount);\n\t\tassert!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).is_empty());\n\t}\n\n\tdelegator_stake_less {\n\t\t// we need at least 1 collators\n\t\tlet n in 1 .. T::MaxTopCandidates::get();\n\t\t// we need at least 1 delegator\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get() - 1;\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\t\tlet amount = T::CurrencyBalance::one();\n\n\t\t// make sure delegator collated to collator\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tlet delegator = state.delegators.into_bounded_vec()[0].owner.clone();\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get());\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tT::Currency::make_free_balance_be(\u0026delegator, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_more(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), amount + amount));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get() + amount + amount);\n\n\t\t// decrease stake once so we have an unstaking entry for this block\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_less(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), amount));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get() + amount);\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).len(), 1);\n\t\tlet unlookup_collator = T::Lookup::unlookup(collator.clone());\n\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin, unlookup_collator, amount)\n\tverify {\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tassert!(state.delegators.into_iter().any(|x| x.owner == delegator));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get());\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).len(), 2);\n\t}\n\n\tleave_delegators {\n\t\t// we need at least 1 collators\n\t\tlet n in 1 .. T::MaxTopCandidates::get();\n\t\t// we need at least 1 delegator\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get() - 1;\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\t\tlet amount = T::CurrencyBalance::one();\n\n\t\t// make sure delegator collated to collator\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tlet delegator = state.delegators.into_bounded_vec()[0].owner.clone();\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get());\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tT::Currency::make_free_balance_be(\u0026delegator, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_more(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), amount + amount));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get() + amount + amount);\n\n\t\t// decrease stake once so we have an unstaking entry for this block\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_less(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), amount));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get() + amount);\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).len(), 1);\n\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin)\n\tverify {\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tassert!(!state.delegators.into_iter().any(|x| x.owner == delegator));\n\t\tassert!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).is_none());\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).len(), 2);\n\t}\n\n\tunlock_unstaked {\n\t\tlet u in 1 .. (T::MaxUnstakeRequests::get() as u32 - 1);\n\n\t\tlet candidate = account(\"collator\", 0u32, COLLATOR_ACCOUNT_SEED);\n\t\tlet free_balance = T::CurrencyBalance::from(u128::MAX);\n\t\tlet stake = T::MinCollatorCandidateStake::get();\n\t\tT::Currency::make_free_balance_be(\u0026candidate, free_balance);\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_candidates(\n\t\t\tT::RuntimeOrigin::from(Some(candidate.clone()).into()),\n\t\t\tstake,\n\t\t));\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026candidate), (free_balance - T::MinCollatorCandidateStake::get()).into());\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::candidate_stake_more(RawOrigin::Signed(candidate.clone()).into(), stake));\n\n\t\t// fill unstake BTreeMap by unstaked many entries of 1\n\t\tfill_unstaking::\u003cT\u003e(\u0026candidate, None, u as u64);\n\t\tassert_eq!(\u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake, stake + stake -  T::CurrencyBalance::from(u as u64));\n\n\t\t// roll to block in which first unstake can be unlocked\n\t\tSystem::\u003cT\u003e::set_block_number(T::StakeDuration::get());\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026candidate), (free_balance - stake - stake).into());\n\t\tlet unlookup_candidate = T::Lookup::unlookup(candidate.clone());\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin, unlookup_candidate)\n\tverify {\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026candidate).len().saturated_into::\u003cu32\u003e(), u.saturating_sub(1u32));\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026candidate), (free_balance - stake - stake + T::CurrencyBalance::one()).into());\n\t}\n\n\tset_max_candidate_stake {\n\t\tlet old = \u003cMaxCollatorCandidateStake\u003cT\u003e\u003e::get();\n\t\tlet new = \u003cMaxCollatorCandidateStake\u003cT\u003e\u003e::get() + T::CurrencyBalance::from(10u128);\n\t}: _(RawOrigin::Root, new)\n\tverify {\n\t\tassert_eq!(\u003cMaxCollatorCandidateStake\u003cT\u003e\u003e::get(), new);\n\t}\n\n\tincrement_delegator_rewards {\n\t\tlet collator = setup_collator_candidates::\u003cT\u003e(1, None)[0].clone();\n\t\tlet delegator = fill_delegators::\u003cT\u003e(1, collator.clone(), COLLATOR_ACCOUNT_SEED)[0].clone();\n\n\t\t// mock high values to compensate for tiny values in unit test env\n\t\tlet stake = T::CurrencyBalance::from(1_000_000_000_000_000_000u128);\n\t\tDelegatorState::\u003cT\u003e::insert(\u0026delegator, crate::types::Delegator { owner: Some(collator.clone()), amount: stake});\n\t\tRewardCount::\u003cT\u003e::insert(\u0026collator, u32::MAX);\n\n\t\tassert!(Rewards::\u003cT\u003e::get(\u0026delegator).is_zero());\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin)\n\tverify {\n\t\tassert!(!Rewards::\u003cT\u003e::get(\u0026delegator).is_zero());\n\t}\n\n\tincrement_collator_rewards {\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet collator = setup_collator_candidates::\u003cT\u003e(1, None)[0].clone();\n\t\tlet delegators = fill_delegators::\u003cT\u003e(m, collator.clone(), COLLATOR_ACCOUNT_SEED);\n\n\t\t// mock high counter to compensate for tiny amounts in unit test env\n\t\tRewardCount::\u003cT\u003e::insert(\u0026collator, u32::MAX);\n\t\tassert!(Rewards::\u003cT\u003e::get(\u0026collator).is_zero(), \"reward {:?}\", Rewards::\u003cT\u003e::get(\u0026collator));\n\t\tlet origin = RawOrigin::Signed(collator.clone());\n\t}: _(origin)\n\tverify {\n\t\tassert!(!Rewards::\u003cT\u003e::get(\u0026collator).is_zero());\n\t}\n\n\tclaim_rewards {\n\t\tlet beneficiary = account(\"beneficiary\", 0, 0);\n\t\tlet amount = T::MinCollatorCandidateStake::get();\n\t\tT::Currency::make_free_balance_be(\u0026beneficiary, amount);\n\t\tRewards::\u003cT\u003e::insert(\u0026beneficiary, amount);\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026beneficiary), amount.into());\n\t\tlet origin = RawOrigin::Signed(beneficiary.clone());\n\t}: _(origin)\n\tverify {\n\t\tassert!(Rewards::\u003cT\u003e::get(\u0026beneficiary).is_zero());\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026beneficiary), (amount + amount).into());\n\t}\n\n\texecute_scheduled_reward_change {\n\t\t// we need at least 1 collators\n\t\tlet n in 0 .. T::MaxTopCandidates::get();\n\t\t// we need at least 1 delegator\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\n\t\tlet old = InflationConfig::\u003cT\u003e::get();\n\t\tassert_eq!(LastRewardReduction::\u003cT\u003e::get(), T::BlockNumber::zero());\n\t\tSystem::\u003cT\u003e::set_block_number(T::BLOCKS_PER_YEAR + T::BlockNumber::one());\n\t}: _(RawOrigin::Signed(collator))\n\tverify {\n\t\tlet new = InflationConfig::\u003cT\u003e::get();\n\t\tassert_eq!(LastRewardReduction::\u003cT\u003e::get(), T::BlockNumber::one());\n\t\tassert_eq!(new.collator.max_rate, old.collator.max_rate);\n\t\tassert_eq!(new.delegator.max_rate, old.delegator.max_rate);\n\t\tassert!(new.collator.reward_rate.annual \u003c old.collator.reward_rate.annual);\n\t\tassert!(new.delegator.reward_rate.annual \u003c old.delegator.reward_rate.annual);\n\t}\n\n}\n\nimpl_benchmark_test_suite!(\n\tPallet,\n\tcrate::mock::ExtBuilder::default()\n\t\t.with_balances(vec![(u64::MAX, 1000 * crate::mock::MILLI_KILT)])\n\t\t.with_collators(vec![(u64::MAX, 1000 * crate::mock::MILLI_KILT)])\n\t\t.build(),\n\tcrate::mock::Test,\n);\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":43},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","default_weights.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\n//! Autogenerated weights for parachain_staking\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2022-02-14, STEPS: {{cmd.steps}}\\, REPEAT: {{cmd.repeat}}\\, LOW RANGE: {{cmd.lowest_range_values}}\\, HIGH RANGE: {{cmd.highest_range_values}}\\\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"spiritnet-dev\"), DB CACHE: 1024\n\n// Executed Command:\n// target/release/kilt-parachain\n// benchmark\n// --chain=spiritnet-dev\n// --steps=50\n// --repeat=20\n// --pallet=parachain-staking\n// --extrinsic=*\n// --execution=wasm\n// --wasm-execution=compiled\n// --heap-pages=4096\n// --output=pallets/parachain-staking/src/default_weights.rs\n// --template=.maintain/weight-template.hbs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n#![allow(clippy::unnecessary_cast)]\n\nuse frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions needed for parachain_staking.\npub trait WeightInfo {\n\tfn on_initialize_no_action() -\u003e Weight;\n\tfn on_initialize_round_update() -\u003e Weight;\n\tfn on_initialize_network_rewards() -\u003e Weight;\n\tfn force_new_round() -\u003e Weight;\n\tfn set_inflation(n: u32, m:u32 ) -\u003e Weight;\n\tfn set_max_selected_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn set_blocks_per_round() -\u003e Weight;\n\tfn force_remove_candidate(n: u32, m: u32, ) -\u003e Weight;\n\tfn join_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn init_leave_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn cancel_leave_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn execute_leave_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn candidate_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight;\n\tfn candidate_stake_less(n: u32, m: u32, ) -\u003e Weight;\n\tfn join_delegators(n: u32, m: u32, ) -\u003e Weight;\n\tfn delegator_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight;\n\tfn delegator_stake_less(n: u32, m: u32, ) -\u003e Weight;\n\tfn leave_delegators(n: u32, m: u32, ) -\u003e Weight;\n\tfn unlock_unstaked(u: u32, ) -\u003e Weight;\n\tfn set_max_candidate_stake() -\u003e Weight;\n\tfn increment_delegator_rewards() -\u003e Weight;\n\tfn increment_collator_rewards(_m: u32, ) -\u003e Weight;\n\tfn claim_rewards() -\u003e Weight;\n\tfn execute_scheduled_reward_change(n: u32, m: u32, ) -\u003e Weight;\n}\n\n/// Weights for parachain_staking using the Substrate node and recommended hardware.\npub struct SubstrateWeight\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e WeightInfo for SubstrateWeight\u003cT\u003e {\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\tfn on_initialize_no_action() -\u003e Weight {\n\t\tWeight::from_parts(3_103_000u64,0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\tfn on_initialize_round_update() -\u003e Weight {\n\t\tWeight::from_parts(11_496_000u64,0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: System Account (r:1 w:1)\n\tfn on_initialize_network_rewards() -\u003e Weight {\n\t\tWeight::from_parts(35_227_000u64,0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(5 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking ForceNewRound (r:0 w:1)\n\tfn force_new_round() -\u003e Weight {\n\t\tWeight::from_parts(5_101_000u64,0)\n\t\t\t.saturating_add(T::DbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:3 w:0)\n\t// Storage: ParachainStaking RewardCount (r:72 w:72)\n\t// Storage: ParachainStaking Rewards (r:2 w:2)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:1)\n\t/// The range of component `n` is `[0, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn set_inflation(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64,0)\n\t\t\t// Standard Error: 3_005_000\n\t\t\t.saturating_add(Weight::from_parts(216_364_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 6_440_000\n\t\t\t.saturating_add(Weight::from_parts(440_763_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((37 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().reads((75 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes((36 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes((75 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:59 w:0)\n\t/// The range of component `n` is `[16, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn set_max_selected_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 524_000\n\t\t\t.saturating_add(Weight::from_parts(5_444_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 883_000\n\t\t\t.saturating_add(Weight::from_parts(5_252_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(1u64.saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\tfn set_blocks_per_round() -\u003e Weight {\n\t\tWeight::from_parts(24_978_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:17 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:36 w:36)\n\t// Storage: ParachainStaking DelegatorState (r:35 w:35)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: Session Validators (r:1 w:0)\n\t// Storage: Session DisabledValidators (r:1 w:1)\n\t// Storage: System Digest (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t/// The range of component `n` is `[17, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn force_remove_candidate(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 1_056_000\n\t\t\t.saturating_add(Weight::from_parts(2_682_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_750_000\n\t\t\t.saturating_add(Weight::from_parts(22_787_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(28 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((3 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(9 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes((3 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking DelegatorState (r:1 w:0)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn join_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(31_764_000u64, 0)\n\t\t\t// Standard Error: 644_000\n\t\t\t.saturating_add(Weight::from_parts(1_293_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_343_000\n\t\t\t.saturating_add(Weight::from_parts(2_377_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(10 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(7 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:17 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn init_leave_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 987_000\n\t\t\t.saturating_add(Weight::from_parts(7_127_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_607_000\n\t\t\t.saturating_add(Weight::from_parts(6_771_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(21 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:2 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn cancel_leave_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 26_390_000\n\t\t\t.saturating_add(Weight::from_parts(13_197_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 42_978_000\n\t\t\t.saturating_add(Weight::from_parts(24_662_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: ParachainStaking Unstaking (r:36 w:36)\n\t// Storage: ParachainStaking DelegatorState (r:35 w:35)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: Session Validators (r:1 w:0)\n\t// Storage: Session DisabledValidators (r:1 w:1)\n\t// Storage: System Digest (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn execute_leave_candidates(_n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(998_775_000u64, 0)\n\t\t\t// Standard Error: 431_000\n\t\t\t.saturating_add(Weight::from_parts(20_295_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(11 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((3 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(7 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes((3 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\t/// The range of component `u` is `[0, 9]`.\n\tfn candidate_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 332_000\n\t\t\t.saturating_add(Weight::from_parts(2_506_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 693_000\n\t\t\t.saturating_add(Weight::from_parts(9_543_000u64, 0).saturating_mul(m as u64))\n\t\t\t// Standard Error: 2_698_000\n\t\t\t.saturating_add(Weight::from_parts(5_104_000u64, 0).saturating_mul(u as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(11 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((1 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(8 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes((1 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn candidate_stake_less(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 905_000\n\t\t\t.saturating_add(Weight::from_parts(2_785_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_888_000\n\t\t\t.saturating_add(Weight::from_parts(10_300_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((1 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(6 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes((1 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:2 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking LastDelegation (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:1 w:1)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn join_delegators(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(8_951_000u64, 0)\n\t\t\t// Standard Error: 855_000\n\t\t\t.saturating_add(Weight::from_parts(1_589_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_919_000\n\t\t\t.saturating_add(Weight::from_parts(3_562_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(12 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(9 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\t/// The range of component `u` is `[1, 9]`.\n\tfn delegator_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(56_774_000u64, 0)\n\t\t\t// Standard Error: 883_000\n\t\t\t.saturating_add(Weight::from_parts(1_562_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_981_000\n\t\t\t.saturating_add(Weight::from_parts(867_000u64, 0).saturating_mul(m as u64))\n\t\t\t// Standard Error: 8_175_000\n\t\t\t.saturating_add(Weight::from_parts(5_717_000u64, 0).saturating_mul(u as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(10 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(7 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn delegator_stake_less(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(1_844_000u64, 0)\n\t\t\t// Standard Error: 138_000\n\t\t\t.saturating_add(Weight::from_parts(1_192_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 310_000\n\t\t\t.saturating_add(Weight::from_parts(2_218_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn leave_delegators(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(3_824_000u64, 0)\n\t\t\t// Standard Error: 51_000\n\t\t\t.saturating_add(Weight::from_parts(1_216_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 114_000\n\t\t\t.saturating_add(Weight::from_parts(2_150_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5 as u64))\n\t}\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t/// The range of component `u` is `[1, 9]`.\n\tfn unlock_unstaked(_u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(30_399_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(3 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:0 w:1)\n\tfn set_max_candidate_stake() -\u003e Weight {\n\t\tWeight::from_parts(13_991_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:0)\n\t// Storage: ParachainStaking RewardCount (r:2 w:1)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\tfn increment_delegator_rewards() -\u003e Weight {\n\t\tWeight::from_parts(25_796_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(6 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:0)\n\t// Storage: ParachainStaking RewardCount (r:1 w:1)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `m` is `[0, 35]`.\n\tfn increment_collator_rewards(_m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(366_611_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(75 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(72 as u64))\n\t}\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\tfn claim_rewards() -\u003e Weight {\n\t\tWeight::from_parts(29_833_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(2 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking LastRewardReduction (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:3 w:0)\n\t// Storage: ParachainStaking RewardCount (r:72 w:72)\n\t// Storage: ParachainStaking Rewards (r:2 w:2)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:0)\n\t/// The range of component `n` is `[0, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn execute_scheduled_reward_change(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 5_730_000\n\t\t\t.saturating_add(Weight::from_parts(202_623_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 12_280_000\n\t\t\t.saturating_add(Weight::from_parts(415_436_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((37 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().reads((75 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes((36 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes((75 as u64).saturating_mul(m as u64)))\n\t}\n}\n\n// For backwards compatibility and tests\nimpl WeightInfo for () {\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\tfn on_initialize_no_action() -\u003e Weight {\n\t\tWeight::from_parts(3_103_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\tfn on_initialize_round_update() -\u003e Weight {\n\t\tWeight::from_parts(11_496_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: System Account (r:1 w:1)\n\tfn on_initialize_network_rewards() -\u003e Weight {\n\t\tWeight::from_parts(35_227_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(5 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking ForceNewRound (r:0 w:1)\n\tfn force_new_round() -\u003e Weight {\n\t\tWeight::from_parts(5_101_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:3 w:0)\n\t// Storage: ParachainStaking RewardCount (r:72 w:72)\n\t// Storage: ParachainStaking Rewards (r:2 w:2)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:1)\n\t/// The range of component `n` is `[0, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn set_inflation(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 3_005_000\n\t\t\t.saturating_add(Weight::from_parts(216_364_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 6_440_000\n\t\t\t.saturating_add(Weight::from_parts(440_763_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((37 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((75 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((36 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((75 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:59 w:0)\n\t/// The range of component `n` is `[16, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn set_max_selected_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 524_000\n\t\t\t.saturating_add(Weight::from_parts(5_444_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 883_000\n\t\t\t.saturating_add(Weight::from_parts(5_252_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1u64.saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\tfn set_blocks_per_round() -\u003e Weight {\n\t\tWeight::from_parts(24_978_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:17 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:36 w:36)\n\t// Storage: ParachainStaking DelegatorState (r:35 w:35)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: Session Validators (r:1 w:0)\n\t// Storage: Session DisabledValidators (r:1 w:1)\n\t// Storage: System Digest (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t/// The range of component `n` is `[17, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn force_remove_candidate(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 1_056_000\n\t\t\t.saturating_add(Weight::from_parts(2_682_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_750_000\n\t\t\t.saturating_add(Weight::from_parts(22_787_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(28 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((3 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(9 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((3 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking DelegatorState (r:1 w:0)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn join_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(31_764_000u64, 0)\n\t\t\t// Standard Error: 644_000\n\t\t\t.saturating_add(Weight::from_parts(1_293_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_343_000\n\t\t\t.saturating_add(Weight::from_parts(2_377_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(10 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(7 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:17 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn init_leave_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 987_000\n\t\t\t.saturating_add(Weight::from_parts(7_127_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_607_000\n\t\t\t.saturating_add(Weight::from_parts(6_771_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(21 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:2 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn cancel_leave_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 26_390_000\n\t\t\t.saturating_add(Weight::from_parts(13_197_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 42_978_000\n\t\t\t.saturating_add(Weight::from_parts(24_662_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(5 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: ParachainStaking Unstaking (r:36 w:36)\n\t// Storage: ParachainStaking DelegatorState (r:35 w:35)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: Session Validators (r:1 w:0)\n\t// Storage: Session DisabledValidators (r:1 w:1)\n\t// Storage: System Digest (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn execute_leave_candidates(_n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(998_775_000u64, 0)\n\t\t\t// Standard Error: 431_000\n\t\t\t.saturating_add(Weight::from_parts(20_295_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(11 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((3 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(7 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((3 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\t/// The range of component `u` is `[0, 9]`.\n\tfn candidate_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 332_000\n\t\t\t.saturating_add(Weight::from_parts(2_506_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 693_000\n\t\t\t.saturating_add(Weight::from_parts(9_543_000u64, 0).saturating_mul(m as u64))\n\t\t\t// Standard Error: 2_698_000\n\t\t\t.saturating_add(Weight::from_parts(5_104_000u64, 0).saturating_mul(u as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(11 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((1 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(8 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((1 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn candidate_stake_less(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 905_000\n\t\t\t.saturating_add(Weight::from_parts(2_785_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_888_000\n\t\t\t.saturating_add(Weight::from_parts(10_300_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((1 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(6 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((1 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:2 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking LastDelegation (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:1 w:1)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn join_delegators(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(8_951_000u64, 0)\n\t\t\t// Standard Error: 855_000\n\t\t\t.saturating_add(Weight::from_parts(1_589_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_919_000\n\t\t\t.saturating_add(Weight::from_parts(3_562_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(12 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(9 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\t/// The range of component `u` is `[1, 9]`.\n\tfn delegator_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(56_774_000u64, 0)\n\t\t\t// Standard Error: 883_000\n\t\t\t.saturating_add(Weight::from_parts(1_562_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_981_000\n\t\t\t.saturating_add(Weight::from_parts(867_000u64, 0).saturating_mul(m as u64))\n\t\t\t// Standard Error: 8_175_000\n\t\t\t.saturating_add(Weight::from_parts(5_717_000u64, 0).saturating_mul(u as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(10 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(7 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn delegator_stake_less(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(1_844_000u64, 0)\n\t\t\t// Standard Error: 138_000\n\t\t\t.saturating_add(Weight::from_parts(1_192_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 310_000\n\t\t\t.saturating_add(Weight::from_parts(2_218_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(5 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn leave_delegators(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(3_824_000u64, 0)\n\t\t\t// Standard Error: 51_000\n\t\t\t.saturating_add(Weight::from_parts(1_216_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 114_000\n\t\t\t.saturating_add(Weight::from_parts(2_150_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(5 as u64))\n\t}\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t/// The range of component `u` is `[1, 9]`.\n\tfn unlock_unstaked(_u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(30_399_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(3 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:0 w:1)\n\tfn set_max_candidate_stake() -\u003e Weight {\n\t\tWeight::from_parts(13_991_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:0)\n\t// Storage: ParachainStaking RewardCount (r:2 w:1)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\tfn increment_delegator_rewards() -\u003e Weight {\n\t\tWeight::from_parts(25_796_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(6 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:0)\n\t// Storage: ParachainStaking RewardCount (r:1 w:1)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `m` is `[0, 35]`.\n\tfn increment_collator_rewards(_m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(366_611_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(75 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(72 as u64))\n\t}\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\tfn claim_rewards() -\u003e Weight {\n\t\tWeight::from_parts(29_833_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(2 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking LastRewardReduction (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:3 w:0)\n\t// Storage: ParachainStaking RewardCount (r:72 w:72)\n\t// Storage: ParachainStaking Rewards (r:2 w:2)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:0)\n\t/// The range of component `n` is `[0, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn execute_scheduled_reward_change(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 5_730_000\n\t\t\t.saturating_add(Weight::from_parts(202_623_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 12_280_000\n\t\t\t.saturating_add(Weight::from_parts(415_436_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((37 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((75 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((36 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((75 as u64).saturating_mul(m as u64)))\n\t}\n}\n","traces":[{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":134},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","inflation.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\n//! Helper methods for computing issuance based on inflation\nuse crate::{pallet::Config, types::BalanceOf};\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::{traits::Saturating, Perquintill, RuntimeDebug};\n\n#[cfg(feature = \"std\")]\nuse serde::{Deserialize, Serialize};\n\n#[cfg_attr(feature = \"std\", derive(Serialize, Deserialize))]\n#[derive(Eq, PartialEq, Clone, Encode, Decode, Default, RuntimeDebug, TypeInfo)]\npub struct RewardRate {\n\tpub annual: Perquintill,\n\tpub per_block: Perquintill,\n}\n\nimpl MaxEncodedLen for RewardRate {\n\tfn max_encoded_len() -\u003e usize {\n\t\t// Perquintill is at most u128\n\t\tu128::max_encoded_len().saturating_add(u128::max_encoded_len())\n\t}\n}\n\n/// Convert annual reward rate to per_block.\nfn annual_to_per_block(blocks_per_year: u64, rate: Perquintill) -\u003e Perquintill {\n\trate / blocks_per_year.max(1)\n}\n\nimpl RewardRate {\n\tpub fn new(blocks_per_year: u64, rate: Perquintill) -\u003e Self {\n\t\tRewardRate { annual: rate, per_block: annual_to_per_block(blocks_per_year, rate) }\n\t}\n}\n\n/// Staking info (staking rate and reward rate) for collators and delegators.\n#[cfg_attr(feature = \"std\", derive(Serialize, Deserialize))]\n#[derive(Eq, PartialEq, Clone, Encode, Decode, Default, RuntimeDebug, TypeInfo)]\npub struct StakingInfo {\n\t/// Maximum staking rate.\n\tpub max_rate: Perquintill,\n\t/// Reward rate annually and per_block.\n\tpub reward_rate: RewardRate,\n}\n\nimpl MaxEncodedLen for StakingInfo {\n\tfn max_encoded_len() -\u003e usize {\n\t\t// Perquintill is at most u128\n\t\tRewardRate::max_encoded_len().saturating_add(u128::max_encoded_len())\n\t}\n}\n\nimpl StakingInfo {\n\tpub fn new(\n\t\tblocks_per_year: u64,\n\t\tmax_rate: Perquintill,\n\t\tannual_reward_rate: Perquintill,\n\t) -\u003e Self {\n\t\tStakingInfo { max_rate, reward_rate: RewardRate::new(blocks_per_year, annual_reward_rate) }\n\t}\n\n\t/// Calculate newly minted rewards on coinbase, e.g.,\n\t/// reward = rewards_per_block * staking_rate.\n\t///\n\t/// NOTE: If we exceed the max staking rate, the reward will be reduced by\n\t/// max_rate / current_rate.\n\tpub fn compute_reward\u003cT: Config\u003e(\n\t\t\u0026self,\n\t\tstake: BalanceOf\u003cT\u003e,\n\t\tcurrent_staking_rate: Perquintill,\n\t\tauthors_per_round: BalanceOf\u003cT\u003e,\n\t) -\u003e BalanceOf\u003cT\u003e {\n\t\t// Perquintill automatically bounds to [0, 100]% in case staking_rate is greater\n\t\t// than self.max_rate\n\t\tlet reduction = Perquintill::from_rational(\n\t\t\tself.max_rate.deconstruct(),\n\t\t\tcurrent_staking_rate.deconstruct(),\n\t\t);\n\t\t// multiplication with perbill cannot overflow\n\t\tlet reward = (self.reward_rate.per_block * stake).saturating_mul(authors_per_round);\n\t\treduction * reward\n\t}\n}\n\n#[cfg_attr(feature = \"std\", derive(Serialize, Deserialize))]\n#[derive(Eq, PartialEq, Clone, Encode, Decode, Default, RuntimeDebug, TypeInfo, MaxEncodedLen)]\npub struct InflationInfo {\n\tpub collator: StakingInfo,\n\tpub delegator: StakingInfo,\n}\n\nimpl InflationInfo {\n\t/// Create a new inflation info from the max staking rates and annual reward\n\t/// rates for collators and delegators.\n\t///\n\t/// Example: InflationInfo::new(Perquintill_from_percent(10), ...)\n\tpub fn new(\n\t\tblocks_per_year: u64,\n\t\tcollator_max_rate_percentage: Perquintill,\n\t\tcollator_annual_reward_rate_percentage: Perquintill,\n\t\tdelegator_max_rate_percentage: Perquintill,\n\t\tdelegator_annual_reward_rate_percentage: Perquintill,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tcollator: StakingInfo::new(\n\t\t\t\tblocks_per_year,\n\t\t\t\tcollator_max_rate_percentage,\n\t\t\t\tcollator_annual_reward_rate_percentage,\n\t\t\t),\n\t\t\tdelegator: StakingInfo::new(\n\t\t\t\tblocks_per_year,\n\t\t\t\tdelegator_max_rate_percentage,\n\t\t\t\tdelegator_annual_reward_rate_percentage,\n\t\t\t),\n\t\t}\n\t}\n\n\t/// Check whether the annual reward rate is approx. the per_block reward\n\t/// rate multiplied with the number of blocks per year\n\tpub fn is_valid(\u0026self, blocks_per_year: u64) -\u003e bool {\n\t\tself.collator.reward_rate.annual \u003e=\n\t\t\tPerquintill::from_parts(\n\t\t\t\tself.collator\n\t\t\t\t\t.reward_rate\n\t\t\t\t\t.per_block\n\t\t\t\t\t.deconstruct()\n\t\t\t\t\t.saturating_mul(blocks_per_year),\n\t\t\t) \u0026\u0026 self.delegator.reward_rate.annual \u003e=\n\t\t\tPerquintill::from_parts(\n\t\t\t\tself.delegator\n\t\t\t\t\t.reward_rate\n\t\t\t\t\t.per_block\n\t\t\t\t\t.deconstruct()\n\t\t\t\t\t.saturating_mul(blocks_per_year),\n\t\t\t)\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse sp_runtime::Perbill;\n\n\tuse super::*;\n\tuse crate::mock::{almost_equal, ExtBuilder, Test, DECIMALS, MAX_COLLATOR_STAKE};\n\n\t#[test]\n\tfn perquintill() {\n\t\tassert_eq!(\n\t\t\tPerquintill::from_percent(100) * Perquintill::from_percent(50),\n\t\t\tPerquintill::from_percent(50)\n\t\t);\n\t}\n\n\t#[test]\n\tfn annual_to_block_rate() {\n\t\tlet rate = Perquintill::one();\n\t\tassert!(almost_equal(\n\t\t\trate * 10_000_000_000u128,\n\t\t\tPerquintill::from_parts(\n\t\t\t\tannual_to_per_block(\u003cTest as Config\u003e::BLOCKS_PER_YEAR, rate).deconstruct() *\n\t\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR\n\t\t\t) * 10_000_000_000u128,\n\t\t\tPerbill::from_perthousand(1)\n\t\t));\n\t}\n\n\t#[test]\n\tfn single_block_reward_collator() {\n\t\tlet inflation = InflationInfo::new(\n\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\tPerquintill::from_percent(10),\n\t\t\tPerquintill::from_percent(10),\n\t\t\tPerquintill::from_percent(40),\n\t\t\tPerquintill::from_percent(8),\n\t\t);\n\t\tlet reward = inflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\tMAX_COLLATOR_STAKE,\n\t\t\tPerquintill::from_percent(9),\n\t\t\t2,\n\t\t);\n\t\tlet expected = \u003cTest as Config\u003e::CurrencyBalance::from(15210282150733u64);\n\t\tassert!(\n\t\t\talmost_equal(reward, expected, Perbill::from_perthousand(1)),\n\t\t\t\"left {:?}, right {:?}\",\n\t\t\treward,\n\t\t\texpected\n\t\t);\n\t}\n\n\t#[test]\n\tfn simple_block_reward_check() {\n\t\tlet precision = Perbill::from_perthousand(1);\n\t\tExtBuilder::default()\n\t\t\t.with_inflation(10, 15, 40, 10, 5)\n\t\t\t.with_balances(vec![(1, 10)])\n\t\t\t.with_collators(vec![(1, 10)])\n\t\t\t.build()\n\t\t\t.execute_with(|| {\n\t\t\t\tlet inflation = InflationInfo::new(\n\t\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\t\tPerquintill::from_percent(10),\n\t\t\t\t\tPerquintill::from_percent(15),\n\t\t\t\t\tPerquintill::from_percent(40),\n\t\t\t\t\tPerquintill::from_percent(10),\n\t\t\t\t);\n\t\t\t\tlet years_u128: BalanceOf\u003cTest\u003e = \u003cTest as Config\u003e::BLOCKS_PER_YEAR as u128;\n\n\t\t\t\t// Dummy checks for correct instantiation\n\t\t\t\tassert!(inflation.is_valid(\u003cTest as Config\u003e::BLOCKS_PER_YEAR));\n\t\t\t\tassert_eq!(inflation.collator.max_rate, Perquintill::from_percent(10));\n\t\t\t\tassert_eq!(inflation.collator.reward_rate.annual, Perquintill::from_percent(15));\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.collator.reward_rate.per_block * DECIMALS * 10_000,\n\t\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS / years_u128,\n\t\t\t\t\t\tprecision\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.collator.reward_rate.per_block * 10_000 * DECIMALS,\n\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS / years_u128,\n\t\t\t\t);\n\t\t\t\tassert_eq!(inflation.delegator.max_rate, Perquintill::from_percent(40));\n\t\t\t\tassert_eq!(inflation.delegator.reward_rate.annual, Perquintill::from_percent(10));\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.delegator.reward_rate.per_block * DECIMALS * 10_000,\n\t\t\t\t\t\tPerquintill::from_percent(10) * 10_000 * DECIMALS / years_u128,\n\t\t\t\t\t\tprecision\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.delegator.reward_rate.per_block * DECIMALS * 10_000,\n\t\t\t\t\tPerquintill::from_percent(10) * 10_000 * DECIMALS / years_u128,\n\t\t\t\t);\n\n\t\t\t\t// Check collator reward computation\n\t\t\t\tlet authors_per_round = 1u128;\n\t\t\t\tlet mut current_staking_rate: Perquintill = inflation.collator.max_rate;\n\t\t\t\tassert_eq!(\n\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t),\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(5000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t5000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(15) * 5000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t5000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(15) * 5000 * DECIMALS,\n\t\t\t\t);\n\t\t\t\t// Check for max_rate which is 10%\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(10_000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t10_000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t10_000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS,\n\t\t\t\t);\n\n\t\t\t\t// Check for exceeding max_rate: 50% instead of 10%\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(50_000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t50_000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t50_000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS,\n\t\t\t\t);\n\n\t\t\t\t// Check delegator reward computation\n\t\t\t\tcurrent_staking_rate = inflation.delegator.max_rate;\n\t\t\t\tassert_eq!(\n\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t),\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(5000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t5000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(10) * 5000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t5000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(10) * 5000 * DECIMALS,\n\t\t\t\t);\n\t\t\t\t// Check for max_rate which is 40%\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(40_000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t40_000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(10) * 40_000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t40_000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(10) * 40_000 * DECIMALS,\n\t\t\t\t);\n\n\t\t\t\t// Check for exceeding max_rate: 50% instead of 40%\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(50_000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t50_000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(8) * 50_000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t50_000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(8) * 50_000 * DECIMALS,\n\t\t\t\t);\n\t\t\t});\n\t}\n}\n","traces":[{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","lib.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\n//! # Parachain Staking\n//!\n//! A simple staking pallet providing means of selecting a set of collators to\n//! become block authors based on their total backed stake. The main difference\n//! between this pallet and `frame/pallet-staking` is that this pallet uses\n//! direct delegation. Delegators choose exactly who they delegate and with what\n//! stake. This is different from `frame/pallet-staking` where you approval vote\n//! and then run Phragmen. Moreover, this pallet rewards a collator and their\n//! delegators immediately when authoring a block. Rewards are calculated\n//! separately between collators and delegators.\n//!\n//! To join the set of candidates, an account must call `join_candidates` with\n//! `MinCollatorCandidateStake` \u003c= stake \u003c= `MaxCollatorCandidateStake`.\n//!\n//! To leave the set of candidates, the collator calls `leave_candidates`. If\n//! the call succeeds, the collator is removed from the pool of candidates so\n//! they cannot be selected for future collator sets, but they are not unstaking\n//! until executing the exit request by calling the extrinsic\n//! `execute_leave_candidates` at least `ExitQueueDelay` rounds later. After\n//! doing so, the collator candidate as well as their delegators are unstaked.\n//! Both parties then have to wait another `StakeDuration` more blocks to be\n//! able to unlock their stake.\n//!\n//! Candidates which requested to leave can still be in the set of authors for\n//! the next round due to the design of the session pallet which at the start of\n//! session s(i) chooses a set for the next session s(i+1). Thus, candidates\n//! have to keep collating at least until the end of the next session (= round).\n//! We extend this by delaying their execute by at least `ExitQueueDelay` many\n//! sessions.\n//!\n//! To join the set of delegators, an account must call `join_delegators` with\n//! stake \u003e= `MinDelegatorStake`. There are also runtime methods for delegating\n//! additional collators and revoking delegations.\n//!\n//!\n//! - [`Config`]\n//! - [`Call`]\n//! - [`Pallet`]\n//!\n//! ## Overview\n//!\n//! The KILT parachain staking pallet provides functions for:\n//! - Joining the set of collator candidates of which the best\n//!   `MaxSelectedCandidates` are chosen to become active collators for the next\n//!   session. That makes the set of active collators the set of block authors\n//!   by handing it over to the session and the authority pallet.\n//! - Delegating to a collator candidate by staking for them.\n//! - Increasing and reducing your stake as a collator or delegator.\n//! - Revoking your delegation entirely.\n//! - Requesting to leave the set of collator candidates.\n//! - Withdrawing your unstaked balance after waiting for a certain number of\n//!   blocks.\n//!\n//! ### Terminology\n//!\n//! - **Candidate:** A user which locks up tokens to be included into the set of\n//!   authorities which author blocks and receive rewards for doing so.\n//!\n//! - **Collator:** A candidate that was chosen to collate this round.\n//!\n//! - **Delegator:** A user which locks up tokens for collators they trust. When\n//!   their collator authors a block, the corresponding delegators also receive\n//!   rewards.\n//!\n//! - **Total Stake:** A collator’s own stake + the sum of delegated stake to\n//!   this collator.\n//!\n//! - **Total collator stake:** The sum of tokens locked for staking from all\n//!   collator candidates.\n//!\n//! - **Total delegator stake:** The sum of tokens locked for staking from all\n//!   delegators.\n//!\n//! - **To Stake:** Lock tokens for staking.\n//!\n//! - **To Unstake:** Unlock tokens from staking.\n//!\n//! - **Round (= Session):** A fixed number of blocks in which the set of\n//!   collators does not change. We set the length of a session to the length of\n//!   a staking round, thus both words are interchangeable in the context of\n//!   this pallet.\n//!\n//! - **Lock:** A freeze on a specified amount of an account's free balance\n//!   until a specified block number. Multiple locks always operate over the\n//!   same funds, so they \"overlay\" rather than \"stack\"\n//!\n//! ## Genesis config\n//!\n//! The ParachainStaking pallet depends on the [`GenesisConfig`].\n//!\n//! ## Assumptions\n//!\n//! - At the start of session s(i), the set of session ids for session s(i+1)\n//!   are chosen. These equal the set of selected candidates. Thus, we cannot\n//!   allow collators to leave at least until the start of session s(i+2).\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::unused_unit)]\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub mod benchmarking;\npub mod default_weights;\npub mod runtime_api;\n\n#[cfg(test)]\npub(crate) mod mock;\n#[cfg(test)]\npub(crate) mod tests;\n\n#[cfg(any(feature = \"try-runtime\", test))]\nmod try_state;\n\nmod inflation;\nmod set;\nmod types;\n\nuse frame_support::pallet;\n\npub use crate::{default_weights::WeightInfo, pallet::*};\n\n#[pallet]\npub mod pallet {\n\tuse super::*;\n\tpub use crate::inflation::{InflationInfo, RewardRate, StakingInfo};\n\n\tuse frame_support::{\n\t\tpallet_prelude::*,\n\t\tstorage::bounded_btree_map::BoundedBTreeMap,\n\t\ttraits::{\n\t\t\tCurrency, EstimateNextSessionRotation, Get, Imbalance, LockIdentifier,\n\t\t\tLockableCurrency, OnUnbalanced, ReservableCurrency, StorageVersion, WithdrawReasons,\n\t\t},\n\t\tBoundedVec,\n\t};\n\n\t#[cfg(feature = \"std\")]\n\tuse frame_support::assert_ok;\n\n\tuse frame_system::pallet_prelude::*;\n\tuse pallet_balances::{BalanceLock, Locks};\n\tuse pallet_session::ShouldEndSession;\n\tuse scale_info::TypeInfo;\n\tuse sp_runtime::{\n\t\ttraits::{Convert, One, SaturatedConversion, Saturating, StaticLookup, Zero},\n\t\tPermill, Perquintill,\n\t};\n\tuse sp_staking::SessionIndex;\n\tuse sp_std::prelude::*;\n\n\tuse crate::{\n\t\tset::OrderedSet,\n\t\ttypes::{\n\t\t\tBalanceOf, Candidate, CandidateOf, CandidateStatus, DelegationCounter, Delegator,\n\t\t\tNegativeImbalanceOf, RoundInfo, Stake, StakeOf, TotalStake,\n\t\t},\n\t};\n\tuse sp_std::{convert::TryInto, fmt::Debug};\n\n\t/// Kilt-specific lock for staking rewards.\n\tpub(crate) const STAKING_ID: LockIdentifier = *b\"kiltpstk\";\n\n\t/// The current storage version.\n\tconst STORAGE_VERSION: StorageVersion = StorageVersion::new(7);\n\n\t/// Pallet for parachain staking.\n\t#[pallet::pallet]\n\t#[pallet::storage_version(STORAGE_VERSION)]\n\tpub struct Pallet\u003cT\u003e(PhantomData\u003cT\u003e);\n\n\t/// Configuration trait of this pallet.\n\t#[pallet::config]\n\tpub trait Config:\n\t\tframe_system::Config + pallet_balances::Config + pallet_session::Config\n\t{\n\t\t/// Overarching event type\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\t\t// FIXME: Remove Currency and CurrencyBalance types. Problem: Need to restrict\n\t\t// pallet_balances::Config::Balance with From\u003cu64\u003e for usage with Perquintill\n\t\t// multiplication\n\t\t/// The currency type\n\t\t/// Note: Declaration of Balance taken from pallet_gilt\n\t\ttype Currency: Currency\u003cSelf::AccountId, Balance = Self::CurrencyBalance\u003e\n\t\t\t+ ReservableCurrency\u003cSelf::AccountId, Balance = Self::CurrencyBalance\u003e\n\t\t\t+ LockableCurrency\u003cSelf::AccountId, Balance = Self::CurrencyBalance\u003e\n\t\t\t+ Eq;\n\n\t\t/// Just the `Currency::Balance` type; we have this item to allow us to\n\t\t/// constrain it to `From\u003cu64\u003e`.\n\t\t/// Note: Definition taken from pallet_gilt\n\t\ttype CurrencyBalance: sp_runtime::traits::AtLeast32BitUnsigned\n\t\t\t+ parity_scale_codec::FullCodec\n\t\t\t+ Copy\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ sp_std::fmt::Debug\n\t\t\t+ Default\n\t\t\t+ From\u003cu64\u003e\n\t\t\t+ From\u003cu128\u003e\n\t\t\t+ Into\u003c\u003cSelf as pallet_balances::Config\u003e::Balance\u003e\n\t\t\t+ From\u003c\u003cSelf as pallet_balances::Config\u003e::Balance\u003e\n\t\t\t+ TypeInfo\n\t\t\t+ MaxEncodedLen;\n\n\t\t/// Minimum number of blocks validation rounds can last.\n\t\t#[pallet::constant]\n\t\ttype MinBlocksPerRound: Get\u003cSelf::BlockNumber\u003e;\n\n\t\t/// Default number of blocks validation rounds last, as set in the\n\t\t/// genesis configuration.\n\t\t#[pallet::constant]\n\t\ttype DefaultBlocksPerRound: Get\u003cSelf::BlockNumber\u003e;\n\t\t/// Number of blocks for which unstaked balance will still be locked\n\t\t/// before it can be unlocked by actively calling the extrinsic\n\t\t/// `unlock_unstaked`.\n\t\t#[pallet::constant]\n\t\ttype StakeDuration: Get\u003cSelf::BlockNumber\u003e;\n\t\t/// Number of rounds a collator has to stay active after submitting a\n\t\t/// request to leave the set of collator candidates.\n\t\t#[pallet::constant]\n\t\ttype ExitQueueDelay: Get\u003cu32\u003e;\n\n\t\t/// Minimum number of collators selected from the set of candidates at\n\t\t/// every validation round.\n\t\t#[pallet::constant]\n\t\ttype MinCollators: Get\u003cu32\u003e;\n\n\t\t/// Minimum number of collators which cannot leave the network if there\n\t\t/// are no others.\n\t\t#[pallet::constant]\n\t\ttype MinRequiredCollators: Get\u003cu32\u003e;\n\n\t\t/// Maximum number of delegations which can be made within the same\n\t\t/// round.\n\t\t///\n\t\t/// NOTE: To prevent re-delegation-reward attacks, we should keep this\n\t\t/// to be one.\n\t\t#[pallet::constant]\n\t\ttype MaxDelegationsPerRound: Get\u003cu32\u003e;\n\n\t\t/// Maximum number of delegators a single collator can have.\n\t\t#[pallet::constant]\n\t\ttype MaxDelegatorsPerCollator: Get\u003cu32\u003e + Debug + PartialEq;\n\n\t\t/// Maximum size of the top candidates set.\n\t\t#[pallet::constant]\n\t\ttype MaxTopCandidates: Get\u003cu32\u003e + Debug + PartialEq;\n\n\t\t/// Minimum stake required for any account to be elected as validator\n\t\t/// for a round.\n\t\t#[pallet::constant]\n\t\ttype MinCollatorStake: Get\u003cBalanceOf\u003cSelf\u003e\u003e;\n\n\t\t/// Minimum stake required for any account to be added to the set of\n\t\t/// candidates.\n\t\t#[pallet::constant]\n\t\ttype MinCollatorCandidateStake: Get\u003cBalanceOf\u003cSelf\u003e\u003e;\n\n\t\t/// Minimum stake required for any account to become a delegator.\n\t\t#[pallet::constant]\n\t\ttype MinDelegatorStake: Get\u003cBalanceOf\u003cSelf\u003e\u003e;\n\n\t\t/// The annual decay rate of the collator rewards\n\t\t#[pallet::constant]\n\t\ttype CollatorRewardRateDecay: Get\u003cPerquintill\u003e;\n\n\t\t/// Max number of concurrent active unstaking requests before\n\t\t/// unlocking.\n\t\t///\n\t\t/// NOTE: To protect against irremovability of a candidate or delegator,\n\t\t/// we only allow for MaxUnstakeRequests - 1 many manual unstake\n\t\t/// requests. The last one serves as a placeholder for the cases of\n\t\t/// calling either `kick_delegator`, force_remove_candidate` or\n\t\t/// `execute_leave_candidates`. Otherwise, a user could max out their\n\t\t/// unstake requests and prevent themselves from being kicked from the\n\t\t/// set of candidates/delegators until they unlock their funds.\n\t\t#[pallet::constant]\n\t\ttype MaxUnstakeRequests: Get\u003cu32\u003e;\n\n\t\t/// The starting block number for the network rewards. Once the current\n\t\t/// block number exceeds this start, the beneficiary will receive the\n\t\t/// configured reward in each block.\n\t\t#[pallet::constant]\n\t\ttype NetworkRewardStart: Get\u003c\u003cSelf as frame_system::Config\u003e::BlockNumber\u003e;\n\n\t\t/// The rate in percent for the network rewards which are based on the\n\t\t/// maximum number of collators and the maximum amount a collator can\n\t\t/// stake.\n\t\t#[pallet::constant]\n\t\ttype NetworkRewardRate: Get\u003cPerquintill\u003e;\n\n\t\t/// The beneficiary to receive the network rewards.\n\t\ttype NetworkRewardBeneficiary: OnUnbalanced\u003cNegativeImbalanceOf\u003cSelf\u003e\u003e;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\tconst BLOCKS_PER_YEAR: Self::BlockNumber;\n\t}\n\n\t#[pallet::error]\n\tpub enum Error\u003cT\u003e {\n\t\t/// The account is not part of the delegators set.\n\t\tDelegatorNotFound,\n\t\t/// The account is not part of the collator candidates set.\n\t\tCandidateNotFound,\n\t\t/// The account is already part of the delegators set.\n\t\tDelegatorExists,\n\t\t/// The account is already part of the collator candidates set.\n\t\tCandidateExists,\n\t\t/// The account tried to stake more or less with amount zero.\n\t\tValStakeZero,\n\t\t/// The account has not staked enough funds to be added to the collator\n\t\t/// candidates set.\n\t\tValStakeBelowMin,\n\t\t/// The account has already staked the maximum amount of funds possible.\n\t\tValStakeAboveMax,\n\t\t/// The account has not staked enough funds to delegate a collator\n\t\t/// candidate.\n\t\tDelegationBelowMin,\n\t\t/// The collator candidate has already trigger the process to leave the\n\t\t/// set of collator candidates.\n\t\tAlreadyLeaving,\n\t\t/// The collator candidate wanted to execute the exit but has not\n\t\t/// requested to leave before by calling `init_leave_candidates`.\n\t\tNotLeaving,\n\t\t/// The collator tried to leave before waiting at least for\n\t\t/// `ExitQueueDelay` many rounds.\n\t\tCannotLeaveYet,\n\t\t/// The account has a full list of unstaking requests and needs to\n\t\t/// unlock at least one of these before being able to join (again).\n\t\t/// NOTE: Can only happen if the account was a candidate or\n\t\t/// delegator before and either got kicked or exited voluntarily.\n\t\tCannotJoinBeforeUnlocking,\n\t\t/// The account is already delegating the collator candidate.\n\t\tAlreadyDelegating,\n\t\t/// The account has not delegated any collator candidate yet, hence it\n\t\t/// is not in the set of delegators.\n\t\tNotYetDelegating,\n\t\t/// The delegator has exceeded the number of delegations per round which\n\t\t/// is equal to MaxDelegatorsPerCollator.\n\t\t///\n\t\t/// This protects against attacks in which a delegator can re-delegate\n\t\t/// from a collator who has already authored a block, to another one\n\t\t/// which has not in this round.\n\t\tDelegationsPerRoundExceeded,\n\t\t/// The collator candidate has already reached the maximum number of\n\t\t/// delegators.\n\t\t///\n\t\t/// This error is generated in case a new delegation request does not\n\t\t/// stake enough funds to replace some other existing delegation.\n\t\tTooManyDelegators,\n\t\t/// The set of collator candidates would fall below the required minimum\n\t\t/// if the collator left.\n\t\tTooFewCollatorCandidates,\n\t\t/// The collator candidate is in the process of leaving the set of\n\t\t/// candidates and cannot perform any other actions in the meantime.\n\t\tCannotStakeIfLeaving,\n\t\t/// The collator candidate is in the process of leaving the set of\n\t\t/// candidates and thus cannot be delegated to.\n\t\tCannotDelegateIfLeaving,\n\t\t/// The delegator has already delegated the maximum number of candidates\n\t\t/// allowed.\n\t\tMaxCollatorsPerDelegatorExceeded,\n\t\t/// The delegator has already previously delegated the collator\n\t\t/// candidate.\n\t\tAlreadyDelegatedCollator,\n\t\t/// The given delegation does not exist in the set of delegations.\n\t\tDelegationNotFound,\n\t\t/// The collator delegate or the delegator is trying to un-stake more\n\t\t/// funds that are currently staked.\n\t\tUnderflow,\n\t\t/// The number of selected candidates per staking round is\n\t\t/// above the maximum value allowed.\n\t\tCannotSetAboveMax,\n\t\t/// The number of selected candidates per staking round is\n\t\t/// below the minimum value allowed.\n\t\tCannotSetBelowMin,\n\t\t/// An invalid inflation configuration is trying to be set.\n\t\tInvalidSchedule,\n\t\t/// The staking reward being unlocked does not exist.\n\t\t/// Max unlocking requests reached.\n\t\tNoMoreUnstaking,\n\t\t/// The reward rate cannot be adjusted yet as an entire year has not\n\t\t/// passed.\n\t\tTooEarly,\n\t\t/// Provided staked value is zero. Should never be thrown.\n\t\tStakeNotFound,\n\t\t/// Cannot unlock when Unstaked is empty.\n\t\tUnstakingIsEmpty,\n\t\t/// Cannot claim rewards if empty.\n\t\tRewardsNotFound,\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\t/// A new staking round has started.\n\t\t/// \\[block number, round number\\]\n\t\tNewRound(T::BlockNumber, SessionIndex),\n\t\t/// A new account has joined the set of top candidates.\n\t\t/// \\[account\\]\n\t\tEnteredTopCandidates(T::AccountId),\n\t\t/// An account was removed from the set of top candidates.\n\t\t/// \\[account\\]\n\t\tLeftTopCandidates(T::AccountId),\n\t\t/// A new account has joined the set of collator candidates.\n\t\t/// \\[account, amount staked by the new candidate\\]\n\t\tJoinedCollatorCandidates(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// A collator candidate has increased the amount of funds at stake.\n\t\t/// \\[collator's account, previous stake, new stake\\]\n\t\tCollatorStakedMore(T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// A collator candidate has decreased the amount of funds at stake.\n\t\t/// \\[collator's account, previous stake, new stake\\]\n\t\tCollatorStakedLess(T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// A collator candidate has started the process to leave the set of\n\t\t/// candidates. \\[round number, collator's account, round number when\n\t\t/// the collator will be effectively removed from the set of\n\t\t/// candidates\\]\n\t\tCollatorScheduledExit(SessionIndex, T::AccountId, SessionIndex),\n\t\t/// A collator candidate has canceled the process to leave the set of\n\t\t/// candidates and was added back to the candidate pool. \\[collator's\n\t\t/// account\\]\n\t\tCollatorCanceledExit(T::AccountId),\n\t\t/// An account has left the set of collator candidates.\n\t\t/// \\[account, amount of funds un-staked\\]\n\t\tCandidateLeft(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// An account was forcedly removed from the  set of collator\n\t\t/// candidates. \\[account, amount of funds un-staked\\]\n\t\tCollatorRemoved(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// The maximum candidate stake has been changed.\n\t\t/// \\[new max amount\\]\n\t\tMaxCandidateStakeChanged(BalanceOf\u003cT\u003e),\n\t\t/// A delegator has increased the amount of funds at stake for a\n\t\t/// collator. \\[delegator's account, collator's account, previous\n\t\t/// delegation stake, new delegation stake\\]\n\t\tDelegatorStakedMore(T::AccountId, T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// A delegator has decreased the amount of funds at stake for a\n\t\t/// collator. \\[delegator's account, collator's account, previous\n\t\t/// delegation stake, new delegation stake\\]\n\t\tDelegatorStakedLess(T::AccountId, T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// An account has left the set of delegators.\n\t\t/// \\[account, amount of funds un-staked\\]\n\t\tDelegatorLeft(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// An account has delegated a new collator candidate.\n\t\t/// \\[account, amount of funds staked, total amount of delegators' funds\n\t\t/// staked for the collator candidate\\]\n\t\tDelegation(T::AccountId, BalanceOf\u003cT\u003e, T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// A new delegation has replaced an existing one in the set of ongoing\n\t\t/// delegations for a collator candidate. \\[new delegator's account,\n\t\t/// amount of funds staked in the new delegation, replaced delegator's\n\t\t/// account, amount of funds staked in the replace delegation, collator\n\t\t/// candidate's account, new total amount of delegators' funds staked\n\t\t/// for the collator candidate\\]\n\t\tDelegationReplaced(\n\t\t\tT::AccountId,\n\t\t\tBalanceOf\u003cT\u003e,\n\t\t\tT::AccountId,\n\t\t\tBalanceOf\u003cT\u003e,\n\t\t\tT::AccountId,\n\t\t\tBalanceOf\u003cT\u003e,\n\t\t),\n\t\t/// An account has stopped delegating a collator candidate.\n\t\t/// \\[account, collator candidate's account, old amount of delegators'\n\t\t/// funds staked, new amount of delegators' funds staked\\]\n\t\tDelegatorLeftCollator(T::AccountId, T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// A collator or a delegator has received a reward.\n\t\t/// \\[account, amount of reward\\]\n\t\tRewarded(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// Inflation configuration for future validation rounds has changed.\n\t\t/// \\[maximum collator's staking rate, maximum collator's reward rate,\n\t\t/// maximum delegator's staking rate, maximum delegator's reward rate\\]\n\t\tRoundInflationSet(Perquintill, Perquintill, Perquintill, Perquintill),\n\t\t/// The maximum number of collator candidates selected in future\n\t\t/// validation rounds has changed. \\[old value, new value\\]\n\t\tMaxSelectedCandidatesSet(u32, u32),\n\t\t/// The length in blocks for future validation rounds has changed.\n\t\t/// \\[round number, first block in the current round, old value, new\n\t\t/// value\\]\n\t\tBlocksPerRoundSet(SessionIndex, T::BlockNumber, T::BlockNumber, T::BlockNumber),\n\t}\n\n\t#[pallet::hooks]\n\timpl\u003cT: Config\u003e Hooks\u003cBlockNumberFor\u003cT\u003e\u003e for Pallet\u003cT\u003e {\n\t\tfn on_initialize(now: T::BlockNumber) -\u003e frame_support::weights::Weight {\n\t\t\tlet mut post_weight = \u003cT as Config\u003e::WeightInfo::on_initialize_no_action();\n\t\t\tlet mut round = \u003cRound\u003cT\u003e\u003e::get();\n\n\t\t\t// check for round update\n\t\t\tif round.should_update(now) {\n\t\t\t\t// mutate round\n\t\t\t\tround.update(now);\n\t\t\t\t// start next round\n\t\t\t\t\u003cRound\u003cT\u003e\u003e::put(round);\n\n\t\t\t\tSelf::deposit_event(Event::NewRound(round.first, round.current));\n\t\t\t\tpost_weight = \u003cT as Config\u003e::WeightInfo::on_initialize_round_update();\n\t\t\t}\n\t\t\t// check for network reward and mint\n\t\t\t// on success, mint each block\n\t\t\tif now \u003e T::NetworkRewardStart::get() {\n\t\t\t\tT::NetworkRewardBeneficiary::on_unbalanced(Self::issue_network_reward());\n\t\t\t\tpost_weight = post_weight\n\t\t\t\t\t.saturating_add(\u003cT as Config\u003e::WeightInfo::on_initialize_network_rewards());\n\t\t\t}\n\t\t\tpost_weight\n\t\t}\n\t}\n\n\t/// The maximum number of collator candidates selected at each round.\n\t#[pallet::storage]\n\t#[pallet::getter(fn max_selected_candidates)]\n\tpub(crate) type MaxSelectedCandidates\u003cT: Config\u003e = StorageValue\u003c_, u32, ValueQuery\u003e;\n\n\t/// Current round number and next round scheduled transition.\n\t#[pallet::storage]\n\t#[pallet::getter(fn round)]\n\tpub(crate) type Round\u003cT: Config\u003e = StorageValue\u003c_, RoundInfo\u003cT::BlockNumber\u003e, ValueQuery\u003e;\n\n\t/// Delegation information for the latest session in which a delegator\n\t/// delegated.\n\t///\n\t/// It maps from an account to the number of delegations in the last\n\t/// session in which they (re-)delegated.\n\t#[pallet::storage]\n\t#[pallet::getter(fn last_delegation)]\n\tpub(crate) type LastDelegation\u003cT: Config\u003e =\n\t\tStorageMap\u003c_, Twox64Concat, T::AccountId, DelegationCounter, ValueQuery\u003e;\n\n\t/// Delegation staking information.\n\t///\n\t/// It maps from an account to its delegation details.\n\t#[pallet::storage]\n\t#[pallet::getter(fn delegator_state)]\n\tpub(crate) type DelegatorState\u003cT: Config\u003e = StorageMap\u003c\n\t\t_,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\tDelegator\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e,\n\t\tOptionQuery,\n\t\u003e;\n\n\t/// The staking information for a candidate.\n\t///\n\t/// It maps from an account to its information.\n\t/// Moreover, it counts the number of candidates.\n\t#[pallet::storage]\n\t#[pallet::getter(fn candidate_pool)]\n\tpub(crate) type CandidatePool\u003cT: Config\u003e = CountedStorageMap\u003c\n\t\t_,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\tCandidate\u003cT::AccountId, BalanceOf\u003cT\u003e, T::MaxDelegatorsPerCollator\u003e,\n\t\tOptionQuery,\n\t\u003e;\n\n\t/// Total funds locked to back the currently selected collators.\n\t/// The sum of all collator and their delegator stakes.\n\t///\n\t/// Note: There are more funds locked by this pallet, since the backing for\n\t/// non collating candidates is not included in [TotalCollatorStake].\n\t#[pallet::storage]\n\t#[pallet::getter(fn total_collator_stake)]\n\tpub(crate) type TotalCollatorStake\u003cT: Config\u003e =\n\t\tStorageValue\u003c_, TotalStake\u003cBalanceOf\u003cT\u003e\u003e, ValueQuery\u003e;\n\n\t/// The collator candidates with the highest amount of stake.\n\t///\n\t/// Each time the stake of a collator is increased, it is checked whether\n\t/// this pushes another candidate out of the list. When the stake is\n\t/// reduced however, it is not checked if another candidate has more stake,\n\t/// since this would require iterating over the entire [CandidatePool].\n\t///\n\t/// There must always be more candidates than [MaxSelectedCandidates] so\n\t/// that a collator can drop out of the collator set by reducing their\n\t/// stake.\n\t#[pallet::storage]\n\t#[pallet::getter(fn top_candidates)]\n\tpub(crate) type TopCandidates\u003cT: Config\u003e = StorageValue\u003c\n\t\t_,\n\t\tOrderedSet\u003cStake\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e, T::MaxTopCandidates\u003e,\n\t\tValueQuery,\n\t\u003e;\n\n\t/// Inflation configuration.\n\t#[pallet::storage]\n\t#[pallet::getter(fn inflation_config)]\n\tpub(crate) type InflationConfig\u003cT: Config\u003e = StorageValue\u003c_, InflationInfo, ValueQuery\u003e;\n\n\t/// The funds waiting to be unstaked.\n\t///\n\t/// It maps from accounts to all the funds addressed to them in the future\n\t/// blocks.\n\t#[pallet::storage]\n\t#[pallet::getter(fn unstaking)]\n\tpub(crate) type Unstaking\u003cT: Config\u003e = StorageMap\u003c\n\t\t_,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\tBoundedBTreeMap\u003cT::BlockNumber, BalanceOf\u003cT\u003e, T::MaxUnstakeRequests\u003e,\n\t\tValueQuery,\n\t\u003e;\n\n\t/// The maximum amount a collator candidate can stake.\n\t#[pallet::storage]\n\t#[pallet::getter(fn max_candidate_stake)]\n\tpub(crate) type MaxCollatorCandidateStake\u003cT: Config\u003e =\n\t\tStorageValue\u003c_, BalanceOf\u003cT\u003e, ValueQuery\u003e;\n\n\t/// The year in which the last automatic reduction of the reward rates\n\t/// occurred.\n\t///\n\t/// It starts at zero at genesis and increments by one every BLOCKS_PER_YEAR\n\t/// many blocks.\n\t#[pallet::storage]\n\t#[pallet::getter(fn last_reward_reduction)]\n\tpub(crate) type LastRewardReduction\u003cT: Config\u003e = StorageValue\u003c_, T::BlockNumber, ValueQuery\u003e;\n\n\t/// The counter of accumulated rewards for an account.\n\t///\n\t/// For collators, it reflects the number of authored blocks since the last\n\t/// reward raise. Thus, everytime a collator authors a block, the\n\t/// counter is increased. It is reset, when the collator increments their\n\t/// rewards.\n\t///\n\t/// For delegators, it is used to determine the difference between the\n\t/// delegator and corresponding collator when incrementing the delegator's\n\t/// rewards. In this case, the counter is never incremented but reset to the\n\t/// collator one when the delegator reward increment happens.\n\t// TODO: Maybe rather use u64. Assuming 30 validators, u32 would suffice for 27 years of constant 12s blocktime.\n\t#[pallet::storage]\n\t#[pallet::getter(fn reward_count)]\n\tpub(crate) type RewardCount\u003cT: Config\u003e =\n\t\tStorageMap\u003c_, Twox64Concat, T::AccountId, u32, ValueQuery\u003e;\n\n\t/// The accumulated rewards for collator candidates and delegators.\n\t///\n\t/// It maps from accounts to their total rewards since the last payout.\n\t#[pallet::storage]\n\t#[pallet::getter(fn rewards)]\n\tpub(crate) type Rewards\u003cT: Config\u003e =\n\t\tStorageMap\u003c_, Twox64Concat, T::AccountId, BalanceOf\u003cT\u003e, ValueQuery\u003e;\n\n\tpub type GenesisStaker\u003cT\u003e = Vec\u003c(\n\t\t\u003cT as frame_system::Config\u003e::AccountId,\n\t\tOption\u003c\u003cT as frame_system::Config\u003e::AccountId\u003e,\n\t\tBalanceOf\u003cT\u003e,\n\t)\u003e;\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn new_round_forced)]\n\tpub(crate) type ForceNewRound\u003cT: Config\u003e = StorageValue\u003c_, bool, ValueQuery\u003e;\n\n\t#[pallet::genesis_config]\n\tpub struct GenesisConfig\u003cT: Config\u003e {\n\t\tpub stakers: GenesisStaker\u003cT\u003e,\n\t\tpub inflation_config: InflationInfo,\n\t\tpub max_candidate_stake: BalanceOf\u003cT\u003e,\n\t\tpub max_selected_candidates: u32,\n\t}\n\n\t#[cfg(feature = \"std\")]\n\timpl\u003cT: Config\u003e Default for GenesisConfig\u003cT\u003e {\n\t\tfn default() -\u003e Self {\n\t\t\tSelf {\n\t\t\t\tstakers: Default::default(),\n\t\t\t\tinflation_config: Default::default(),\n\t\t\t\tmax_candidate_stake: Default::default(),\n\t\t\t\tmax_selected_candidates: Default::default(),\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::genesis_build]\n\timpl\u003cT: Config\u003e GenesisBuild\u003cT\u003e for GenesisConfig\u003cT\u003e {\n\t\tfn build(\u0026self) {\n\t\t\tassert!(\n\t\t\t\tself.inflation_config.is_valid(T::BLOCKS_PER_YEAR.saturated_into()),\n\t\t\t\t\"Invalid inflation configuration\"\n\t\t\t);\n\n\t\t\tInflationConfig::\u003cT\u003e::put(self.inflation_config.clone());\n\t\t\tMaxCollatorCandidateStake::\u003cT\u003e::put(self.max_candidate_stake);\n\n\t\t\t// Setup delegate \u0026 collators\n\t\t\tfor \u0026(ref actor, ref opt_val, balance) in \u0026self.stakers {\n\t\t\t\tassert!(\n\t\t\t\t\tT::Currency::free_balance(actor) \u003e= balance,\n\t\t\t\t\t\"Account does not have enough balance to stake.\"\n\t\t\t\t);\n\t\t\t\tif let Some(delegated_val) = opt_val {\n\t\t\t\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_delegators(\n\t\t\t\t\t\tT::RuntimeOrigin::from(Some(actor.clone()).into()),\n\t\t\t\t\t\tT::Lookup::unlookup(delegated_val.clone()),\n\t\t\t\t\t\tbalance,\n\t\t\t\t\t));\n\t\t\t\t} else {\n\t\t\t\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_candidates(\n\t\t\t\t\t\tT::RuntimeOrigin::from(Some(actor.clone()).into()),\n\t\t\t\t\t\tbalance\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Set total selected candidates to minimum config\n\t\t\tMaxSelectedCandidates::\u003cT\u003e::put(\n\t\t\t\tself.max_selected_candidates.max(T::MinCollators::get()),\n\t\t\t);\n\n\t\t\t\u003cPallet\u003cT\u003e\u003e::update_total_stake();\n\n\t\t\t// Start Round 0 at Block 0\n\t\t\tlet round: RoundInfo\u003cT::BlockNumber\u003e =\n\t\t\t\tRoundInfo::new(0u32, 0u32.into(), T::DefaultBlocksPerRound::get());\n\t\t\t\u003cRound\u003cT\u003e\u003e::put(round);\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Forces the start of the new round in the next block.\n\t\t///\n\t\t/// The new round will be enforced via \u003cT as\n\t\t/// ShouldEndSession\u003c_\u003e\u003e::should_end_session.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::force_new_round())]\n\t\tpub fn force_new_round(origin: OriginFor\u003cT\u003e) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\n\t\t\t// set force_new_round handle which, at the start of the next block, will\n\t\t\t// trigger `should_end_session` in `Session::on_initialize` and update the\n\t\t\t// current round\n\t\t\t\u003cForceNewRound\u003cT\u003e\u003e::put(true);\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Set the annual inflation rate to derive per-round inflation.\n\t\t///\n\t\t/// The inflation details are considered valid if the annual reward rate\n\t\t/// is approximately the per-block reward rate multiplied by the\n\t\t/// estimated* total number of blocks per year.\n\t\t///\n\t\t/// The estimated average block time is twelve seconds.\n\t\t///\n\t\t/// NOTE: Iterates over CandidatePool for each candidate over their\n\t\t/// delegators to set rewards. Needs to be improved when scaling up\n\t\t/// `MaxTopCandidates`.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t///\n\t\t/// Emits `RoundInflationSet`.\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::set_inflation(T::MaxTopCandidates::get(), T::MaxDelegatorsPerCollator::get()))]\n\t\tpub fn set_inflation(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcollator_max_rate_percentage: Perquintill,\n\t\t\tcollator_annual_reward_rate_percentage: Perquintill,\n\t\t\tdelegator_max_rate_percentage: Perquintill,\n\t\t\tdelegator_annual_reward_rate_percentage: Perquintill,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_root(origin)?;\n\n\t\t\tlet inflation = InflationInfo::new(\n\t\t\t\tT::BLOCKS_PER_YEAR.saturated_into(),\n\t\t\t\tcollator_max_rate_percentage,\n\t\t\t\tcollator_annual_reward_rate_percentage,\n\t\t\t\tdelegator_max_rate_percentage,\n\t\t\t\tdelegator_annual_reward_rate_percentage,\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tinflation.is_valid(T::BLOCKS_PER_YEAR.saturated_into()),\n\t\t\t\tError::\u003cT\u003e::InvalidSchedule\n\t\t\t);\n\n\t\t\t// set rewards for all collators and delegators due\n\t\t\tlet mut num_delegators = 0;\n\t\t\tCandidatePool::\u003cT\u003e::iter().for_each(|(id, state)| {\n\t\t\t\tnum_delegators = num_delegators.max(Self::do_inc_collator_reward(\u0026id, state.stake));\n\t\t\t});\n\n\t\t\tSelf::deposit_event(Event::RoundInflationSet(\n\t\t\t\tinflation.collator.max_rate,\n\t\t\t\tinflation.collator.reward_rate.per_block,\n\t\t\t\tinflation.delegator.max_rate,\n\t\t\t\tinflation.delegator.reward_rate.per_block,\n\t\t\t));\n\t\t\tInflationConfig::\u003cT\u003e::put(inflation);\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::set_inflation(\n\t\t\t\tCandidatePool::\u003cT\u003e::count(),\n\t\t\t\tnum_delegators.saturated_into(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Set the maximum number of collator candidates that can be selected\n\t\t/// at the beginning of each validation round.\n\t\t///\n\t\t/// Changes are not applied until the start of the next round.\n\t\t///\n\t\t/// The new value must be higher than the minimum allowed as set in the\n\t\t/// pallet's configuration.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t///\n\t\t/// Emits `MaxSelectedCandidatesSet`.\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::set_max_selected_candidates(\n\t\t\t*new,\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn set_max_selected_candidates(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tnew: u32,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_root(origin)?;\n\t\t\tensure!(new \u003e= T::MinCollators::get(), Error::\u003cT\u003e::CannotSetBelowMin);\n\t\t\tensure!(new \u003c= T::MaxTopCandidates::get(), Error::\u003cT\u003e::CannotSetAboveMax);\n\t\t\tlet old = MaxSelectedCandidates::\u003cT\u003e::get();\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tMaxSelectedCandidates::\u003cT\u003e::put(new);\n\n\t\t\t// Update total amount at stake for new top collators and their delegators\n\t\t\tlet start = old.min(new);\n\t\t\tlet end = old.max(new);\n\n\t\t\t// The slice [start, end] contains the added or removed collators. We sum up\n\t\t\t// their stake to adjust the total stake.\n\t\t\tlet (diff_collation, diff_delegation, num_delegators) = TopCandidates::\u003cT\u003e::get()\n\t\t\t\t.into_iter()\n\t\t\t\t.skip(start.saturated_into())\n\t\t\t\t// SAFETY: we ensured that end \u003e start further above.\n\t\t\t\t.take((end - start).saturated_into())\n\t\t\t\t.filter_map(|candidate| CandidatePool::\u003cT\u003e::get(\u0026candidate.owner))\n\t\t\t\t.map(|state| {\n\t\t\t\t\t(\n\t\t\t\t\t\tstate.stake,\n\t\t\t\t\t\t// SAFETY: the total is always more than the stake\n\t\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t\t\tstate.delegators.len().saturated_into::\u003cu32\u003e(),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.reduce(|a, b| (a.0.saturating_add(b.0), a.1.saturating_add(b.1), a.2.max(b.2)))\n\t\t\t\t.unwrap_or((BalanceOf::\u003cT\u003e::zero(), BalanceOf::\u003cT\u003e::zero(), 0u32));\n\n\t\t\tTotalCollatorStake::\u003cT\u003e::mutate(|total| {\n\t\t\t\tif new \u003e old {\n\t\t\t\t\ttotal.collators = total.collators.saturating_add(diff_collation);\n\t\t\t\t\ttotal.delegators = total.delegators.saturating_add(diff_delegation);\n\t\t\t\t} else {\n\t\t\t\t\ttotal.collators = total.collators.saturating_sub(diff_collation);\n\t\t\t\t\ttotal.delegators = total.delegators.saturating_sub(diff_delegation);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tSelf::deposit_event(Event::MaxSelectedCandidatesSet(old, new));\n\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::set_max_selected_candidates(\n\t\t\t\t// SAFETY: we ensured that end \u003e start further above.\n\t\t\t\tend - start,\n\t\t\t\tnum_delegators,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Set the number of blocks each validation round lasts.\n\t\t///\n\t\t/// If the new value is less than the length of the current round, the\n\t\t/// system will immediately move to the next round in the next block.\n\t\t///\n\t\t/// The new value must be higher than the minimum allowed as set in the\n\t\t/// pallet's configuration.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t///\n\t\t/// Emits `BlocksPerRoundSet`.\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::set_blocks_per_round())]\n\t\tpub fn set_blocks_per_round(origin: OriginFor\u003cT\u003e, new: T::BlockNumber) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\t\t\tensure!(new \u003e= T::MinBlocksPerRound::get(), Error::\u003cT\u003e::CannotSetBelowMin);\n\n\t\t\tlet old_round = \u003cRound\u003cT\u003e\u003e::get();\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\t\u003cRound\u003cT\u003e\u003e::put(RoundInfo { length: new, ..old_round });\n\n\t\t\tSelf::deposit_event(Event::BlocksPerRoundSet(\n\t\t\t\told_round.current,\n\t\t\t\told_round.first,\n\t\t\t\told_round.length,\n\t\t\t\tnew,\n\t\t\t));\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Set the maximal amount a collator can stake. Existing stakes are not\n\t\t/// changed.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t///\n\t\t/// Emits `MaxCandidateStakeChanged`.\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::set_max_candidate_stake())]\n\t\tpub fn set_max_candidate_stake(origin: OriginFor\u003cT\u003e, new: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\t\t\tensure!(new \u003e= T::MinCollatorCandidateStake::get(), Error::\u003cT\u003e::CannotSetBelowMin);\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tMaxCollatorCandidateStake::\u003cT\u003e::put(new);\n\n\t\t\tSelf::deposit_event(Event::MaxCandidateStakeChanged(new));\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Forcedly removes a collator candidate from the TopCandidates and\n\t\t/// clears all associated storage for the candidate and their\n\t\t/// delegators.\n\t\t///\n\t\t/// Prepares unstaking of the candidates and their delegators stake\n\t\t/// which can be unlocked via `unlock_unstaked` after waiting at\n\t\t/// least `StakeDuration` many blocks. Also increments rewards for the\n\t\t/// collator and their delegators.\n\t\t///\n\t\t/// Increments rewards of candidate and their delegators.\n\t\t///\n\t\t/// Emits `CandidateRemoved`.\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::force_remove_candidate(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn force_remove_candidate(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcollator: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_root(origin)?;\n\t\t\tlet collator = T::Lookup::lookup(collator)?;\n\t\t\tlet state = CandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tlet total_amount = state.total;\n\n\t\t\tlet mut candidates = TopCandidates::\u003cT\u003e::get();\n\t\t\tensure!(\n\t\t\t\tcandidates.len().saturated_into::\u003cu32\u003e() \u003e T::MinRequiredCollators::get(),\n\t\t\t\tError::\u003cT\u003e::TooFewCollatorCandidates\n\t\t\t);\n\n\t\t\t// *** No Fail except during remove_candidate beyond this point ***\n\n\t\t\t// remove candidate storage and increment rewards\n\t\t\tSelf::remove_candidate(\u0026collator, \u0026state)?;\n\n\t\t\tlet (num_collators, num_delegators) = if candidates\n\t\t\t\t.remove(\u0026Stake { owner: collator.clone(), amount: state.total })\n\t\t\t\t.is_some()\n\t\t\t{\n\t\t\t\t// update top candidates\n\t\t\t\tTopCandidates::\u003cT\u003e::put(candidates);\n\t\t\t\t// update total amount at stake from scratch\n\t\t\t\tSelf::update_total_stake()\n\t\t\t} else {\n\t\t\t\t(0u32, 0u32)\n\t\t\t};\n\n\t\t\tSelf::deposit_event(Event::CollatorRemoved(collator, total_amount));\n\n\t\t\tOk(Some(\u003cT as Config\u003e::WeightInfo::force_remove_candidate(\n\t\t\t\tnum_collators,\n\t\t\t\tnum_delegators,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Join the set of collator candidates.\n\t\t///\n\t\t/// In the next blocks, if the collator candidate has enough funds\n\t\t/// staked to be included in any of the top `MaxSelectedCandidates`\n\t\t/// positions, it will be included in the set of potential authors that\n\t\t/// will be selected by the stake-weighted random selection function.\n\t\t///\n\t\t/// The staked funds of the new collator candidate are added to the\n\t\t/// total stake of the system.\n\t\t///\n\t\t/// The total amount of funds staked must be within the allowed range as\n\t\t/// set in the pallet's configuration.\n\t\t///\n\t\t/// The dispatch origin must not be already part of the collator\n\t\t/// candidates nor of the delegators set.\n\t\t///\n\t\t/// Emits `JoinedCollatorCandidates`.\n\t\t#[pallet::call_index(6)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::join_candidates(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn join_candidates(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tstake: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet sender = ensure_signed(origin)?;\n\t\t\tif let Some(is_active_candidate) = Self::is_active_candidate(\u0026sender) {\n\t\t\t\tensure!(is_active_candidate, Error::\u003cT\u003e::AlreadyLeaving);\n\t\t\t\tensure!(!is_active_candidate, Error::\u003cT\u003e::CandidateExists);\n\t\t\t}\n\t\t\tensure!(!Self::is_delegator(\u0026sender), Error::\u003cT\u003e::DelegatorExists);\n\t\t\tensure!(stake \u003e= T::MinCollatorCandidateStake::get(), Error::\u003cT\u003e::ValStakeBelowMin);\n\t\t\tensure!(stake \u003c= MaxCollatorCandidateStake::\u003cT\u003e::get(), Error::\u003cT\u003e::ValStakeAboveMax);\n\t\t\tensure!(\n\t\t\t\tUnstaking::\u003cT\u003e::get(\u0026sender).len().saturated_into::\u003cu32\u003e() \u003c\n\t\t\t\t\tT::MaxUnstakeRequests::get(),\n\t\t\t\tError::\u003cT\u003e::CannotJoinBeforeUnlocking\n\t\t\t);\n\n\t\t\t// *** No Fail except during increase_lock beyond this point ***\n\n\t\t\tSelf::increase_lock(\u0026sender, stake, BalanceOf::\u003cT\u003e::zero())?;\n\n\t\t\tlet candidate = Candidate::new(sender.clone(), stake);\n\t\t\tlet n = Self::update_top_candidates(\n\t\t\t\tsender.clone(),\n\t\t\t\tBalanceOf::\u003cT\u003e::zero(),\n\t\t\t\tBalanceOf::\u003cT\u003e::zero(),\n\t\t\t\tstake,\n\t\t\t\tBalanceOf::\u003cT\u003e::zero(),\n\t\t\t);\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026sender, candidate);\n\n\t\t\tSelf::deposit_event(Event::JoinedCollatorCandidates(sender, stake));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::join_candidates(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Request to leave the set of collator candidates.\n\t\t///\n\t\t/// On success, the account is immediately removed from the candidate\n\t\t/// pool to prevent selection as a collator in future validation rounds,\n\t\t/// but unstaking of the funds is executed with a delay of\n\t\t/// `StakeDuration` blocks.\n\t\t///\n\t\t/// The exit request can be reversed by calling\n\t\t/// `cancel_leave_candidates`.\n\t\t///\n\t\t/// This operation affects the pallet's total stake amount. It is\n\t\t/// updated even though the funds of the candidate who signaled to leave\n\t\t/// are still locked for `ExitDelay` + `StakeDuration` more blocks.\n\t\t///\n\t\t/// NOTE 1: Upon starting a new session_i in `new_session`, the current\n\t\t/// top candidates are selected to be block authors for session_i+1. Any\n\t\t/// changes to the top candidates afterwards do not effect the set of\n\t\t/// authors for session_i+1.\n\t\t/// Thus, we have to make sure none of these collators can\n\t\t/// leave before session_i+1 ends by delaying their\n\t\t/// exit for `ExitDelay` many blocks.\n\t\t///\n\t\t/// NOTE 2: We do not increment rewards in this extrinsic as the\n\t\t/// candidate could still author blocks, and thus be eligible to receive\n\t\t/// rewards, until the end of the next session.\n\t\t///\n\t\t/// Emits `CollatorScheduledExit`.\n\t\t#[pallet::call_index(7)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::init_leave_candidates(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxTopCandidates::get().saturating_mul(T::MaxDelegatorsPerCollator::get())\n\t\t))]\n\t\tpub fn init_leave_candidates(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet collator = ensure_signed(origin)?;\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!state.is_leaving(), Error::\u003cT\u003e::AlreadyLeaving);\n\t\t\tlet mut candidates = TopCandidates::\u003cT\u003e::get();\n\t\t\tensure!(\n\t\t\t\tcandidates.len().saturated_into::\u003cu32\u003e() \u003e T::MinRequiredCollators::get(),\n\t\t\t\tError::\u003cT\u003e::TooFewCollatorCandidates\n\t\t\t);\n\n\t\t\tlet now = \u003cRound\u003cT\u003e\u003e::get().current;\n\t\t\tlet when = now.saturating_add(T::ExitQueueDelay::get());\n\t\t\tstate.leave_candidates(when);\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tlet (num_collators, num_delegators) = if candidates\n\t\t\t\t.remove(\u0026Stake { owner: collator.clone(), amount: state.total })\n\t\t\t\t.is_some()\n\t\t\t{\n\t\t\t\t// update top candidates\n\t\t\t\tTopCandidates::\u003cT\u003e::put(candidates);\n\t\t\t\tSelf::deposit_event(Event::LeftTopCandidates(collator.clone()));\n\t\t\t\t// update total amount at stake from scratch\n\t\t\t\tSelf::update_total_stake()\n\t\t\t} else {\n\t\t\t\t(0u32, 0u32)\n\t\t\t};\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\n\t\t\tSelf::deposit_event(Event::CollatorScheduledExit(now, collator, when));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::init_leave_candidates(\n\t\t\t\tnum_collators,\n\t\t\t\tnum_delegators,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Execute the network exit of a candidate who requested to leave at\n\t\t/// least `ExitQueueDelay` rounds ago. Prepares unstaking of the\n\t\t/// candidates and their delegators stake which can be unlocked via\n\t\t/// `unlock_unstaked` after waiting at least `StakeDuration` many\n\t\t/// blocks.\n\t\t///\n\t\t/// Requires the candidate to previously have called\n\t\t/// `init_leave_candidates`.\n\t\t///\n\t\t/// The exit request can be reversed by calling\n\t\t/// `cancel_leave_candidates`.\n\t\t///\n\t\t/// NOTE: Iterates over CandidatePool for each candidate over their\n\t\t/// delegators to set rewards. Needs to be improved when scaling up\n\t\t/// `MaxTopCandidates`.\n\t\t///\n\t\t/// Emits `CollatorLeft`.\n\t\t#[pallet::call_index(8)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::execute_leave_candidates(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t))]\n\t\tpub fn execute_leave_candidates(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcollator: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_signed(origin)?;\n\t\t\tlet collator = T::Lookup::lookup(collator)?;\n\t\t\tlet state = CandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(state.is_leaving(), Error::\u003cT\u003e::NotLeaving);\n\t\t\tensure!(state.can_exit(\u003cRound\u003cT\u003e\u003e::get().current), Error::\u003cT\u003e::CannotLeaveYet);\n\n\t\t\tlet num_delegators = state.delegators.len().saturated_into::\u003cu32\u003e();\n\t\t\tlet total_amount = state.total;\n\n\t\t\t// *** No Fail except during remove_candidate beyond this point ***\n\n\t\t\t// remove candidate storage and increment rewards\n\t\t\tSelf::remove_candidate(\u0026collator, \u0026state)?;\n\n\t\t\tSelf::deposit_event(Event::CandidateLeft(collator, total_amount));\n\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::execute_leave_candidates(\n\t\t\t\tT::MaxTopCandidates::get(),\n\t\t\t\tnum_delegators,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Revert the previously requested exit of the network of a collator\n\t\t/// candidate. On success, adds back the candidate to the TopCandidates\n\t\t/// and updates the collators.\n\t\t///\n\t\t/// Requires the candidate to previously have called\n\t\t/// `init_leave_candidates`.\n\t\t///\n\t\t/// Emits `CollatorCanceledExit`.\n\t\t#[pallet::call_index(9)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::cancel_leave_candidates(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t))]\n\t\tpub fn cancel_leave_candidates(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet candidate = ensure_signed(origin)?;\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026candidate).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(state.is_leaving(), Error::\u003cT\u003e::NotLeaving);\n\n\t\t\t// revert leaving state\n\t\t\tstate.revert_leaving();\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tlet n = Self::update_top_candidates(\n\t\t\t\tcandidate.clone(),\n\t\t\t\tstate.stake,\n\t\t\t\t// safe because total \u003e= stake\n\t\t\t\tstate.total - state.stake,\n\t\t\t\tstate.stake,\n\t\t\t\tstate.total - state.stake,\n\t\t\t);\n\n\t\t\t// update candidates for next round\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026candidate, state);\n\n\t\t\tSelf::deposit_event(Event::CollatorCanceledExit(candidate));\n\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::cancel_leave_candidates(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Stake more funds for a collator candidate.\n\t\t///\n\t\t/// If not in the set of candidates, staking enough funds allows the\n\t\t/// account to be added to it. The larger amount of funds, the higher\n\t\t/// chances to be selected as the author of the next block.\n\t\t///\n\t\t/// This operation affects the pallet's total stake amount.\n\t\t///\n\t\t/// The resulting total amount of funds staked must be within the\n\t\t/// allowed range as set in the pallet's configuration.\n\t\t///\n\t\t/// Emits `CollatorStakedMore`.\n\t\t#[pallet::call_index(10)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::candidate_stake_more(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\tT::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e()\n\t\t))]\n\t\tpub fn candidate_stake_more(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tmore: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet collator = ensure_signed(origin)?;\n\n\t\t\tensure!(!more.is_zero(), Error::\u003cT\u003e::ValStakeZero);\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!state.is_leaving(), Error::\u003cT\u003e::CannotStakeIfLeaving);\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: before_stake, total: before_total, .. } = state;\n\t\t\tstate.stake_more(more);\n\t\t\tlet after_stake = state.stake;\n\t\t\tensure!(\n\t\t\t\tstate.stake \u003c= MaxCollatorCandidateStake::\u003cT\u003e::get(),\n\t\t\t\tError::\u003cT\u003e::ValStakeAboveMax\n\t\t\t);\n\n\t\t\t// *** No Fail except during increase_lock beyond this point ***\n\n\t\t\tlet unstaking_len = Self::increase_lock(\u0026collator, state.stake, more)?;\n\n\t\t\tlet n = if state.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcollator.clone(),\n\t\t\t\t\tbefore_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\tbefore_total - before_stake,\n\t\t\t\t\tstate.stake,\n\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\n\t\t\t// increment rewards for origin + their delegators and reset reward counter\n\t\t\tSelf::do_inc_collator_reward(\u0026collator, before_stake);\n\n\t\t\tSelf::deposit_event(Event::CollatorStakedMore(collator, before_stake, after_stake));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::candidate_stake_more(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t\tunstaking_len,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Stake less funds for a collator candidate.\n\t\t///\n\t\t/// If the new amount of staked fund is not large enough, the account\n\t\t/// could be removed from the set of collator candidates and not be\n\t\t/// considered for authoring the next blocks.\n\t\t///\n\t\t/// This operation affects the pallet's total stake amount.\n\t\t///\n\t\t/// The unstaked funds are not released immediately to the account, but\n\t\t/// they will be available after `StakeDuration` blocks.\n\t\t///\n\t\t/// The resulting total amount of funds staked must be within the\n\t\t/// allowed range as set in the pallet's configuration.\n\t\t///\n\t\t/// Emits `CollatorStakedLess`.\n\t\t#[pallet::call_index(11)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::candidate_stake_less(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn candidate_stake_less(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tless: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet collator = ensure_signed(origin)?;\n\t\t\tensure!(!less.is_zero(), Error::\u003cT\u003e::ValStakeZero);\n\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!state.is_leaving(), Error::\u003cT\u003e::CannotStakeIfLeaving);\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: before_stake, total: before_total, .. } = state;\n\t\t\tlet after = state.stake_less(less).ok_or(Error::\u003cT\u003e::Underflow)?;\n\t\t\tensure!(after \u003e= T::MinCollatorCandidateStake::get(), Error::\u003cT\u003e::ValStakeBelowMin);\n\n\t\t\t// *** No Fail except during prep_unstake beyond this point ***\n\n\t\t\t// we don't unlock immediately\n\t\t\tSelf::prep_unstake(\u0026collator, less, false)?;\n\n\t\t\tlet n = if state.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcollator.clone(),\n\t\t\t\t\tbefore_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\tbefore_total - before_stake,\n\t\t\t\t\tstate.stake,\n\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\n\t\t\t// increment rewards for origin + their delegators and reset reward counter\n\t\t\tSelf::do_inc_collator_reward(\u0026collator, before_stake);\n\n\t\t\tSelf::deposit_event(Event::CollatorStakedLess(collator, before_stake, after));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::candidate_stake_less(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Join the set of delegators by delegating to a collator candidate.\n\t\t///\n\t\t/// The account that wants to delegate cannot be part of the collator\n\t\t/// candidates set as well.\n\t\t///\n\t\t/// The caller must _not_ have a delegation. If that is the case, they\n\t\t/// are required to first remove the delegation.\n\t\t///\n\t\t/// The amount staked must be larger than the minimum required to become\n\t\t/// a delegator as set in the pallet's configuration.\n\t\t///\n\t\t/// As only `MaxDelegatorsPerCollator` are allowed to delegate a given\n\t\t/// collator, the amount staked must be larger than the lowest one in\n\t\t/// the current set of delegator for the operation to be meaningful.\n\t\t///\n\t\t/// The collator's total stake as well as the pallet's total stake are\n\t\t/// increased accordingly.\n\t\t///\n\t\t/// Emits `Delegation`.\n\t\t/// Emits `DelegationReplaced` if the candidate has\n\t\t/// `MaxDelegatorsPerCollator` many delegations but this delegator\n\t\t/// staked more than one of the other delegators of this candidate.\n\t\t#[pallet::call_index(12)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::join_delegators(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn join_delegators(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcollator: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet acc = ensure_signed(origin)?;\n\t\t\tlet collator = T::Lookup::lookup(collator)?;\n\n\t\t\t// check balance\n\t\t\tensure!(\n\t\t\t\tpallet_balances::Pallet::\u003cT\u003e::free_balance(acc.clone()) \u003e= amount.into(),\n\t\t\t\tpallet_balances::Error::\u003cT\u003e::InsufficientBalance\n\t\t\t);\n\n\t\t\t// first delegation\n\t\t\tensure!(DelegatorState::\u003cT\u003e::get(\u0026acc).is_none(), Error::\u003cT\u003e::AlreadyDelegating);\n\t\t\tensure!(amount \u003e= T::MinDelegatorStake::get(), Error::\u003cT\u003e::DelegationBelowMin);\n\n\t\t\t// cannot be a collator candidate and delegator with same AccountId\n\t\t\tensure!(Self::is_active_candidate(\u0026acc).is_none(), Error::\u003cT\u003e::CandidateExists);\n\t\t\tensure!(\n\t\t\t\tUnstaking::\u003cT\u003e::get(\u0026acc).len().saturated_into::\u003cu32\u003e() \u003c\n\t\t\t\t\tT::MaxUnstakeRequests::get(),\n\t\t\t\tError::\u003cT\u003e::CannotJoinBeforeUnlocking\n\t\t\t);\n\t\t\t// cannot delegate if number of delegations in this round exceeds\n\t\t\t// MaxDelegationsPerRound\n\t\t\tlet delegation_counter = Self::get_delegation_counter(\u0026acc)?;\n\n\t\t\t// prepare update of collator state\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tlet num_delegations_pre_insertion: u32 = state.delegators.len().saturated_into();\n\n\t\t\tensure!(!state.is_leaving(), Error::\u003cT\u003e::CannotDelegateIfLeaving);\n\t\t\tlet delegation = Stake { owner: acc.clone(), amount };\n\n\t\t\t// attempt to insert delegator and check for uniqueness\n\t\t\t// NOTE: excess is handled below because we support replacing a delegator with\n\t\t\t// fewer stake\n\t\t\tlet insert_delegator = state\n\t\t\t\t.delegators\n\t\t\t\t// we handle TooManyDelegators error below in do_update_delegator\n\t\t\t\t.try_insert(delegation.clone())\n\t\t\t\t.unwrap_or(true);\n\t\t\t// should never fail but let's be safe\n\t\t\tensure!(insert_delegator, Error::\u003cT\u003e::DelegatorExists);\n\n\t\t\tlet delegator_state = Delegator { amount, owner: Some(collator.clone()) };\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: old_stake, total: old_total, .. } = state;\n\n\t\t\t// update state and potentially prepare kicking a delegator with less staked\n\t\t\t// amount (includes setting rewards for kicked delegator)\n\t\t\tlet state = if num_delegations_pre_insertion == T::MaxDelegatorsPerCollator::get() {\n\t\t\t\tSelf::do_update_delegator(delegation, state)?\n\t\t\t} else {\n\t\t\t\tstate.total = state.total.saturating_add(amount);\n\t\t\t\tstate\n\t\t\t};\n\t\t\tlet new_total = state.total;\n\n\t\t\t// *** No Fail except during increase_lock beyond this point ***\n\n\t\t\t// lock stake\n\t\t\tSelf::increase_lock(\u0026acc, amount, BalanceOf::\u003cT\u003e::zero())?;\n\n\t\t\t// update top candidates and total amount at stake\n\t\t\tlet n = if state.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcollator.clone(),\n\t\t\t\t\told_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\told_total - old_stake,\n\t\t\t\t\tstate.stake,\n\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\n\t\t\t// update states\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\t\t\tDelegatorState::\u003cT\u003e::insert(\u0026acc, delegator_state);\n\t\t\t\u003cLastDelegation\u003cT\u003e\u003e::insert(\u0026acc, delegation_counter);\n\n\t\t\t// initiate reward counter to match the current state of the candidate\n\t\t\tRewardCount::\u003cT\u003e::insert(\u0026acc, RewardCount::\u003cT\u003e::get(\u0026collator));\n\n\t\t\tSelf::deposit_event(Event::Delegation(acc, amount, collator, new_total));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::join_delegators(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Leave the set of delegators and, by implication, revoke the ongoing\n\t\t/// delegation.\n\t\t///\n\t\t/// All staked funds are not unlocked immediately, but they are added to\n\t\t/// the queue of pending unstaking, and will effectively be released\n\t\t/// after `StakeDuration` blocks from the moment the delegator leaves.\n\t\t///\n\t\t/// This operation reduces the total stake of the pallet as well as the\n\t\t/// stakes of all collators that were delegated, potentially affecting\n\t\t/// their chances to be included in the set of candidates in the next\n\t\t/// rounds.\n\t\t///\n\t\t/// Automatically increments the accumulated rewards of the origin of\n\t\t/// the current delegation.\n\t\t///\n\t\t/// Emits `DelegatorLeft`.\n\t\t#[pallet::call_index(13)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::leave_delegators(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn leave_delegators(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet acc = ensure_signed(origin)?;\n\t\t\tlet delegator = DelegatorState::\u003cT\u003e::get(\u0026acc).ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\t\t\t// should never throw\n\t\t\tlet collator = delegator.owner.ok_or(Error::\u003cT\u003e::DelegationNotFound)?;\n\t\t\tSelf::delegator_leaves_collator(acc.clone(), collator)?;\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tDelegatorState::\u003cT\u003e::remove(\u0026acc);\n\n\t\t\tSelf::deposit_event(Event::DelegatorLeft(acc, delegator.amount));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::leave_delegators(\n\t\t\t\t1,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Increase the stake for delegating a collator candidate.\n\t\t///\n\t\t/// If not in the set of candidates, staking enough funds allows the\n\t\t/// collator candidate to be added to it.\n\t\t///\n\t\t/// Emits `DelegatorStakedMore`.\n\t\t#[pallet::call_index(14)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::delegator_stake_more(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\tT::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e())\n\t\t)]\n\t\tpub fn delegator_stake_more(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcandidate: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t\tmore: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet delegator = ensure_signed(origin)?;\n\t\t\tensure!(!more.is_zero(), Error::\u003cT\u003e::ValStakeZero);\n\n\t\t\tlet candidate = T::Lookup::lookup(candidate)?;\n\t\t\tlet mut delegation =\n\t\t\t\tDelegatorState::\u003cT\u003e::get(\u0026delegator).ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\t\t\tlet mut collator =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026candidate).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!collator.is_leaving(), Error::\u003cT\u003e::CannotDelegateIfLeaving);\n\t\t\tlet stake_after = delegation\n\t\t\t\t.inc_delegation(candidate.clone(), more)\n\t\t\t\t.map_err(|_| Error::\u003cT\u003e::DelegationNotFound)?;\n\n\t\t\t// *** No Fail except during increase_lock beyond this point ***\n\n\t\t\t// update lock\n\t\t\tlet unstaking_len = Self::increase_lock(\u0026delegator, stake_after, more)?;\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: before_stake, total: before_total, .. } = collator;\n\t\t\tcollator.inc_delegator(delegator.clone(), more);\n\t\t\tlet after = collator.total;\n\n\t\t\t// update top candidates and total amount at stake\n\t\t\tlet n = if collator.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcandidate.clone(),\n\t\t\t\t\tbefore_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\tbefore_total - before_stake,\n\t\t\t\t\tcollator.stake,\n\t\t\t\t\tcollator.total - collator.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\n\t\t\t// set rewards and reset reward counter\n\t\t\tSelf::do_inc_delegator_reward(\u0026delegator, stake_after.saturating_sub(more), \u0026candidate);\n\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026candidate, collator);\n\t\t\tDelegatorState::\u003cT\u003e::insert(\u0026delegator, delegation);\n\n\t\t\tSelf::deposit_event(Event::DelegatorStakedMore(\n\t\t\t\tdelegator,\n\t\t\t\tcandidate,\n\t\t\t\tbefore_total,\n\t\t\t\tafter,\n\t\t\t));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::delegator_stake_more(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t\tunstaking_len,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Reduce the stake for delegating a collator candidate.\n\t\t///\n\t\t/// If the new amount of staked fund is not large enough, the collator\n\t\t/// could be removed from the set of collator candidates and not be\n\t\t/// considered for authoring the next blocks.\n\t\t///\n\t\t/// The unstaked funds are not release immediately to the account, but\n\t\t/// they will be available after `StakeDuration` blocks.\n\t\t///\n\t\t/// The remaining staked funds must still be larger than the minimum\n\t\t/// required by this pallet to maintain the status of delegator.\n\t\t///\n\t\t/// The resulting total amount of funds staked must be within the\n\t\t/// allowed range as set in the pallet's configuration.\n\t\t///\n\t\t/// Emits `DelegatorStakedLess`.\n\t\t#[pallet::call_index(15)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::delegator_stake_less(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn delegator_stake_less(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcandidate: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t\tless: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet delegator = ensure_signed(origin)?;\n\t\t\tensure!(!less.is_zero(), Error::\u003cT\u003e::ValStakeZero);\n\n\t\t\tlet candidate = T::Lookup::lookup(candidate)?;\n\t\t\tlet mut delegations =\n\t\t\t\tDelegatorState::\u003cT\u003e::get(\u0026delegator).ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\t\t\tlet mut collator =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026candidate).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!collator.is_leaving(), Error::\u003cT\u003e::CannotDelegateIfLeaving);\n\t\t\tlet stake_after = delegations\n\t\t\t\t.dec_delegation(candidate.clone(), less)\n\t\t\t\t.map_err(|_| Error::\u003cT\u003e::DelegationNotFound)?\n\t\t\t\t.ok_or(Error::\u003cT\u003e::Underflow)?;\n\n\t\t\tensure!(stake_after \u003e= T::MinDelegatorStake::get(), Error::\u003cT\u003e::DelegationBelowMin);\n\n\t\t\t// *** No Fail except during prep_unstake beyond this point ***\n\n\t\t\tSelf::prep_unstake(\u0026delegator, less, false)?;\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: before_stake, total: before_total, .. } = collator;\n\t\t\tcollator.dec_delegator(delegator.clone(), less);\n\t\t\tlet after = collator.total;\n\n\t\t\t// update top candidates and total amount at stake\n\t\t\tlet n = if collator.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcandidate.clone(),\n\t\t\t\t\tbefore_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\tbefore_total - before_stake,\n\t\t\t\t\tcollator.stake,\n\t\t\t\t\tcollator.total - collator.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\n\t\t\t// set rewards and reset reward counter\n\t\t\tSelf::do_inc_delegator_reward(\u0026delegator, stake_after.saturating_add(less), \u0026candidate);\n\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026candidate, collator);\n\t\t\tDelegatorState::\u003cT\u003e::insert(\u0026delegator, delegations);\n\n\t\t\tSelf::deposit_event(Event::DelegatorStakedLess(\n\t\t\t\tdelegator,\n\t\t\t\tcandidate,\n\t\t\t\tbefore_total,\n\t\t\t\tafter,\n\t\t\t));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::delegator_stake_less(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Unlock all previously staked funds that are now available for\n\t\t/// unlocking by the origin account after `StakeDuration` blocks have\n\t\t/// elapsed.\n\t\t///\n\t\t/// Weight: O(U) where U is the number of locked unstaking requests\n\t\t/// bounded by `MaxUnstakeRequests`.\n\t\t/// - Reads: [Origin Account], Unstaking, Locks\n\t\t/// - Writes: Unstaking, Locks\n\t\t/// - Kills: Unstaking \u0026 Locks if no balance is locked anymore\n\t\t/// # \u003c/weight\u003e\n\t\t#[pallet::call_index(16)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::unlock_unstaked(\n\t\t\tT::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e()\n\t\t))]\n\t\tpub fn unlock_unstaked(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\ttarget: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_signed(origin)?;\n\t\t\tlet target = T::Lookup::lookup(target)?;\n\n\t\t\tlet unstaking_len = Self::do_unlock(\u0026target)?;\n\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::unlock_unstaked(unstaking_len)).into())\n\t\t}\n\n\t\t/// Claim block authoring rewards for the target address.\n\t\t///\n\t\t/// Requires `Rewards` to be set beforehand, which can by triggered by\n\t\t/// any of the following options\n\t\t/// * Calling increment_{collator, delegator}_rewards (active)\n\t\t/// * Altering your stake (active)\n\t\t/// * Leaving the network as a collator (active)\n\t\t/// * Revoking a delegation as a delegator (active)\n\t\t/// * Being a delegator whose collator left the network, altered their\n\t\t///   stake or incremented rewards (passive)\n\t\t///\n\t\t/// The dispatch origin can be any signed one, e.g., anyone can claim\n\t\t/// for anyone.\n\t\t///\n\t\t/// Emits `Rewarded`.\n\t\t#[pallet::call_index(17)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::claim_rewards())]\n\t\tpub fn claim_rewards(origin: OriginFor\u003cT\u003e) -\u003e DispatchResult {\n\t\t\tlet target = ensure_signed(origin)?;\n\n\t\t\t// we could kill the storage entry but let's be safe in case the deposit fails\n\t\t\tlet rewards = Rewards::\u003cT\u003e::get(\u0026target);\n\t\t\tensure!(!rewards.is_zero(), Error::\u003cT\u003e::RewardsNotFound);\n\n\t\t\t// mint into target and reset rewards\n\t\t\tlet rewards = T::Currency::deposit_into_existing(\u0026target, rewards)?;\n\t\t\tRewards::\u003cT\u003e::remove(\u0026target);\n\n\t\t\tSelf::deposit_event(Event::Rewarded(target, rewards.peek()));\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Actively increment the rewards of a collator and their delegators.\n\t\t///\n\t\t/// The same effect is triggered by changing the stake or leaving the\n\t\t/// network.\n\t\t///\n\t\t/// The dispatch origin must be a collator.\n\t\t#[pallet::call_index(18)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::increment_collator_rewards(T::MaxDelegatorsPerCollator::get()))]\n\t\tpub fn increment_collator_rewards(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet collator = ensure_signed(origin)?;\n\t\t\tlet state = CandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\n\t\t\t// early exit\n\t\t\tlet reward_count = RewardCount::\u003cT\u003e::get(\u0026collator);\n\t\t\tensure!(!reward_count.is_zero(), Error::\u003cT\u003e::RewardsNotFound);\n\n\t\t\tlet num_delegators = Self::do_inc_collator_reward(\u0026collator, state.stake);\n\t\t\tOk(Some(\u003cT as Config\u003e::WeightInfo::increment_collator_rewards(\n\t\t\t\tnum_delegators.saturated_into(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Actively increment the rewards of a delegator for all their\n\t\t/// delegations.\n\t\t///\n\t\t/// The same effect is triggered by changing the stake or revoking\n\t\t/// delegations.\n\t\t///\n\t\t/// The dispatch origin must be a delegator.\n\t\t#[pallet::call_index(19)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::increment_delegator_rewards())]\n\t\tpub fn increment_delegator_rewards(origin: OriginFor\u003cT\u003e) -\u003e DispatchResult {\n\t\t\tlet delegator = ensure_signed(origin)?;\n\t\t\tlet delegation =\n\t\t\t\tDelegatorState::\u003cT\u003e::get(\u0026delegator).ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\t\t\t// should never throw\n\t\t\tlet collator = delegation.owner.ok_or(Error::\u003cT\u003e::DelegationNotFound)?;\n\n\t\t\tSelf::do_inc_delegator_reward(\u0026delegator, delegation.amount, \u0026collator);\n\t\t\tensure!(!Rewards::\u003cT\u003e::get(\u0026delegator).is_zero(), Error::\u003cT\u003e::RewardsNotFound);\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Executes the annual reduction of the reward rates for collators and\n\t\t/// delegators. Moreover, sets rewards for all collators and delegators\n\t\t/// before adjusting the inflation.\n\t\t///\n\t\t/// Emits `RoundInflationSet`.\n\t\t#[pallet::call_index(20)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::execute_scheduled_reward_change(T::MaxTopCandidates::get(), T::MaxDelegatorsPerCollator::get()))]\n\t\tpub fn execute_scheduled_reward_change(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_signed(origin)?;\n\n\t\t\tlet now = frame_system::Pallet::\u003cT\u003e::block_number();\n\t\t\tlet year = now / T::BLOCKS_PER_YEAR;\n\t\t\tlet last_update = LastRewardReduction::\u003cT\u003e::get();\n\n\t\t\tensure!(year \u003e last_update, Error::\u003cT\u003e::TooEarly);\n\n\t\t\t// Calculate new inflation based on last year\n\t\t\tlet inflation = InflationConfig::\u003cT\u003e::get();\n\n\t\t\tlet c_reward_rate =\n\t\t\t\tinflation.collator.reward_rate.annual * T::CollatorRewardRateDecay::get();\n\t\t\t// delegator reward rate should be 6% in 2nd year and 0% afterwards\n\t\t\tlet d_reward_rate = if year == T::BlockNumber::one() {\n\t\t\t\t// Amplitude: this value differs from the original\n\t\t\t\tPerquintill::from_percent(7)\n\t\t\t} else {\n\t\t\t\tPerquintill::zero()\n\t\t\t};\n\t\t\tlet new_inflation = InflationInfo::new(\n\t\t\t\tT::BLOCKS_PER_YEAR.saturated_into(),\n\t\t\t\tinflation.collator.max_rate,\n\t\t\t\tc_reward_rate,\n\t\t\t\tinflation.delegator.max_rate,\n\t\t\t\td_reward_rate,\n\t\t\t);\n\t\t\t// should never fail\n\t\t\tensure!(\n\t\t\t\tnew_inflation.is_valid(T::BLOCKS_PER_YEAR.saturated_into()),\n\t\t\t\tError::\u003cT\u003e::InvalidSchedule\n\t\t\t);\n\n\t\t\t// set rewards for all collators and delegators before updating reward rates\n\t\t\tlet mut max_num_delegators = 0;\n\t\t\tCandidatePool::\u003cT\u003e::iter().for_each(|(id, state)| {\n\t\t\t\tmax_num_delegators =\n\t\t\t\t\tmax_num_delegators.max(Self::do_inc_collator_reward(\u0026id, state.stake));\n\t\t\t});\n\n\t\t\t// update inflation config\n\t\t\tInflationConfig::\u003cT\u003e::put(new_inflation.clone());\n\t\t\tLastRewardReduction::\u003cT\u003e::put(year);\n\t\t\tSelf::deposit_event(Event::RoundInflationSet(\n\t\t\t\tnew_inflation.collator.max_rate,\n\t\t\t\tnew_inflation.collator.reward_rate.per_block,\n\t\t\t\tnew_inflation.delegator.max_rate,\n\t\t\t\tnew_inflation.delegator.reward_rate.per_block,\n\t\t\t));\n\n\t\t\tOk(Some(\u003cT as Config\u003e::WeightInfo::execute_scheduled_reward_change(\n\t\t\t\tCandidatePool::\u003cT\u003e::count(),\n\t\t\t\tmax_num_delegators.saturated_into(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\t}\n\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Check whether an account is currently delegating.\n\t\tpub fn is_delegator(acc: \u0026T::AccountId) -\u003e bool {\n\t\t\tDelegatorState::\u003cT\u003e::get(acc).is_some()\n\t\t}\n\n\t\t/// Check whether an account is currently a collator candidate and\n\t\t/// whether their state is CollatorStatus::Active.\n\t\t///\n\t\t/// Returns Some(is_active) if the account is a candidate, else None.\n\t\tpub fn is_active_candidate(acc: \u0026T::AccountId) -\u003e Option\u003cbool\u003e {\n\t\t\tif let Some(state) = CandidatePool::\u003cT\u003e::get(acc) {\n\t\t\t\tSome(state.status == CandidateStatus::Active)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t}\n\n\t\t/// Update the top candidates and total amount at stake after mutating\n\t\t/// an active candidate's stake.\n\t\t///\n\t\t/// NOTE: It is assumed that the calling context checks whether the\n\t\t/// collator candidate is currently active before calling this function.\n\t\tfn update_top_candidates(\n\t\t\tcandidate: T::AccountId,\n\t\t\told_self: BalanceOf\u003cT\u003e,\n\t\t\told_delegators: BalanceOf\u003cT\u003e,\n\t\t\tnew_self: BalanceOf\u003cT\u003e,\n\t\t\tnew_delegators: BalanceOf\u003cT\u003e,\n\t\t) -\u003e u32 {\n\t\t\tlet mut top_candidates = TopCandidates::\u003cT\u003e::get();\n\t\t\tlet num_top_candidates: u32 = top_candidates.len().saturated_into();\n\t\t\tlet old_stake =\n\t\t\t\tStake { owner: candidate.clone(), amount: old_self.saturating_add(old_delegators) };\n\t\t\tlet new_stake =\n\t\t\t\tStake { owner: candidate.clone(), amount: new_self.saturating_add(new_delegators) };\n\n\t\t\t// update TopCandidates set\n\t\t\tlet maybe_top_candidate_update = if let Ok(i) = top_candidates.linear_search(\u0026old_stake)\n\t\t\t{\n\t\t\t\t// case 1: candidate is member of TopCandidates with old stake\n\t\t\t\ttop_candidates.mutate(|vec| {\n\t\t\t\t\tif let Some(stake) = vec.get_mut(i) {\n\t\t\t\t\t\tstake.amount = new_stake.amount;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tSome((Some(i), top_candidates))\n\t\t\t} else if top_candidates.try_insert_replace(new_stake.clone()).is_ok() {\n\t\t\t\t// case 2: candidate ascends into TopCandidates with new stake\n\t\t\t\t// and might replace another candidate if TopCandidates is full\n\t\t\t\tSelf::deposit_event(Event::EnteredTopCandidates(candidate));\n\t\t\t\tSome((None, top_candidates))\n\t\t\t} else {\n\t\t\t\t// case 3: candidate neither was nor will be member of TopCandidates\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\t// update storage for TotalCollatorStake and TopCandidates\n\t\t\tif let Some((maybe_old_idx, top_candidates)) = maybe_top_candidate_update {\n\t\t\t\tlet max_selected_candidates =\n\t\t\t\t\tMaxSelectedCandidates::\u003cT\u003e::get().saturated_into::\u003cusize\u003e();\n\t\t\t\tlet was_collating =\n\t\t\t\t\tmaybe_old_idx.map(|i| i \u003c max_selected_candidates).unwrap_or(false);\n\t\t\t\tlet is_collating = top_candidates\n\t\t\t\t\t.linear_search(\u0026new_stake)\n\t\t\t\t\t.map(|i| i \u003c max_selected_candidates)\n\t\t\t\t\t.unwrap_or(false);\n\n\t\t\t\t// update TopCollatorStake storage iff candidate was or will be a collator\n\t\t\t\tmatch (was_collating, is_collating) {\n\t\t\t\t\t(true, true) =\u003e {\n\t\t\t\t\t\tSelf::update_total_stake_by(\n\t\t\t\t\t\t\tnew_self,\n\t\t\t\t\t\t\tnew_delegators,\n\t\t\t\t\t\t\told_self,\n\t\t\t\t\t\t\told_delegators,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t(true, false) =\u003e {\n\t\t\t\t\t\t// candidate left the collator set because they staked less and have been\n\t\t\t\t\t\t// replaced by the next candidate in the queue at position\n\t\t\t\t\t\t// min(max_selected_candidates, top_candidates) - 1 in TopCandidates\n\t\t\t\t\t\tlet new_col_idx =\n\t\t\t\t\t\t\tmax_selected_candidates.min(top_candidates.len()).saturating_sub(1);\n\n\t\t\t\t\t\t// get displacer\n\t\t\t\t\t\tlet (add_collators, add_delegators) =\n\t\t\t\t\t\t\tSelf::get_top_candidate_stake_at(\u0026top_candidates, new_col_idx)\n\t\t\t\t\t\t\t\t// shouldn't be possible to fail, but we handle it gracefully\n\t\t\t\t\t\t\t\t.unwrap_or((new_self, new_delegators));\n\t\t\t\t\t\tSelf::update_total_stake_by(\n\t\t\t\t\t\t\tadd_collators,\n\t\t\t\t\t\t\tadd_delegators,\n\t\t\t\t\t\t\told_self,\n\t\t\t\t\t\t\told_delegators,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t(false, true) =\u003e {\n\t\t\t\t\t\t// candidate pushed out the least staked collator which is now at position\n\t\t\t\t\t\t// min(max_selected_top_candidates, top_candidates - 1) in TopCandidates\n\t\t\t\t\t\tlet old_col_idx =\n\t\t\t\t\t\t\tmax_selected_candidates.min(top_candidates.len().saturating_sub(1));\n\n\t\t\t\t\t\t// get amount to subtract from TotalCollatorStake\n\t\t\t\t\t\tlet (drop_self, drop_delegators) =\n\t\t\t\t\t\t\tSelf::get_top_candidate_stake_at(\u0026top_candidates, old_col_idx)\n\t\t\t\t\t\t\t\t// default to zero if candidate DNE, e.g. TopCandidates is not full\n\t\t\t\t\t\t\t\t.unwrap_or((BalanceOf::\u003cT\u003e::zero(), BalanceOf::\u003cT\u003e::zero()));\n\t\t\t\t\t\tSelf::update_total_stake_by(\n\t\t\t\t\t\t\tnew_self,\n\t\t\t\t\t\t\tnew_delegators,\n\t\t\t\t\t\t\tdrop_self,\n\t\t\t\t\t\t\tdrop_delegators,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e {},\n\t\t\t\t}\n\n\t\t\t\t// update TopCandidates storage\n\t\t\t\tTopCandidates::\u003cT\u003e::put(top_candidates);\n\t\t\t}\n\n\t\t\tnum_top_candidates\n\t\t}\n\n\t\t/// Retrieve the staked amounts (self, sum of delegators) of member of\n\t\t/// [TopCandidates] at the given index, if it exists.\n\t\tfn get_top_candidate_stake_at(\n\t\t\ttop_candidates: \u0026OrderedSet\u003cStakeOf\u003cT\u003e, T::MaxTopCandidates\u003e,\n\t\t\tindex: usize,\n\t\t) -\u003e Option\u003c(BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e)\u003e {\n\t\t\ttop_candidates\n\t\t\t\t.get(index)\n\t\t\t\t.and_then(|stake| CandidatePool::\u003cT\u003e::get(\u0026stake.owner))\n\t\t\t\t// SAFETY: the total is always more than the stake\n\t\t\t\t.map(|state| (state.stake, state.total - state.stake))\n\t\t}\n\n\t\t/// Mutate the [TotalCollatorStake] by both incrementing and decreasing\n\t\t/// it by the provided values.\n\t\tfn update_total_stake_by(\n\t\t\tadd_collators: BalanceOf\u003cT\u003e,\n\t\t\tadd_delegators: BalanceOf\u003cT\u003e,\n\t\t\tsub_collators: BalanceOf\u003cT\u003e,\n\t\t\tsub_delegators: BalanceOf\u003cT\u003e,\n\t\t) {\n\t\t\tTotalCollatorStake::\u003cT\u003e::mutate(|total| {\n\t\t\t\ttotal.collators =\n\t\t\t\t\ttotal.collators.saturating_sub(sub_collators).saturating_add(add_collators);\n\t\t\t\ttotal.delegators =\n\t\t\t\t\ttotal.delegators.saturating_sub(sub_delegators).saturating_add(add_delegators);\n\t\t\t});\n\t\t}\n\n\t\t/// Iterate over the top `MaxSelectedCandidates` many collators in terms\n\t\t/// of cumulated stake (self + from delegators) from the [TopCandidates]\n\t\t/// and recalculate the [TotalCollatorStake] from scratch.\n\t\t///\n\t\t/// NOTE: Should only be called in rare circumstances in which we cannot\n\t\t/// guarantee a single candidate's stake has changed, e.g. on genesis or\n\t\t/// when a collator leaves. Otherwise, please use\n\t\t/// [update_total_stake_by].\n\t\tfn update_total_stake() -\u003e (u32, u32) {\n\t\t\tlet mut num_of_delegators = 0u32;\n\t\t\tlet mut collator_stake = BalanceOf::\u003cT\u003e::zero();\n\t\t\tlet mut delegator_stake = BalanceOf::\u003cT\u003e::zero();\n\n\t\t\tlet collators = Self::selected_candidates();\n\n\t\t\t// Snapshot exposure for round for weighting reward distribution\n\t\t\tfor account in collators.iter() {\n\t\t\t\tlet state = CandidatePool::\u003cT\u003e::get(\u0026account)\n\t\t\t\t\t.expect(\"all members of TopCandidates must be candidates q.e.d\");\n\t\t\t\tnum_of_delegators =\n\t\t\t\t\tnum_of_delegators.max(state.delegators.len().saturated_into::\u003cu32\u003e());\n\n\t\t\t\t// sum up total stake and amount of collators, delegators\n\t\t\t\tlet amount_collator = state.stake;\n\t\t\t\tcollator_stake = collator_stake.saturating_add(state.stake);\n\t\t\t\t// safe to subtract because total \u003e= stake\n\t\t\t\tlet amount_delegators = state.total - amount_collator;\n\t\t\t\tdelegator_stake = delegator_stake.saturating_add(amount_delegators);\n\t\t\t}\n\n\t\t\tTotalCollatorStake::\u003cT\u003e::mutate(|total| {\n\t\t\t\ttotal.collators = collator_stake;\n\t\t\t\ttotal.delegators = delegator_stake;\n\t\t\t});\n\n\t\t\t// return number of selected candidates and the corresponding number of their\n\t\t\t// delegators for post-weight correction\n\t\t\t(collators.len().saturated_into(), num_of_delegators)\n\t\t}\n\n\t\t/// Update the collator's state by removing the delegator's stake and\n\t\t/// starting the process to unlock the delegator's staked funds as well\n\t\t/// as incrementing their accumulated rewards.\n\t\t///\n\t\t/// This operation affects the pallet's total stake.\n\t\tfn delegator_leaves_collator(\n\t\t\tdelegator: T::AccountId,\n\t\t\tcollator: T::AccountId,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\n\t\t\tlet delegator_stake = state\n\t\t\t\t.delegators\n\t\t\t\t.remove(\u0026Stake {\n\t\t\t\t\towner: delegator.clone(),\n\t\t\t\t\t// amount is irrelevant for removal\n\t\t\t\t\tamount: BalanceOf::\u003cT\u003e::one(),\n\t\t\t\t})\n\t\t\t\t.map(|nom| nom.amount)\n\t\t\t\t.ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: old_stake, total: old_total, .. } = state;\n\t\t\tstate.total = state.total.saturating_sub(delegator_stake);\n\t\t\tlet new_total = state.total;\n\n\t\t\t// set rewards\n\t\t\tSelf::do_inc_delegator_reward(\u0026delegator, delegator_stake, \u0026collator);\n\n\t\t\t// we don't unlock immediately\n\t\t\tSelf::prep_unstake(\u0026delegator, delegator_stake, false)?;\n\n\t\t\t// update top candidates and total amount at stake\n\t\t\tif state.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcollator.clone(),\n\t\t\t\t\told_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\told_total - old_stake,\n\t\t\t\t\tstate.stake,\n\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t);\n\t\t\t}\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\n\t\t\tSelf::deposit_event(Event::DelegatorLeftCollator(\n\t\t\t\tdelegator,\n\t\t\t\tcollator,\n\t\t\t\tdelegator_stake,\n\t\t\t\tnew_total,\n\t\t\t));\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Return the best `MaxSelectedCandidates` many candidates.\n\t\t///\n\t\t/// In case a collator from last round was replaced by a candidate with\n\t\t/// the same total stake during sorting, we revert this swap to\n\t\t/// prioritize collators over candidates.\n\t\tpub fn selected_candidates() -\u003e BoundedVec\u003cT::AccountId, T::MaxTopCandidates\u003e {\n\t\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\n\t\t\t// Should never fail since WASM usize are 32bits and native are either 32 or 64\n\t\t\tlet top_n = MaxSelectedCandidates::\u003cT\u003e::get().saturated_into::\u003cusize\u003e();\n\n\t\t\tlog::trace!(\"{} Candidates for {} Collator seats\", candidates.len(), top_n);\n\n\t\t\t// Choose the top MaxSelectedCandidates qualified candidates\n\t\t\tlet collators = candidates\n\t\t\t\t.into_iter()\n\t\t\t\t.take(top_n)\n\t\t\t\t.filter(|x| x.amount \u003e= T::MinCollatorStake::get())\n\t\t\t\t.map(|x| x.owner)\n\t\t\t\t.collect::\u003cVec\u003cT::AccountId\u003e\u003e();\n\n\t\t\tcollators.try_into().expect(\"Did not extend Collators q.e.d.\")\n\t\t}\n\n\t\t/// Attempts to add the stake to the set of delegators of a collator\n\t\t/// which already reached its maximum size by removing an already\n\t\t/// existing delegator with less staked value. If the given staked\n\t\t/// amount is at most the minimum staked value of the original delegator\n\t\t/// set, an error is returned.\n\t\t///\n\t\t/// Sets rewards for the removed delegator.\n\t\t///\n\t\t/// Returns a tuple which contains the updated candidate state as well\n\t\t/// as the potentially replaced delegation which will be used later when\n\t\t/// updating the storage of the replaced delegator.\n\t\t///\n\t\t/// Emits `DelegationReplaced` if the stake exceeds one of the current\n\t\t/// delegations.\n\t\t#[allow(clippy::type_complexity)]\n\t\tfn do_update_delegator(\n\t\t\tstake: Stake\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e,\n\t\t\tmut state: Candidate\u003cT::AccountId, BalanceOf\u003cT\u003e, T::MaxDelegatorsPerCollator\u003e,\n\t\t) -\u003e Result\u003cCandidateOf\u003cT, T::MaxDelegatorsPerCollator\u003e, DispatchError\u003e {\n\t\t\t// attempt to replace the last element of the set\n\t\t\tlet stake_to_remove =\n\t\t\t\tstate.delegators.try_insert_replace(stake.clone()).map_err(|err_too_many| {\n\t\t\t\t\tif err_too_many {\n\t\t\t\t\t\tError::\u003cT\u003e::TooManyDelegators\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// should never occur because we previously check this case, but let's be sure\n\t\t\t\t\t\tError::\u003cT\u003e::AlreadyDelegating\n\t\t\t\t\t}\n\t\t\t\t})?;\n\n\t\t\tstate.total = state.total.saturating_add(stake.amount);\n\n\t\t\tif let Some(stake_to_remove) = stake_to_remove {\n\t\t\t\t// update total stake\n\t\t\t\tstate.total = state.total.saturating_sub(stake_to_remove.amount);\n\n\t\t\t\t// set rewards for kicked delegator\n\t\t\t\tSelf::do_inc_delegator_reward(\n\t\t\t\t\t\u0026stake_to_remove.owner,\n\t\t\t\t\tstake_to_remove.amount,\n\t\t\t\t\t\u0026state.id,\n\t\t\t\t);\n\t\t\t\t// prepare unstaking for kicked delegator\n\t\t\t\tSelf::prep_unstake(\u0026stake_to_remove.owner, stake_to_remove.amount, true)?;\n\t\t\t\t// remove Delegator state for kicked delegator\n\t\t\t\tDelegatorState::\u003cT\u003e::remove(\u0026stake_to_remove.owner);\n\n\t\t\t\tSelf::deposit_event(Event::DelegationReplaced(\n\t\t\t\t\tstake.owner,\n\t\t\t\t\tstake.amount,\n\t\t\t\t\tstake_to_remove.owner,\n\t\t\t\t\tstake_to_remove.amount,\n\t\t\t\t\tstate.id.clone(),\n\t\t\t\t\tstate.total,\n\t\t\t\t));\n\t\t\t}\n\n\t\t\tOk(state)\n\t\t}\n\n\t\t/// Either set or increase the BalanceLock of target account to\n\t\t/// amount.\n\t\t///\n\t\t/// Consumes unstaked balance which can be unlocked in the future up to\n\t\t/// amount and updates `Unstaking` storage accordingly.\n\t\tfn increase_lock(\n\t\t\twho: \u0026T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t\tmore: BalanceOf\u003cT\u003e,\n\t\t) -\u003e Result\u003cu32, DispatchError\u003e {\n\t\t\tensure!(\n\t\t\t\tpallet_balances::Pallet::\u003cT\u003e::free_balance(who) \u003e= amount.into(),\n\t\t\t\tpallet_balances::Error::\u003cT\u003e::InsufficientBalance\n\t\t\t);\n\n\t\t\tlet mut unstaking_len = 0u32;\n\n\t\t\t// *** No Fail except during Unstaking mutation beyond this point ***\n\n\t\t\t// update Unstaking by consuming up to {amount | more}\n\t\t\t\u003cUnstaking\u003cT\u003e\u003e::try_mutate(who, |unstaking| -\u003e DispatchResult {\n\t\t\t\t// reduce {amount | more} by unstaking until either {amount | more} is zero or\n\t\t\t\t// no unstaking is left\n\t\t\t\t// if more is set, we only want to reduce by more to achieve 100 - 40 + 30 = 90\n\t\t\t\t// locked\n\t\t\t\tlet mut amt_consuming_unstaking = if more.is_zero() { amount } else { more };\n\t\t\t\tunstaking_len = unstaking.len().saturated_into();\n\t\t\t\tfor (block_number, locked_balance) in unstaking.clone() {\n\t\t\t\t\tif amt_consuming_unstaking.is_zero() {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else if locked_balance \u003e amt_consuming_unstaking {\n\t\t\t\t\t\t// amount is only reducible by locked_balance - amt_consuming_unstaking\n\t\t\t\t\t\tlet delta = locked_balance.saturating_sub(amt_consuming_unstaking);\n\t\t\t\t\t\t// replace old entry with delta\n\t\t\t\t\t\tunstaking\n\t\t\t\t\t\t\t.try_insert(block_number, delta)\n\t\t\t\t\t\t\t.map_err(|_| Error::\u003cT\u003e::NoMoreUnstaking)?;\n\t\t\t\t\t\tamt_consuming_unstaking = Zero::zero();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// amount is either still reducible or reached\n\t\t\t\t\t\tamt_consuming_unstaking =\n\t\t\t\t\t\t\tamt_consuming_unstaking.saturating_sub(locked_balance);\n\t\t\t\t\t\tunstaking.remove(\u0026block_number);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOk(())\n\t\t\t})?;\n\n\t\t\t// Either set a new lock or potentially extend the existing one if amount\n\t\t\t// exceeds the currently locked amount\n\t\t\tT::Currency::extend_lock(STAKING_ID, who, amount, WithdrawReasons::all());\n\n\t\t\tOk(unstaking_len)\n\t\t}\n\n\t\t/// Set the unlocking block for the account and corresponding amount\n\t\t/// which can be unlocked via `unlock_unstaked` after waiting at\n\t\t/// least for `StakeDuration` many blocks.\n\t\t///\n\t\t/// Throws if the amount is zero (unlikely) or if active unlocking\n\t\t/// requests exceed limit. The latter defends against stake reduction\n\t\t/// spamming.\n\t\tfn prep_unstake(\n\t\t\twho: \u0026T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t\tis_removal: bool,\n\t\t) -\u003e DispatchResult {\n\t\t\t// should never occur but let's be safe\n\t\t\tensure!(!amount.is_zero(), Error::\u003cT\u003e::StakeNotFound);\n\n\t\t\tlet now = \u003cframe_system::Pallet\u003cT\u003e\u003e::block_number();\n\t\t\tlet unlock_block = now.saturating_add(T::StakeDuration::get());\n\t\t\tlet mut unstaking = \u003cUnstaking\u003cT\u003e\u003e::get(who);\n\n\t\t\tlet allowed_unstakings = if is_removal {\n\t\t\t\t// the account was forcedly removed and we allow to fill all unstake requests\n\t\t\t\tT::MaxUnstakeRequests::get()\n\t\t\t} else {\n\t\t\t\t// we need to reserve a free slot for a forced removal of the account\n\t\t\t\tT::MaxUnstakeRequests::get().saturating_sub(1)\n\t\t\t};\n\t\t\tensure!(\n\t\t\t\tunstaking.len().saturated_into::\u003cu32\u003e() \u003c allowed_unstakings,\n\t\t\t\tError::\u003cT\u003e::NoMoreUnstaking,\n\t\t\t);\n\n\t\t\t// if existent, we have to add the current amount of same unlock_block, because\n\t\t\t// insert overwrites the current value\n\t\t\tlet amount = amount\n\t\t\t\t.saturating_add(*unstaking.get(\u0026unlock_block).unwrap_or(\u0026BalanceOf::\u003cT\u003e::zero()));\n\t\t\tunstaking\n\t\t\t\t.try_insert(unlock_block, amount)\n\t\t\t\t.map_err(|_| Error::\u003cT\u003e::NoMoreUnstaking)?;\n\t\t\t\u003cUnstaking\u003cT\u003e\u003e::insert(who, unstaking);\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Clear the CandidatePool of the candidate and remove all delegations\n\t\t/// to the candidate. Moreover, prepare unstaking for the candidate and\n\t\t/// their former delegations.\n\t\tfn remove_candidate(\n\t\t\tcollator: \u0026T::AccountId,\n\t\t\tstate: \u0026CandidateOf\u003cT, T::MaxDelegatorsPerCollator\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\t// iterate over delegators\n\t\t\tfor stake in \u0026state.delegators[..] {\n\t\t\t\t// prepare unstaking of delegator\n\t\t\t\tSelf::prep_unstake(\u0026stake.owner, stake.amount, true)?;\n\t\t\t\t// remove delegation from delegator state\n\t\t\t\tif let Some(mut delegator) = DelegatorState::\u003cT\u003e::get(\u0026stake.owner) {\n\t\t\t\t\tdelegator\n\t\t\t\t\t\t.rm_delegation(collator.clone())\n\t\t\t\t\t\t.map_err(|_| Error::\u003cT\u003e::DelegationNotFound)?;\n\t\t\t\t\tDelegatorState::\u003cT\u003e::remove(\u0026stake.owner);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prepare unstaking of collator candidate\n\t\t\tSelf::prep_unstake(\u0026state.id, state.stake, true)?;\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\t// increment rewards of collator and their delegators\n\t\t\tSelf::do_inc_collator_reward(collator, state.stake);\n\n\t\t\t// disable validator for next session if they were in the set of validators\n\t\t\tpallet_session::Pallet::\u003cT\u003e::validators()\n\t\t\t\t.into_iter()\n\t\t\t\t.enumerate()\n\t\t\t\t.find_map(|(i, id)| {\n\t\t\t\t\tif \u003cT as pallet_session::Config\u003e::ValidatorIdOf::convert(collator.clone()) ==\n\t\t\t\t\t\tSome(id)\n\t\t\t\t\t{\n\t\t\t\t\t\tSome(i)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNone\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.map(u32::saturated_from::\u003cusize\u003e)\n\t\t\t\t// FIXME: Does not prevent the collator from being able to author a block in this (or potentially the next) session. See https://github.com/paritytech/substrate/issues/8004\n\t\t\t\t.map(pallet_session::Pallet::\u003cT\u003e::disable_index);\n\n\t\t\tCandidatePool::\u003cT\u003e::remove(\u0026collator);\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Withdraw all staked currency which was unstaked at least\n\t\t/// `StakeDuration` blocks ago.\n\t\tfn do_unlock(who: \u0026T::AccountId) -\u003e Result\u003cu32, DispatchError\u003e {\n\t\t\tlet now = \u003cframe_system::Pallet\u003cT\u003e\u003e::block_number();\n\t\t\tlet mut unstaking = \u003cUnstaking\u003cT\u003e\u003e::get(who);\n\t\t\tlet unstaking_len = unstaking.len().saturated_into::\u003cu32\u003e();\n\t\t\tensure!(!unstaking.is_empty(), Error::\u003cT\u003e::UnstakingIsEmpty);\n\n\t\t\tlet mut total_unlocked: BalanceOf\u003cT\u003e = Zero::zero();\n\t\t\tlet mut total_locked: BalanceOf\u003cT\u003e = Zero::zero();\n\t\t\tlet mut expired = Vec::new();\n\n\t\t\t// check potential unlocks\n\t\t\tfor (block_number, locked_balance) in unstaking.clone().into_iter() {\n\t\t\t\tif block_number \u003c= now {\n\t\t\t\t\texpired.push(block_number);\n\t\t\t\t\ttotal_unlocked = total_unlocked.saturating_add(locked_balance);\n\t\t\t\t} else {\n\t\t\t\t\ttotal_locked = total_locked.saturating_add(locked_balance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor block_number in expired {\n\t\t\t\tunstaking.remove(\u0026block_number);\n\t\t\t}\n\n\t\t\t// iterate balance locks to retrieve amount of locked balance\n\t\t\tlet locks = Locks::\u003cT\u003e::get(who);\n\t\t\ttotal_locked = if let Some(BalanceLock { amount, .. }) =\n\t\t\t\tlocks.iter().find(|l| l.id == STAKING_ID)\n\t\t\t{\n\t\t\t\tamount.saturating_sub(total_unlocked.into()).into()\n\t\t\t} else {\n\t\t\t\t// should never fail to find the lock since we checked whether unstaking is not\n\t\t\t\t// empty but let's be safe\n\t\t\t\tZero::zero()\n\t\t\t};\n\n\t\t\tif total_locked.is_zero() {\n\t\t\t\tT::Currency::remove_lock(STAKING_ID, who);\n\t\t\t\t\u003cUnstaking\u003cT\u003e\u003e::remove(who);\n\t\t\t} else {\n\t\t\t\tT::Currency::set_lock(STAKING_ID, who, total_locked, WithdrawReasons::all());\n\t\t\t\t\u003cUnstaking\u003cT\u003e\u003e::insert(who, unstaking);\n\t\t\t}\n\n\t\t\tOk(unstaking_len)\n\t\t}\n\n\t\t/// Checks whether a delegator can still delegate in this round, e.g.,\n\t\t/// if they have not delegated MaxDelegationsPerRound many times\n\t\t/// already in this round.\n\t\tfn get_delegation_counter(\n\t\t\tdelegator: \u0026T::AccountId,\n\t\t) -\u003e Result\u003cDelegationCounter, DispatchError\u003e {\n\t\t\tlet last_delegation = \u003cLastDelegation\u003cT\u003e\u003e::get(delegator);\n\t\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\n\t\t\t// reset counter if the round advanced since last delegation\n\t\t\tlet counter =\n\t\t\t\tif last_delegation.round \u003c round.current { 0u32 } else { last_delegation.counter };\n\n\t\t\tensure!(\n\t\t\t\tcounter \u003c T::MaxDelegationsPerRound::get(),\n\t\t\t\tError::\u003cT\u003e::DelegationsPerRoundExceeded\n\t\t\t);\n\n\t\t\tOk(DelegationCounter { round: round.current, counter: counter.saturating_add(1) })\n\t\t}\n\n\t\t/// Calculates the network rewards per block with the current data and\n\t\t/// issues these rewards to the network. The imbalance will be handled\n\t\t/// in `on_initialize` by adding it to the free balance of\n\t\t/// `NetworkRewardBeneficiary`.\n\t\t///\n\t\t/// Over the course of an entire year, the network rewards equal the\n\t\t/// maximum annual collator staking rewards multiplied with the\n\t\t/// NetworkRewardRate. E.g., assuming 10% annual collator reward rate,\n\t\t/// 10% max staking rate, 200k KILT max collator stake and 30 collators:\n\t\t/// NetworkRewards = NetworkRewardRate * 10% * 10% * 200_000 KILT * 30\n\t\t///\n\t\t/// The expected rewards are the product of\n\t\t///  * the current total maximum collator rewards\n\t\t///  * and the configured NetworkRewardRate\n\t\t///\n\t\t/// `col_reward_rate_per_block * col_max_stake * max_num_of_collators *\n\t\t/// NetworkRewardRate`\n\t\tfn issue_network_reward() -\u003e NegativeImbalanceOf\u003cT\u003e {\n\t\t\t// Multiplication with Perquintill cannot overflow\n\t\t\tlet max_col_rewards = InflationConfig::\u003cT\u003e::get().collator.reward_rate.per_block *\n\t\t\t\tMaxCollatorCandidateStake::\u003cT\u003e::get() *\n\t\t\t\tMaxSelectedCandidates::\u003cT\u003e::get().into();\n\t\t\tlet network_reward = T::NetworkRewardRate::get() * max_col_rewards;\n\n\t\t\tT::Currency::issue(network_reward)\n\t\t}\n\n\t\t/// Calculates the collator staking rewards for authoring `multiplier`\n\t\t/// many blocks based on the given stake.\n\t\t///\n\t\t/// Depends on the current total issuance and staking reward\n\t\t/// configuration for collators.\n\t\tfn calc_block_rewards_collator(\n\t\t\tstake: BalanceOf\u003cT\u003e,\n\t\t\tmultiplier: BalanceOf\u003cT\u003e,\n\t\t) -\u003e BalanceOf\u003cT\u003e {\n\t\t\tlet total_issuance = T::Currency::total_issuance();\n\t\t\tlet TotalStake { collators: total_collators, .. } = \u003cTotalCollatorStake\u003cT\u003e\u003e::get();\n\t\t\tlet staking_rate = Perquintill::from_rational(total_collators, total_issuance);\n\n\t\t\tInflationConfig::\u003cT\u003e::get().collator.compute_reward::\u003cT\u003e(\n\t\t\t\tstake,\n\t\t\t\tstaking_rate,\n\t\t\t\tmultiplier,\n\t\t\t)\n\t\t}\n\n\t\t/// Calculates the delegator staking rewards for `multiplier` many\n\t\t/// blocks based on the given stake.\n\t\t///\n\t\t/// Depends on the current total issuance and staking reward\n\t\t/// configuration for delegators.\n\t\tfn calc_block_rewards_delegator(\n\t\t\tstake: BalanceOf\u003cT\u003e,\n\t\t\tmultiplier: BalanceOf\u003cT\u003e,\n\t\t) -\u003e BalanceOf\u003cT\u003e {\n\t\t\tlet total_issuance = T::Currency::total_issuance();\n\t\t\tlet TotalStake { delegators: total_delegators, .. } = \u003cTotalCollatorStake\u003cT\u003e\u003e::get();\n\t\t\tlet staking_rate = Perquintill::from_rational(total_delegators, total_issuance);\n\n\t\t\tInflationConfig::\u003cT\u003e::get().delegator.compute_reward::\u003cT\u003e(\n\t\t\t\tstake,\n\t\t\t\tstaking_rate,\n\t\t\t\tmultiplier,\n\t\t\t)\n\t\t}\n\n\t\t/// Calculates the staking rewards for a given account address.\n\t\t///\n\t\t/// At least used in Runtime API.\n\t\tpub fn get_unclaimed_staking_rewards(acc: \u0026T::AccountId) -\u003e BalanceOf\u003cT\u003e {\n\t\t\tlet mut reward_count = RewardCount::\u003cT\u003e::get(acc);\n\t\t\tlet rewards = Rewards::\u003cT\u003e::get(acc);\n\n\t\t\t// delegators and collators need to be handled differently\n\t\t\tif let Some(delegator_state) = DelegatorState::\u003cT\u003e::get(acc) {\n\t\t\t\t// delegator reward counts do not automatically increment in order to be\n\t\t\t\t// scalable, see [increment_delegator_rewards] for details\n\t\t\t\t// therefore, we need to query the counter of the collator\n\t\t\t\t// (`delegator_stare.owner`)\n\t\t\t\treward_count = reward_count.saturating_add(\n\t\t\t\t\tdelegator_state.owner.map(RewardCount::\u003cT\u003e::get).unwrap_or(0u32),\n\t\t\t\t);\n\t\t\t\tlet stake = delegator_state.amount;\n\t\t\t\t// rewards += stake * (self_count + collator_count) * delegator_reward_rate\n\t\t\t\trewards\n\t\t\t\t\t.saturating_add(Self::calc_block_rewards_delegator(stake, reward_count.into()))\n\t\t\t} else if Self::is_active_candidate(acc).is_some() {\n\t\t\t\tlet stake = CandidatePool::\u003cT\u003e::get(acc)\n\t\t\t\t\t.map(|state| state.stake)\n\t\t\t\t\t.unwrap_or_else(BalanceOf::\u003cT\u003e::zero);\n\t\t\t\t// rewards += stake * self_count * collator_reward_rate\n\t\t\t\trewards\n\t\t\t\t\t.saturating_add(Self::calc_block_rewards_collator(stake, reward_count.into()))\n\t\t\t} else {\n\t\t\t\tBalanceOf::\u003cT\u003e::zero()\n\t\t\t}\n\t\t}\n\n\t\t/// Increment the accumulated rewards of a collator by consuming their\n\t\t/// current rewards counter.\n\t\t///\n\t\t/// Moreover, automatically increments all associated delegators since\n\t\t/// their reward increment is dependend on the collator reward counter.\n\t\t///\n\t\t/// Resets all reward counters of the collator and their delegators to\n\t\t/// zero.\n\t\tfn do_inc_collator_reward(collator: \u0026T::AccountId, stake: BalanceOf\u003cT\u003e) -\u003e usize {\n\t\t\t// get reward counters\n\t\t\tlet col_reward_count = RewardCount::\u003cT\u003e::get(collator);\n\n\t\t\t// set reward data for collator\n\t\t\tRewards::\u003cT\u003e::mutate(collator, |reward| {\n\t\t\t\t*reward = reward.saturating_add(Self::calc_block_rewards_collator(\n\t\t\t\t\tstake,\n\t\t\t\t\tcol_reward_count.into(),\n\t\t\t\t));\n\t\t\t});\n\n\t\t\t// set reward data for delegators\n\t\t\tlet num_delegators = if let Some(state) = CandidatePool::\u003cT\u003e::get(collator.clone()) {\n\t\t\t\tlet num_delegators = state.delegators.len();\n\t\t\t\tfor Stake { owner, amount } in state.delegators {\n\t\t\t\t\tSelf::do_inc_delegator_reward(\u0026owner, amount, collator);\n\t\t\t\t\t// Reset delegator counter since collator counter will be reset\n\t\t\t\t\tRewardCount::\u003cT\u003e::insert(owner, 0);\n\t\t\t\t}\n\t\t\t\tnum_delegators\n\t\t\t} else {\n\t\t\t\t0usize\n\t\t\t};\n\n\t\t\t// Reset collator reward count\n\t\t\tRewardCount::\u003cT\u003e::insert(collator, 0);\n\n\t\t\tnum_delegators\n\t\t}\n\n\t\t/// Increment the accumulated rewards of a delegator by consuming their\n\t\t/// current rewards counter. The counter will be reset to the collator\n\t\t/// counter.\n\t\tfn do_inc_delegator_reward(\n\t\t\tacc: \u0026T::AccountId,\n\t\t\tstake: BalanceOf\u003cT\u003e,\n\t\t\tcol: \u0026T::AccountId,\n\t\t) -\u003e Weight {\n\t\t\t// get reward counters\n\t\t\tlet del_reward_count = RewardCount::\u003cT\u003e::get(acc);\n\t\t\tlet col_reward_count = RewardCount::\u003cT\u003e::get(col);\n\t\t\tlet diff = col_reward_count.saturating_sub(del_reward_count);\n\n\t\t\t// only update if collator has higher reward count\n\t\t\tif diff \u003e 0 {\n\t\t\t\tRewards::\u003cT\u003e::mutate(acc, |reward| {\n\t\t\t\t\t*reward = reward\n\t\t\t\t\t\t.saturating_add(Self::calc_block_rewards_delegator(stake, diff.into()));\n\t\t\t\t});\n\t\t\t\t// align with collator counter such that incrementing would\n\t\t\t\t// lead to 0 rewards until the collator counter increases\n\t\t\t\tRewardCount::\u003cT\u003e::insert(acc, col_reward_count);\n\n\t\t\t\t// 4 reads from reward calc\n\t\t\t\tT::DbWeight::get().reads_writes(6, 2)\n\t\t\t} else {\n\t\t\t\tT::DbWeight::get().reads(2)\n\t\t\t}\n\t\t}\n\n\t\t/// Calculates the current staking and reward rates for collators and\n\t\t/// delegators.\n\t\t///\n\t\t/// At least used in Runtime API.\n\t\tpub fn get_staking_rates() -\u003e runtime_api::StakingRates {\n\t\t\tlet total_issuance = T::Currency::total_issuance();\n\t\t\tlet total_stake = TotalCollatorStake::\u003cT\u003e::get();\n\t\t\tlet inflation_config = InflationConfig::\u003cT\u003e::get();\n\t\t\tlet collator_staking_rate =\n\t\t\t\tPerquintill::from_rational(total_stake.collators, total_issuance);\n\t\t\tlet delegator_staking_rate =\n\t\t\t\tPerquintill::from_rational(total_stake.delegators, total_issuance);\n\t\t\tlet collator_reward_rate = Perquintill::from_rational(\n\t\t\t\tinflation_config.collator.max_rate.deconstruct(),\n\t\t\t\tcollator_staking_rate.deconstruct(),\n\t\t\t) * inflation_config.collator.reward_rate.annual;\n\t\t\tlet delegator_reward_rate = Perquintill::from_rational(\n\t\t\t\tinflation_config.delegator.max_rate.deconstruct(),\n\t\t\t\tdelegator_staking_rate.deconstruct(),\n\t\t\t) * inflation_config.delegator.reward_rate.annual;\n\n\t\t\truntime_api::StakingRates {\n\t\t\t\tcollator_staking_rate,\n\t\t\t\tcollator_reward_rate,\n\t\t\t\tdelegator_staking_rate,\n\t\t\t\tdelegator_reward_rate,\n\t\t\t}\n\t\t}\n\t}\n\n\timpl\u003cT\u003e pallet_authorship::EventHandler\u003cT::AccountId, T::BlockNumber\u003e for Pallet\u003cT\u003e\n\twhere\n\t\tT: Config + pallet_authorship::Config + pallet_session::Config,\n\t{\n\t\t/// Increments the reward counter of the block author by the current\n\t\t/// number of collators in the session.\n\t\tfn note_author(author: T::AccountId) {\n\t\t\t// should always include state except if the collator has been forcedly removed\n\t\t\t// via `force_remove_candidate` in the current or previous round\n\t\t\tif CandidatePool::\u003cT\u003e::get(\u0026author).is_some() {\n\t\t\t\t// necessary to compensate for a potentially fluctuating number of collators\n\t\t\t\tlet authors = pallet_session::Pallet::\u003cT\u003e::validators();\n\t\t\t\tRewardCount::\u003cT\u003e::mutate(\u0026author, |count| {\n\t\t\t\t\t*count = count.saturating_add(authors.len().saturated_into::\u003cu32\u003e());\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tframe_system::Pallet::\u003cT\u003e::register_extra_weight_unchecked(\n\t\t\t\tT::DbWeight::get().reads_writes(2, 1),\n\t\t\t\tDispatchClass::Mandatory,\n\t\t\t);\n\t\t}\n\t}\n\n\timpl\u003cT: Config\u003e pallet_session::SessionManager\u003cT::AccountId\u003e for Pallet\u003cT\u003e {\n\t\t/// 1. A new session starts.\n\t\t/// 2. In hook new_session: Read the current top n candidates from the\n\t\t///    TopCandidates and assign this set to author blocks for the next\n\t\t///    session.\n\t\t/// 3. AuRa queries the authorities from the session pallet for\n\t\t///    this session and picks authors on round-robin-basis from list of\n\t\t///    authorities.\n\t\tfn new_session(new_index: SessionIndex) -\u003e Option\u003cVec\u003cT::AccountId\u003e\u003e {\n\t\t\tlog::debug!(\n\t\t\t\t\"assembling new collators for new session {} at #{:?}\",\n\t\t\t\tnew_index,\n\t\t\t\t\u003cframe_system::Pallet\u003cT\u003e\u003e::block_number(),\n\t\t\t);\n\n\t\t\tframe_system::Pallet::\u003cT\u003e::register_extra_weight_unchecked(\n\t\t\t\tT::DbWeight::get().reads(2),\n\t\t\t\tDispatchClass::Mandatory,\n\t\t\t);\n\n\t\t\tlet collators = Pallet::\u003cT\u003e::selected_candidates().to_vec();\n\t\t\tif collators.is_empty() {\n\t\t\t\t// we never want to pass an empty set of collators. This would brick the chain.\n\t\t\t\tlog::error!(\"💥 keeping old session because of empty collator set!\");\n\t\t\t\tNone\n\t\t\t} else {\n\t\t\t\tSome(collators)\n\t\t\t}\n\t\t}\n\n\t\tfn end_session(_end_index: SessionIndex) {\n\t\t\t// we too are not caring.\n\t\t}\n\n\t\tfn start_session(_start_index: SessionIndex) {\n\t\t\t// we too are not caring.\n\t\t}\n\t}\n\n\timpl\u003cT: Config\u003e ShouldEndSession\u003cT::BlockNumber\u003e for Pallet\u003cT\u003e {\n\t\tfn should_end_session(now: T::BlockNumber) -\u003e bool {\n\t\t\tframe_system::Pallet::\u003cT\u003e::register_extra_weight_unchecked(\n\t\t\t\tT::DbWeight::get().reads(2),\n\t\t\t\tDispatchClass::Mandatory,\n\t\t\t);\n\n\t\t\tlet mut round = \u003cRound\u003cT\u003e\u003e::get();\n\t\t\t// always update when a new round should start\n\t\t\tif round.should_update(now) {\n\t\t\t\ttrue\n\t\t\t} else if \u003cForceNewRound\u003cT\u003e\u003e::get() {\n\t\t\t\tframe_system::Pallet::\u003cT\u003e::register_extra_weight_unchecked(\n\t\t\t\t\tT::DbWeight::get().writes(2),\n\t\t\t\t\tDispatchClass::Mandatory,\n\t\t\t\t);\n\t\t\t\t// check for forced new round\n\t\t\t\t\u003cForceNewRound\u003cT\u003e\u003e::put(false);\n\t\t\t\tround.update(now);\n\t\t\t\t\u003cRound\u003cT\u003e\u003e::put(round);\n\t\t\t\tSelf::deposit_event(Event::NewRound(round.first, round.current));\n\t\t\t\ttrue\n\t\t\t} else {\n\t\t\t\tfalse\n\t\t\t}\n\t\t}\n\t}\n\n\timpl\u003cT: Config\u003e EstimateNextSessionRotation\u003cT::BlockNumber\u003e for Pallet\u003cT\u003e {\n\t\tfn average_session_length() -\u003e T::BlockNumber {\n\t\t\t\u003cRound\u003cT\u003e\u003e::get().length\n\t\t}\n\n\t\tfn estimate_current_session_progress(now: T::BlockNumber) -\u003e (Option\u003cPermill\u003e, Weight) {\n\t\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\t\t\tlet passed_blocks = now.saturating_sub(round.first);\n\n\t\t\t(\n\t\t\t\tSome(Permill::from_rational(passed_blocks, round.length)),\n\t\t\t\t// One read for the round info, blocknumber is read free\n\t\t\t\tT::DbWeight::get().reads(1),\n\t\t\t)\n\t\t}\n\n\t\tfn estimate_next_session_rotation(\n\t\t\t_now: T::BlockNumber,\n\t\t) -\u003e (Option\u003cT::BlockNumber\u003e, Weight) {\n\t\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\n\t\t\t(\n\t\t\t\tSome(round.first + round.length),\n\t\t\t\t// One read for the round info, blocknumber is read free\n\t\t\t\tT::DbWeight::get().reads(1),\n\t\t\t)\n\t\t}\n\t}\n}\n","traces":[{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":961,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":965,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":966,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1028,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1032,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1042,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1048,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1050,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1096,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1098,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1662,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1718,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1726,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1746,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1749,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1766,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1775,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1840,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1846,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1858,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1875,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1877,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1886,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1890,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1891,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1906,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1908,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1914,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1917,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1919,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1922,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1926,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1930,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1935,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1941,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1944,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1945,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1948,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1949,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1951,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1953,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1954,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1959,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1966,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1977,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1979,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1992,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1993,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2008,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2009,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2011,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2017,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2018,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2028,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2029,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2047,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2048,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2050,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2055,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2057,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2058,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2060,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2061,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2065,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2068,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2071,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2073,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2074,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2076,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2077,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2078,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2081,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2083,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2084,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2087,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2089,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2097,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2098,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2662,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2674,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":804},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","mock.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n//! Test utilities\n\n#![allow(clippy::from_over_into)]\n\nuse super::*;\nuse crate::{self as stake, types::NegativeImbalanceOf};\nuse frame_support::{\n\tassert_ok, construct_runtime, parameter_types,\n\ttraits::{Currency, GenesisBuild, OnFinalize, OnInitialize, OnUnbalanced},\n};\nuse pallet_authorship::EventHandler;\nuse sp_consensus_aura::sr25519::AuthorityId;\nuse sp_core::H256;\nuse sp_runtime::{\n\timpl_opaque_keys,\n\ttesting::{Header, UintAuthorityId},\n\ttraits::{BlakeTwo256, ConvertInto, IdentityLookup, OpaqueKeys},\n\tPerbill, Perquintill,\n};\nuse sp_std::fmt::Debug;\n\npub(crate) type UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic\u003cTest\u003e;\npub(crate) type Block = frame_system::mocking::MockBlock\u003cTest\u003e;\npub(crate) type Balance = u128;\npub(crate) type AccountId = u64;\npub(crate) type BlockNumber = u64;\n\npub(crate) const MILLI_KILT: Balance = 10u128.pow(12);\npub(crate) const MAX_COLLATOR_STAKE: Balance = 200_000 * 1000 * MILLI_KILT;\npub(crate) const BLOCKS_PER_ROUND: BlockNumber = 5;\npub(crate) const DECIMALS: Balance = 1000 * MILLI_KILT;\npub(crate) const TREASURY_ACC: AccountId = u64::MAX;\n\n// Configure a mock runtime to test the pallet.\nconstruct_runtime!(\n\tpub enum Test where\n\t\tBlock = Block,\n\t\tNodeBlock = Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e},\n\t\tAura: pallet_aura::{Pallet, Storage},\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e},\n\t\tStakePallet: stake::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e},\n\t\tAuthorship: pallet_authorship::{Pallet, Storage},\n\t}\n);\n\nparameter_types! {\n\tpub const BlockHashCount: u64 = 250;\n\tpub const MaximumBlockLength: u32 = 2 * 1024;\n\tpub const AvailableBlockRatio: Perbill = Perbill::one();\n\tpub const SS58Prefix: u8 = 42;\n}\n\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\ttype DbWeight = ();\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Index = u64;\n\ttype BlockNumber = BlockNumber;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Hash = H256;\n\ttype Hashing = BlakeTwo256;\n\ttype AccountId = AccountId;\n\ttype Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n\ttype Header = Header;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BlockHashCount = BlockHashCount;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype SS58Prefix = SS58Prefix;\n\ttype OnSetCode = ();\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = 1;\n}\n\nimpl pallet_balances::Config for Test {\n\ttype MaxLocks = ();\n\ttype MaxReserves = ();\n\ttype ReserveIdentifier = [u8; 8];\n\ttype Balance = Balance;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n}\n\nimpl pallet_aura::Config for Test {\n\ttype AuthorityId = AuthorityId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxCollatorCandidates;\n}\n\nimpl pallet_authorship::Config for Test {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = Pallet\u003cTest\u003e;\n}\n\nparameter_types! {\n\tpub const MinBlocksPerRound: BlockNumber = 3;\n\tpub const StakeDuration: u32 = 2;\n\tpub const ExitQueueDelay: u32 = 2;\n\tpub const DefaultBlocksPerRound: BlockNumber = BLOCKS_PER_ROUND;\n\tpub const MinCollators: u32 = 2;\n\tpub const MaxDelegationsPerRound: u32 = 2;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxDelegatorsPerCollator: u32 = 4;\n\tpub const MinCollatorStake: Balance = 10;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxCollatorCandidates: u32 = 10;\n\tpub const MinDelegatorStake: Balance = 5;\n\tpub const MaxUnstakeRequests: u32 = 6;\n\tpub const NetworkRewardRate: Perquintill = Perquintill::from_percent(10);\n\tpub const NetworkRewardStart: BlockNumber = 5 * 5 * 60 * 24 * 36525 / 100;\n\tpub const CollatorRewardRateDecay: Perquintill = Perquintill::from_percent(98);\n}\n\npub struct ToBeneficiary();\nimpl OnUnbalanced\u003cNegativeImbalanceOf\u003cTest\u003e\u003e for ToBeneficiary {\n\tfn on_nonzero_unbalanced(amount: NegativeImbalanceOf\u003cTest\u003e) {\n\t\t// Must resolve into existing but better to be safe.\n\t\t\u003cTest as Config\u003e::Currency::resolve_creating(\u0026TREASURY_ACC, amount);\n\t}\n}\n\nimpl Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyBalance = \u003cSelf as pallet_balances::Config\u003e::Balance;\n\ttype MinBlocksPerRound = MinBlocksPerRound;\n\ttype DefaultBlocksPerRound = DefaultBlocksPerRound;\n\ttype StakeDuration = StakeDuration;\n\ttype ExitQueueDelay = ExitQueueDelay;\n\ttype MinCollators = MinCollators;\n\ttype MinRequiredCollators = MinCollators;\n\ttype MaxDelegationsPerRound = MaxDelegationsPerRound;\n\ttype MaxDelegatorsPerCollator = MaxDelegatorsPerCollator;\n\ttype MinCollatorStake = MinCollatorStake;\n\ttype MinCollatorCandidateStake = MinCollatorStake;\n\ttype MaxTopCandidates = MaxCollatorCandidates;\n\ttype MinDelegatorStake = MinDelegatorStake;\n\ttype MaxUnstakeRequests = MaxUnstakeRequests;\n\ttype NetworkRewardRate = NetworkRewardRate;\n\ttype NetworkRewardStart = NetworkRewardStart;\n\ttype NetworkRewardBeneficiary = ToBeneficiary;\n\ttype CollatorRewardRateDecay = CollatorRewardRateDecay;\n\ttype WeightInfo = ();\n\tconst BLOCKS_PER_YEAR: Self::BlockNumber = 5 * 60 * 24 * 36525 / 100;\n}\n\nimpl_opaque_keys! {\n\tpub struct MockSessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\nparameter_types! {\n\tpub const DisabledValidatorsThreshold: Perbill = Perbill::from_percent(17);\n}\n\nimpl pallet_session::Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = AccountId;\n\ttype ValidatorIdOf = ConvertInto;\n\ttype ShouldEndSession = StakePallet;\n\ttype NextSessionRotation = StakePallet;\n\ttype SessionManager = StakePallet;\n\ttype SessionHandler = \u003cMockSessionKeys as OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = MockSessionKeys;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = 1;\n}\n\nimpl pallet_timestamp::Config for Test {\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n}\n\npub(crate) struct ExtBuilder {\n\t// endowed accounts with balances\n\tbalances: Vec\u003c(AccountId, Balance)\u003e,\n\t// [collator, amount]\n\tcollators: Vec\u003c(AccountId, Balance)\u003e,\n\t// [delegator, collator, delegation_amount]\n\tdelegators: Vec\u003c(AccountId, AccountId, Balance)\u003e,\n\t// inflation config\n\tinflation_config: InflationInfo,\n\t// blocks per round\n\tblocks_per_round: BlockNumber,\n}\n\nimpl Default for ExtBuilder {\n\tfn default() -\u003e ExtBuilder {\n\t\tExtBuilder {\n\t\t\tbalances: vec![],\n\t\t\tdelegators: vec![],\n\t\t\tcollators: vec![],\n\t\t\tblocks_per_round: BLOCKS_PER_ROUND,\n\t\t\tinflation_config: InflationInfo::new(\n\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\tPerquintill::from_percent(10),\n\t\t\t\tPerquintill::from_percent(15),\n\t\t\t\tPerquintill::from_percent(40),\n\t\t\t\tPerquintill::from_percent(10),\n\t\t\t),\n\t\t}\n\t}\n}\n\nimpl ExtBuilder {\n\t#[must_use]\n\tpub(crate) fn with_balances(mut self, balances: Vec\u003c(AccountId, Balance)\u003e) -\u003e Self {\n\t\tself.balances = balances;\n\t\tself\n\t}\n\n\t#[must_use]\n\tpub(crate) fn with_collators(mut self, collators: Vec\u003c(AccountId, Balance)\u003e) -\u003e Self {\n\t\tself.collators = collators;\n\t\tself\n\t}\n\n\t#[must_use]\n\tpub(crate) fn with_delegators(\n\t\tmut self,\n\t\tdelegators: Vec\u003c(AccountId, AccountId, Balance)\u003e,\n\t) -\u003e Self {\n\t\tself.delegators = delegators;\n\t\tself\n\t}\n\n\t#[must_use]\n\tpub(crate) fn with_inflation(\n\t\tmut self,\n\t\tcol_max: u64,\n\t\tcol_rewards: u64,\n\t\td_max: u64,\n\t\td_rewards: u64,\n\t\tblocks_per_round: BlockNumber,\n\t) -\u003e Self {\n\t\tself.inflation_config = InflationInfo::new(\n\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\tPerquintill::from_percent(col_max),\n\t\t\tPerquintill::from_percent(col_rewards),\n\t\t\tPerquintill::from_percent(d_max),\n\t\t\tPerquintill::from_percent(d_rewards),\n\t\t);\n\t\tself.blocks_per_round = blocks_per_round;\n\n\t\tself\n\t}\n\n\t#[must_use]\n\tpub(crate) fn set_blocks_per_round(mut self, blocks_per_round: BlockNumber) -\u003e Self {\n\t\tself.blocks_per_round = blocks_per_round;\n\t\tself\n\t}\n\n\tpub(crate) fn build(self) -\u003e sp_io::TestExternalities {\n\t\tlet mut t = frame_system::GenesisConfig::default()\n\t\t\t.build_storage::\u003cTest\u003e()\n\t\t\t.expect(\"Frame system builds valid default genesis config\");\n\n\t\tpallet_balances::GenesisConfig::\u003cTest\u003e { balances: self.balances.clone() }\n\t\t\t.assimilate_storage(\u0026mut t)\n\t\t\t.expect(\"Pallet balances storage can be assimilated\");\n\n\t\tlet mut stakers: Vec\u003c(AccountId, Option\u003cAccountId\u003e, Balance)\u003e = Vec::new();\n\t\tfor collator in self.collators.clone() {\n\t\t\tstakers.push((collator.0, None, collator.1));\n\t\t}\n\t\tfor delegator in self.delegators.clone() {\n\t\t\tstakers.push((delegator.0, Some(delegator.1), delegator.2));\n\t\t}\n\t\tstake::GenesisConfig::\u003cTest\u003e {\n\t\t\tstakers,\n\t\t\tinflation_config: self.inflation_config.clone(),\n\t\t\tmax_candidate_stake: 160_000_000 * DECIMALS,\n\t\t\tmax_selected_candidates: 2,\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.expect(\"Parachain Staking's storage can be assimilated\");\n\n\t\t// stashes are the AccountId\n\t\tlet session_keys: Vec\u003c_\u003e = self\n\t\t\t.collators\n\t\t\t.iter()\n\t\t\t.map(|(k, _)| (*k, *k, MockSessionKeys { aura: UintAuthorityId(*k).to_public_key() }))\n\t\t\t.collect();\n\n\t\t// NOTE: this will initialize the aura authorities\n\t\t// through OneSessionHandler::on_genesis_session\n\t\tpallet_session::GenesisConfig::\u003cTest\u003e { keys: session_keys }\n\t\t\t.assimilate_storage(\u0026mut t)\n\t\t\t.expect(\"Session Pallet's storage can be assimilated\");\n\n\t\tlet mut ext = sp_io::TestExternalities::new(t);\n\n\t\tif self.blocks_per_round != BLOCKS_PER_ROUND {\n\t\t\text.execute_with(|| {\n\t\t\t\tStakePallet::set_blocks_per_round(RuntimeOrigin::root(), self.blocks_per_round)\n\t\t\t\t\t.expect(\"Ran into issues when setting blocks_per_round\");\n\t\t\t});\n\t\t}\n\n\t\text.execute_with(|| System::set_block_number(1));\n\t\text\n\t}\n\tpub fn build_and_execute_with_sanity_tests(self, test: impl FnOnce()) {\n\t\tself.build().execute_with(|| {\n\t\t\ttest();\n\t\t\tcrate::try_state::do_try_state::\u003cTest\u003e()\n\t\t\t\t.expect(\"Sanity test for parachain staking failed.\");\n\t\t})\n\t}\n}\n\n/// Compare whether the difference of both sides is at most `precision * left`.\npub(crate) fn almost_equal(left: Balance, right: Balance, precision: Perbill) -\u003e bool {\n\tlet err = precision * left;\n\tleft.max(right) - left.min(right) \u003c= err\n}\n\n/// Incrementelly traverses from the current block to the provided one and\n/// potentially sets block authors.\n///\n/// If for a block `i` the corresponding index of the authors input is set, this\n/// account is regarded to be the block author and thus gets noted.\n///\n/// NOTE: At most, this updates the RewardCount of the block author but does not\n/// increment rewards or claim them. Please use `roll_to_claim_rewards` in that\n/// case.\npub(crate) fn roll_to(n: BlockNumber, authors: Vec\u003cOption\u003cAccountId\u003e\u003e) {\n\twhile System::block_number() \u003c n {\n\t\tif let Some(Some(author)) = authors.get((System::block_number()) as usize) {\n\t\t\tStakePallet::note_author(*author);\n\t\t}\n\t\t\u003cAllPalletsWithSystem as OnFinalize\u003cu64\u003e\u003e::on_finalize(System::block_number());\n\t\tSystem::set_block_number(System::block_number() + 1);\n\t\t\u003cAllPalletsWithSystem as OnInitialize\u003cu64\u003e\u003e::on_initialize(System::block_number());\n\t}\n}\n\n#[allow(unused_must_use)]\n/// Incrementelly traverses from the current block to the provided one and\n/// potentially sets block authors.\n///\n/// If existent, rewards of the block author and their delegators are\n/// incremented and claimed.\n///\n/// If for a block `i` the corresponding index of the authors input is set, this\n/// account is regarded to be the block author and thus gets noted.\npub(crate) fn roll_to_claim_rewards(n: BlockNumber, authors: Vec\u003cOption\u003cAccountId\u003e\u003e) {\n\twhile System::block_number() \u003c n {\n\t\tif let Some(Some(author)) = authors.get((System::block_number()) as usize) {\n\t\t\tStakePallet::note_author(*author);\n\t\t\t// author must convert RewardCount to Rewards before claiming\n\t\t\tassert_ok!(StakePallet::increment_collator_rewards(RuntimeOrigin::signed(*author)));\n\n\t\t\t// author claims rewards\n\t\t\tassert_ok!(StakePallet::claim_rewards(RuntimeOrigin::signed(*author)));\n\n\t\t\t// claim rewards for delegators\n\t\t\tlet col_state =\n\t\t\t\tStakePallet::candidate_pool(author).expect(\"Block author must be candidate\");\n\t\t\tfor delegation in col_state.delegators {\n\t\t\t\t// NOTE: cannot use assert_ok! as we sometimes expect zero rewards for\n\t\t\t\t// delegators such that the claiming would throw\n\t\t\t\tStakePallet::claim_rewards(RuntimeOrigin::signed(delegation.owner));\n\t\t\t}\n\t\t}\n\t\t\u003cAllPalletsWithSystem as OnFinalize\u003cu64\u003e\u003e::on_finalize(System::block_number());\n\t\tSystem::set_block_number(System::block_number() + 1);\n\t\t\u003cAllPalletsWithSystem as OnInitialize\u003cu64\u003e\u003e::on_initialize(System::block_number());\n\t}\n}\n\npub(crate) fn last_event() -\u003e RuntimeEvent {\n\tSystem::events().pop().expect(\"Event expected\").event\n}\n\npub(crate) fn events() -\u003e Vec\u003cpallet::Event\u003cTest\u003e\u003e {\n\tSystem::events()\n\t\t.into_iter()\n\t\t.map(|r| r.event)\n\t\t.filter_map(|e| if let RuntimeEvent::StakePallet(inner) = e { Some(inner) } else { None })\n\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","runtime_api.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse frame_support::dispatch::fmt::Debug;\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::Perquintill;\n\n#[derive(Decode, Encode, TypeInfo, MaxEncodedLen, PartialEq, Eq, Debug)]\npub struct StakingRates {\n\tpub collator_staking_rate: Perquintill,\n\tpub collator_reward_rate: Perquintill,\n\tpub delegator_staking_rate: Perquintill,\n\tpub delegator_reward_rate: Perquintill,\n}\n\nsp_api::decl_runtime_apis! {\n\tpub trait ParachainStakingApi\u003cAccountId, Balance\u003e\n\twhere\n\t\tAccountId:  Eq + PartialEq + Debug + Encode + Decode + Clone,\n\t\tBalance: Encode + Decode + MaxEncodedLen + Copy + Clone + Debug + Eq + PartialEq\n\t{\n\t\tfn get_unclaimed_staking_rewards(account: \u0026AccountId) -\u003e Balance;\n\t\tfn get_staking_rates() -\u003e StakingRates;\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","set.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2023 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\nuse frame_support::{traits::Get, BoundedVec, DefaultNoBound, RuntimeDebug};\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::{traits::Zero, SaturatedConversion};\nuse sp_std::{\n\tcmp::Ordering,\n\tconvert::TryInto,\n\tops::{Index, Range, RangeFull},\n};\n\n#[cfg(feature = \"std\")]\nuse sp_std::prelude::*;\n\n/// An ordered set backed by `BoundedVec`.\n#[derive(\n\tPartialEq, Eq, Encode, Decode, DefaultNoBound, Clone, TypeInfo, MaxEncodedLen, RuntimeDebug,\n)]\n#[scale_info(skip_type_params(S))]\n#[codec(mel_bound(T: MaxEncodedLen))]\npub struct OrderedSet\u003cT, S: Get\u003cu32\u003e\u003e(BoundedVec\u003cT, S\u003e);\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e OrderedSet\u003cT, S\u003e {\n\t/// Create a new empty set.\n\tpub fn new() -\u003e Self {\n\t\tSelf(BoundedVec::default())\n\t}\n\n\tpub fn iter(\u0026self) -\u003e sp_std::slice::Iter\u003c'_, T\u003e {\n\t\tself.0.iter()\n\t}\n\n\t/// Creates an ordered set from a `BoundedVec`.\n\t///\n\t/// The vector will be sorted reversily (from greatest to lowest) and\n\t/// deduped first.\n\tpub fn from(bv: BoundedVec\u003cT, S\u003e) -\u003e Self {\n\t\tlet mut v = bv.into_inner();\n\t\tv.sort_by(|a, b| b.cmp(a));\n\t\tv.dedup();\n\t\tSelf::from_sorted_set(v.try_into().map_err(|_| ()).expect(\"No values were added\"))\n\t}\n\n\t/// Create a set from a `BoundedVec`.\n\t///\n\t/// Assumes that `v` is sorted reversely (from greatest to lowest) and only\n\t/// contains unique elements.\n\tpub fn from_sorted_set(bv: BoundedVec\u003cT, S\u003e) -\u003e Self {\n\t\tSelf(bv)\n\t}\n\n\t/// Mutate the set without restrictions. After the set was mutated it will\n\t/// be resorted and deduplicated.\n\tpub fn mutate\u003cF: FnOnce(\u0026mut BoundedVec\u003cT, S\u003e)\u003e(\u0026mut self, function: F) {\n\t\tfunction(\u0026mut self.0);\n\t\t(self.0[..]).sort_by(|a, b| b.cmp(a));\n\n\t\t// TODO: add dedup to BoundedVec\n\t\tlet mut i: usize = 0;\n\t\tlet mut next = i.saturating_add(1);\n\t\twhile next \u003c self.len() {\n\t\t\tif self[i] == self[next] {\n\t\t\t\tself.0.remove(next);\n\t\t\t} else {\n\t\t\t\ti = next;\n\t\t\t\tnext = next.saturating_add(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Inserts an element, if no equal item exist in the set.\n\t///\n\t/// Returns an error if insertion would exceed the bounded vec's max size.\n\t/// The error contains the index where the element would be inserted, if\n\t/// enough space would be left.\n\t///\n\t/// Returns true if the item is unique in the set, otherwise returns false.\n\tpub fn try_insert(\u0026mut self, value: T) -\u003e Result\u003cbool, usize\u003e {\n\t\tmatch self.linear_search(\u0026value) {\n\t\t\tOk(_) =\u003e Ok(false),\n\t\t\tErr(loc) =\u003e {\n\t\t\t\tself.0.try_insert(loc, value).map_err(|_| loc)?;\n\t\t\t\tOk(true)\n\t\t\t},\n\t\t}\n\t}\n\n\t/// Inserts an element, if no equal item exist in the set. If the set is\n\t/// full, but an element with a lower rank is in the set, the element with\n\t/// the lowest rank will be removed and the new element will be added.\n\t///\n\t/// Returns\n\t/// * Ok(Some(old_element)) if the new element was added and an old element\n\t///   had to be removed.\n\t/// * Ok(None) if the element was added without removing an element.\n\t/// * Err(true) if the set is full and the new element has a lower rank than\n\t///   the lowest element in the set.\n\t/// * Err(false) if the element is already in the set.\n\tpub fn try_insert_replace(\u0026mut self, value: T) -\u003e Result\u003cOption\u003cT\u003e, bool\u003e {\n\t\t// the highest allowed index\n\t\tlet highest_index: usize = S::get().saturating_sub(1).saturated_into();\n\t\tif S::get().is_zero() {\n\t\t\treturn Err(true)\n\t\t}\n\t\tmatch self.try_insert(value.clone()) {\n\t\t\tErr(loc) if loc \u003c= highest_index =\u003e {\n\t\t\t\t// always replace the last element\n\t\t\t\tlet last_idx = self.len().saturating_sub(1);\n\t\t\t\t// accessing by index wont panic since we checked the index, inserting the item\n\t\t\t\t// at the end of the list to ensure last-in-least-priority-rule for collators.\n\t\t\t\t// sorting algorithm must be stable!\n\t\t\t\tlet old = sp_std::mem::replace(\u0026mut self.0[last_idx], value);\n\t\t\t\tself.sort_greatest_to_lowest();\n\t\t\t\tOk(Some(old))\n\t\t\t},\n\t\t\tErr(_) =\u003e Err(true),\n\t\t\tOk(false) =\u003e Err(false),\n\t\t\tOk(_) =\u003e Ok(None),\n\t\t}\n\t}\n\n\t/// Inserts a new element or updates the value of an existing one.\n\t///\n\t/// Returns an error if the maximum size of the bounded vec would be\n\t/// exceeded upon insertion.\n\t///\n\t/// Returns the old value if existing or None if the value did not exist\n\t/// before.\n\tpub fn try_upsert(\u0026mut self, value: T) -\u003e Result\u003cOption\u003cT\u003e, ()\u003e {\n\t\tmatch self.linear_search(\u0026value) {\n\t\t\tOk(i) =\u003e {\n\t\t\t\tlet old = sp_std::mem::replace(\u0026mut self.0[i], value);\n\t\t\t\tself.sort_greatest_to_lowest();\n\t\t\t\tOk(Some(old))\n\t\t\t},\n\t\t\tErr(i) =\u003e {\n\t\t\t\t// Delegator\n\t\t\t\tself.0.try_insert(i, value).map_err(|_| ())?;\n\t\t\t\tOk(None)\n\t\t\t},\n\t\t}\n\t}\n\n\t/// Removes an element.\n\t///\n\t/// Returns true if removal happened.\n\tpub fn remove(\u0026mut self, value: \u0026T) -\u003e Option\u003cT\u003e {\n\t\tmatch self.linear_search(value) {\n\t\t\tOk(loc) =\u003e Some(self.0.remove(loc)),\n\t\t\tErr(_) =\u003e None,\n\t\t}\n\t}\n\n\t/// Return whether the set contains `value`.\n\tpub fn contains(\u0026self, value: \u0026T) -\u003e bool {\n\t\tself.linear_search(value).is_ok()\n\t}\n\n\t/// Iteratively searches this (from greatest to lowest) ordered set for a\n\t/// given element.\n\t///\n\t/// 1. If the value is found, then Result::Ok is returned, containing the\n\t/// index of the matching element.\n\t/// 2. If the value is not found, then Result::Err is returned, containing\n\t/// the index where a matching element could be inserted while maintaining\n\t/// sorted order.\n\tpub fn linear_search(\u0026self, value: \u0026T) -\u003e Result\u003cusize, usize\u003e {\n\t\tlet size = self.0.len();\n\t\tlet mut loc: usize = size;\n\t\t// keep running until we find a smaller item\n\t\tself.0\n\t\t\t.iter()\n\t\t\t.enumerate()\n\t\t\t.find_map(|(i, v)| {\n\t\t\t\tmatch (v.cmp(value), loc == size) {\n\t\t\t\t\t// prevent to have same items\n\t\t\t\t\t(Ordering::Equal, _) =\u003e Some(Ok(i)),\n\t\t\t\t\t// eventually, we want to return this index but we need to keep checking for Ordering::Equal in case\n\t\t\t\t\t// value is still in the set\n\t\t\t\t\t(Ordering::Less, true) =\u003e {\n\t\t\t\t\t\t// insert after current element\n\t\t\t\t\t\tloc = i;\n\t\t\t\t\t\tNone\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t})\n\t\t\t.unwrap_or(Err(loc))\n\t}\n\n\t/// Clear the set.\n\tpub fn clear(\u0026mut self) {\n\t\tself.0 = BoundedVec::default();\n\t}\n\n\t/// Return the length of the set.\n\tpub fn len(\u0026self) -\u003e usize {\n\t\tself.0.len()\n\t}\n\n\t/// Return whether the set is empty.\n\tpub fn is_empty(\u0026self) -\u003e bool {\n\t\tself.0.is_empty()\n\t}\n\n\t/// Convert the set to a bounded vector.\n\tpub fn into_bounded_vec(self) -\u003e BoundedVec\u003cT, S\u003e {\n\t\tself.0\n\t}\n\n\t/// Returns a reference to an element or None if out of bounds.\n\tpub fn get(\u0026self, index: usize) -\u003e Option\u003c\u0026T\u003e {\n\t\tself.0.get(index)\n\t}\n\n\t/// Sorts from greatest to lowest.\n\tpub fn sort_greatest_to_lowest(\u0026mut self) {\n\t\t(self.0[..]).sort_by(|a, b| b.cmp(a));\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e From\u003cBoundedVec\u003cT, S\u003e\u003e for OrderedSet\u003cT, S\u003e {\n\tfn from(bv: BoundedVec\u003cT, S\u003e) -\u003e Self {\n\t\tSelf::from(bv)\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e Index\u003cusize\u003e for OrderedSet\u003cT, S\u003e {\n\ttype Output = T;\n\n\tfn index(\u0026self, index: usize) -\u003e \u0026Self::Output {\n\t\t\u0026self.0[index]\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e Index\u003cRange\u003cusize\u003e\u003e for OrderedSet\u003cT, S\u003e {\n\ttype Output = [T];\n\n\tfn index(\u0026self, range: Range\u003cusize\u003e) -\u003e \u0026Self::Output {\n\t\t\u0026self.0[range]\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e Index\u003cRangeFull\u003e for OrderedSet\u003cT, S\u003e {\n\ttype Output = [T];\n\n\tfn index(\u0026self, range: RangeFull) -\u003e \u0026Self::Output {\n\t\t\u0026self.0[range]\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e IntoIterator for OrderedSet\u003cT, S\u003e {\n\ttype Item = T;\n\ttype IntoIter = sp_std::vec::IntoIter\u003cSelf::Item\u003e;\n\n\tfn into_iter(self) -\u003e Self::IntoIter {\n\t\tself.0.into_iter()\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e From\u003cOrderedSet\u003cT, S\u003e\u003e for BoundedVec\u003cT, S\u003e {\n\tfn from(s: OrderedSet\u003cT, S\u003e) -\u003e Self {\n\t\ts.0\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse crate::{mock::Test, types::StakeOf};\n\tuse frame_support::parameter_types;\n\tuse sp_runtime::RuntimeDebug;\n\n\tuse super::*;\n\n\tparameter_types! {\n\t\t#[derive(Eq, PartialEq, RuntimeDebug)]\n\t\tpub const Zero: u32 = 0;\n\t\t#[derive(Eq, PartialEq, RuntimeDebug)]\n\t\tpub const One: u32 = 1;\n\t\t#[derive(Eq, PartialEq, RuntimeDebug)]\n\t\tpub const Eight: u32 = 8;\n\t\t#[derive(Clone, Eq, PartialEq, RuntimeDebug)]\n\t\tpub const Five: u32 = 5;\n\t}\n\n\t#[test]\n\tfn from() {\n\t\tlet v: BoundedVec\u003ci32, Eight\u003e = vec![4, 2, 3, 4, 3, 1].try_into().unwrap();\n\t\tlet set: OrderedSet\u003ci32, Eight\u003e = v.into();\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 2, 3, 4].try_into().unwrap()));\n\t}\n\n\t#[test]\n\tfn insert() {\n\t\tlet mut set: OrderedSet\u003ci32, Eight\u003e = OrderedSet::new();\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![].try_into().unwrap()));\n\n\t\tassert_eq!(set.try_insert(1), Ok(true));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1].try_into().unwrap()));\n\n\t\tassert_eq!(set.try_insert(5), Ok(true));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 5].try_into().unwrap()));\n\n\t\tassert_eq!(set.try_insert(3), Ok(true));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 3, 5].try_into().unwrap()));\n\n\t\tassert_eq!(set.try_insert(3), Ok(false));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 3, 5].try_into().unwrap()));\n\t}\n\n\t#[test]\n\tfn remove() {\n\t\tlet mut set: OrderedSet\u003ci32, Eight\u003e =\n\t\t\tOrderedSet::from(vec![1, 2, 3, 4].try_into().unwrap());\n\n\t\tassert_eq!(set.remove(\u00265), None);\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 2, 3, 4].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00261), Some(1));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![2, 3, 4].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00263), Some(3));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![2, 4].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00263), None);\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![2, 4].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00264), Some(4));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![2].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00262), Some(2));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00262), None);\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![].try_into().unwrap()));\n\t}\n\n\t#[test]\n\tfn contains() {\n\t\tlet set: OrderedSet\u003ci32, Eight\u003e = OrderedSet::from(vec![1, 2, 3, 4].try_into().unwrap());\n\t\tassert!(!set.contains(\u00265));\n\t\tassert!(set.contains(\u00261));\n\t\tassert!(set.contains(\u00263));\n\t}\n\n\t#[test]\n\tfn clear() {\n\t\tlet mut set: OrderedSet\u003ci32, Eight\u003e =\n\t\t\tOrderedSet::from(vec![1, 2, 3, 4].try_into().unwrap());\n\t\tset.clear();\n\t\tassert_eq!(set, OrderedSet::new());\n\t}\n\n\t#[test]\n\tfn try_insert_replace_integer() {\n\t\tlet mut set: OrderedSet\u003ci32, Zero\u003e = OrderedSet::from(vec![].try_into().unwrap());\n\t\tassert_eq!(set.try_insert_replace(10), Err(true));\n\n\t\tlet mut set: OrderedSet\u003ci32, One\u003e = OrderedSet::from(vec![].try_into().unwrap());\n\t\tassert_eq!(set.try_insert_replace(10), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(9), Err(true));\n\t\tassert_eq!(set.try_insert_replace(11), Ok(Some(10)));\n\n\t\tlet mut set: OrderedSet\u003ci32, Five\u003e = OrderedSet::from(vec![].try_into().unwrap());\n\t\tassert_eq!(set.try_insert_replace(10), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(7), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(9), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(8), Ok(None));\n\n\t\tassert_eq!(set.clone().into_bounded_vec().into_inner(), vec![10, 9, 8, 7]);\n\t\tassert_eq!(set.try_insert_replace(5), Ok(None));\n\t\tassert!(set.try_insert(11).is_err());\n\n\t\tassert_eq!(set.try_insert_replace(6), Ok(Some(5)));\n\t\tassert_eq!(set.clone().into_bounded_vec().into_inner(), vec![10, 9, 8, 7, 6]);\n\n\t\tassert_eq!(set.try_insert_replace(6), Err(false));\n\t\tassert_eq!(set.try_insert_replace(5), Err(true));\n\n\t\tassert_eq!(set.try_insert_replace(10), Err(false));\n\t\tassert_eq!(set.try_insert_replace(11), Ok(Some(6)));\n\t\tassert_eq!(set.into_bounded_vec().into_inner(), vec![11, 10, 9, 8, 7]);\n\t}\n\n\t#[test]\n\tfn try_insert_replace_stake() {\n\t\tlet mut set: OrderedSet\u003cStakeOf\u003cTest\u003e, Eight\u003e = OrderedSet::from(\n\t\t\tvec![\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 8, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t]\n\t\t\t.try_into()\n\t\t\t.unwrap(),\n\t\t);\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 1, amount: 0 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 7, amount: 100 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 7, amount: 50 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 8, amount: 50 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 2, amount: 100 }), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 2, amount: 90 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 10, amount: 65 }), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 11, amount: 60 }), Err(true));\n\t\tassert_eq!(\n\t\t\tset.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 11, amount: 100 }),\n\t\t\tOk(Some(StakeOf::\u003cTest\u003e { owner: 9, amount: 60 }))\n\t\t);\n\t}\n\n\t#[test]\n\tfn exceeding_max_size_should_fail() {\n\t\tlet mut set: OrderedSet\u003ci32, Five\u003e =\n\t\t\tOrderedSet::from(vec![1, 2, 3, 4, 5].try_into().unwrap());\n\t\tlet inserted = set.try_insert(6);\n\n\t\tassert!(inserted.is_err());\n\t}\n\n\t#[test]\n\tfn linear_search() {\n\t\tlet set: OrderedSet\u003cStakeOf\u003cTest\u003e, Eight\u003e = OrderedSet::from(\n\t\t\tvec![\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 8, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t]\n\t\t\t.try_into()\n\t\t\t.unwrap(),\n\t\t);\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 1, amount: 0 }), Ok(0));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 7, amount: 100 }), Ok(3));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 7, amount: 50 }), Ok(3));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 8, amount: 50 }), Ok(4));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 100 }), Err(1));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 90 }), Err(2));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 65 }), Err(5));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 60 }), Err(6));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 59 }), Err(6));\n\t}\n\n\t#[test]\n\tfn upsert_set() {\n\t\tlet mut set: OrderedSet\u003cStakeOf\u003cTest\u003e, Eight\u003e = OrderedSet::from(\n\t\t\tvec![\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t]\n\t\t\t.try_into()\n\t\t\t.unwrap(),\n\t\t);\n\t\tassert_eq!(set.try_insert(StakeOf::\u003cTest\u003e { owner: 2, amount: 75 }), Ok(true));\n\t\tassert_eq!(\n\t\t\tset,\n\t\t\tOrderedSet::from(\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 75 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t\t]\n\t\t\t\t.try_into()\n\t\t\t\t.unwrap()\n\t\t\t)\n\t\t);\n\t\tassert_eq!(\n\t\t\tset.try_upsert(StakeOf::\u003cTest\u003e { owner: 2, amount: 90 }),\n\t\t\tOk(Some(StakeOf::\u003cTest\u003e { owner: 2, amount: 75 }))\n\t\t);\n\t\tassert_eq!(\n\t\t\tset,\n\t\t\tOrderedSet::from(\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 90 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t\t]\n\t\t\t\t.try_into()\n\t\t\t\t.unwrap()\n\t\t\t)\n\t\t);\n\t\tassert_eq!(\n\t\t\tset.try_upsert(StakeOf::\u003cTest\u003e { owner: 2, amount: 60 }),\n\t\t\tOk(Some(StakeOf::\u003cTest\u003e { owner: 2, amount: 90 }))\n\t\t);\n\t\tassert_eq!(\n\t\t\tset,\n\t\t\tOrderedSet::from(\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 60 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t\t]\n\t\t\t\t.try_into()\n\t\t\t\t.unwrap()\n\t\t\t)\n\t\t);\n\t}\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":91},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","tests.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\n//! Unit testing\n\nuse std::{convert::TryInto, iter};\n\nuse frame_support::{\n\tassert_noop, assert_ok, storage::bounded_btree_map::BoundedBTreeMap,\n\ttraits::EstimateNextSessionRotation, BoundedVec,\n};\nuse pallet_authorship::EventHandler;\nuse pallet_balances::{BalanceLock, Error as BalancesError, Reasons};\nuse pallet_session::{SessionManager, ShouldEndSession};\nuse sp_runtime::{traits::Zero, Perbill, Permill, Perquintill, SaturatedConversion};\n\nuse crate::{\n\tmock::{\n\t\talmost_equal, events, last_event, roll_to, roll_to_claim_rewards, AccountId, Balance,\n\t\tBalances, BlockNumber, ExtBuilder, RuntimeEvent as MetaEvent, RuntimeOrigin as Origin,\n\t\tSession, StakePallet, System, Test, BLOCKS_PER_ROUND, DECIMALS, TREASURY_ACC,\n\t},\n\truntime_api::StakingRates,\n\tset::OrderedSet,\n\ttypes::{\n\t\tBalanceOf, Candidate, CandidateStatus, DelegationCounter, Delegator, RoundInfo, Stake,\n\t\tStakeOf, TotalStake,\n\t},\n\tCandidatePool, Config, Error, Event, InflationInfo, RewardRate, StakingInfo, STAKING_ID,\n};\n\n#[test]\nfn should_select_collators_genesis_session() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 20),\n\t\t\t(2, 20),\n\t\t\t(3, 20),\n\t\t\t(4, 20),\n\t\t\t(5, 20),\n\t\t\t(6, 20),\n\t\t\t(7, 20),\n\t\t\t(8, 20),\n\t\t\t(9, 20),\n\t\t\t(10, 20),\n\t\t\t(11, 20),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::new_session(0)\n\t\t\t\t\t.expect(\"first session must return new collators\")\n\t\t\t\t\t.len(),\n\t\t\t\t2\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::new_session(1)\n\t\t\t\t\t.expect(\"second session must return new collators\")\n\t\t\t\t\t.len(),\n\t\t\t\t2\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn genesis() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 300),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 9),\n\t\t\t(9, 4),\n\t\t])\n\t\t.with_collators(vec![(1, 500), (2, 200)])\n\t\t.with_delegators(vec![(3, 1, 100), (4, 1, 100), (5, 2, 100), (6, 2, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert!(System::events().is_empty());\n\n\t\t\t// Collators\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 700, delegators: 400 }\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 700 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 400 }\n\t\t\t\t]\n\t\t\t\t.try_into(),\n\t\t\t\tOk(StakePallet::top_candidates().into_bounded_vec())\n\t\t\t);\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\n\t\t\t// 1\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), 500);\n\t\t\tassert_eq!(Balances::free_balance(\u00261), 1000);\n\t\t\tassert!(StakePallet::is_active_candidate(\u00261).is_some());\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(\u00261),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 1,\n\t\t\t\t\tstake: 500,\n\t\t\t\t\tdelegators: OrderedSet::from_sorted_set(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 100 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 700,\n\t\t\t\t\tstatus: CandidateStatus::Active,\n\t\t\t\t})\n\t\t\t);\n\t\t\t// 2\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u00262), 300);\n\t\t\tassert!(StakePallet::is_active_candidate(\u00262).is_some());\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(\u00262),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 2,\n\t\t\t\t\tstake: 200,\n\t\t\t\t\tdelegators: OrderedSet::from_sorted_set(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 400,\n\t\t\t\t\tstatus: CandidateStatus::Active,\n\t\t\t\t})\n\t\t\t);\n\t\t\t// Delegators\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 700, delegators: 400 }\n\t\t\t);\n\t\t\tfor x in 3..7 {\n\t\t\t\tassert!(StakePallet::is_delegator(\u0026x));\n\t\t\t\tassert_eq!(Balances::usable_balance(\u0026x), 0);\n\t\t\t\tassert_eq!(Balances::free_balance(\u0026x), 100);\n\t\t\t}\n\t\t\t// Uninvolved\n\t\t\tfor x in 7..10 {\n\t\t\t\tassert!(!StakePallet::is_delegator(\u0026x));\n\t\t\t}\n\t\t\tassert_eq!(Balances::free_balance(\u00267), 100);\n\t\t\tassert_eq!(Balances::usable_balance(\u00267), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u00268), 9);\n\t\t\tassert_eq!(Balances::usable_balance(\u00268), 9);\n\t\t\tassert_eq!(Balances::free_balance(\u00269), 4);\n\t\t\tassert_eq!(Balances::usable_balance(\u00269), 4);\n\n\t\t\t// Safety first checks\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::max_selected_candidates(),\n\t\t\t\t\u003cTest as Config\u003e::MinCollators::get()\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::round(),\n\t\t\t\tRoundInfo::new(0u32, 0u32.into(), \u003cTest as Config\u003e::DefaultBlocksPerRound::get())\n\t\t\t);\n\t\t});\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(6, 1, 10), (7, 1, 10), (8, 2, 10), (9, 2, 10), (10, 1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert!(System::events().is_empty());\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 5);\n\n\t\t\t// Collators\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 40, delegators: 50 }\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tOk(StakePallet::top_candidates().into_bounded_vec()),\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 50 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 40 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 20 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 20 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 10 }\n\t\t\t\t]\n\t\t\t\t.try_into()\n\t\t\t);\n\t\t\tfor x in 1..5 {\n\t\t\t\tassert!(StakePallet::is_active_candidate(\u0026x).is_some());\n\t\t\t\tassert_eq!(Balances::free_balance(\u0026x), 100);\n\t\t\t\tassert_eq!(Balances::usable_balance(\u0026x), 80);\n\t\t\t}\n\t\t\tassert!(StakePallet::is_active_candidate(\u00265).is_some());\n\t\t\tassert_eq!(Balances::free_balance(\u00265), 100);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), 90);\n\t\t\t// Delegators\n\t\t\tfor x in 6..11 {\n\t\t\t\tassert!(StakePallet::is_delegator(\u0026x));\n\t\t\t\tassert_eq!(Balances::free_balance(\u0026x), 100);\n\t\t\t\tassert_eq!(Balances::usable_balance(\u0026x), 90);\n\t\t\t}\n\n\t\t\t// Safety first checks\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::max_selected_candidates(),\n\t\t\t\t\u003cTest as Config\u003e::MinCollators::get()\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::round(),\n\t\t\t\tRoundInfo::new(0, 0, \u003cTest as Config\u003e::DefaultBlocksPerRound::get())\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn join_collator_candidates() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 300),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 9),\n\t\t\t(9, 4),\n\t\t\t(10, 161_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 500), (2, 200)])\n\t\t.with_delegators(vec![(3, 1, 100), (4, 1, 100), (5, 2, 100), (6, 2, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 700, delegators: 400 }\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(1), 11u128,),\n\t\t\t\tError::\u003cTest\u003e::CandidateExists\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(1), 1, 11u128,),\n\t\t\t\tError::\u003cTest\u003e::CandidateExists\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(3), 11u128,),\n\t\t\t\tError::\u003cTest\u003e::DelegatorExists\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(7), 9u128,),\n\t\t\t\tError::\u003cTest\u003e::ValStakeBelowMin\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(8), 10u128,),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\t\t\tassert!(System::events().is_empty());\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(7), 10u128,));\n\t\t\tassert_eq!(\n\t\t\t\tlast_event(),\n\t\t\t\tMetaEvent::StakePallet(Event::JoinedCollatorCandidates(7, 10u128))\n\t\t\t);\n\n\t\t\t// MaxCollatorCandidateStake\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(10), 161_000_000 * DECIMALS),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_candidates(\n\t\t\t\tOrigin::signed(10),\n\t\t\t\tStakePallet::max_candidate_stake()\n\t\t\t));\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 4);\n\n\t\t\tassert_eq!(\n\t\t\t\tlast_event(),\n\t\t\t\tMetaEvent::StakePallet(Event::JoinedCollatorCandidates(\n\t\t\t\t\t10,\n\t\t\t\t\tStakePallet::max_candidate_stake(),\n\t\t\t\t))\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn collator_exit_executes_after_delay() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 300),\n\t\t\t(3, 110),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 9),\n\t\t\t(9, 4),\n\t\t\t(10, 10),\n\t\t])\n\t\t.with_collators(vec![(1, 500), (2, 200), (7, 100)])\n\t\t.with_delegators(vec![(3, 1, 100), (4, 1, 100), (5, 2, 100), (6, 2, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 3);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 700, delegators: 400 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 800, delegators: 400 }\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 7]);\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(3)),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\n\t\t\troll_to(11, vec![]);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\t// Still three, candidate didn't leave yet\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 3);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(10), 2, 10),\n\t\t\t\tError::\u003cTest\u003e::CannotDelegateIfLeaving\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 7]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(2, 2, 4)));\n\t\t\tlet info = StakePallet::candidate_pool(\u00262).unwrap();\n\t\t\tassert_eq!(info.status, CandidateStatus::Leaving(4));\n\n\t\t\troll_to(21, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(2), 2));\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\n\t\t\t// we must exclude leaving collators from rewards while\n\t\t\t// holding them retroactively accountable for previous faults\n\t\t\t// (within the last T::StakeDuration blocks)\n\t\t\troll_to(25, vec![]);\n\t\t\tlet expected = vec![\n\t\t\t\tEvent::MaxSelectedCandidatesSet(2, 5),\n\t\t\t\tEvent::NewRound(5, 1),\n\t\t\t\tEvent::NewRound(10, 2),\n\t\t\t\tEvent::LeftTopCandidates(2),\n\t\t\t\tEvent::CollatorScheduledExit(2, 2, 4),\n\t\t\t\tEvent::NewRound(15, 3),\n\t\t\t\tEvent::NewRound(20, 4),\n\t\t\t\tEvent::CandidateLeft(2, 400),\n\t\t\t\tEvent::NewRound(25, 5),\n\t\t\t];\n\t\t\tassert_eq!(events(), expected);\n\t\t});\n}\n\n#[test]\nfn collator_selection_chooses_top_candidates() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 1000),\n\t\t\t(3, 1000),\n\t\t\t(4, 1000),\n\t\t\t(5, 1000),\n\t\t\t(6, 1000),\n\t\t\t(7, 33),\n\t\t\t(8, 33),\n\t\t\t(9, 33),\n\t\t])\n\t\t.with_collators(vec![(1, 100), (2, 90), (3, 80), (4, 70), (5, 60), (6, 50)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 190, delegators: 0 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 400, delegators: 0 }\n\t\t\t);\n\t\t\troll_to(8, vec![]);\n\t\t\t// should choose top MaxSelectedCandidates (5), in order\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\t\t\tlet expected = vec![Event::MaxSelectedCandidatesSet(2, 5), Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), expected);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(6)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5],);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(1, 6, 3)));\n\n\t\t\troll_to(15, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(6), 6));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\n\t\t\troll_to(21, vec![]);\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(6), 69u128));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tlast_event(),\n\t\t\t\tMetaEvent::StakePallet(Event::JoinedCollatorCandidates(6, 69u128))\n\t\t\t);\n\n\t\t\troll_to(27, vec![]);\n\t\t\t// should choose top MaxSelectedCandidates (5), in order\n\t\t\tlet expected = vec![\n\t\t\t\tEvent::MaxSelectedCandidatesSet(2, 5),\n\t\t\t\tEvent::NewRound(5, 1),\n\t\t\t\tEvent::LeftTopCandidates(6),\n\t\t\t\tEvent::CollatorScheduledExit(1, 6, 3),\n\t\t\t\t// TotalCollatorStake is updated once candidate 6 left in `execute_delayed_collator_exits`\n\t\t\t\tEvent::NewRound(10, 2),\n\t\t\t\tEvent::NewRound(15, 3),\n\t\t\t\tEvent::CandidateLeft(6, 50),\n\t\t\t\tEvent::NewRound(20, 4),\n\t\t\t\t// 5 had staked 60 which was exceeded by 69 of 6\n\t\t\t\tEvent::EnteredTopCandidates(6),\n\t\t\t\tEvent::JoinedCollatorCandidates(6, 69),\n\t\t\t\tEvent::NewRound(25, 5),\n\t\t\t];\n\t\t\tassert_eq!(events(), expected);\n\t\t});\n}\n\n#[test]\nfn exit_queue_with_events() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 1000),\n\t\t\t(3, 1000),\n\t\t\t(4, 1000),\n\t\t\t(5, 1000),\n\t\t\t(6, 1000),\n\t\t\t(7, 33),\n\t\t\t(8, 33),\n\t\t\t(9, 33),\n\t\t])\n\t\t.with_collators(vec![(1, 100), (2, 90), (3, 80), (4, 70), (5, 60), (6, 50)])\n\t\t.with_inflation(100, 15, 40, 10, BLOCKS_PER_ROUND)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 6);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\n\t\t\troll_to(8, vec![]);\n\t\t\t// should choose top MaxSelectedCandidates (5), in order\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\t\t\tlet mut expected = vec![Event::MaxSelectedCandidatesSet(2, 5), Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), expected);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(6)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(1, 6, 3)));\n\n\t\t\troll_to(11, vec![]);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(5)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(2, 5, 4)));\n\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 6, \"No collators have left yet.\");\n\t\t\troll_to(16, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(6), 6));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(4)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(3, 4, 5)));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(4)),\n\t\t\t\tError::\u003cTest\u003e::AlreadyLeaving\n\t\t\t);\n\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 5, \"Collator #5 left.\");\n\t\t\troll_to(20, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(5), 5));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3]);\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 4, \"Two out of six collators left.\");\n\n\t\t\troll_to(26, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(4), 4));\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 3, \"Three out of six collators left.\");\n\n\t\t\troll_to(30, vec![]);\n\t\t\tlet mut new_events = vec![\n\t\t\t\tEvent::LeftTopCandidates(6),\n\t\t\t\tEvent::CollatorScheduledExit(1, 6, 3),\n\t\t\t\tEvent::NewRound(10, 2),\n\t\t\t\tEvent::LeftTopCandidates(5),\n\t\t\t\tEvent::CollatorScheduledExit(2, 5, 4),\n\t\t\t\tEvent::NewRound(15, 3),\n\t\t\t\tEvent::CandidateLeft(6, 50),\n\t\t\t\tEvent::LeftTopCandidates(4),\n\t\t\t\tEvent::CollatorScheduledExit(3, 4, 5),\n\t\t\t\tEvent::NewRound(20, 4),\n\t\t\t\tEvent::CandidateLeft(5, 60),\n\t\t\t\tEvent::NewRound(25, 5),\n\t\t\t\tEvent::CandidateLeft(4, 70),\n\t\t\t\tEvent::NewRound(30, 6),\n\t\t\t];\n\t\t\texpected.append(\u0026mut new_events);\n\t\t\tassert_eq!(events(), expected);\n\t\t});\n}\n\n#[test]\nfn execute_leave_candidates_with_delay() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 1000),\n\t\t\t(3, 1000),\n\t\t\t(4, 1000),\n\t\t\t(5, 1000),\n\t\t\t(6, 1000),\n\t\t\t(7, 1000),\n\t\t\t(8, 1000),\n\t\t\t(9, 1000),\n\t\t\t(10, 1000),\n\t\t\t(11, 1000),\n\t\t\t(12, 1000),\n\t\t\t(13, 1000),\n\t\t\t(14, 1000),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 30),\n\t\t\t(4, 40),\n\t\t\t(5, 50),\n\t\t\t(6, 60),\n\t\t\t(7, 70),\n\t\t\t(8, 80),\n\t\t\t(9, 90),\n\t\t\t(10, 100),\n\t\t])\n\t\t.with_delegators(vec![(11, 1, 110), (12, 1, 120), (13, 2, 130), (14, 2, 140)])\n\t\t.with_inflation(100, 15, 40, 10, BLOCKS_PER_ROUND)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 10);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 30, delegators: 500 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 300, delegators: 500 }\n\t\t\t);\n\n\t\t\troll_to(5, vec![]);\n\t\t\t// should choose top MaxSelectedCandidates (5), in order\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 1, 10, 9, 8]);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(10)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(9)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(7)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(6)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(5)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(8)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![4, 3]);\n\t\t\tfor owner in vec![1, 2, 5, 6, 7, 8, 9, 10].iter() {\n\t\t\t\tassert!(StakePallet::candidate_pool(owner)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.can_exit(1 + \u003cTest as Config\u003e::ExitQueueDelay::get()));\n\t\t\t}\n\t\t\tlet total_stake = TotalStake { collators: 70, delegators: 0 };\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(1),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 1,\n\t\t\t\t\tstake: 10,\n\t\t\t\t\tdelegators: OrderedSet::from(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 11, amount: 110 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 12, amount: 120 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 240,\n\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t})\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 2,\n\t\t\t\t\tstake: 20,\n\t\t\t\t\tdelegators: OrderedSet::from(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 13, amount: 130 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 14, amount: 140 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 290,\n\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t})\n\t\t\t);\n\t\t\tfor collator in 5u64..=10u64 {\n\t\t\t\tassert_eq!(\n\t\t\t\t\tStakePallet::candidate_pool(collator),\n\t\t\t\t\tSome(Candidate::\u003c\n\t\t\t\t\t\tAccountId,\n\t\t\t\t\t\tBalance,\n\t\t\t\t\t\t\u003cTest as Config\u003e::MaxDelegatorsPerCollator,\n\t\t\t\t\t\u003e {\n\t\t\t\t\t\tid: collator,\n\t\t\t\t\t\tstake: collator as u128 * 10u128,\n\t\t\t\t\t\tdelegators: OrderedSet::from(BoundedVec::default()),\n\t\t\t\t\t\ttotal: collator as u128 * 10u128,\n\t\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tassert!(StakePallet::is_active_candidate(\u0026collator).is_some());\n\t\t\t\tassert!(StakePallet::unstaking(collator).is_empty());\n\t\t\t}\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(11),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(1), amount: 110 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(12),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(1), amount: 120 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(13),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(2), amount: 130 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(14),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(2), amount: 140 })\n\t\t\t);\n\t\t\tfor delegator in 11u64..=14u64 {\n\t\t\t\tassert!(StakePallet::is_delegator(\u0026delegator));\n\t\t\t\tassert!(StakePallet::unstaking(delegator).is_empty());\n\t\t\t}\n\n\t\t\t// exits cannot be executed yet but in the next round\n\t\t\troll_to(10, vec![]);\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![4, 3]);\n\t\t\tfor owner in vec![1, 2, 5, 6, 7, 8, 9, 10].iter() {\n\t\t\t\tassert!(StakePallet::candidate_pool(owner)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.can_exit(1 + \u003cTest as Config\u003e::ExitQueueDelay::get()));\n\t\t\t\tassert_noop!(\n\t\t\t\t\tStakePallet::execute_leave_candidates(Origin::signed(*owner), *owner),\n\t\t\t\t\tError::\u003cTest\u003e::CannotLeaveYet\n\t\t\t\t);\n\t\t\t}\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(1),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 1,\n\t\t\t\t\tstake: 10,\n\t\t\t\t\tdelegators: OrderedSet::from(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 11, amount: 110 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 12, amount: 120 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 240,\n\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t})\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 2,\n\t\t\t\t\tstake: 20,\n\t\t\t\t\tdelegators: OrderedSet::from(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 13, amount: 130 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 14, amount: 140 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 290,\n\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t})\n\t\t\t);\n\t\t\tfor collator in 5u64..=10u64 {\n\t\t\t\tassert_eq!(\n\t\t\t\t\tStakePallet::candidate_pool(collator),\n\t\t\t\t\tSome(Candidate::\u003c\n\t\t\t\t\t\tAccountId,\n\t\t\t\t\t\tBalance,\n\t\t\t\t\t\t\u003cTest as Config\u003e::MaxDelegatorsPerCollator,\n\t\t\t\t\t\u003e {\n\t\t\t\t\t\tid: collator,\n\t\t\t\t\t\tstake: collator as u128 * 10u128,\n\t\t\t\t\t\tdelegators: OrderedSet::from(BoundedVec::default()),\n\t\t\t\t\t\ttotal: collator as u128 * 10u128,\n\t\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tassert!(StakePallet::is_active_candidate(\u0026collator).is_some());\n\t\t\t\tassert!(StakePallet::unstaking(collator).is_empty());\n\t\t\t}\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(11),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(1), amount: 110 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(12),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(1), amount: 120 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(13),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(2), amount: 130 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(14),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(2), amount: 140 })\n\t\t\t);\n\t\t\tfor delegator in 11u64..=14u64 {\n\t\t\t\tassert!(StakePallet::is_delegator(\u0026delegator));\n\t\t\t\tassert!(StakePallet::unstaking(delegator).is_empty());\n\t\t\t}\n\n\t\t\t// first five exits are executed\n\t\t\troll_to(15, vec![]);\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![4, 3]);\n\t\t\tfor collator in vec![1u64, 2u64, 5u64, 6u64, 7u64].iter() {\n\t\t\t\tassert_ok!(StakePallet::execute_leave_candidates(\n\t\t\t\t\tOrigin::signed(*collator),\n\t\t\t\t\t*collator\n\t\t\t\t));\n\t\t\t\tassert!(StakePallet::candidate_pool(\u0026collator).is_none());\n\t\t\t\tassert!(StakePallet::is_active_candidate(collator).is_none());\n\t\t\t\tassert_eq!(StakePallet::unstaking(collator).len(), 1);\n\t\t\t}\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 5, \"Five collators left.\");\n\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tfor delegator in 11u64..=14u64 {\n\t\t\t\tassert!(!StakePallet::is_delegator(\u0026delegator));\n\t\t\t\tassert_eq!(StakePallet::unstaking(delegator).len(), 1);\n\t\t\t}\n\n\t\t\t// last 3 exits are executed\n\t\t\troll_to(20, vec![]);\n\t\t\tfor collator in 8u64..=10u64 {\n\t\t\t\tassert_ok!(StakePallet::execute_leave_candidates(\n\t\t\t\t\tOrigin::signed(collator),\n\t\t\t\t\tcollator\n\t\t\t\t));\n\t\t\t\tassert!(StakePallet::candidate_pool(\u0026collator).is_none());\n\t\t\t\tassert!(StakePallet::is_active_candidate(\u0026collator).is_none());\n\t\t\t\tassert_eq!(StakePallet::unstaking(collator).len(), 1);\n\t\t\t}\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2, \"3 collators left.\");\n\t\t});\n}\n\n// FIXME: Re-enable or potentially remove entirely\n#[test]\nfn multiple_delegations() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t\t(11, 100),\n\t\t\t(12, 100),\n\t\t\t// new\n\t\t\t(13, 100),\n\t\t\t(14, 100),\n\t\t\t(15, 100),\n\t\t\t(16, 100),\n\t\t\t(17, 100),\n\t\t\t(18, 100),\n\t\t\t(99, 1),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(6, 1, 10), (7, 1, 10), (8, 2, 10), (9, 2, 10), (10, 1, 10)])\n\t\t.set_blocks_per_round(5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\troll_to(\n\t\t\t\t8,\n\t\t\t\tvec![Some(1), Some(2), Some(3), Some(4), Some(5), Some(1), Some(2), Some(3)],\n\t\t\t);\n\t\t\t// chooses top MaxSelectedCandidates (5), in order\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\t\t\tlet mut expected = vec![Event::MaxSelectedCandidatesSet(2, 5), Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), expected);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(13), 2, 2),\n\t\t\t\tError::\u003cTest\u003e::DelegationBelowMin,\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(13), 2, 10));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(14), 4, 10));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(15), 3, 10));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 4, 3, 5]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(6), 5, 10),\n\t\t\t\tError::\u003cTest\u003e::AlreadyDelegating,\n\t\t\t);\n\n\t\t\troll_to(\n\t\t\t\t16,\n\t\t\t\tvec![Some(1), Some(2), Some(3), Some(4), Some(5), Some(1), Some(2), Some(3)],\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 4, 3, 5]);\n\t\t\tlet mut new = vec![\n\t\t\t\tEvent::Delegation(13, 10, 2, 50),\n\t\t\t\tEvent::Delegation(14, 10, 4, 30),\n\t\t\t\tEvent::Delegation(15, 10, 3, 30),\n\t\t\t\tEvent::NewRound(10, 2),\n\t\t\t\tEvent::NewRound(15, 3),\n\t\t\t];\n\t\t\texpected.append(\u0026mut new);\n\t\t\tassert_eq!(events(), expected);\n\n\t\t\troll_to(21, vec![Some(1), Some(2), Some(3), Some(4), Some(5)]);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(16), 2, 80));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(99), 3, 11),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(17), 2, 10),\n\t\t\t\tError::\u003cTest\u003e::TooManyDelegators\n\t\t\t);\n\t\t\t// kick 13 by staking 1 more (11 \u003e 10)\n\t\t\tassert!(StakePallet::unstaking(13).is_empty());\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(17), 2, 11));\n\t\t\tassert!(StakePallet::delegator_state(13).is_none());\n\t\t\tassert_eq!(StakePallet::unstaking(13).get(\u002623), Some(\u002610u128));\n\t\t\t// kick 9 by staking 1 more (11 \u003e 10)\n\t\t\tassert!(StakePallet::unstaking(9).is_empty());\n\t\t\tassert!(StakePallet::rewards(9).is_zero());\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(11), 2, 11));\n\t\t\t// 11 should be initiated with the same reward counter as their collator 2\n\t\t\tassert_eq!(StakePallet::reward_count(2), StakePallet::reward_count(11));\n\n\t\t\tassert!(StakePallet::delegator_state(9).is_none());\n\t\t\tassert_eq!(StakePallet::unstaking(9).get(\u002623), Some(\u002610u128));\n\t\t\tassert!(!StakePallet::candidate_pool(2)\n\t\t\t\t.unwrap()\n\t\t\t\t.delegators\n\t\t\t\t.contains(\u0026StakeOf::\u003cTest\u003e { owner: 9, amount: 10 }));\n\n\t\t\troll_to(26, vec![Some(1), Some(2), Some(3), Some(4), Some(5)]);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 1, 4, 3, 5]);\n\t\t\tlet mut new2 = vec![\n\t\t\t\tEvent::NewRound(20, 4),\n\t\t\t\tEvent::Delegation(16, 80, 2, 130),\n\t\t\t\tEvent::DelegationReplaced(17, 11, 13, 10, 2, 131),\n\t\t\t\tEvent::Delegation(17, 11, 2, 131),\n\t\t\t\tEvent::DelegationReplaced(11, 11, 9, 10, 2, 132),\n\t\t\t\tEvent::Delegation(11, 11, 2, 132),\n\t\t\t\tEvent::NewRound(25, 5),\n\t\t\t];\n\t\t\texpected.append(\u0026mut new2);\n\t\t\tassert_eq!(events(), expected);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 4, 3, 5]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(5, 2, 7)));\n\n\t\t\troll_to(31, vec![Some(1), Some(2), Some(3), Some(4), Some(5)]);\n\t\t\tlet mut new3 = vec![\n\t\t\t\tEvent::LeftTopCandidates(2),\n\t\t\t\tEvent::CollatorScheduledExit(5, 2, 7),\n\t\t\t\tEvent::NewRound(30, 6),\n\t\t\t];\n\t\t\texpected.append(\u0026mut new3);\n\t\t\tassert_eq!(events(), expected);\n\n\t\t\t// test join_delegator errors\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(18), 1, 10));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(12), 1, 10),\n\t\t\t\tError::\u003cTest\u003e::TooManyDelegators\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(12), 1, 11));\n\n\t\t\t// verify that delegations are removed after collator leaves, not before\n\t\t\tassert!(StakePallet::candidate_pool(2)\n\t\t\t\t.unwrap()\n\t\t\t\t.delegators\n\t\t\t\t.contains(\u0026StakeOf::\u003cTest\u003e { owner: 8, amount: 10 }));\n\t\t\tassert!(StakePallet::candidate_pool(2)\n\t\t\t\t.unwrap()\n\t\t\t\t.delegators\n\t\t\t\t.contains(\u0026StakeOf::\u003cTest\u003e { owner: 17, amount: 11 }));\n\t\t\tassert_eq!(StakePallet::delegator_state(8).unwrap().amount, 10);\n\t\t\tassert_eq!(StakePallet::delegator_state(17).unwrap().amount, 11);\n\t\t\tassert_eq!(Balances::usable_balance(\u00268), 90);\n\t\t\tassert_eq!(Balances::usable_balance(\u002617), 89);\n\t\t\tassert_eq!(Balances::free_balance(\u00268), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u002617), 100);\n\n\t\t\troll_to(35, vec![Some(1), Some(2), Some(3), Some(4)]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(2), 2));\n\t\t\tlet mut unbonding_8: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(\n\t\t\t\tunbonding_8.try_insert(35u64 + \u003cTest as Config\u003e::StakeDuration::get() as u64, 10)\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::unstaking(8), unbonding_8);\n\t\t\tlet mut unbonding_17: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(\n\t\t\t\tunbonding_17.try_insert(35u64 + \u003cTest as Config\u003e::StakeDuration::get() as u64, 11)\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::unstaking(17), unbonding_17);\n\n\t\t\troll_to(37, vec![Some(1), Some(2)]);\n\t\t\tassert!(StakePallet::delegator_state(8).is_none());\n\t\t\tassert!(StakePallet::delegator_state(17).is_none());\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(8), 8));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(17), 17));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::unlock_unstaked(Origin::signed(12), 12),\n\t\t\t\tError::\u003cTest\u003e::UnstakingIsEmpty\n\t\t\t);\n\t\t\tassert_eq!(Balances::usable_balance(\u002617), 100);\n\t\t\tassert_eq!(Balances::usable_balance(\u00268), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u002617), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u00268), 100);\n\t\t});\n}\n\n#[test]\nfn should_update_total_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t\t(11, 161_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(7, 1, 10), (8, 2, 10), (9, 2, 10)])\n\t\t.set_blocks_per_round(5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet mut old_stake = StakePallet::total_collator_stake();\n\t\t\tassert_eq!(old_stake, TotalStake { collators: 40, delegators: 30 });\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 50));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: old_stake.collators + 50, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 50));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: old_stake.collators - 50, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(7), 1, 50));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(7), 1, 0),\n\t\t\t\tError::\u003cTest\u003e::ValStakeZero\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(7), 1, 0),\n\t\t\t\tError::\u003cTest\u003e::ValStakeZero\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators + 50, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(7), 1, 50));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators - 50, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(11), 1, 200));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators + 200, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_eq!(StakePallet::delegator_state(11).unwrap().amount, 200);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(11)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators - 200, ..old_stake }\n\t\t\t);\n\n\t\t\tlet old_stake = StakePallet::total_collator_stake();\n\t\t\tassert_eq!(StakePallet::delegator_state(8).unwrap().amount, 10);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(8)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators - 10, ..old_stake }\n\t\t\t);\n\n\t\t\t// should immediately affect total stake because collator can't be chosen in\n\t\t\t// active set from now on, thus delegated stake is reduced\n\t\t\tlet old_stake = StakePallet::total_collator_stake();\n\t\t\tassert_eq!(StakePallet::candidate_pool(2).unwrap().total, 30);\n\t\t\tassert_eq!(StakePallet::candidate_pool(2).unwrap().stake, 20);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 1]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().stake,\n\t\t\t\tStakePallet::candidate_pool(3).unwrap().stake\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\tlet old_stake = TotalStake {\n\t\t\t\tdelegators: old_stake.delegators - 10,\n\t\t\t\t// total active collator stake is unchanged because number of selected candidates is 2 and 2's\n\t\t\t\t// replacement has the same self stake as 2\n\t\t\t\tcollators: old_stake.collators,\n\t\t\t};\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 3]);\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), old_stake);\n\n\t\t\t// shouldn't change total stake when 2 leaves\n\t\t\troll_to(10, vec![]);\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), old_stake);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), old_stake);\n\t\t})\n}\n\n#[test]\nfn collators_bond() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t\t(11, 161_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(6, 1, 10), (7, 1, 10), (8, 2, 10), (9, 2, 10), (10, 1, 10)])\n\t\t.set_blocks_per_round(5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(6), 50),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(6), 50),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 50));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 40),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\tassert!(StakePallet::candidate_pool(1)\n\t\t\t\t.unwrap()\n\t\t\t\t.can_exit(\u003cTest as Config\u003e::ExitQueueDelay::get()));\n\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 30),\n\t\t\t\tError::\u003cTest\u003e::CannotStakeIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(1), 10),\n\t\t\t\tError::\u003cTest\u003e::CannotStakeIfLeaving\n\t\t\t);\n\n\t\t\troll_to(30, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(1), 1));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 40),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(2), 80));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(2), 90));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(3), 10));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(2), 11),\n\t\t\t\tError::\u003cTest\u003e::Underflow\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(2), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeBelowMin\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(3), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeBelowMin\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(4), 11),\n\t\t\t\tError::\u003cTest\u003e::ValStakeBelowMin\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(4), 10));\n\n\t\t\t// MaxCollatorCandidateStake\n\t\t\tassert_ok!(StakePallet::join_candidates(\n\t\t\t\tOrigin::signed(11),\n\t\t\t\tStakePallet::max_candidate_stake()\n\t\t\t));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(11), 1u128),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax,\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn delegators_bond() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(6, 1, 10), (7, 1, 10), (8, 2, 10), (9, 2, 10)])\n\t\t.set_blocks_per_round(5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(6), 2, 50),\n\t\t\t\tError::\u003cTest\u003e::AlreadyDelegating\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(1), 2, 50),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(1), 2, 50),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(6), 2, 50),\n\t\t\t\tError::\u003cTest\u003e::DelegationNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(7), 6, 50),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(7), 6, 50),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(6), 1, 11),\n\t\t\t\tError::\u003cTest\u003e::Underflow\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(6), 1, 8),\n\t\t\t\tError::\u003cTest\u003e::DelegationBelowMin\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(6), 1, 10));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(6), 2, 5),\n\t\t\t\tError::\u003cTest\u003e::DelegationNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(6), 1, 81),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(10), 1, 4),\n\t\t\t\tError::\u003cTest\u003e::DelegationBelowMin\n\t\t\t);\n\n\t\t\troll_to(9, vec![]);\n\t\t\tassert_eq!(Balances::usable_balance(\u00266), 80);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\tassert!(StakePallet::candidate_pool(1)\n\t\t\t\t.unwrap()\n\t\t\t\t.can_exit(1 + \u003cTest as Config\u003e::ExitQueueDelay::get()));\n\n\t\t\troll_to(31, vec![]);\n\t\t\tassert!(StakePallet::is_delegator(\u00266));\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(1), 1));\n\t\t\tassert!(!StakePallet::is_delegator(\u00266));\n\t\t\tassert_eq!(Balances::usable_balance(\u00266), 80);\n\t\t\tassert_eq!(Balances::free_balance(\u00266), 100);\n\t\t});\n}\n\n#[test]\nfn should_leave_delegators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.with_delegators(vec![(2, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert!(StakePallet::delegator_state(2).is_none());\n\t\t\tassert!(!StakePallet::candidate_pool(1)\n\t\t\t\t.unwrap()\n\t\t\t\t.delegators\n\t\t\t\t.contains(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 100 }));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::leave_delegators(Origin::signed(2)),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::leave_delegators(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn round_transitions() {\n\tlet col_max = 10;\n\tlet col_rewards = 15;\n\tlet d_max = 40;\n\tlet d_rewards = 10;\n\tlet inflation = InflationInfo::new(\n\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\tPerquintill::from_percent(col_max),\n\t\tPerquintill::from_percent(col_rewards),\n\t\tPerquintill::from_percent(d_max),\n\t\tPerquintill::from_percent(d_rewards),\n\t);\n\n\t// round_immediately_jumps_if_current_duration_exceeds_new_blocks_per_round\n\t// change from 5 bpr to 3 in block 5 -\u003e 8 should be new round\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 20)])\n\t\t.with_delegators(vec![(2, 1, 10), (3, 1, 10)])\n\t\t.with_inflation(col_max, col_rewards, d_max, d_rewards, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\t\t\troll_to(5, vec![]);\n\t\t\tlet init = vec![Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), init);\n\t\t\tassert_ok!(StakePallet::set_blocks_per_round(Origin::root(), 3));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::set_blocks_per_round(Origin::root(), 1),\n\t\t\t\tError::\u003cTest\u003e::CannotSetBelowMin\n\t\t\t);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::BlocksPerRoundSet(1, 5, 5, 3)));\n\n\t\t\t// inflation config should be untouched after per_block update\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\n\t\t\t// last round startet at 5 but we are already at 9, so we expect 9 to be the new\n\t\t\t// round\n\t\t\troll_to(8, vec![]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::NewRound(8, 2)));\n\t\t});\n\n\t// if duration of current round is less than new bpr, round waits until new bpr\n\t// passes\n\t// change from 5 bpr to 3 in block 6 -\u003e 8 should be new round\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 20)])\n\t\t.with_delegators(vec![(2, 1, 10), (3, 1, 10)])\n\t\t.with_inflation(col_max, col_rewards, d_max, d_rewards, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\t\t\t// Default round every 5 blocks, but MinBlocksPerRound is 3 and we set it to min\n\t\t\t// 3 blocks\n\t\t\troll_to(6, vec![]);\n\t\t\t// chooses top MaxSelectedCandidates (5), in order\n\t\t\tlet init = vec![Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), init);\n\t\t\tassert_ok!(StakePallet::set_blocks_per_round(Origin::root(), 3));\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::BlocksPerRoundSet(1, 5, 5, 3)));\n\n\t\t\t// inflation config should be untouched after per_block update\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\n\t\t\t// there should not be a new event\n\t\t\troll_to(7, vec![]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::BlocksPerRoundSet(1, 5, 5, 3)));\n\n\t\t\troll_to(8, vec![]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::NewRound(8, 2)));\n\t\t});\n\n\t// round_immediately_jumps_if_current_duration_exceeds_new_blocks_per_round\n\t// change from 5 bpr (blocks_per_round) to 3 in block 7 -\u003e 8 should be new round\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 20)])\n\t\t.with_delegators(vec![(2, 1, 10), (3, 1, 10)])\n\t\t.with_inflation(col_max, col_rewards, d_max, d_rewards, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// Default round every 5 blocks, but MinBlocksPerRound is 3 and we set it to min\n\t\t\t// 3 blocks\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\t\t\troll_to(7, vec![]);\n\t\t\t// chooses top MaxSelectedCandidates (5), in order\n\t\t\tlet init = vec![Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), init);\n\t\t\tassert_ok!(StakePallet::set_blocks_per_round(Origin::root(), 3));\n\n\t\t\t// inflation config should be untouched after per_block update\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::inflation_config(),\n\t\t\t\tInflationInfo::new(\n\t\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\t\tPerquintill::from_percent(col_max),\n\t\t\t\t\tPerquintill::from_percent(col_rewards),\n\t\t\t\t\tPerquintill::from_percent(d_max),\n\t\t\t\t\tPerquintill::from_percent(d_rewards)\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::BlocksPerRoundSet(1, 5, 5, 3)));\n\t\t\troll_to(8, vec![]);\n\n\t\t\t// last round startet at 5, so we expect 8 to be the new round\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::NewRound(8, 2)));\n\t\t});\n}\n\n#[test]\nfn coinbase_rewards_few_blocks_detailed_check() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 40_000_000 * DECIMALS),\n\t\t\t(2, 40_000_000 * DECIMALS),\n\t\t\t(3, 40_000_000 * DECIMALS),\n\t\t\t(4, 20_000_000 * DECIMALS),\n\t\t\t(5, 20_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 8_000_000 * DECIMALS), (2, 8_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![\n\t\t\t(3, 1, 32_000_000 * DECIMALS),\n\t\t\t(4, 1, 16_000_000 * DECIMALS),\n\t\t\t(5, 2, 16_000_000 * DECIMALS),\n\t\t])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet inflation = StakePallet::inflation_config();\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\t\t\tassert_eq!(total_issuance, 160_000_000 * DECIMALS);\n\n\t\t\t// compute rewards\n\t\t\tlet c_staking_rate = Perquintill::from_rational(16_000_000 * DECIMALS, total_issuance);\n\t\t\tlet c_rewards: BalanceOf\u003cTest\u003e = inflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t16_000_000 * DECIMALS,\n\t\t\t\tc_staking_rate,\n\t\t\t\t1u128,\n\t\t\t);\n\t\t\tlet d_staking_rate = Perquintill::from_rational(64_000_000 * DECIMALS, total_issuance);\n\t\t\tlet d_rewards: BalanceOf\u003cTest\u003e = inflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t64_000_000 * DECIMALS,\n\t\t\t\td_staking_rate,\n\t\t\t\t2u128,\n\t\t\t);\n\n\t\t\t// set 1 to be author for blocks 1-3, then 2 for blocks 4-5\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\tvec![None, Some(1u64), Some(1u64), Some(1u64), Some(2u64), Some(2u64)];\n\t\t\t// let d_rewards: Balance = 3 * 2469135802453333 / 2;\n\t\t\tlet user_1 = Balances::usable_balance(\u00261);\n\t\t\tlet user_2 = Balances::usable_balance(\u00262);\n\t\t\tlet user_3 = Balances::usable_balance(\u00263);\n\t\t\tlet user_4 = Balances::usable_balance(\u00264);\n\t\t\tlet user_5 = Balances::usable_balance(\u00265);\n\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5);\n\n\t\t\t// 1 is block author for 1st block\n\t\t\troll_to_claim_rewards(2, authors.clone());\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards / 2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 4);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5);\n\n\t\t\t// 1 is block author for 2nd block\n\t\t\troll_to_claim_rewards(3, authors.clone());\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + 2 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5);\n\n\t\t\t// 1 is block author for 3rd block\n\t\t\troll_to_claim_rewards(4, authors.clone());\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + 3 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards / 2 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 4 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5);\n\n\t\t\t// 2 is block author for 4th block\n\t\t\troll_to_claim_rewards(5, authors.clone());\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + 3 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2 + c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards / 2 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 4 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5 + d_rewards / 4);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(5)));\n\n\t\t\t// 2 is block author for 5th block\n\t\t\troll_to_claim_rewards(6, authors);\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + 3 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2 + 2 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards / 2 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 4 * 3);\n\t\t\t// should not receive rewards due to revoked delegation\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5 + d_rewards / 4);\n\t\t});\n}\n\n#[test]\nfn delegator_should_not_receive_rewards_after_revoking() {\n\t// test edge case of 1 delegator\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10_000_000 * DECIMALS), (2, 10_000_000 * DECIMALS)])\n\t\t.with_collators(vec![(1, 10_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, 10_000_000 * DECIMALS)])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e = (1u64..100u64).map(|_| Some(1u64)).collect();\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), Balance::zero());\n\t\t\troll_to_claim_rewards(100, authors);\n\t\t\tassert!(Balances::usable_balance(\u00261) \u003e Balance::zero());\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), 10_000_000 * DECIMALS);\n\t\t});\n\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 10_000_000 * DECIMALS),\n\t\t\t(2, 10_000_000 * DECIMALS),\n\t\t\t(3, 10_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 10_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, 10_000_000 * DECIMALS), (3, 1, 10_000_000 * DECIMALS)])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(3)));\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e = (1u64..100u64).map(|_| Some(1u64)).collect();\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), Balance::zero());\n\t\t\troll_to_claim_rewards(100, authors);\n\t\t\tassert!(Balances::usable_balance(\u00261) \u003e Balance::zero());\n\t\t\tassert!(Balances::usable_balance(\u00262) \u003e Balance::zero());\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(3), 3));\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), 10_000_000 * DECIMALS);\n\t\t});\n}\n#[test]\nfn coinbase_rewards_many_blocks_simple_check() {\n\tlet num_of_years: Perquintill = Perquintill::from_perthousand(2);\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 40_000_000 * DECIMALS),\n\t\t\t(2, 40_000_000 * DECIMALS),\n\t\t\t(3, 40_000_000 * DECIMALS),\n\t\t\t(4, 20_000_000 * DECIMALS),\n\t\t\t(5, 20_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 8_000_000 * DECIMALS), (2, 8_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![\n\t\t\t(3, 1, 32_000_000 * DECIMALS),\n\t\t\t(4, 1, 16_000_000 * DECIMALS),\n\t\t\t(5, 2, 16_000_000 * DECIMALS),\n\t\t])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet inflation = StakePallet::inflation_config();\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\t\t\tassert_eq!(total_issuance, 160_000_000 * DECIMALS);\n\t\t\tlet end_block: BlockNumber = num_of_years * Test::BLOCKS_PER_YEAR as BlockNumber;\n\t\t\t// set round robin authoring\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\t(0u64..=end_block).map(|i| Some(i % 2 + 1)).collect();\n\t\t\troll_to_claim_rewards(end_block, authors);\n\n\t\t\tlet rewards_1 = Balances::free_balance(\u00261).saturating_sub(40_000_000 * DECIMALS);\n\t\t\tlet rewards_2 = Balances::free_balance(\u00262).saturating_sub(40_000_000 * DECIMALS);\n\t\t\tlet rewards_3 = Balances::free_balance(\u00263).saturating_sub(40_000_000 * DECIMALS);\n\t\t\tlet rewards_4 = Balances::free_balance(\u00264).saturating_sub(20_000_000 * DECIMALS);\n\t\t\tlet rewards_5 = Balances::free_balance(\u00265).saturating_sub(20_000_000 * DECIMALS);\n\t\t\tlet expected_collator_rewards =\n\t\t\t\tnum_of_years * inflation.collator.reward_rate.annual * 16_000_000 * DECIMALS;\n\t\t\tlet expected_delegator_rewards =\n\t\t\t\tnum_of_years * inflation.delegator.reward_rate.annual * 64_000_000 * DECIMALS;\n\n\t\t\t// 1200000000000000000000\n\t\t\t// 2399074074058720000\n\n\t\t\t// collator rewards should be about the same\n\t\t\tassert!(almost_equal(rewards_1, rewards_2, Perbill::from_perthousand(1)));\n\t\t\tassert!(\n\t\t\t\talmost_equal(\n\t\t\t\t\trewards_1,\n\t\t\t\t\tnum_of_years * inflation.collator.reward_rate.annual * 8_000_000 * DECIMALS,\n\t\t\t\t\tPerbill::from_perthousand(1)\n\t\t\t\t),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\trewards_1,\n\t\t\t\tinflation.collator.reward_rate.annual * 8_000_000 * DECIMALS,\n\t\t\t);\n\n\t\t\t// delegator rewards should be about the same\n\t\t\tassert!(\n\t\t\t\talmost_equal(rewards_3, rewards_4 + rewards_5, Perbill::from_perthousand(1)),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\trewards_3,\n\t\t\t\trewards_4 + rewards_5\n\t\t\t);\n\t\t\tassert!(almost_equal(\n\t\t\t\trewards_3,\n\t\t\t\tnum_of_years * inflation.delegator.reward_rate.annual * 32_000_000 * DECIMALS,\n\t\t\t\tPerbill::from_perthousand(1)\n\t\t\t));\n\n\t\t\t// check rewards in total\n\t\t\tassert!(\n\t\t\t\talmost_equal(\n\t\t\t\t\trewards_1 + rewards_2,\n\t\t\t\t\texpected_collator_rewards,\n\t\t\t\t\tPerbill::from_perthousand(1),\n\t\t\t\t),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\trewards_1 + rewards_2,\n\t\t\t\texpected_collator_rewards,\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\talmost_equal(\n\t\t\t\t\trewards_3 + rewards_4 + rewards_5,\n\t\t\t\t\texpected_delegator_rewards,\n\t\t\t\t\tPerbill::from_perthousand(1),\n\t\t\t\t),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\trewards_3 + rewards_4 + rewards_5,\n\t\t\t\texpected_delegator_rewards,\n\t\t\t);\n\n\t\t\t// old issuance + rewards should equal new issuance\n\t\t\tassert!(\n\t\t\t\talmost_equal(\n\t\t\t\t\ttotal_issuance + expected_collator_rewards + expected_delegator_rewards,\n\t\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance(),\n\t\t\t\t\tPerbill::from_perthousand(1),\n\t\t\t\t),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\ttotal_issuance + expected_collator_rewards + expected_delegator_rewards,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance(),\n\t\t\t);\n\t\t});\n}\n\n// Could only occur if we increase MinDelegatorStakeOf::\u003cTest\u003evia runtime\n// upgrade and don't migrate delegators which fall below minimum\n#[test]\nfn should_not_reward_delegators_below_min_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10 * DECIMALS), (2, 10 * DECIMALS), (3, 10 * DECIMALS), (4, 5)])\n\t\t.with_collators(vec![(1, 10 * DECIMALS), (2, 10 * DECIMALS)])\n\t\t.with_delegators(vec![(3, 2, 10 * DECIMALS)])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// impossible but lets assume it happened\n\t\t\tlet mut state =\n\t\t\t\tStakePallet::candidate_pool(\u00261).expect(\"CollatorState cannot be missing\");\n\t\t\tlet delegator_stake_below_min = \u003cTest as Config\u003e::MinDelegatorStake::get() - 1;\n\t\t\tstate.stake += delegator_stake_below_min;\n\t\t\tstate.total += delegator_stake_below_min;\n\t\t\tlet impossible_bond =\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4u64, amount: delegator_stake_below_min };\n\t\t\tassert_eq!(state.delegators.try_insert(impossible_bond), Ok(true));\n\t\t\t\u003ccrate::CandidatePool\u003cTest\u003e\u003e::insert(\u00261u64, state);\n\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\tvec![Some(1u64), Some(1u64), Some(1u64), Some(1u64)];\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), 5);\n\n\t\t\t// should only reward 1\n\t\t\troll_to_claim_rewards(4, authors);\n\t\t\tassert!(Balances::usable_balance(\u00261) \u003e Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), 5);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), Balance::zero());\n\t\t});\n}\n\n#[test]\n#[should_panic]\nfn should_deny_low_delegator_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10 * DECIMALS), (2, 10 * DECIMALS), (3, 10 * DECIMALS), (4, 1)])\n\t\t.with_collators(vec![(1, 10 * DECIMALS), (2, 10 * DECIMALS)])\n\t\t.with_delegators(vec![(4, 2, 1)])\n\t\t.build()\n\t\t.execute_with(|| {});\n}\n\n#[test]\n#[should_panic]\nfn should_deny_low_collator_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10 * DECIMALS), (2, 5)])\n\t\t.with_collators(vec![(1, 10 * DECIMALS), (2, 5)])\n\t\t.build()\n\t\t.execute_with(|| {});\n}\n\n#[test]\n#[should_panic]\nfn should_deny_duplicate_collators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10 * DECIMALS)])\n\t\t.with_collators(vec![(1, 10 * DECIMALS), (1, 10 * DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {});\n}\n\n#[test]\nfn reach_max_top_candidates() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 11),\n\t\t\t(2, 20),\n\t\t\t(3, 11),\n\t\t\t(4, 11),\n\t\t\t(5, 11),\n\t\t\t(6, 11),\n\t\t\t(7, 11),\n\t\t\t(8, 11),\n\t\t\t(9, 11),\n\t\t\t(10, 11),\n\t\t\t(11, 11),\n\t\t\t(12, 12),\n\t\t\t(13, 13),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().len().saturated_into::\u003cu32\u003e(),\n\t\t\t\t\u003cTest as Config\u003e::MaxTopCandidates::get()\n\t\t\t);\n\t\t\t// should not be possible to join candidate pool, even with more stake\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(11), 11));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\tvec![2, 11, 1, 3, 4, 5, 6, 7, 8, 9]\n\t\t\t);\n\t\t\t// last come, last one in the list\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(12), 11));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\tvec![2, 11, 12, 1, 3, 4, 5, 6, 7, 8]\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(3), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(4), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(5), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(6), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(7), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(8), 1));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\tvec![2, 11, 12, 1, 3, 4, 5, 6, 7, 8]\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn should_estimate_current_session_progress() {\n\tExtBuilder::default()\n\t\t.set_blocks_per_round(100)\n\t\t.with_balances(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t\t(11, 10),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(10).0.unwrap(),\n\t\t\t\tPermill::from_percent(10)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(20).0.unwrap(),\n\t\t\t\tPermill::from_percent(20)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(30).0.unwrap(),\n\t\t\t\tPermill::from_percent(30)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(60).0.unwrap(),\n\t\t\t\tPermill::from_percent(60)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(100).0.unwrap(),\n\t\t\t\tPermill::from_percent(100)\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn should_estimate_next_session_rotation() {\n\tExtBuilder::default()\n\t\t.set_blocks_per_round(100)\n\t\t.with_balances(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t\t(11, 10),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(10).0.unwrap(), 100);\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(20).0.unwrap(), 100);\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(30).0.unwrap(), 100);\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(60).0.unwrap(), 100);\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(100).0.unwrap(), 100);\n\t\t});\n}\n\n#[test]\nfn should_end_session_when_appropriate() {\n\tExtBuilder::default()\n\t\t.set_blocks_per_round(100)\n\t\t.with_balances(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t\t(11, 10),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert!(!StakePallet::should_end_session(10));\n\t\t\tassert!(!StakePallet::should_end_session(20));\n\t\t\tassert!(!StakePallet::should_end_session(30));\n\t\t\tassert!(!StakePallet::should_end_session(60));\n\t\t\tassert!(StakePallet::should_end_session(100));\n\t\t});\n}\n\n#[test]\nfn set_max_selected_candidates_safe_guards() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::set_max_selected_candidates(\n\t\t\t\t\tOrigin::root(),\n\t\t\t\t\t\u003cTest as Config\u003e::MinCollators::get() - 1\n\t\t\t\t),\n\t\t\t\tError::\u003cTest\u003e::CannotSetBelowMin\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::set_max_selected_candidates(\n\t\t\t\t\tOrigin::root(),\n\t\t\t\t\t\u003cTest as Config\u003e::MaxTopCandidates::get() + 1\n\t\t\t\t),\n\t\t\t\tError::\u003cTest\u003e::CannotSetAboveMax\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(\n\t\t\t\tOrigin::root(),\n\t\t\t\t\u003cTest as Config\u003e::MinCollators::get() + 1\n\t\t\t));\n\t\t});\n}\n\n#[test]\nfn set_max_selected_candidates_total_stake() {\n\tlet balances: Vec\u003c(AccountId, Balance)\u003e = (1..19).map(|x| (x, 100)).collect();\n\tExtBuilder::default()\n\t\t.with_balances(balances)\n\t\t.with_collators(vec![\n\t\t\t(1, 11),\n\t\t\t(2, 12),\n\t\t\t(3, 13),\n\t\t\t(4, 14),\n\t\t\t(5, 15),\n\t\t\t(6, 16),\n\t\t\t(7, 17),\n\t\t\t(8, 18),\n\t\t])\n\t\t.with_delegators(vec![\n\t\t\t(11, 1, 21),\n\t\t\t(12, 2, 22),\n\t\t\t(13, 3, 23),\n\t\t\t(14, 4, 24),\n\t\t\t(15, 5, 25),\n\t\t\t(16, 6, 26),\n\t\t\t(17, 7, 27),\n\t\t\t(18, 8, 28),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 35, delegators: 55 }\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 3));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 51, delegators: 81 }\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 80, delegators: 130 }\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 116, delegators: 196 }\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 2));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 35, delegators: 55 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_inflation() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet mut invalid_inflation = InflationInfo {\n\t\t\t\tcollator: StakingInfo {\n\t\t\t\t\tmax_rate: Perquintill::one(),\n\t\t\t\t\treward_rate: RewardRate {\n\t\t\t\t\t\tannual: Perquintill::from_percent(99),\n\t\t\t\t\t\tper_block: Perquintill::from_percent(1),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdelegator: StakingInfo {\n\t\t\t\t\tmax_rate: Perquintill::one(),\n\t\t\t\t\treward_rate: RewardRate {\n\t\t\t\t\t\tannual: Perquintill::from_percent(99),\n\t\t\t\t\t\tper_block: Perquintill::from_percent(1),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t\tassert!(!invalid_inflation.is_valid(\u003cTest as Config\u003e::BLOCKS_PER_YEAR));\n\t\t\tinvalid_inflation.collator.reward_rate.per_block = Perquintill::zero();\n\t\t\tassert!(!invalid_inflation.is_valid(\u003cTest as Config\u003e::BLOCKS_PER_YEAR));\n\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\tPerquintill::from_percent(0),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t));\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(0),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t));\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(0),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t));\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(0),\n\t\t\t));\n\t\t});\n}\n\n#[test]\nfn unlock_unstaked() {\n\t// same_unstaked_as_restaked\n\t// block 1: stake \u0026 unstake for 100\n\t// block 2: stake \u0026 unstake for 100\n\t// should remove first entry in unstaking BoundedBTreeMap when staking in block\n\t// 2 should still have 100 locked until unlocking\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10), (2, 100)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.with_delegators(vec![(2, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(3, 100));\n\t\t\tlet lock = BalanceLock { id: STAKING_ID, amount: 100, reasons: Reasons::All };\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// join delegators and revoke again --\u003e consume unstaking at block 3\n\t\t\troll_to(2, vec![]);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tunstaking.remove(\u00263);\n\t\t\tassert_ok!(unstaking.try_insert(4, 100));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// should reduce unlocking but not unlock anything\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(4, vec![]);\n\t\t\tunstaking.remove(\u00264);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![]);\n\t\t});\n\n\t// less_unstaked_than_restaked\n\t// block 1: stake \u0026 unstake for 10\n\t// block 2: stake \u0026 unstake for 100\n\t// should remove first entry in unstaking BoundedBTreeMap when staking in block\n\t// 2 should still have 90 locked until unlocking in block 4\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10), (2, 100)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.with_delegators(vec![(2, 1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(3, 10));\n\t\t\tlet mut lock = BalanceLock { id: STAKING_ID, amount: 10, reasons: Reasons::All };\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// join delegators and revoke again\n\t\t\troll_to(2, vec![]);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tunstaking.remove(\u00263);\n\t\t\tassert_ok!(unstaking.try_insert(4, 100));\n\t\t\tlock.amount = 100;\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// unlock unstaked, remove lock, empty unlocking\n\t\t\troll_to(4, vec![]);\n\t\t\tunstaking.remove(\u00264);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock]);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![]);\n\t\t});\n\n\t// more_unstaked_than_restaked\n\t// block 1: stake \u0026 unstake for 100\n\t// block 2: stake \u0026 unstake for 10\n\t// should reduce first entry from amount 100 to 90 in unstaking BoundedBTreeMap\n\t// when staking in block 2\n\t// should have 100 locked until unlocking in block 3, then 10\n\t// should have 10 locked until further unlocking in block 4\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10), (2, 100)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.with_delegators(vec![(2, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(3, 100));\n\t\t\tlet mut lock = BalanceLock { id: STAKING_ID, amount: 100, reasons: Reasons::All };\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// join delegators and revoke again\n\t\t\troll_to(2, vec![]);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert_ok!(unstaking.try_insert(3, 90));\n\t\t\tassert_ok!(unstaking.try_insert(4, 10));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// should reduce unlocking but not unlock anything\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// should be able to unlock 90 of 100 from unstaking\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tunstaking.remove(\u00263);\n\t\t\tlock.amount = 10;\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock]);\n\t\t\t// should be able to unlock 10 of remaining 10\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tunstaking.remove(\u00264);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![]);\n\t\t});\n\n\t// test_stake_less\n\t// block 1: stake \u0026 unstake for 100\n\t// block 2: stake \u0026 unstake for 10\n\t// should reduce first entry from amount 100 to 90 in unstaking BoundedBTreeMap\n\t// when staking in block 2\n\t// should have 100 locked until unlocking in block 3, then 10\n\t// should have 10 locked until further unlocking in block 4\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200)])\n\t\t.with_collators(vec![(1, 200)])\n\t\t.with_delegators(vec![(2, 1, 200)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// should be able to decrease more often than MaxUnstakeRequests because it's\n\t\t\t// the same block and thus unstaking is increased at block 3 instead of having\n\t\t\t// multiple entries for the same block\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10),);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10),);\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(3, 60));\n\t\t\tlet mut lock = BalanceLock { id: STAKING_ID, amount: 200, reasons: Reasons::All };\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(2, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10),);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10),);\n\t\t\tassert_ok!(unstaking.try_insert(4, 10));\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10),);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10),);\n\t\t\tassert_ok!(unstaking.try_insert(5, 10));\n\t\t\tassert_ok!(unstaking.try_insert(5, 10));\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\t// should unlock 60\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tlock.amount = 140;\n\t\t\tunstaking.remove(\u00263);\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// reach MaxUnstakeRequests\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\troll_to(5, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\troll_to(6, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(unstaking.try_insert(6, 10));\n\t\t\tassert_ok!(unstaking.try_insert(7, 10));\n\t\t\tassert_ok!(unstaking.try_insert(8, 10));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(7, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(1), 10),\n\t\t\t\tError::\u003cTest\u003e::NoMoreUnstaking\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(2), 1, 10),\n\t\t\t\tError::\u003cTest\u003e::NoMoreUnstaking\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tunstaking.remove(\u00264);\n\t\t\tunstaking.remove(\u00265);\n\t\t\tunstaking.remove(\u00266);\n\t\t\tunstaking.remove(\u00267);\n\t\t\tlock.amount = 100;\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 40));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 40));\n\t\t\tassert_ok!(unstaking.try_insert(9, 40));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 30));\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(2), 1, 30));\n\t\t\tunstaking.remove(\u00268);\n\t\t\tassert_ok!(unstaking.try_insert(9, 20));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock]);\n\t\t});\n}\n\n#[test]\nfn kick_candidate_with_full_unstaking() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200), (3, 300)])\n\t\t.with_collators(vec![(1, 200), (2, 200), (3, 200)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet max_unstake_reqs: usize =\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests::get().saturating_sub(1).saturated_into();\n\t\t\t// Fill unstake requests\n\t\t\tfor block in 1u64..1u64.saturating_add(max_unstake_reqs as u64) {\n\t\t\t\tSystem::set_block_number(block);\n\t\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(3), 1));\n\t\t\t}\n\t\t\tassert_eq!(StakePallet::unstaking(3).into_inner().len(), max_unstake_reqs);\n\n\t\t\t// Additional unstake should fail\n\t\t\tSystem::set_block_number(100);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(3), 1),\n\t\t\t\tError::\u003cTest\u003e::NoMoreUnstaking\n\t\t\t);\n\n\t\t\t// Fill last unstake request by removing candidate and unstaking all stake\n\t\t\tassert_ok!(StakePallet::force_remove_candidate(Origin::root(), 3));\n\n\t\t\t// Cannot join with full unstaking\n\t\t\tassert_eq!(StakePallet::unstaking(3).into_inner().len(), max_unstake_reqs + 1);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(3), 100),\n\t\t\t\tError::\u003cTest\u003e::CannotJoinBeforeUnlocking\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(3), 3));\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(3), 100));\n\t\t});\n}\n#[test]\nfn kick_delegator_with_full_unstaking() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200), (3, 200), (4, 200), (5, 420), (6, 200)])\n\t\t.with_collators(vec![(1, 200)])\n\t\t.with_delegators(vec![(2, 1, 200), (3, 1, 200), (4, 1, 200), (5, 1, 200)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet max_unstake_reqs: usize =\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests::get().saturating_sub(1).saturated_into();\n\t\t\t// Fill unstake requests\n\t\t\tfor block in 1u64..1u64.saturating_add(max_unstake_reqs as u64) {\n\t\t\t\tSystem::set_block_number(block);\n\t\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(5), 1, 1));\n\t\t\t}\n\t\t\tassert_eq!(StakePallet::unstaking(5).into_inner().len(), max_unstake_reqs);\n\n\t\t\t// Additional unstake should fail\n\t\t\tSystem::set_block_number(100);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(5), 1, 1),\n\t\t\t\tError::\u003cTest\u003e::NoMoreUnstaking\n\t\t\t);\n\n\t\t\t// Fill last unstake request by replacing delegator\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 1, 200));\n\t\t\tassert_eq!(StakePallet::unstaking(5).into_inner().len(), max_unstake_reqs + 1);\n\t\t\tassert!(!StakePallet::is_delegator(\u00265));\n\n\t\t\t// Cannot join with full unstaking\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(5), 1, 100),\n\t\t\t\tError::\u003cTest\u003e::CannotJoinBeforeUnlocking\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(5), 5));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(5), 1, 220));\n\t\t});\n}\n\n#[test]\nfn candidate_leaves() {\n\tlet balances: Vec\u003c(AccountId, Balance)\u003e = (1u64..=15u64).map(|id| (id, 100)).collect();\n\tExtBuilder::default()\n\t\t.with_balances(balances)\n\t\t.with_collators(vec![(1, 100), (2, 100)])\n\t\t.with_delegators(vec![(12, 1, 100), (13, 1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\tvec![1, 2]\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(11)),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::TooFewCollatorCandidates\n\t\t\t);\n\t\t\t// add five more collator to max fill TopCandidates\n\t\t\tfor candidate in 3u64..11u64 {\n\t\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(candidate), 100));\n\t\t\t}\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\t(1u64..11u64).collect::\u003cVec\u003cu64\u003e\u003e()\n\t\t\t);\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 10);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\t(2u64..11u64).collect::\u003cVec\u003cu64\u003e\u003e()\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(15), 1, 10),\n\t\t\t\tError::\u003cTest\u003e::CannotDelegateIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(12), 1, 1),\n\t\t\t\tError::\u003cTest\u003e::CannotDelegateIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(12), 1, 1),\n\t\t\t\tError::\u003cTest\u003e::CannotDelegateIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::CannotStakeIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::CannotStakeIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::AlreadyLeaving\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::candidate_pool(1).unwrap().status, CandidateStatus::Leaving(2));\n\t\t\tassert!(StakePallet::candidate_pool(1).unwrap().can_exit(2));\n\t\t\tassert!(!StakePallet::candidate_pool(1).unwrap().can_exit(1));\n\t\t\tassert!(StakePallet::candidate_pool(1).unwrap().can_exit(3));\n\n\t\t\t// next rounds starts, cannot leave yet\n\t\t\troll_to(5, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::execute_leave_candidates(Origin::signed(2), 2),\n\t\t\t\tError::\u003cTest\u003e::NotLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::execute_leave_candidates(Origin::signed(2), 1),\n\t\t\t\tError::\u003cTest\u003e::CannotLeaveYet\n\t\t\t);\n\t\t\t// add 11 as candidate to reach max size for TopCandidates and then try leave\n\t\t\t// again as 1 which should not be possible\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(11), 100));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\t(2u64..12u64).collect::\u003cVec\u003cu64\u003e\u003e()\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(11)));\n\t\t\t// join back\n\t\t\tassert_ok!(StakePallet::cancel_leave_candidates(Origin::signed(1)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\t(1u64..11u64).collect::\u003cVec\u003cu64\u003e\u003e()\n\t\t\t);\n\n\t\t\tlet stake: Vec\u003cStake\u003cAccountId, Balance\u003e\u003e = (1u64..11u64)\n\t\t\t\t.zip(iter::once(210).chain(iter::repeat(100)))\n\t\t\t\t.map(|(id, amount)| StakeOf::\u003cTest\u003e { owner: id, amount })\n\t\t\t\t.collect();\n\t\t\tassert_eq!(StakePallet::top_candidates(), OrderedSet::from(stake.try_into().unwrap()));\n\t\t\tlet state = StakePallet::candidate_pool(1).unwrap();\n\t\t\tassert_eq!(state.status, CandidateStatus::Active);\n\t\t\tassert_eq!(state.delegators.len(), 2);\n\t\t\tassert_eq!(state.total, 210);\n\t\t\tassert_eq!(\n\t\t\t\tstate.total,\n\t\t\t\tStakePallet::top_candidates()\n\t\t\t\t\t.into_bounded_vec()\n\t\t\t\t\t.iter()\n\t\t\t\t\t.find(|other| other.owner == 1)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.amount\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\n\t\t\troll_to(15, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(13), 1));\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(17, 100));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(12), unstaking);\n\n\t\t\t// cannot unlock yet\n\t\t\troll_to(16, vec![]);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(4), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(4), 12));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(12), unstaking);\n\n\t\t\t// can unlock now\n\t\t\troll_to(17, vec![]);\n\t\t\tunstaking.remove(\u002617);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(4), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(4), 12));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(12), unstaking);\n\t\t});\n}\n\n#[test]\nfn adjust_reward_rates() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10_000_000 * DECIMALS), (2, 90_000_000 * DECIMALS)])\n\t\t.with_collators(vec![(1, 10_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, 40_000_000 * DECIMALS)])\n\t\t.with_inflation(10, 10, 40, 8, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet inflation_0 = StakePallet::inflation_config();\n\t\t\tlet num_of_years = 3 * \u003cTest as Config\u003e::BLOCKS_PER_YEAR;\n\t\t\t// 1 authors every block\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\t(0u64..=num_of_years).map(|_| Some(1u64)).collect();\n\n\t\t\t// reward once in first year\n\t\t\troll_to_claim_rewards(2, authors.clone());\n\t\t\tlet c_rewards_0 = Balances::free_balance(\u00261).saturating_sub(10_000_000 * DECIMALS);\n\t\t\tlet d_rewards_0 = Balances::free_balance(\u00262).saturating_sub(90_000_000 * DECIMALS);\n\t\t\tassert!(!c_rewards_0.is_zero());\n\t\t\tassert!(!d_rewards_0.is_zero());\n\n\t\t\t// finish first year\n\t\t\tSystem::set_block_number(\u003cTest as Config\u003e::BLOCKS_PER_YEAR);\n\t\t\troll_to_claim_rewards(\u003cTest as Config\u003e::BLOCKS_PER_YEAR + 1, vec![]);\n\t\t\t// reward reduction should not happen automatically anymore\n\t\t\tassert_eq!(StakePallet::last_reward_reduction(), 0u64);\n\t\t\tassert_ok!(StakePallet::execute_scheduled_reward_change(Origin::signed(1)));\n\t\t\tassert_eq!(StakePallet::last_reward_reduction(), 1u64);\n\t\t\tlet inflation_1 = InflationInfo::new(\n\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\tinflation_0.collator.max_rate,\n\t\t\t\tPerquintill::from_parts(98000000000000000),\n\t\t\t\tinflation_0.delegator.max_rate,\n\t\t\t\tPerquintill::from_percent(7),\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::inflation_config(), inflation_1);\n\t\t\t// reward once in 2nd year\n\t\t\troll_to_claim_rewards(\u003cTest as Config\u003e::BLOCKS_PER_YEAR + 2, authors.clone());\n\t\t\tlet c_rewards_1 = Balances::free_balance(\u00261)\n\t\t\t\t.saturating_sub(10_000_000 * DECIMALS)\n\t\t\t\t.saturating_sub(c_rewards_0);\n\t\t\tlet d_rewards_1 = Balances::free_balance(\u00262)\n\t\t\t\t.saturating_sub(90_000_000 * DECIMALS)\n\t\t\t\t.saturating_sub(d_rewards_0);\n\t\t\tassert!(c_rewards_0 \u003e c_rewards_1, \"left {:?}, right {:?}\", c_rewards_0, c_rewards_1);\n\t\t\tassert!(d_rewards_0 \u003e d_rewards_1);\n\n\t\t\t// finish 2nd year\n\t\t\tSystem::set_block_number(2 * \u003cTest as Config\u003e::BLOCKS_PER_YEAR);\n\t\t\troll_to_claim_rewards(2 * \u003cTest as Config\u003e::BLOCKS_PER_YEAR + 1, vec![]);\n\t\t\t// reward reduction should not happen automatically anymore\n\t\t\tassert_eq!(StakePallet::last_reward_reduction(), 1u64);\n\t\t\tassert_ok!(StakePallet::execute_scheduled_reward_change(Origin::signed(1)));\n\t\t\tassert_eq!(StakePallet::last_reward_reduction(), 2u64);\n\t\t\tlet inflation_2 = InflationInfo::new(\n\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\tinflation_0.collator.max_rate,\n\t\t\t\tPerquintill::from_parts(96040000000000000),\n\t\t\t\tinflation_0.delegator.max_rate,\n\t\t\t\tPerquintill::zero(),\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::inflation_config(), inflation_2);\n\t\t\t// reward once in 3rd year\n\t\t\troll_to_claim_rewards(2 * \u003cTest as Config\u003e::BLOCKS_PER_YEAR + 2, authors);\n\t\t\tlet c_rewards_2 = Balances::free_balance(\u00261)\n\t\t\t\t.saturating_sub(10_000_000 * DECIMALS)\n\t\t\t\t.saturating_sub(c_rewards_0)\n\t\t\t\t.saturating_sub(c_rewards_1);\n\t\t\tlet d_rewards_2 = Balances::free_balance(\u00262)\n\t\t\t\t.saturating_sub(90_000_000 * DECIMALS)\n\t\t\t\t.saturating_sub(d_rewards_0)\n\t\t\t\t.saturating_sub(d_rewards_1);\n\t\t\tassert!(c_rewards_1 \u003e c_rewards_2);\n\t\t\tassert!(d_rewards_2.is_zero());\n\t\t});\n}\n\n#[test]\nfn increase_max_candidate_stake() {\n\tlet max_stake = 160_000_000 * DECIMALS;\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200_000_000 * DECIMALS)])\n\t\t.with_collators(vec![(1, max_stake)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::max_candidate_stake(), max_stake);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_candidate_stake(Origin::root(), max_stake + 1));\n\t\t\tassert_eq!(\n\t\t\t\tlast_event(),\n\t\t\t\tMetaEvent::StakePallet(Event::MaxCandidateStakeChanged(max_stake + 1))\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::max_candidate_stake(), max_stake + 1);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 1));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn decrease_max_candidate_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100)])\n\t\t.with_collators(vec![(1, 100), (2, 90), (3, 40)])\n\t\t.with_delegators(vec![(4, 2, 10), (5, 3, 20)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 60 }\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_candidate_stake(Origin::root(), 50));\n\t\t\tassert_eq!(StakePallet::max_candidate_stake(), 50);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::MaxCandidateStakeChanged(50)));\n\n\t\t\t// check collator states, nothing changed\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 60 }\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 0),\n\t\t\t\tError::\u003cTest\u003e::ValStakeZero\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(1), 0),\n\t\t\t\tError::\u003cTest\u003e::ValStakeZero\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 50));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::set_max_candidate_stake(Origin::root(), 9),\n\t\t\t\tError::\u003cTest\u003e::CannotSetBelowMin\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn exceed_delegations_per_round() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.with_delegators(vec![(2, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// leave and re-join to set counter to 2 (= MaxDelegationsPerRound)\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\t// reached max delegations in this round\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(2), 1, 100),\n\t\t\t\tError::\u003cTest\u003e::DelegationsPerRoundExceeded\n\t\t\t);\n\n\t\t\t// roll to next round to clear DelegationCounter\n\t\t\troll_to(5, vec![]);\n\t\t\tassert_eq!(StakePallet::last_delegation(2), DelegationCounter { round: 0, counter: 2 });\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\t// counter should be reset because the round changed\n\t\t\tassert_eq!(StakePallet::last_delegation(2), DelegationCounter { round: 1, counter: 1 });\n\t\t\t// leave and re-join to set counter to 2 (= MaxDelegationsPerRound))\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(2), 1, 100),\n\t\t\t\tError::\u003cTest\u003e::AlreadyDelegating\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(2), 1, 100),\n\t\t\t\tError::\u003cTest\u003e::DelegationsPerRoundExceeded\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::last_delegation(2), DelegationCounter { round: 1, counter: 2 });\n\t\t});\n}\n\n#[test]\nfn force_remove_candidate() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 100), (2, 100), (3, 100)])\n\t\t.with_delegators(vec![(4, 1, 50), (5, 1, 50)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 3);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 2, 50));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\tassert!(StakePallet::unstaking(1).get(\u00263).is_none());\n\t\t\tassert!(StakePallet::unstaking(2).get(\u00263).is_none());\n\t\t\tassert!(StakePallet::unstaking(3).get(\u00263).is_none());\n\n\t\t\t// force remove 1\n\t\t\tassert!(Session::disabled_validators().is_empty());\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::force_remove_candidate(Origin::root(), 1));\n\t\t\t// collator stake does not change since 3, who took 1's place, has staked the\n\t\t\t// same amount\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 50 }\n\t\t\t);\n\t\t\tassert_eq!(Session::disabled_validators(), vec![0]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorRemoved(1, 200)));\n\t\t\tassert!(\n\t\t\t\t!StakePallet::top_candidates().contains(\u0026StakeOf::\u003cTest\u003e { owner: 1, amount: 100 })\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 3]);\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\t\t\tassert!(StakePallet::candidate_pool(1).is_none());\n\t\t\tassert!(StakePallet::delegator_state(4).is_none());\n\t\t\tassert!(StakePallet::delegator_state(5).is_none());\n\t\t\tassert_eq!(StakePallet::unstaking(1).get(\u00263), Some(\u0026100));\n\t\t\tassert_eq!(StakePallet::unstaking(4).get(\u00263), Some(\u002650));\n\t\t\tassert_eq!(StakePallet::unstaking(5).get(\u00263), Some(\u002650));\n\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::force_remove_candidate(Origin::root(), 2),\n\t\t\t\tError::\u003cTest\u003e::TooFewCollatorCandidates\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::force_remove_candidate(Origin::root(), 4),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\n\t\t\t// session 1: expect 1 to still be in validator set but as disabled\n\t\t\troll_to(5, vec![]);\n\t\t\tassert_eq!(Session::current_index(), 1);\n\t\t\tassert_eq!(Session::validators(), vec![1, 2]);\n\t\t\tassert_eq!(Session::disabled_validators(), vec![0]);\n\n\t\t\t// session 2: expect validator set to have changed\n\t\t\troll_to(10, vec![]);\n\t\t\tassert_eq!(Session::validators(), vec![2, 3]);\n\t\t\tassert!(Session::disabled_validators().is_empty());\n\t\t});\n}\n\n#[test]\nfn prioritize_collators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200), (3, 200), (4, 200), (5, 200), (6, 200), (7, 200)])\n\t\t.with_collators(vec![(2, 100), (3, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![2, 3]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 3]);\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(1), 100));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![2, 3, 1]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 3]);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\tassert_eq!(StakePallet::top_candidates().len(), 2);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![3, 1]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(3), 10));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 3]);\n\n\t\t\t// add 6\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(6), 100));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![1, 6]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.chain(vec![StakeOf::\u003cTest\u003e { owner: 3, amount: 90 }])\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// add 4\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(4), 100));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![1, 6, 4]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.chain(vec![StakeOf::\u003cTest\u003e { owner: 3, amount: 90 }])\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// add 5\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(5), 100));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![1, 6, 4, 5]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.chain(vec![StakeOf::\u003cTest\u003e { owner: 3, amount: 90 }])\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// 3 stake_more\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(3), 20));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![3, 1]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// 1 stake_less\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 1));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![3, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 99 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// 7 delegates to 4\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(7), 5, 20));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![5, 3]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 120 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 99 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// 7 decreases delegation\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(7), 5, 10));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![5, 3]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 99 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(7)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![3, 5]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 99 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn prioritize_delegators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 1000),\n\t\t\t(3, 1000),\n\t\t\t(4, 1000),\n\t\t\t(5, 1000),\n\t\t\t(6, 1000),\n\t\t\t(7, 1000),\n\t\t\t(8, 1000),\n\t\t\t(9, 1000),\n\t\t])\n\t\t.with_collators(vec![(1, 100), (2, 100), (3, 100)])\n\t\t.with_delegators(vec![(4, 2, 100), (7, 2, 100), (6, 2, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 1]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(5), 2, 110));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// delegate_less\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(5), 2, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// delegate_more\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(6), 2, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(7), 2, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn authorities_per_round() {\n\tlet stake = 100 * DECIMALS;\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, stake),\n\t\t\t(2, stake),\n\t\t\t(3, stake),\n\t\t\t(4, stake),\n\t\t\t(5, stake),\n\t\t\t(6, stake),\n\t\t\t(7, stake),\n\t\t\t(8, stake),\n\t\t\t(9, stake),\n\t\t\t(10, stake),\n\t\t\t(11, 100 * stake),\n\t\t])\n\t\t.with_collators(vec![(1, stake), (2, stake), (3, stake), (4, stake)])\n\t\t.build_and_execute_with_sanity_tests(|| {\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\t// reward 1 once per round\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\t(0u64..=100).map(|i| if i % 5 == 2 { Some(1u64) } else { None }).collect();\n\t\t\tlet inflation = StakePallet::inflation_config();\n\n\t\t\t// roll to last block of round 0\n\t\t\troll_to_claim_rewards(4, authors.clone());\n\t\t\tlet reward_0 = inflation.collator.reward_rate.per_block * stake * 2;\n\t\t\tassert_eq!(Balances::free_balance(1), stake + reward_0);\n\t\t\t// increase max selected candidates which will become effective in round 2\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 10));\n\n\t\t\t// roll to last block of round 1\n\t\t\t// should still multiply with 2 because the Authority set was chosen at start of\n\t\t\t// round 1\n\t\t\troll_to_claim_rewards(9, authors.clone());\n\t\t\tlet reward_1 = inflation.collator.reward_rate.per_block * stake * 2;\n\t\t\tassert_eq!(Balances::free_balance(1), stake + reward_0 + reward_1);\n\n\t\t\t// roll to last block of round 2\n\t\t\t// should multiply with 4 because there are only 4 candidates\n\t\t\troll_to_claim_rewards(14, authors.clone());\n\n\t\t\tlet reward_2 = inflation.collator.reward_rate.per_block * stake * 4;\n\t\t\tassert_eq!(Balances::free_balance(1), stake + reward_0 + reward_1 + reward_2);\n\n\t\t\t// roll to last block of round 3\n\t\t\t// should multiply with 4 because there are only 4 candidates\n\t\t\troll_to_claim_rewards(19, authors);\n\t\t\tlet reward_3 = inflation.collator.reward_rate.per_block * stake * 4;\n\t\t\tassert_eq!(\n\t\t\t\tBalances::free_balance(1),\n\t\t\t\tstake + reward_0 + reward_1 + reward_2 + reward_3\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn force_new_round() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 100), (2, 100), (3, 100), (4, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet mut round = RoundInfo { current: 0, first: 0, length: 5 };\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::validators(), vec![1, 2]);\n\t\t\tassert_eq!(Session::current_index(), 0);\n\t\t\t// 3 should be validator in round 2\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(5), 3, 100));\n\n\t\t\t// init force new round from 0 to 1, updating the authorities\n\t\t\tassert_ok!(StakePallet::force_new_round(Origin::root()));\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::current_index(), 0);\n\t\t\tassert!(StakePallet::new_round_forced());\n\n\t\t\t// force new round should become active by starting next block\n\t\t\troll_to(2, vec![]);\n\t\t\tround = RoundInfo { current: 1, first: 2, length: 5 };\n\t\t\tassert_eq!(Session::current_index(), 1);\n\t\t\tassert_eq!(Session::validators(), vec![1, 2]);\n\t\t\tassert!(!StakePallet::new_round_forced());\n\n\t\t\t// roll to next block in same round 1\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_eq!(Session::current_index(), 1);\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\t// assert_eq!(Session::validators(), vec![3, 1]);\n\t\t\tassert!(!StakePallet::new_round_forced());\n\t\t\t// 4 should become validator in session 3 if we do not force a new round\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 4, 100));\n\n\t\t\t// end session 2 naturally\n\t\t\troll_to(7, vec![]);\n\t\t\tround = RoundInfo { current: 2, first: 7, length: 5 };\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::current_index(), 2);\n\t\t\tassert!(!StakePallet::new_round_forced());\n\t\t\tassert_eq!(Session::validators(), vec![3, 1]);\n\n\t\t\t// force new round 3\n\t\t\tassert_ok!(StakePallet::force_new_round(Origin::root()));\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::current_index(), 2);\n\t\t\t// validator set should not change until next round\n\t\t\tassert_eq!(Session::validators(), vec![3, 1]);\n\t\t\tassert!(StakePallet::new_round_forced());\n\n\t\t\t// force new round should become active by starting next block\n\t\t\troll_to(8, vec![]);\n\t\t\tround = RoundInfo { current: 3, first: 8, length: 5 };\n\t\t\tassert_eq!(Session::current_index(), 3);\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::validators(), vec![3, 4]);\n\t\t\tassert!(!StakePallet::new_round_forced());\n\t\t});\n}\n\n#[test]\nfn replace_lowest_delegator() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.with_delegators(vec![(2, 1, 51), (3, 1, 51), (4, 1, 51), (5, 1, 50)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(1).unwrap().delegators.len() as u32,\n\t\t\t\t\u003cTest as Config\u003e::MaxDelegatorsPerCollator::get()\n\t\t\t);\n\n\t\t\t// 6 replaces 5\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 1, 51));\n\t\t\tassert!(StakePallet::delegator_state(5).is_none());\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(1)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.delegators\n\t\t\t\t\t.into_bounded_vec()\n\t\t\t\t\t.into_inner(),\n\t\t\t\tvec![\n\t\t\t\t\tStake { owner: 2, amount: 51 },\n\t\t\t\t\tStake { owner: 3, amount: 51 },\n\t\t\t\t\tStake { owner: 4, amount: 51 },\n\t\t\t\t\tStake { owner: 6, amount: 51 }\n\t\t\t\t]\n\t\t\t);\n\n\t\t\t// 5 attempts to replace 6 with more balance than available\n\t\t\tframe_support::assert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(5), 1, 101),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\t\t\tassert!(StakePallet::delegator_state(6).is_some());\n\t\t})\n}\n\n#[test]\nfn network_reward_multiple_blocks() {\n\tlet max_stake: Balance = 160_000_000 * DECIMALS;\n\tlet collators: Vec\u003c(AccountId, Balance)\u003e =\n\t\t(1u64..=\u003cTest as Config\u003e::MinCollators::get().saturating_add(1).into())\n\t\t\t.map(|acc_id| (acc_id, max_stake))\n\t\t\t.collect();\n\n\tExtBuilder::default()\n\t\t.with_balances(collators.clone())\n\t\t.with_collators(collators)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(max_stake, StakePallet::max_candidate_stake());\n\t\t\tlet total_collator_stake =\n\t\t\t\tmax_stake.saturating_mul(\u003cTest as Config\u003e::MinCollators::get().into());\n\t\t\tassert_eq!(total_collator_stake, StakePallet::total_collator_stake().collators);\n\t\t\tassert!(Balances::free_balance(\u0026TREASURY_ACC).is_zero());\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\n\t\t\t// total issuance should not increase when not noting authors because we haven't\n\t\t\t// reached NetworkRewardStart yet\n\t\t\troll_to(10, vec![None]);\n\t\t\tassert!(Balances::free_balance(\u0026TREASURY_ACC).is_zero());\n\t\t\tassert_eq!(total_issuance, \u003cTest as Config\u003e::Currency::total_issuance());\n\n\t\t\t// set current block to one block before NetworkRewardStart\n\t\t\tlet network_reward_start = \u003cTest as Config\u003e::NetworkRewardStart::get();\n\t\t\tSystem::set_block_number(network_reward_start.saturating_sub(1));\n\n\t\t\t// network rewards should only appear 1 block after start\n\t\t\troll_to(network_reward_start, vec![None]);\n\t\t\tassert!(Balances::free_balance(\u0026TREASURY_ACC).is_zero());\n\t\t\tassert_eq!(total_issuance, \u003cTest as Config\u003e::Currency::total_issuance());\n\n\t\t\t// should mint to treasury now\n\t\t\troll_to(network_reward_start + 1, vec![None]);\n\t\t\tlet network_reward = Balances::free_balance(\u0026TREASURY_ACC);\n\t\t\tassert!(!network_reward.is_zero());\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + network_reward,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\t\t\tlet inflation_config = StakePallet::inflation_config();\n\t\t\tlet col_rewards =\n\t\t\t\tinflation_config.collator.reward_rate.per_block * total_collator_stake;\n\t\t\tassert_eq!(network_reward, \u003cTest as Config\u003e::NetworkRewardRate::get() * col_rewards);\n\n\t\t\t// should mint exactly the same amount\n\t\t\troll_to(network_reward_start + 2, vec![None]);\n\t\t\tassert_eq!(2 * network_reward, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + 2 * network_reward,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\n\t\t\t// should mint exactly the same amount in each block\n\t\t\troll_to(network_reward_start + 100, vec![None]);\n\t\t\tassert_eq!(100 * network_reward, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + 100 * network_reward,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\n\t\t\t// should mint the same amount even if a collator exits because reward is only\n\t\t\t// based on MaxCollatorCandidateStake and MaxSelectedCandidates\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\troll_to(network_reward_start + 101, vec![None]);\n\t\t\tassert_eq!(101 * network_reward, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + 101 * network_reward,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn network_reward_increase_max_candidate_stake() {\n\tlet max_stake: Balance = 160_000_000 * DECIMALS;\n\tlet collators: Vec\u003c(AccountId, Balance)\u003e = (1u64..=\u003cTest as Config\u003e::MinCollators::get()\n\t\t.into())\n\t\t.map(|acc_id| (acc_id, max_stake))\n\t\t.collect();\n\n\tExtBuilder::default()\n\t\t.with_balances(collators.clone())\n\t\t.with_collators(collators)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet network_reward_start = \u003cTest as Config\u003e::NetworkRewardStart::get();\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\t\t\tSystem::set_block_number(network_reward_start);\n\n\t\t\t// should mint to treasury now\n\t\t\troll_to(network_reward_start + 1, vec![None]);\n\t\t\tlet reward_before = Balances::free_balance(\u0026TREASURY_ACC);\n\t\t\tassert!(!reward_before.is_zero());\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + reward_before,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\n\t\t\t// double max stake\n\t\t\tlet max_stake_doubled = 320_000_000 * DECIMALS;\n\t\t\tlet reward_after = 2 * reward_before;\n\t\t\tassert_ok!(StakePallet::set_max_candidate_stake(Origin::root(), max_stake_doubled));\n\t\t\troll_to(network_reward_start + 2, vec![None]);\n\t\t\tassert_eq!(reward_before + reward_after, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\treward_before + reward_after + total_issuance,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn network_reward_increase_max_collator_count() {\n\tlet max_stake: Balance = 160_000_000 * DECIMALS;\n\tlet collators: Vec\u003c(AccountId, Balance)\u003e = (1u64..=\u003cTest as Config\u003e::MinCollators::get()\n\t\t.into())\n\t\t.map(|acc_id| (acc_id, max_stake))\n\t\t.collect();\n\n\tExtBuilder::default()\n\t\t.with_balances(collators.clone())\n\t\t.with_collators(collators)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet network_reward_start = \u003cTest as Config\u003e::NetworkRewardStart::get();\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\t\t\tSystem::set_block_number(network_reward_start);\n\n\t\t\t// should mint to treasury now\n\t\t\troll_to(network_reward_start + 1, vec![None]);\n\t\t\tlet reward_before = Balances::free_balance(\u0026TREASURY_ACC);\n\t\t\tassert!(!reward_before.is_zero());\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + reward_before,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\n\t\t\t// tripple number of max collators\n\t\t\tlet reward_after = 3 * reward_before;\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(\n\t\t\t\tOrigin::root(),\n\t\t\t\t\u003cTest as Config\u003e::MinCollators::get() * 3\n\t\t\t));\n\t\t\troll_to(network_reward_start + 2, vec![None]);\n\t\t\tassert_eq!(reward_before + reward_after, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\treward_before + reward_after + total_issuance,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_total_stake_collators_stay() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200), (3, 200), (4, 200)])\n\t\t.with_collators(vec![(1, 100), (2, 50)])\n\t\t.with_delegators(vec![(3, 1, 100), (4, 2, 50)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 150, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 160, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(2), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 155, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(3), 1, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 155, delegators: 160 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(4), 2, 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 155, delegators: 155 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_total_stake_displace_collators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 200),\n\t\t\t(2, 200),\n\t\t\t(3, 200),\n\t\t\t(4, 200),\n\t\t\t(5, 200),\n\t\t\t(6, 200),\n\t\t\t(7, 200),\n\t\t\t(8, 200),\n\t\t\t(1337, 200),\n\t\t])\n\t\t.with_collators(vec![(1, 10), (2, 20), (3, 30), (4, 40)])\n\t\t.with_delegators(vec![(5, 1, 50), (6, 2, 50), (7, 3, 55), (8, 4, 55)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\n\t\t\t// 4 is pushed out by staking less\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(4), 30));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 50, delegators: 105 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(8), 4, 45));\n\n\t\t\t// 3 is pushed out by delegator staking less\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(7), 3, 45));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 30, delegators: 100 }\n\t\t\t);\n\n\t\t\t// 1 is pushed out by new candidate\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(1337), 100));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 120, delegators: 50 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_total_stake_new_collators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.with_delegators(vec![(4, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 100, delegators: 100 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(2), 100));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 100 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(3), 2, 50));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(4)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 50 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_total_stake_no_collator_changes() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 200),\n\t\t\t(2, 200),\n\t\t\t(3, 200),\n\t\t\t(4, 200),\n\t\t\t(5, 200),\n\t\t\t(6, 200),\n\t\t\t(7, 200),\n\t\t\t(8, 200),\n\t\t\t(1337, 200),\n\t\t])\n\t\t.with_collators(vec![(1, 10), (2, 20), (3, 30), (4, 40)])\n\t\t.with_delegators(vec![(5, 1, 50), (6, 2, 50), (7, 3, 55), (8, 4, 55)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(5), 1, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(2), 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(6), 2, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn rewards_candidate_stake_more() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 2 * DECIMALS), (2, DECIMALS), (3, DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// stake more to trigger reward incrementing\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), DECIMALS));\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_candidate_stake_less() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 2 * DECIMALS), (2, DECIMALS), (3, DECIMALS)])\n\t\t.with_collators(vec![(1, 2 * DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero());\n\t\t\t});\n\n\t\t\t// stake less to trigger reward incrementing\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), DECIMALS));\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_candidate_leave_network() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 2 * DECIMALS),\n\t\t\t(2, DECIMALS),\n\t\t\t(3, DECIMALS),\n\t\t\t(4, DECIMALS),\n\t\t\t(5, DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 2 * DECIMALS), (4, DECIMALS), (5, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// init does not increment rewards\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\n\t\t\t// advance two rounds to enable leaving\n\t\t\troll_to(\n\t\t\t\t10,\n\t\t\t\tvec![\n\t\t\t\t\t// we're already in block 1, so cant note_author for block 1\n\t\t\t\t\tNone,\n\t\t\t\t\tSome(1),\n\t\t\t\t\tSome(2),\n\t\t\t\t\tSome(1),\n\t\t\t\t\tSome(2),\n\t\t\t\t\tSome(1),\n\t\t\t\t\tSome(2),\n\t\t\t\t\tSome(1),\n\t\t\t\t\tSome(2),\n\t\t\t\t],\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 4 * 2);\n\n\t\t\t// count for delegators should not be incremented\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\n\t\t\t// rewards should not be incremented\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero());\n\t\t\t});\n\n\t\t\t// execute leave intent to trigger reward incrementing\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(1), 1));\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_force_remove_candidate() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, DECIMALS),\n\t\t\t(2, DECIMALS),\n\t\t\t(3, DECIMALS),\n\t\t\t(4, DECIMALS),\n\t\t\t(5, DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, DECIMALS), (4, DECIMALS), (5, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// init does not increment rewards\n\t\t\tStakePallet::note_author(1);\n\t\t\tStakePallet::note_author(2);\n\n\t\t\t// removing triggers reward increment for collator 1 and delegators 4, 5\n\t\t\tassert_ok!(StakePallet::force_remove_candidate(Origin::root(), 1));\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t\t(4..=5).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn reward_count_join_delegators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\t// delegator should have same counter as collator upon joining\n\t\t\tassert_eq!(StakePallet::reward_count(2), 1);\n\t\t});\n}\n\n#[test]\nfn rewards_delegator_stake_more() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, DECIMALS), (2, DECIMALS), (3, 2 * DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// stake more to trigger reward incrementing just for 3\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(3), 1, DECIMALS));\n\t\t\t// 1 should still have counter 1 but no rewards\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::rewards(1).is_zero());\n\t\t\t// 2 should still have neither rewards nor counter\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::rewards(2).is_zero());\n\t\t\t// 3 should have rewards and the same counter as 1\n\t\t\tassert_eq!(StakePallet::reward_count(3), 1);\n\t\t\tassert!(!StakePallet::rewards(3).is_zero());\n\t\t});\n}\n\n#[test]\nfn rewards_delegator_stake_less() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, DECIMALS), (2, DECIMALS), (3, 2 * DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, 2 * DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// stake less to trigger reward incrementing just for 3\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(3), 1, DECIMALS));\n\t\t\t// 1 should still have counter 1 but no rewards\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::rewards(1).is_zero());\n\t\t\t// 2 should still have neither rewards nor counter\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::rewards(2).is_zero());\n\t\t\t// 3 should have rewards and the same counter as 1\n\t\t\tassert_eq!(StakePallet::reward_count(3), 1);\n\t\t\tassert!(!StakePallet::rewards(3).is_zero());\n\t\t});\n}\n\n#[test]\nfn rewards_delegator_replaced() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 2 * DECIMALS),\n\t\t\t(2, 2 * DECIMALS),\n\t\t\t(3, 2 * DECIMALS),\n\t\t\t(4, 2 * DECIMALS),\n\t\t\t(5, 2 * DECIMALS),\n\t\t\t(6, 2 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 2 * DECIMALS)])\n\t\t.with_delegators(vec![\n\t\t\t(2, 1, 2 * DECIMALS),\n\t\t\t(3, 1, 2 * DECIMALS),\n\t\t\t(4, 1, 2 * DECIMALS),\n\t\t\t(5, 1, DECIMALS),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\n\t\t\t// 6 kicks 5\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 1, 2 * DECIMALS));\n\t\t\t// 5 should have rewards and counter updated\n\t\t\tassert!(!StakePallet::rewards(5).is_zero());\n\t\t\tassert_eq!(StakePallet::reward_count(5), 1);\n\t\t\t// 6 should not have rewards but same counter as former collator\n\t\t\tassert!(StakePallet::rewards(6).is_zero());\n\t\t\tassert_eq!(StakePallet::reward_count(6), 1);\n\t\t});\n}\n\n#[test]\nfn rewards_delegator_leaves() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, DECIMALS), (2, DECIMALS), (3, DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note collator once to set their counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// only 3 should have non-zero rewards and their counter reset\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(3)));\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::rewards(1).is_zero());\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::rewards(2).is_zero());\n\t\t\tassert!(!StakePallet::rewards(3).is_zero());\n\t\t\tassert_eq!(StakePallet::reward_count(3), 1);\n\t\t});\n}\n\n#[test]\nfn rewards_set_inflation() {\n\tlet hundred = Perquintill::from_percent(100);\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, DECIMALS),\n\t\t\t(2, DECIMALS),\n\t\t\t(3, DECIMALS),\n\t\t\t(4, DECIMALS),\n\t\t\t(5, DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, DECIMALS), (2, DECIMALS)])\n\t\t.with_delegators(vec![(3, 1, DECIMALS), (4, 1, DECIMALS), (5, 2, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note collators\n\t\t\tStakePallet::note_author(1);\n\t\t\tStakePallet::note_author(1);\n\t\t\tStakePallet::note_author(2);\n\n\t\t\t// set inflation to trigger reward setting\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\thundred,\n\t\t\t\thundred,\n\t\t\t\thundred,\n\t\t\t\thundred\n\t\t\t));\n\t\t\t// rewards should be set and counter reset\n\t\t\t(1..=5).for_each(|id| {\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_yearly_inflation_adjustment() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, DECIMALS),\n\t\t\t(2, DECIMALS),\n\t\t\t(3, DECIMALS),\n\t\t\t(4, DECIMALS),\n\t\t\t(5, DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, DECIMALS), (2, DECIMALS)])\n\t\t.with_delegators(vec![(3, 1, DECIMALS), (4, 1, DECIMALS), (5, 2, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// init counter and go to next year\n\t\t\tStakePallet::note_author(1);\n\t\t\tStakePallet::note_author(2);\n\t\t\tSystem::set_block_number(\u003cTest as Config\u003e::BLOCKS_PER_YEAR - 1);\n\t\t\troll_to_claim_rewards(\u003cTest as Config\u003e::BLOCKS_PER_YEAR + 1, vec![]);\n\n\t\t\t// rewards should not be triggered before executing pending adjustment\n\t\t\t(1..=5).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// execute to trigger reward increment\n\t\t\tassert_ok!(StakePallet::execute_scheduled_reward_change(Origin::signed(1)));\n\t\t\t(1..=5).for_each(|id| {\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_incrementing_and_claiming() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, DECIMALS), (2, DECIMALS), (3, DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// claiming or incrementing should not be possible with zero counter\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::increment_collator_rewards(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::RewardsNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::increment_delegator_rewards(Origin::signed(2)),\n\t\t\t\tError::\u003cTest\u003e::RewardsNotFound\n\t\t\t);\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert_noop!(\n\t\t\t\t\tStakePallet::claim_rewards(Origin::signed(id)),\n\t\t\t\t\tError::\u003cTest\u003e::RewardsNotFound,\n\t\t\t\t);\n\t\t\t});\n\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\n\t\t\t// claiming should not be possible before incrementing rewards\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert_noop!(\n\t\t\t\t\tStakePallet::claim_rewards(Origin::signed(id)),\n\t\t\t\t\tError::\u003cTest\u003e::RewardsNotFound\n\t\t\t\t);\n\t\t\t});\n\n\t\t\t// increment rewards for 2 and match counter to collator\n\t\t\tassert_ok!(StakePallet::increment_delegator_rewards(Origin::signed(2)));\n\t\t\tassert_eq!(StakePallet::reward_count(2), 1);\n\t\t\tlet rewards_2 = StakePallet::rewards(2);\n\t\t\tassert!(!rewards_2.is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\tassert!(StakePallet::rewards(3).is_zero());\n\n\t\t\t// should set rewards for delegator 3 as well\n\t\t\tassert_ok!(StakePallet::increment_collator_rewards(Origin::signed(1)));\n\t\t\tassert!(StakePallet::reward_count(1).is_zero());\n\t\t\tassert!(!StakePallet::rewards(1).is_zero());\n\t\t\t// counter of delegators should be reset to 0 (= cols counter)\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t// rewards of 2 should not be changed\n\t\t\tassert_eq!(StakePallet::rewards(2), rewards_2);\n\t\t\t// 3 should have rewards now (passively)\n\t\t\tassert!(!StakePallet::rewards(3).is_zero());\n\n\t\t\t// claim for 1 to move rewards into balance\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(1)));\n\t\t\tassert!(StakePallet::reward_count(1).is_zero());\n\t\t\tassert!(StakePallet::rewards(1).is_zero());\n\t\t\t// delegator situation should be unchanged\n\t\t\tassert!(Balances::free_balance(\u00261) \u003e DECIMALS);\n\t\t\tassert_eq!(Balances::free_balance(\u00262), DECIMALS);\n\t\t\tassert_eq!(Balances::free_balance(\u00263), DECIMALS);\n\n\t\t\t// claim for 2 to move rewards into balance\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(2)));\n\t\t\tassert!(Balances::free_balance(\u00262) \u003e DECIMALS);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::rewards(2).is_zero());\n\t\t\tassert_eq!(Balances::free_balance(\u00263), DECIMALS);\n\n\t\t\t// should not be able to claim for incorrect role\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::increment_collator_rewards(Origin::signed(2)),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::increment_delegator_rewards(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn api_get_unclaimed_staking_rewards() {\n\tlet stake = 100_000 * DECIMALS;\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, stake), (2, stake), (3, 100 * stake)])\n\t\t.with_collators(vec![(1, stake), (3, 2 * stake)])\n\t\t.with_delegators(vec![(2, 1, stake)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet inflation_config = StakePallet::inflation_config();\n\n\t\t\t// Increment rewards of 1 and 2\n\t\t\troll_to(2, vec![None, Some(1)]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::get_unclaimed_staking_rewards(\u00261),\n\t\t\t\t// Multiplying with 2 because there are two authors\n\t\t\t\tinflation_config.collator.reward_rate.per_block * stake * 2\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::get_unclaimed_staking_rewards(\u00262),\n\t\t\t\tinflation_config.delegator.reward_rate.per_block * stake * 2\n\t\t\t);\n\t\t\tassert!(StakePallet::get_unclaimed_staking_rewards(\u00263).is_zero());\n\n\t\t\t// Should only increment rewards of 3\n\t\t\troll_to(3, vec![None, None, Some(3)]);\n\t\t\tlet rewards_1 = StakePallet::get_unclaimed_staking_rewards(\u00261);\n\t\t\tlet rewards_2 = StakePallet::get_unclaimed_staking_rewards(\u00262);\n\t\t\tlet rewards_3 = StakePallet::get_unclaimed_staking_rewards(\u00263);\n\t\t\tassert_eq!(2 * rewards_1, rewards_3,);\n\t\t\tassert_eq!(rewards_2, inflation_config.delegator.reward_rate.per_block * stake * 2);\n\n\t\t\t// API and actual claiming should match\n\t\t\tassert_ok!(StakePallet::increment_collator_rewards(Origin::signed(1)));\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(1)));\n\t\t\tassert_eq!(rewards_1, Balances::usable_balance(\u00261));\n\t\t\tassert_ok!(StakePallet::increment_delegator_rewards(Origin::signed(2)));\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(2)));\n\t\t\tassert_eq!(rewards_2, Balances::usable_balance(\u00262));\n\t\t\tassert_ok!(StakePallet::increment_collator_rewards(Origin::signed(3)));\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(3)));\n\t\t\tassert_eq!(rewards_3 + 98 * stake, Balances::usable_balance(\u00263));\n\t\t});\n}\n\n#[test]\nfn api_get_staking_rates() {\n\tlet stake = 100_000 * DECIMALS;\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, stake), (2, stake), (3, 2 * stake)])\n\t\t.with_collators(vec![(1, stake), (2, stake)])\n\t\t.with_delegators(vec![(3, 1, stake)])\n\t\t.with_inflation(25, 10, 25, 8, \u003cTest as Config\u003e::BLOCKS_PER_YEAR)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet mut rates = StakingRates {\n\t\t\t\tcollator_staking_rate: Perquintill::from_percent(50),\n\t\t\t\tcollator_reward_rate: Perquintill::from_percent(5),\n\t\t\t\tdelegator_staking_rate: Perquintill::from_percent(25),\n\t\t\t\tdelegator_reward_rate: Perquintill::from_percent(8),\n\t\t\t};\n\t\t\t// collators exceed max staking rate\n\t\t\tassert_eq!(rates, StakePallet::get_staking_rates());\n\n\t\t\t// candidates stake less to not exceed max staking rate\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), stake / 2));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(2), stake / 2));\n\t\t\t// delegator stakes more to exceed\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(3), 1, stake));\n\t\t\trates.collator_staking_rate = Perquintill::from_percent(25);\n\t\t\trates.collator_reward_rate = Perquintill::from_percent(10);\n\t\t\trates.delegator_staking_rate = Perquintill::from_percent(50);\n\t\t\trates.delegator_reward_rate = Perquintill::from_percent(4);\n\t\t\tassert_eq!(rates, StakePallet::get_staking_rates());\n\t\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","try_state.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2023 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\nuse frame_support::{ensure, traits::Get};\nuse scale_info::prelude::format;\nuse sp_runtime::{\n\ttraits::{CheckedAdd, Zero},\n\tSaturatedConversion, Saturating,\n};\n\nuse crate::{\n\tset::OrderedSet,\n\ttypes::{BalanceOf, Candidate, Stake},\n\tCandidatePool, Config, DelegatorState, LastDelegation, MaxCollatorCandidateStake,\n\tMaxSelectedCandidates, Pallet, Round, TopCandidates, TotalCollatorStake,\n};\n\npub fn log_and_return_error_message(error_message: String) -\u003e \u0026'static str {\n\tlog::error!(\"{}\", error_message);\n\t\"Sanity test error\"\n}\n\npub(crate) fn do_try_state\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\tvalidate_candiate_pool::\u003cT\u003e()?;\n\tvalidate_delegators::\u003cT\u003e()?;\n\tvalidate_top_candidates::\u003cT\u003e()?;\n\tvalidate_stake::\u003cT\u003e()\n}\n\nfn validate_candiate_pool\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\t// check if enough collators are set.\n\tensure!(\n\t\tCandidatePool::\u003cT\u003e::count() \u003e= T::MinCollators::get(),\n\t\tlog_and_return_error_message(format!(\n\t\t\t\"Insufficient collators. Collators count: {:?}. Min required collators: {:?}\",\n\t\t\tCandidatePool::\u003cT\u003e::count(),\n\t\t\tT::MinCollators::get()\n\t\t))\n\t);\n\n\tCandidatePool::\u003cT\u003e::iter_values().try_for_each(\n\t\t|candidate: Candidate\u003cT::AccountId, BalanceOf\u003cT\u003e, _\u003e| -\u003e Result\u003c(), \u0026'static str\u003e {\n\t\t\tlet sum_delegations: BalanceOf\u003cT\u003e = candidate\n\t\t\t\t.delegators\n\t\t\t\t.iter()\n\t\t\t\t.fold(Zero::zero(), |acc, stake| acc.saturating_add(stake.amount));\n\n\t\t\t// total stake should be the sum of delegators stake + colator stake.\n\t\t\tlet stake_total = sum_delegations.checked_add(\u0026candidate.stake);\n\t\t\tensure!(\n\t\t\t\tstake_total == Some(candidate.total),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Total stake of collator {:?} does not match. Saved stake: {:?}. Calculated stake: {:?}\",\n\t\t\t\t\tcandidate.id, candidate.stake, stake_total\n\t\t\t\t))\n\t\t\t);\n\n\t\t\t// Min required stake should be set\n\t\t\tensure!(\n\t\t\t\tcandidate.stake \u003e= T::MinCollatorCandidateStake::get(),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Stake of collator {:?} insufficient. Required stake: {:?}. Owned Stake: {:?} \",\n\t\t\t\t\tcandidate.id,\n\t\t\t\t\tT::MinCollatorCandidateStake::get(),\n\t\t\t\t\tcandidate.stake\n\t\t\t\t))\n\t\t\t);\n\n\t\t\tvalidate_delegators_from_collator::\u003cT\u003e(candidate.delegators)?;\n\n\t\t\t// check min and max stake for each candidate\n\t\t\tensure!(\n\t\t\t\tcandidate.stake \u003c= MaxCollatorCandidateStake::\u003cT\u003e::get(),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Candidate {:?} exceeded stake. Allowed stake: {:?}. Owned Stake: {:?}\",\n\t\t\t\t\tcandidate.id,\n\t\t\t\t\tMaxCollatorCandidateStake::\u003cT\u003e::get(),\n\t\t\t\t\tcandidate.stake\n\t\t\t\t))\n\t\t\t);\n\n\t\t\tOk(())\n\t\t},\n\t)\n}\n\nfn validate_top_candidates\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\tlet top_candidates = TopCandidates::\u003cT\u003e::get();\n\n\t// check if enough top candidates are set.\n\tensure!(\n\t\ttop_candidates.len() \u003e= T::MinRequiredCollators::get().saturated_into(),\n\t\tlog_and_return_error_message(format!(\n\t\t\t\"Not enough candidates are set. Candidate count: {:?}. Required: {:?}\",\n\t\t\ttop_candidates.len(),\n\t\t\tT::MinRequiredCollators::get()\n\t\t))\n\t);\n\n\ttop_candidates.iter().try_for_each(|stake| -\u003e Result\u003c(), \u0026'static str\u003e {\n\t\t// top candidates should be part of the candidate pool.\n\t\tensure!(\n\t\t\tCandidatePool::\u003cT\u003e::contains_key(\u0026stake.owner),\n\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\"Unknown candidate {:?} in top candidates.\",\n\t\t\t\tstake.owner\n\t\t\t))\n\t\t);\n\n\t\t// an account can not be candidate and delegator.\n\t\tensure!(\n\t\t\tDelegatorState::\u003cT\u003e::get(\u0026stake.owner).is_none(),\n\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\"Account {:?} is delegator and candidate.\",\n\t\t\t\tstake.owner\n\t\t\t))\n\t\t);\n\n\t\t// a top candidate should be active.\n\t\tensure!(\n\t\t\tPallet::\u003cT\u003e::is_active_candidate(\u0026stake.owner).unwrap(),\n\t\t\tlog_and_return_error_message(format!(\"Top candidate {:?} is inactive\", stake.owner))\n\t\t);\n\n\t\tOk(())\n\t})\n}\n\nfn validate_delegators_from_collator\u003cT: Config\u003e(\n\tdelegators: OrderedSet\u003cStake\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e, T::MaxDelegatorsPerCollator\u003e,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n\tdelegators\n\t\t.iter()\n\t\t.try_for_each(|delegator_stake| -\u003e Result\u003c(), \u0026'static str\u003e {\n\t\t\tlet last_delegation = LastDelegation::\u003cT\u003e::get(\u0026delegator_stake.owner);\n\t\t\tlet round = Round::\u003cT\u003e::get();\n\t\t\tlet counter = if last_delegation.round \u003c round.current {\n\t\t\t\t0u32\n\t\t\t} else {\n\t\t\t\tlast_delegation.counter\n\t\t\t};\n\n\t\t\t// each delegator should not exceed the [MaxDelegationsPerRound]\n\t\t\tensure!(\n\t\t\t\tcounter \u003c= T::MaxDelegationsPerRound::get(),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Delegator {:?} exceeded delegations per round. Allowed delegations {:?}. Confirmed delegations {:?}\",\n\t\t\t\t\tdelegator_stake.owner, T::MaxDelegationsPerRound::get(), counter\n\t\t\t\t))\n\t\t\t);\n\n\t\t\t// each delegator should have the min required stake\n\t\t\tensure!(\n\t\t\t\tdelegator_stake.amount \u003e= T::MinDelegatorStake::get(),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Delegator {:?} insufficient stake. Required stake: {:?}. Owned stake: {:?}\",\n\t\t\t\t\tdelegator_stake.owner,\n\t\t\t\t\tT::MinDelegatorStake::get(),\n\t\t\t\t\tdelegator_stake.amount\n\t\t\t\t))\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tDelegatorState::\u003cT\u003e::get(\u0026delegator_stake.owner).is_some(),\n\t\t\t\tlog_and_return_error_message(format!(\"Unknown delegator {:?}\", delegator_stake.owner))\n\t\t\t);\n\n\t\t\tOk(())\n\t\t})\n}\n\nfn validate_stake\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\t// the total fund has to be the sum over the first [MaxSelectedCandidates] of\n\t// [TopCandidates].\n\tlet top_candidates = TopCandidates::\u003cT\u003e::get();\n\tlet top_n = MaxSelectedCandidates::\u003cT\u003e::get().saturated_into::\u003cusize\u003e();\n\n\tlet total_stake = TotalCollatorStake::\u003cT\u003e::get();\n\n\tlet collator_delegator_stake = top_candidates\n\t\t.iter()\n\t\t.take(top_n)\n\t\t.fold(Zero::zero(), |acc: BalanceOf\u003cT\u003e, details| acc.saturating_add(details.amount));\n\n\tlet collator_stake = top_candidates\n\t\t.iter()\n\t\t.take(top_n)\n\t\t.filter_map(|stake| CandidatePool::\u003cT\u003e::get(\u0026stake.owner))\n\t\t.fold(Zero::zero(), |acc: BalanceOf\u003cT\u003e, candidate| acc.saturating_add(candidate.stake));\n\n\tlet delegator_state = collator_delegator_stake.saturating_sub(collator_stake);\n\n\tensure!(\n\t\ttotal_stake.collators == collator_stake,\n\t\tlog_and_return_error_message(format!(\n\t\t\t\"Corrupted total collator stake. Saved total stake: {:?}. Calculated stake: {:?}\",\n\t\t\ttotal_stake.collators, collator_stake\n\t\t))\n\t);\n\n\tensure!(\n\t\ttotal_stake.delegators == delegator_state,\n\t\tlog_and_return_error_message(format!(\n\t\t\t\"Corrupted total delegator stake. Saved total stake: {:?}. Calculated stake: {:?}\",\n\t\t\ttotal_stake.delegators, delegator_state\n\t\t))\n\t);\n\n\tOk(())\n}\n\nfn validate_delegators\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\tDelegatorState::\u003cT\u003e::iter_values().try_for_each(\n\t\t|delegator_details| -\u003e Result\u003c(), \u0026'static str\u003e {\n\t\t\tlet Some(owner) = \u0026delegator_details.owner else {\n\t\t\treturn Err(\"owner not found\");\n\t\t};\n\n\t\t\tensure!(\n\t\t\t\tCandidatePool::\u003cT\u003e::contains_key(owner),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Collator {:?} not found\",\n\t\t\t\t\tdelegator_details.owner\n\t\t\t\t))\n\t\t\t);\n\t\t\tOk(())\n\t\t},\n\t)\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":120},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","types.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\nuse frame_support::traits::{Currency, Get};\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::{\n\ttraits::{AtLeast32BitUnsigned, CheckedSub, Saturating, Zero},\n\tRuntimeDebug,\n};\nuse sp_staking::SessionIndex;\nuse sp_std::{\n\tcmp::Ordering,\n\tfmt::Debug,\n\tops::{Add, Sub},\n};\n\nuse crate::{set::OrderedSet, Config};\n\n/// A struct represented an amount of staked funds.\n///\n/// The stake has a destination account (to which the stake is directed) and an\n/// amount of funds staked.\n#[derive(Default, Clone, Encode, Decode, RuntimeDebug, PartialEq, Eq, TypeInfo, MaxEncodedLen)]\n#[codec(mel_bound(AccountId: MaxEncodedLen, Balance: MaxEncodedLen))]\npub struct Stake\u003cAccountId, Balance\u003e\nwhere\n\tAccountId: Eq + Ord,\n\tBalance: Eq + Ord,\n{\n\t/// The account that is backed by the stake.\n\tpub owner: AccountId,\n\n\t/// The amount of backing the `owner` received.\n\tpub amount: Balance,\n}\n\nimpl\u003cA, B\u003e From\u003cA\u003e for Stake\u003cA, B\u003e\nwhere\n\tA: Eq + Ord,\n\tB: Default + Eq + Ord,\n{\n\tfn from(owner: A) -\u003e Self {\n\t\tStake { owner, amount: B::default() }\n\t}\n}\n\nimpl\u003cAccountId: Ord, Balance: PartialEq + Ord\u003e PartialOrd for Stake\u003cAccountId, Balance\u003e {\n\tfn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n\t\tSome(self.cmp(other))\n\t}\n}\n\n// We order by stake and only return an equal order, if both account ids match.\n// This prevents the same account ids to be in the same OrderedSet. Otherwise,\n// it is ordered from greatest to lowest stake (primary) and from first joined\n// to last joined (primary).\nimpl\u003cAccountId: Ord, Balance: PartialEq + Ord\u003e Ord for Stake\u003cAccountId, Balance\u003e {\n\tfn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n\t\tmatch (self.owner.cmp(\u0026other.owner), self.amount.cmp(\u0026other.amount)) {\n\t\t\t// enforce unique account ids\n\t\t\t(Ordering::Equal, _) =\u003e Ordering::Equal,\n\t\t\t// prioritize existing members if stakes match\n\t\t\t(_, Ordering::Equal) =\u003e Ordering::Greater,\n\t\t\t// order by stake\n\t\t\t(_, ord) =\u003e ord,\n\t\t}\n\t}\n}\n\n/// The activity status of the collator.\n#[derive(Copy, Clone, PartialEq, Eq, Encode, Decode, RuntimeDebug, TypeInfo, MaxEncodedLen)]\npub enum CandidateStatus {\n\t/// Committed to be online and producing valid blocks (not equivocating)\n\tActive,\n\t/// Staked until the inner round\n\tLeaving(SessionIndex),\n}\n\nimpl Default for CandidateStatus {\n\tfn default() -\u003e CandidateStatus {\n\t\tCandidateStatus::Active\n\t}\n}\n\n#[derive(Encode, Decode, Clone, RuntimeDebug, PartialEq, Eq, TypeInfo, MaxEncodedLen)]\n#[scale_info(skip_type_params(MaxDelegatorsPerCandidate))]\n#[codec(mel_bound(AccountId: MaxEncodedLen, Balance: MaxEncodedLen))]\n/// Global collator state with commission fee, staked funds, and delegations\npub struct Candidate\u003cAccountId, Balance, MaxDelegatorsPerCandidate\u003e\nwhere\n\tAccountId: Eq + Ord + Debug,\n\tBalance: Eq + Ord + Debug,\n\tMaxDelegatorsPerCandidate: Get\u003cu32\u003e + Debug + PartialEq,\n{\n\t/// Account id of the candidate.\n\tpub id: AccountId,\n\n\t/// The stake that the candidate put down.\n\tpub stake: Balance,\n\n\t/// The delegators that back the candidate.\n\tpub delegators: OrderedSet\u003cStake\u003cAccountId, Balance\u003e, MaxDelegatorsPerCandidate\u003e,\n\n\t/// The total backing a collator has.\n\t///\n\t/// Should equal the sum of all delegators stake adding collators stake\n\tpub total: Balance,\n\n\t/// The current status of the candidate. Indicates whether a candidate is\n\t/// active or leaving the candidate pool\n\tpub status: CandidateStatus,\n}\n\nimpl\u003cA, B, S\u003e Candidate\u003cA, B, S\u003e\nwhere\n\tA: Ord + Clone + Debug,\n\tB: AtLeast32BitUnsigned + Ord + Copy + Saturating + Debug + Zero,\n\tS: Get\u003cu32\u003e + Debug + PartialEq,\n{\n\tpub fn new(id: A, stake: B) -\u003e Self {\n\t\tlet total = stake;\n\t\tCandidate {\n\t\t\tid,\n\t\t\tstake,\n\t\t\tdelegators: OrderedSet::new(),\n\t\t\ttotal,\n\t\t\tstatus: CandidateStatus::default(), // default active\n\t\t}\n\t}\n\n\tpub fn is_active(\u0026self) -\u003e bool {\n\t\tself.status == CandidateStatus::Active\n\t}\n\n\tpub fn is_leaving(\u0026self) -\u003e bool {\n\t\tmatches!(self.status, CandidateStatus::Leaving(_))\n\t}\n\n\tpub fn can_exit(\u0026self, when: u32) -\u003e bool {\n\t\tmatches!(self.status, CandidateStatus::Leaving(at) if at \u003c= when )\n\t}\n\n\tpub fn revert_leaving(\u0026mut self) {\n\t\tself.status = CandidateStatus::Active;\n\t}\n\n\tpub fn stake_more(\u0026mut self, more: B) {\n\t\tself.stake = self.stake.saturating_add(more);\n\t\tself.total = self.total.saturating_add(more);\n\t}\n\n\t// Returns None if underflow or less == self.stake (in which case collator\n\t// should leave).\n\tpub fn stake_less(\u0026mut self, less: B) -\u003e Option\u003cB\u003e {\n\t\tif self.stake \u003e less {\n\t\t\tself.stake = self.stake.saturating_sub(less);\n\t\t\tself.total = self.total.saturating_sub(less);\n\t\t\tSome(self.stake)\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn inc_delegator(\u0026mut self, delegator: A, more: B) {\n\t\tif let Ok(i) = self\n\t\t\t.delegators\n\t\t\t.linear_search(\u0026Stake::\u003cA, B\u003e { owner: delegator, amount: B::zero() })\n\t\t{\n\t\t\tself.delegators.mutate(|vec| vec[i].amount = vec[i].amount.saturating_add(more));\n\t\t\tself.total = self.total.saturating_add(more);\n\t\t\tself.delegators.sort_greatest_to_lowest()\n\t\t}\n\t}\n\n\tpub fn dec_delegator(\u0026mut self, delegator: A, less: B) {\n\t\tif let Ok(i) = self\n\t\t\t.delegators\n\t\t\t.linear_search(\u0026Stake::\u003cA, B\u003e { owner: delegator, amount: B::zero() })\n\t\t{\n\t\t\tself.delegators.mutate(|vec| vec[i].amount = vec[i].amount.saturating_sub(less));\n\t\t\tself.total = self.total.saturating_sub(less);\n\t\t\tself.delegators.sort_greatest_to_lowest()\n\t\t}\n\t}\n\n\tpub fn leave_candidates(\u0026mut self, round: SessionIndex) {\n\t\tself.status = CandidateStatus::Leaving(round);\n\t}\n}\n\npub type Delegator\u003cAccountId, Balance\u003e = Stake\u003cOption\u003cAccountId\u003e, Balance\u003e;\nimpl\u003cAccountId, Balance\u003e Delegator\u003cAccountId, Balance\u003e\nwhere\n\tAccountId: Eq + Ord + Clone + Debug,\n\tBalance: Copy\n\t\t+ Add\u003cOutput = Balance\u003e\n\t\t+ Saturating\n\t\t+ PartialOrd\n\t\t+ Eq\n\t\t+ Ord\n\t\t+ Debug\n\t\t+ Zero\n\t\t+ Default\n\t\t+ CheckedSub,\n{\n\t/// Adds a new delegation.\n\t///\n\t/// If already delegating to someone, this call will fail.\n\tpub fn add_delegation(\u0026mut self, stake: Stake\u003cAccountId, Balance\u003e) -\u003e Result\u003c(), ()\u003e {\n\t\tif self.owner.is_none() \u0026\u0026 self.amount.is_zero() {\n\t\t\tself.owner = Some(stake.owner);\n\t\t\tself.amount = stake.amount;\n\t\t\tOk(())\n\t\t} else {\n\t\t\tErr(())\n\t\t}\n\t}\n\n\t/// Returns Ok if the delegation for the\n\t/// collator exists and `Err` otherwise.\n\tpub fn rm_delegation(\u0026mut self, collator: AccountId) -\u003e Result\u003c(), ()\u003e {\n\t\tif self.owner == Some(collator) {\n\t\t\tself.amount = Balance::zero();\n\t\t\tself.owner = None;\n\t\t\tOk(())\n\t\t} else {\n\t\t\tErr(())\n\t\t}\n\t}\n\n\t/// Returns Ok(delegated_amount) if successful, `Err` if delegation was\n\t/// not found.\n\tpub fn inc_delegation(\u0026mut self, collator: AccountId, more: Balance) -\u003e Result\u003cBalance, ()\u003e {\n\t\tif self.owner == Some(collator) {\n\t\t\tself.amount = self.amount.saturating_add(more);\n\t\t\tOk(self.amount)\n\t\t} else {\n\t\t\tErr(())\n\t\t}\n\t}\n\n\t/// Returns Ok(Some(delegated_amount)) if successful, `Err` if delegation\n\t/// was not found and Ok(None) if delegated stake would underflow.\n\tpub fn dec_delegation(\n\t\t\u0026mut self,\n\t\tcollator: AccountId,\n\t\tless: Balance,\n\t) -\u003e Result\u003cOption\u003cBalance\u003e, ()\u003e {\n\t\tif self.owner == Some(collator) {\n\t\t\tOk(self.amount.checked_sub(\u0026less).map(|new| {\n\t\t\t\tself.amount = new;\n\t\t\t\tself.amount\n\t\t\t}))\n\t\t} else {\n\t\t\tErr(())\n\t\t}\n\t}\n}\n\n/// The current round index and transition information.\n#[derive(Copy, Clone, PartialEq, Eq, Encode, Decode, RuntimeDebug, TypeInfo, MaxEncodedLen)]\npub struct RoundInfo\u003cBlockNumber\u003e {\n\t/// Current round index.\n\tpub current: SessionIndex,\n\t/// The first block of the current round.\n\tpub first: BlockNumber,\n\t/// The length of the current round in blocks.\n\tpub length: BlockNumber,\n}\n\nimpl\u003cB\u003e RoundInfo\u003cB\u003e\nwhere\n\tB: Copy + Saturating + From\u003cu32\u003e + PartialOrd,\n{\n\tpub fn new(current: SessionIndex, first: B, length: B) -\u003e RoundInfo\u003cB\u003e {\n\t\tRoundInfo { current, first, length }\n\t}\n\n\t/// Checks if the round should be updated.\n\t///\n\t/// The round should update if `self.length` or more blocks where produced\n\t/// after `self.first`.\n\tpub fn should_update(\u0026self, now: B) -\u003e bool {\n\t\tlet l = now.saturating_sub(self.first);\n\t\tl \u003e= self.length\n\t}\n\n\t/// Starts a new round.\n\tpub fn update(\u0026mut self, now: B) {\n\t\tself.current = self.current.saturating_add(1u32);\n\t\tself.first = now;\n\t}\n}\n\nimpl\u003cB\u003e Default for RoundInfo\u003cB\u003e\nwhere\n\tB: Copy + Saturating + Add\u003cOutput = B\u003e + Sub\u003cOutput = B\u003e + From\u003cu32\u003e + PartialOrd,\n{\n\tfn default() -\u003e RoundInfo\u003cB\u003e {\n\t\tRoundInfo::new(0u32, 0u32.into(), 20.into())\n\t}\n}\n\n/// The total stake of the pallet.\n///\n/// The stake includes both collators' and delegators' staked funds.\n#[derive(Default, Clone, Encode, Decode, RuntimeDebug, PartialEq, Eq, TypeInfo, MaxEncodedLen)]\npub struct TotalStake\u003cBalance: Default\u003e {\n\tpub collators: Balance,\n\tpub delegators: Balance,\n}\n\n/// The number of delegations a delegator has done within the last session in\n/// which they delegated.\n#[derive(Default, Clone, Encode, Decode, Eq, MaxEncodedLen, PartialEq, RuntimeDebug, TypeInfo)]\npub struct DelegationCounter {\n\t/// The index of the last delegation.\n\tpub round: SessionIndex,\n\t/// The number of delegations made within round.\n\tpub counter: u32,\n}\n\npub type AccountIdOf\u003cT\u003e = \u003cT as frame_system::Config\u003e::AccountId;\npub type BalanceOf\u003cT\u003e = \u003c\u003cT as Config\u003e::Currency as Currency\u003cAccountIdOf\u003cT\u003e\u003e\u003e::Balance;\npub type CandidateOf\u003cT, S\u003e = Candidate\u003cAccountIdOf\u003cT\u003e, BalanceOf\u003cT\u003e, S\u003e;\npub type StakeOf\u003cT\u003e = Stake\u003cAccountIdOf\u003cT\u003e, BalanceOf\u003cT\u003e\u003e;\npub type NegativeImbalanceOf\u003cT\u003e =\n\t\u003c\u003cT as Config\u003e::Currency as Currency\u003cAccountIdOf\u003cT\u003e\u003e\u003e::NegativeImbalance;\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","Users","marcel","Documents","pendulum","pallets","vesting-manager","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub use pallet::*;\n\nuse frame_support::traits::VestingSchedule;\nuse sp_runtime::traits::StaticLookup;\n\ntype AccountIdLookupOf\u003cT\u003e = \u003c\u003cT as frame_system::Config\u003e::Lookup as StaticLookup\u003e::Source;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::pallet]\n\tpub struct Pallet\u003cT\u003e(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\t\ttype VestingSchedule: VestingSchedule\u003cSelf::AccountId\u003e;\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\tVestingScheduleRemoved { who: T::AccountId, schedule_index: u32 },\n\t}\n\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(10_000_000)]\n\t\tpub fn remove_vesting_schedule(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\twho: AccountIdLookupOf\u003cT\u003e,\n\t\t\tschedule_index: u32,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_root(origin)?;\n\t\t\tlet who = T::Lookup::lookup(who)?;\n\t\t\tT::VestingSchedule::remove_vesting_schedule(\u0026who, schedule_index)?;\n\n\t\t\tSelf::deposit_event(Event::VestingScheduleRemoved { who, schedule_index });\n\n\t\t\t// waive the fee\n\t\t\tOk(Pays::No.into())\n\t\t}\n\t}\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","build.rs"],"content":"use substrate_wasm_builder::WasmBuilder;\n\nfn main() {\n\tWasmBuilder::new()\n\t\t.with_current_project()\n\t\t.export_heap_base()\n\t\t.import_memory()\n\t\t.build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nmod weights;\npub mod xcm_config;\npub mod zenlink;\n\nuse crate::zenlink::*;\nuse bifrost_farming as farming;\nuse bifrost_farming_rpc_runtime_api as farming_rpc_runtime_api;\nuse xcm::v3::MultiLocation;\nuse zenlink_protocol::{AssetBalance, MultiAssetsHandler, PairInfo};\n\npub use parachain_staking::InflationInfo;\n\nuse codec::Encode;\n\nuse smallvec::smallvec;\nuse sp_api::impl_runtime_apis;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata, H256};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{\n\t\tAccountIdConversion, AccountIdLookup, BlakeTwo256, Block as BlockT, Convert, ConvertInto,\n\t},\n\ttransaction_validity::{TransactionSource, TransactionValidity},\n\tApplyExtrinsicResult, DispatchError, FixedPointNumber, SaturatedConversion,\n};\n\nconst CONTRACTS_DEBUG_OUTPUT: bool = true;\n\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\nuse frame_support::{\n\tconstruct_runtime,\n\tdispatch::DispatchClass,\n\tparameter_types,\n\ttraits::{\n\t\tConstBool, ConstU32, Contains, Currency as FrameCurrency, EitherOfDiverse,\n\t\tEqualPrivilegeOnly, Imbalance, OnUnbalanced, WithdrawReasons,\n\t},\n\tweights::{\n\t\tconstants::WEIGHT_REF_TIME_PER_SECOND, ConstantMultiplier, Weight, WeightToFeeCoefficient,\n\t\tWeightToFeeCoefficients, WeightToFeePolynomial,\n\t},\n\tPalletId,\n};\nuse frame_system::{\n\tlimits::{BlockLength, BlockWeights},\n\tEnsureRoot, EnsureSigned,\n};\npub use sp_runtime::{MultiAddress, Perbill, Permill, Perquintill};\n\nuse runtime_common::{\n\tasset_registry, opaque, AccountId, Amount, AuraId, Balance, BlockNumber, Hash, Index, PoolId,\n\tReserveIdentifier, Signature, EXISTENTIAL_DEPOSIT, MILLIUNIT, NANOUNIT, UNIT,\n};\n\nuse cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;\n\nuse dia_oracle::DiaOracle;\n\nuse xcm_config::{XcmConfig, XcmOriginToTransactDispatchOrigin};\n\nuse orml_currencies::BasicCurrencyAdapter;\nuse orml_traits::{currency::MutationHooks, parameter_type_with_key};\n\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\n\npub use dia_oracle::dia::AssetId;\npub use issue::{Event as IssueEvent, IssueRequest};\npub use module_oracle_rpc_runtime_api::BalanceWrapper;\npub use nomination::Event as NominationEvent;\nuse oracle::{\n\tdia,\n\tdia::{DiaOracleAdapter, NativeCurrencyKey, XCMCurrencyConversion},\n};\npub use redeem::{Event as RedeemEvent, RedeemRequest};\npub use replace::{Event as ReplaceEvent, ReplaceRequest};\npub use security::StatusCode;\npub use spacewalk_primitives::CurrencyId;\npub use stellar_relay::traits::{FieldLength, Organization, Validator};\n// Polkadot imports\nuse polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};\n\nuse spacewalk_primitives::{\n\tself as primitives, CurrencyId::XCM, Moment, SignedFixedPoint, SignedInner, UnsignedFixedPoint,\n\tUnsignedInner,\n};\n\nuse weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};\n\n// XCM Imports\nuse xcm_executor::XcmExecutor;\n\npub type VaultId = primitives::VaultId\u003cAccountId, CurrencyId\u003e;\n\n/// The address format for describing accounts.\npub type Address = MultiAddress\u003cAccountId, ()\u003e;\n\n/// Block header type as expected by this runtime.\npub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\n/// Block type as expected by this runtime.\npub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock\u003cBlock\u003e;\n\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId\u003cBlock\u003e;\n\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender\u003cRuntime\u003e,\n\tframe_system::CheckSpecVersion\u003cRuntime\u003e,\n\tframe_system::CheckTxVersion\u003cRuntime\u003e,\n\tframe_system::CheckGenesis\u003cRuntime\u003e,\n\tframe_system::CheckEra\u003cRuntime\u003e,\n\tframe_system::CheckNonce\u003cRuntime\u003e,\n\tframe_system::CheckWeight\u003cRuntime\u003e,\n\tpallet_transaction_payment::ChargeTransactionPayment\u003cRuntime\u003e,\n);\n\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tgeneric::UncheckedExtrinsic\u003cAddress, RuntimeCall, Signature, SignedExtra\u003e;\n\npub type SignedPayload = generic::SignedPayload\u003cRuntimeCall, SignedExtra\u003e;\n\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic\u003cAccountId, RuntimeCall, SignedExtra\u003e;\n\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive\u003c\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext\u003cRuntime\u003e,\n\tRuntime,\n\tAllPalletsWithSystem,\n\u003e;\n\npub struct AmplitudeDiaOracleKeyConverter;\n\nimpl NativeCurrencyKey for AmplitudeDiaOracleKeyConverter {\n\tfn native_symbol() -\u003e Vec\u003cu8\u003e {\n\t\tb\"AMPE\".to_vec()\n\t}\n\n\tfn native_chain() -\u003e Vec\u003cu8\u003e {\n\t\tb\"Amplitude\".to_vec()\n\t}\n}\n\nimpl XCMCurrencyConversion for AmplitudeDiaOracleKeyConverter {\n\tfn convert_to_dia_currency_id(token_symbol: u8) -\u003e Option\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e)\u003e {\n\t\tmatch token_symbol {\n\t\t\t0 =\u003e Some((b\"Kusama\".to_vec(), b\"KSM\".to_vec())),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n\n\tfn convert_from_dia_currency_id(blockchain: Vec\u003cu8\u003e, symbol: Vec\u003cu8\u003e) -\u003e Option\u003cu8\u003e {\n\t\tmatch (blockchain.as_slice(), symbol.as_slice()) {\n\t\t\t(b\"Kusama\", b\"KSM\") =\u003e Some(0),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\ntype DataProviderImpl = DiaOracleAdapter\u003c\n\tDiaOracleModule,\n\tUnsignedFixedPoint,\n\tMoment,\n\tdia::DiaOracleKeyConvertor\u003cAmplitudeDiaOracleKeyConverter\u003e,\n\tConvertPrice,\n\tConvertMoment,\n\u003e;\n\npub struct ConvertPrice;\n\nimpl Convert\u003cu128, Option\u003cUnsignedFixedPoint\u003e\u003e for ConvertPrice {\n\tfn convert(price: u128) -\u003e Option\u003cUnsignedFixedPoint\u003e {\n\t\tSome(UnsignedFixedPoint::from_inner(price))\n\t}\n}\n\npub struct ConvertMoment;\n\nimpl Convert\u003cu64, Option\u003cMoment\u003e\u003e for ConvertMoment {\n\tfn convert(moment: u64) -\u003e Option\u003cMoment\u003e {\n\t\t// The provided moment is in seconds, but we need milliseconds\n\t\tSome(moment.saturating_mul(1000))\n\t}\n}\n\n/// Handles converting a weight scalar to a fee value, based on the scale and granularity of the\n/// node's balance type.\n///\n/// This should typically create a mapping between the following ranges:\n///   - `[0, MAXIMUM_BLOCK_WEIGHT]`\n///   - `[Balance::min, Balance::max]`\n///\n/// Yet, it can be used for any other sort of change to weight-fee. Some examples being:\n///   - Setting it to `0` will essentially disable the weight fee.\n///   - Setting it to `1` will cause the literal `#[weight = x]` values to be charged.\npub struct WeightToFee;\n\nimpl WeightToFeePolynomial for WeightToFee {\n\ttype Balance = Balance;\n\tfn polynomial() -\u003e WeightToFeeCoefficients\u003cSelf::Balance\u003e {\n\t\tlet p = MILLIUNIT;\n\t\tlet q = 10 * Balance::from(ExtrinsicBaseWeight::get().ref_time());\n\t\tsmallvec![WeightToFeeCoefficient {\n\t\t\tdegree: 1,\n\t\t\tnegative: false,\n\t\t\tcoeff_frac: Perbill::from_rational(p % q, q),\n\t\t\tcoeff_integer: p / q,\n\t\t}]\n\t}\n}\n\nimpl_opaque_keys! {\n\tpub struct SessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\n#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"amplitude\"),\n\timpl_name: create_runtime_str!(\"amplitude\"),\n\tauthoring_version: 1,\n\tspec_version: 10,\n\timpl_version: 0,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 10,\n\tstate_version: 1,\n};\n\n/// This determines the average expected block time that we are targeting.\n/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.\n/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked\n/// up by `pallet_aura` to implement `fn slot_duration()`.\n///\n/// Change this to adjust the block time.\npub const MILLISECS_PER_BLOCK: u64 = 12000;\n\n// NOTE: Currently it is not possible to change the slot duration after the chain has started.\n//       Attempting to do so will brick block production.\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\npub const BLOCKS_PER_YEAR: BlockNumber = DAYS * 36525 / 100;\n\n/// We assume that ~5% of the block weight is consumed by `on_initialize` handlers. This is\n/// used to limit the maximal weight of a single extrinsic.\nconst AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(5);\n\n/// We allow `Normal` extrinsics to fill up the block up to 75%, the rest can be used by\n/// `Operational` extrinsics.\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\n/// We allow for 0.5 of a second of compute with a 12 second average block time.\nconst MAXIMUM_BLOCK_WEIGHT: Weight =\n\tWeight::from_parts(WEIGHT_REF_TIME_PER_SECOND.saturating_div(2), 0)\n\t\t.set_proof_size(cumulus_primitives_core::relay_chain::MAX_POV_SIZE as u64);\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -\u003e NativeVersion {\n\tNativeVersion { runtime_version: VERSION, can_author_with: Default::default() }\n}\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\n\t// This part is copied from Substrate's `bin/node/runtime/src/lib.rs`.\n\t//  The `RuntimeBlockLength` and `RuntimeBlockWeights` exist here because the\n\t// `DeletionWeightLimit` and `DeletionQueueDepth` depend on those to parameterize\n\t// the lazy contract deletion.\n\tpub RuntimeBlockLength: BlockLength =\n\t\tBlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub RuntimeBlockWeights: BlockWeights = BlockWeights::builder()\n\t\t.base_block(BlockExecutionWeight::get())\n\t\t.for_class(DispatchClass::all(), |weights| {\n\t\t\tweights.base_extrinsic = ExtrinsicBaseWeight::get();\n\t\t})\n\t\t.for_class(DispatchClass::Normal, |weights| {\n\t\t\tweights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);\n\t\t})\n\t\t.for_class(DispatchClass::Operational, |weights| {\n\t\t\tweights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);\n\t\t\t// Operational transactions have some extra reserved space, so that they\n\t\t\t// are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.\n\t\t\tweights.reserved = Some(\n\t\t\t\tMAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT\n\t\t\t);\n\t\t})\n\t\t.avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)\n\t\t.build_or_panic();\n\tpub const SS58Prefix: u16 = 57;\n}\n\npub struct BaseFilter;\n\nimpl Contains\u003cRuntimeCall\u003e for BaseFilter {\n\tfn contains(call: \u0026RuntimeCall) -\u003e bool {\n\t\tmatch call {\n\t\t\t// These modules are all allowed to be called by transactions:\n\t\t\tRuntimeCall::Bounties(_) |\n\t\t\tRuntimeCall::ChildBounties(_) |\n\t\t\tRuntimeCall::Treasury(_) |\n\t\t\tRuntimeCall::Tokens(_) |\n\t\t\tRuntimeCall::Currencies(_) |\n\t\t\tRuntimeCall::ParachainStaking(_) |\n\t\t\tRuntimeCall::Democracy(_) |\n\t\t\tRuntimeCall::Council(_) |\n\t\t\tRuntimeCall::TechnicalCommittee(_) |\n\t\t\tRuntimeCall::System(_) |\n\t\t\tRuntimeCall::Scheduler(_) |\n\t\t\tRuntimeCall::Preimage(_) |\n\t\t\tRuntimeCall::Timestamp(_) |\n\t\t\tRuntimeCall::Balances(_) |\n\t\t\tRuntimeCall::Session(_) |\n\t\t\tRuntimeCall::ParachainSystem(_) |\n\t\t\tRuntimeCall::XcmpQueue(_) |\n\t\t\tRuntimeCall::PolkadotXcm(_) |\n\t\t\tRuntimeCall::DmpQueue(_) |\n\t\t\tRuntimeCall::Utility(_) |\n\t\t\tRuntimeCall::Vesting(_) |\n\t\t\tRuntimeCall::XTokens(_) |\n\t\t\tRuntimeCall::Multisig(_) |\n\t\t\tRuntimeCall::Identity(_) |\n\t\t\tRuntimeCall::Contracts(_) |\n\t\t\tRuntimeCall::ZenlinkProtocol(_) |\n\t\t\tRuntimeCall::VestingManager(_) |\n\t\t\tRuntimeCall::DiaOracleModule(_) |\n\t\t\tRuntimeCall::Fee(_) |\n\t\t\tRuntimeCall::Issue(_) |\n\t\t\tRuntimeCall::Nomination(_) |\n\t\t\tRuntimeCall::Oracle(_) |\n\t\t\tRuntimeCall::Redeem(_) |\n\t\t\tRuntimeCall::Replace(_) |\n\t\t\tRuntimeCall::Security(_) |\n\t\t\tRuntimeCall::StellarRelay(_) |\n\t\t\tRuntimeCall::VaultRegistry(_) |\n\t\t\tRuntimeCall::VaultRewards(_) |\n\t\t\tRuntimeCall::Farming(_) |\n\t\t\tRuntimeCall::AssetRegistry(_) =\u003e true,\n\t\t\t// All pallets are allowed, but exhaustive match is defensive\n\t\t\t// in the case of adding new pallets.\n\t\t}\n\t}\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype RuntimeCall = RuntimeCall;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup\u003cAccountId, ()\u003e;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\t/// The ubiquitous origin type.\n\ttype RuntimeOrigin = RuntimeOrigin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// Runtime version.\n\ttype Version = Version;\n\t/// Converts a module to an index of this module in the runtime.\n\ttype PalletInfo = PalletInfo;\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = BaseFilter;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// Block \u0026 extrinsics weights: base values and limits.\n\ttype BlockWeights = RuntimeBlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = RuntimeBlockLength;\n\t/// This is used as an identifier of the chain. 57 is the prefix for Amplitude\n\ttype SS58Prefix = SS58Prefix;\n\t/// The action to take on a Runtime Upgrade\n\ttype OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode\u003cSelf\u003e;\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = pallet_timestamp::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const UncleGenerations: u32 = 2;\n}\n\nimpl pallet_authorship::Config for Runtime {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = ParachainStaking;\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = EXISTENTIAL_DEPOSIT;\n\tpub const MaxLocks: u32 = 50;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = Treasury;\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 100 * NANOUNIT;\n\tpub const OperationalFeeMultiplier: u8 = 5;\n}\n\ntype NegativeImbalance = \u003cBalances as FrameCurrency\u003cAccountId\u003e\u003e::NegativeImbalance;\n\npub struct DealWithFees;\n\nimpl OnUnbalanced\u003cNegativeImbalance\u003e for DealWithFees {\n\tfn on_unbalanceds\u003cB\u003e(mut fees_then_tips: impl Iterator\u003cItem = NegativeImbalance\u003e) {\n\t\tif let Some(mut fees) = fees_then_tips.next() {\n\t\t\tif let Some(tips) = fees_then_tips.next() {\n\t\t\t\ttips.merge_into(\u0026mut fees);\n\t\t\t}\n\t\t\t// for fees and tips, 100% to treasury\n\t\t\tTreasury::on_unbalanced(fees);\n\t\t}\n\t}\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter\u003cBalances, DealWithFees\u003e;\n\ttype WeightToFee = WeightToFee;\n\ttype LengthToFee = ConstantMultiplier\u003cBalance, TransactionByteFee\u003e;\n\ttype FeeMultiplierUpdate = SlowAdjustingFeeUpdate\u003cSelf\u003e;\n\ttype OperationalFeeMultiplier = OperationalFeeMultiplier;\n}\n\nparameter_types! {\n\tpub const ReservedXcmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n\tpub const ReservedDmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n}\n\nimpl cumulus_pallet_parachain_system::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSystemEvent = ();\n\ttype SelfParaId = parachain_info::Pallet\u003cRuntime\u003e;\n\ttype DmpMessageHandler = DmpQueue;\n\ttype ReservedDmpWeight = ReservedDmpWeight;\n\ttype OutboundXcmpMessageSource = XcmpQueue;\n\ttype XcmpMessageHandler = XcmpQueue;\n\ttype ReservedXcmpWeight = ReservedXcmpWeight;\n\ttype CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;\n}\n\nimpl parachain_info::Config for Runtime {}\n\nimpl cumulus_pallet_aura_ext::Config for Runtime {}\n\nimpl cumulus_pallet_xcmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ChannelInfo = ParachainSystem;\n\ttype VersionWrapper = ();\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype PriceForSiblingDelivery = ();\n\ttype WeightInfo = cumulus_pallet_xcmp_queue::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl cumulus_pallet_dmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const Offset: u32 = 0;\n\tpub const MaxAuthorities: u32 = 200;\n}\n\nimpl pallet_session::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\ttype ValidatorIdOf = ConvertInto;\n\ttype ShouldEndSession = ParachainStaking;\n\ttype NextSessionRotation = ParachainStaking;\n\ttype SessionManager = ParachainStaking;\n\ttype SessionHandler = \u003cSessionKeys as sp_runtime::traits::OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = SessionKeys;\n\ttype WeightInfo = pallet_session::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nparameter_types! {\n\tpub const LaunchPeriod: BlockNumber = 5 * DAYS;\n\tpub const VotingPeriod: BlockNumber = 5 * DAYS;\n\tpub const FastTrackVotingPeriod: BlockNumber = 3 * HOURS;\n\tpub const MinimumDeposit: Balance = UNIT;\n\tpub const EnactmentPeriod: BlockNumber = 2 * DAYS;\n\tpub const CooloffPeriod: BlockNumber = 7 * DAYS;\n\tpub const MaxProposals: u32 = 100;\n}\n\nimpl pallet_democracy::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype EnactmentPeriod = EnactmentPeriod;\n\ttype LaunchPeriod = LaunchPeriod;\n\ttype VotingPeriod = VotingPeriod;\n\ttype VoteLockingPeriod = EnactmentPeriod;\n\t// Same as EnactmentPeriod\n\ttype MinimumDeposit = MinimumDeposit;\n\t/// A straight majority of the council can decide what their next motion is.\n\ttype ExternalOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A super-majority can have the next scheduled referendum be a straight majority-carries vote.\n\ttype ExternalMajorityOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A unanimous council can have the next scheduled referendum be a straight default-carries\n\t/// (NTB) vote.\n\ttype ExternalDefaultOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 1\u003e;\n\t/// Two thirds of the technical committee can have an ExternalMajority/ExternalDefault vote\n\t/// be tabled immediately and with a shorter voting/enactment period.\n\ttype FastTrackOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 2, 3\u003e;\n\ttype InstantOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e;\n\ttype InstantAllowed = frame_support::traits::ConstBool\u003ctrue\u003e;\n\ttype FastTrackVotingPeriod = FastTrackVotingPeriod;\n\t// To cancel a proposal which has been passed, 2/3 of the council must agree to it.\n\ttype CancellationOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 2, 3\u003e;\n\t// To cancel a proposal before it has been passed, the technical committee must be unanimous or\n\t// Root must agree.\n\ttype CancelProposalOrigin = EitherOfDiverse\u003c\n\t\tEnsureRoot\u003cAccountId\u003e,\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e,\n\t\u003e;\n\ttype BlacklistOrigin = EnsureRoot\u003cAccountId\u003e;\n\t// Any single technical committee member may veto a coming council proposal, however they can\n\t// only do it once and it lasts only for the cool-off period.\n\ttype VetoOrigin = pallet_collective::EnsureMember\u003cAccountId, TechnicalCollective\u003e;\n\ttype CooloffPeriod = CooloffPeriod;\n\ttype Slash = ();\n\ttype Scheduler = Scheduler;\n\ttype PalletsOrigin = OriginCaller;\n\ttype MaxVotes = ConstU32\u003c100\u003e;\n\ttype WeightInfo = pallet_democracy::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxProposals = MaxProposals;\n\ttype Preimages = Preimage;\n\ttype MaxDeposits = ConstU32\u003c100\u003e;\n\ttype MaxBlacklisted = ConstU32\u003c100\u003e;\n\ttype SubmitOrigin = EnsureSigned\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const CouncilMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const CouncilMaxProposals: u32 = 100;\n\tpub const CouncilMaxMembers: u32 = 100;\n}\n\ntype CouncilCollective = pallet_collective::Instance1;\n\nimpl pallet_collective::Config\u003cCouncilCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = CouncilMotionDuration;\n\ttype MaxProposals = CouncilMaxProposals;\n\ttype MaxMembers = CouncilMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const TechnicalMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const TechnicalMaxProposals: u32 = 100;\n\tpub const TechnicalMaxMembers: u32 = 100;\n}\n\ntype TechnicalCollective = pallet_collective::Instance2;\n\nimpl pallet_collective::Config\u003cTechnicalCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = TechnicalMotionDuration;\n\ttype MaxProposals = TechnicalMaxProposals;\n\ttype MaxMembers = TechnicalMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub MaximumSchedulerWeight: Weight = Perbill::from_percent(80) *\n\t\tRuntimeBlockWeights::get().max_block;\n}\n\nimpl pallet_scheduler::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype PalletsOrigin = OriginCaller;\n\ttype RuntimeCall = RuntimeCall;\n\ttype MaximumWeight = MaximumSchedulerWeight;\n\ttype ScheduleOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype MaxScheduledPerBlock = ConstU32\u003c50\u003e;\n\ttype WeightInfo = pallet_scheduler::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype OriginPrivilegeCmp = EqualPrivilegeOnly;\n\ttype Preimages = Preimage;\n}\n\nparameter_types! {\n\tpub const PreimageMaxSize: u32 = 4096 * 1024;\n\tpub const PreimageBaseDeposit: Balance = 1 * UNIT;\n\t// One cent: $10,000 / MB\n\tpub const PreimageByteDeposit: Balance = 10 * MILLIUNIT;\n}\n\nimpl pallet_preimage::Config for Runtime {\n\ttype WeightInfo = pallet_preimage::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype ManagerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype BaseDeposit = PreimageBaseDeposit;\n\ttype ByteDeposit = PreimageByteDeposit;\n}\n\nparameter_types! {\n\tpub const ProposalBond: Permill = Permill::from_percent(5);\n\tpub const ProposalBondMinimum: Balance = 10 * UNIT;\n\tpub const SpendPeriod: BlockNumber = 7 * DAYS;\n\tpub const Burn: Permill = Permill::from_percent(0);\n\tpub const TreasuryPalletId: PalletId = PalletId(*b\"py/trsry\");\n\tpub const MaxApprovals: u32 = 100;\n}\n\ntype TreasuryApproveOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 3, 5\u003e,\n\u003e;\n\ntype TreasuryRejectOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_treasury::Config for Runtime {\n\ttype PalletId = TreasuryPalletId;\n\ttype Currency = Balances;\n\ttype ApproveOrigin = TreasuryApproveOrigin;\n\ttype RejectOrigin = TreasuryRejectOrigin;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSlash = Treasury;\n\ttype ProposalBond = ProposalBond;\n\ttype ProposalBondMinimum = ProposalBondMinimum;\n\ttype ProposalBondMaximum = ();\n\ttype SpendPeriod = SpendPeriod;\n\ttype Burn = Burn;\n\ttype BurnDestination = ();\n\ttype SpendFunds = Bounties;\n\ttype WeightInfo = pallet_treasury::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxApprovals = MaxApprovals;\n\ttype SpendOrigin = frame_support::traits::NeverEnsureOrigin\u003cu128\u003e;\n}\n\nparameter_types! {\n\tpub const BountyCuratorDeposit: Permill = Permill::from_percent(50);\n\tpub const BountyValueMinimum: Balance = 5 * UNIT;\n\tpub const BountyDepositBase: Balance = 1 * UNIT;\n\tpub const CuratorDepositMultiplier: Permill = Permill::from_percent(50);\n\tpub const CuratorDepositMin: Balance = 1 * UNIT;\n\tpub const CuratorDepositMax: Balance = 100 * UNIT;\n\tpub const DataDepositPerByte: Balance = 30 * MILLIUNIT;\n\tpub const BountyDepositPayoutDelay: BlockNumber = 4 * DAYS;\n\tpub const BountyUpdatePeriod: BlockNumber = 20 * DAYS;\n\tpub const MaximumReasonLength: u32 = 5000;\n}\n\nimpl pallet_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BountyDepositBase = BountyDepositBase;\n\ttype BountyDepositPayoutDelay = BountyDepositPayoutDelay;\n\ttype BountyUpdatePeriod = BountyUpdatePeriod;\n\ttype CuratorDepositMultiplier = CuratorDepositMultiplier;\n\ttype CuratorDepositMin = CuratorDepositMin;\n\ttype CuratorDepositMax = CuratorDepositMax;\n\ttype BountyValueMinimum = BountyValueMinimum;\n\ttype DataDepositPerByte = DataDepositPerByte;\n\ttype MaximumReasonLength = MaximumReasonLength;\n\ttype WeightInfo = pallet_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype ChildBountyManager = ChildBounties;\n}\n\nparameter_types! {\n\tpub const ChildBountyValueMinimum: Balance = 1 * UNIT;\n}\n\nimpl pallet_child_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MaxActiveChildBountyCount = ConstU32\u003c10\u003e;\n\ttype ChildBountyValueMinimum = ChildBountyValueMinimum;\n\ttype WeightInfo = pallet_child_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_type_with_key! {\n\tpub ExistentialDeposits: |_currency_id: CurrencyId| -\u003e Balance {\n\t\tNANOUNIT\n\t};\n}\n\npub fn get_all_module_accounts() -\u003e Vec\u003cAccountId\u003e {\n\tvec![Treasury::account_id()]\n}\n\npub struct DustRemovalWhitelist;\n\nimpl Contains\u003cAccountId\u003e for DustRemovalWhitelist {\n\tfn contains(a: \u0026AccountId) -\u003e bool {\n\t\tget_all_module_accounts().contains(a)\n\t}\n}\n\npub struct CurrencyHooks\u003cT\u003e(PhantomData\u003cT\u003e);\n\nimpl\u003cT: orml_tokens::Config\u003e MutationHooks\u003cT::AccountId, T::CurrencyId, T::Balance\u003e\n\tfor CurrencyHooks\u003cT\u003e\n{\n\ttype OnDust = orml_tokens::BurnDust\u003cT\u003e;\n\ttype OnSlash = ();\n\ttype PreDeposit = ();\n\ttype PostDeposit = ();\n\ttype PreTransfer = ();\n\ttype PostTransfer = ();\n\ttype OnNewTokenAccount = ();\n\ttype OnKilledTokenAccount = ();\n}\n\nimpl orml_tokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype Amount = Amount;\n\ttype CurrencyId = CurrencyId;\n\ttype WeightInfo = ();\n\ttype ExistentialDeposits = ExistentialDeposits;\n\ttype CurrencyHooks = CurrencyHooks\u003cRuntime\u003e;\n\ttype MaxLocks = ConstU32\u003c50\u003e;\n\ttype DustRemovalWhitelist = DustRemovalWhitelist;\n\ttype MaxReserves = ConstU32\u003c0\u003e;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const NativeCurrencyId: CurrencyId = CurrencyId::Native;\n}\n\nimpl orml_currencies::Config for Runtime {\n\ttype MultiCurrency = Tokens;\n\ttype NativeCurrency = BasicCurrencyAdapter\u003cRuntime, Balances, Amount, BlockNumber\u003e;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype WeightInfo = ();\n}\n\nimpl orml_asset_registry::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CustomMetadata = asset_registry::CustomMetadata;\n\ttype AssetId = CurrencyId;\n\ttype AuthorityOrigin = asset_registry::AssetAuthority;\n\ttype AssetProcessor = asset_registry::CustomAssetProcessor;\n\ttype Balance = Balance;\n\ttype WeightInfo = weights::orml_asset_registry::WeightInfo\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinBlocksPerRound: BlockNumber = HOURS;\n\tpub const DefaultBlocksPerRound: BlockNumber = 2 * HOURS;\n\tpub const StakeDuration: BlockNumber = 7 * DAYS;\n\tpub const ExitQueueDelay: u32 = 2;\n\tpub const MinCollators: u32 = 8;\n\tpub const MinRequiredCollators: u32 = 4;\n\tpub const MaxDelegationsPerRound: u32 = 1;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxDelegatorsPerCollator: u32 = 40;\n\tpub const MinCollatorStake: Balance = 5_000 * UNIT;\n\tpub const MinDelegatorStake: Balance = 10 * UNIT;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxTopCandidates: u32 = 40;\n\tpub const MaxUnstakeRequests: u32 = 10;\n\tpub const NetworkRewardStart: BlockNumber = BlockNumber::MAX;\n\tpub const NetworkRewardRate: Perquintill = Perquintill::from_percent(0);\n\tpub const CollatorRewardRateDecay: Perquintill = Perquintill::from_parts(936_879_853_200_000_000u64);\n}\n\nimpl parachain_staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyBalance = Balance;\n\n\ttype MinBlocksPerRound = MinBlocksPerRound;\n\ttype DefaultBlocksPerRound = DefaultBlocksPerRound;\n\ttype StakeDuration = StakeDuration;\n\ttype ExitQueueDelay = ExitQueueDelay;\n\ttype MinCollators = MinCollators;\n\ttype MinRequiredCollators = MinRequiredCollators;\n\ttype MaxDelegationsPerRound = MaxDelegationsPerRound;\n\ttype MaxDelegatorsPerCollator = MaxDelegatorsPerCollator;\n\ttype MinCollatorStake = MinCollatorStake;\n\ttype MinCollatorCandidateStake = MinCollatorStake;\n\ttype MaxTopCandidates = MaxTopCandidates;\n\ttype MinDelegatorStake = MinDelegatorStake;\n\ttype MaxUnstakeRequests = MaxUnstakeRequests;\n\ttype NetworkRewardRate = NetworkRewardRate;\n\ttype NetworkRewardStart = NetworkRewardStart;\n\ttype NetworkRewardBeneficiary = Treasury;\n\ttype CollatorRewardRateDecay = CollatorRewardRateDecay;\n\ttype WeightInfo = parachain_staking::default_weights::SubstrateWeight\u003cRuntime\u003e;\n\n\tconst BLOCKS_PER_YEAR: BlockNumber = BLOCKS_PER_YEAR;\n}\n\nparameter_types! {\n\tpub const DepositBase: Balance = 300 * MILLIUNIT;\n\tpub const DepositFactor: Balance = 50 * MILLIUNIT;\n}\n\nimpl pallet_multisig::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Currency = Balances;\n\ttype DepositBase = DepositBase;\n\ttype DepositFactor = DepositFactor;\n\ttype MaxSignatories = ConstU32\u003c20\u003e;\n\ttype WeightInfo = pallet_multisig::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_utility::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype PalletsOrigin = OriginCaller;\n\ttype WeightInfo = pallet_utility::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinVestedTransfer: Balance = 0;\n\tpub UnvestedFundsAllowedWithdrawReasons: WithdrawReasons =\n\t\tWithdrawReasons::except(WithdrawReasons::TRANSFER | WithdrawReasons::RESERVE);\n}\n\nimpl pallet_vesting::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BlockNumberToBalance = ConvertInto;\n\ttype MinVestedTransfer = MinVestedTransfer;\n\ttype UnvestedFundsAllowedWithdrawReasons = UnvestedFundsAllowedWithdrawReasons;\n\ttype WeightInfo = pallet_vesting::weights::SubstrateWeight\u003cRuntime\u003e;\n\tconst MAX_VESTING_SCHEDULES: u32 = 10;\n}\n\nimpl vesting_manager::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype VestingSchedule = Vesting;\n}\n\nconst fn deposit(items: u32, bytes: u32) -\u003e Balance {\n\t(items as Balance * UNIT + (bytes as Balance) * (5 * MILLIUNIT / 100)) / 10\n}\n\nparameter_types! {\n\tpub const DepositPerItem: Balance = deposit(1, 0);\n\tpub const DepositPerByte: Balance = deposit(0, 1);\n\tpub const DeletionQueueDepth: u32 = 128;\n\tpub DeletionWeightLimit: Weight = RuntimeBlockWeights::get()\n\t\t.per_class\n\t\t.get(DispatchClass::Normal)\n\t\t.max_total\n\t\t.unwrap_or(RuntimeBlockWeights::get().max_block);\n\tpub Schedule: pallet_contracts::Schedule\u003cRuntime\u003e = Default::default();\n}\n\nimpl pallet_contracts::Config for Runtime {\n\ttype Time = Timestamp;\n\ttype Randomness = RandomnessCollectiveFlip;\n\ttype Currency = Balances;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype CallFilter = frame_support::traits::Nothing;\n\ttype DepositPerItem = DepositPerItem;\n\ttype DepositPerByte = DepositPerByte;\n\ttype CallStack = [pallet_contracts::Frame\u003cSelf\u003e; 5];\n\ttype WeightPrice = pallet_transaction_payment::Pallet\u003cSelf\u003e;\n\ttype WeightInfo = pallet_contracts::weights::SubstrateWeight\u003cSelf\u003e;\n\ttype ChainExtension = ();\n\ttype DeletionQueueDepth = DeletionQueueDepth;\n\ttype DeletionWeightLimit = DeletionWeightLimit;\n\ttype Schedule = Schedule;\n\ttype AddressGenerator = pallet_contracts::DefaultAddressGenerator;\n\ttype MaxCodeLen = ConstU32\u003c{ 123 * 1024 }\u003e;\n\ttype MaxStorageKeyLen = ConstU32\u003c128\u003e;\n\ttype UnsafeUnstableInterface = ConstBool\u003ctrue\u003e;\n\ttype MaxDebugBufferLen = ConstU32\u003c{ 2 * 1024 * 1024 }\u003e;\n}\n\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {}\n\nparameter_types! {\n\tpub const BasicDeposit: Balance = 10 * UNIT;       // 258 bytes on-chain\n\tpub const FieldDeposit: Balance = 25 * MILLIUNIT;  // 66 bytes on-chain\n\tpub const SubAccountDeposit: Balance = 2 * UNIT;   // 53 bytes on-chain\n\tpub const MaxSubAccounts: u32 = 100;\n\tpub const MaxAdditionalFields: u32 = 100;\n\tpub const MaxRegistrars: u32 = 20;\n}\n\ntype EnsureRootOrHalfCouncil = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_identity::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BasicDeposit = BasicDeposit;\n\ttype FieldDeposit = FieldDeposit;\n\ttype SubAccountDeposit = SubAccountDeposit;\n\ttype MaxSubAccounts = MaxSubAccounts;\n\ttype MaxAdditionalFields = MaxAdditionalFields;\n\ttype MaxRegistrars = MaxRegistrars;\n\ttype Slashed = Treasury;\n\ttype ForceOrigin = EnsureRootOrHalfCouncil;\n\ttype RegistrarOrigin = EnsureRootOrHalfCouncil;\n\ttype WeightInfo = pallet_identity::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl dia_oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype AuthorityId = dia_oracle::crypto::DiaAuthId;\n\ttype WeightInfo = dia_oracle::weights::DiaWeightInfo\u003cRuntime\u003e;\n}\n\nimpl frame_system::offchain::SigningTypes for Runtime {\n\ttype Public = \u003cSignature as sp_runtime::traits::Verify\u003e::Signer;\n\ttype Signature = Signature;\n}\n\nimpl\u003cC\u003e frame_system::offchain::SendTransactionTypes\u003cC\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cC\u003e,\n{\n\ttype OverarchingCall = RuntimeCall;\n\ttype Extrinsic = UncheckedExtrinsic;\n}\n\nimpl\u003cLocalCall\u003e frame_system::offchain::CreateSignedTransaction\u003cLocalCall\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cLocalCall\u003e,\n{\n\tfn create_transaction\u003cC: frame_system::offchain::AppCrypto\u003cSelf::Public, Self::Signature\u003e\u003e(\n\t\tcall: RuntimeCall,\n\t\tpublic: \u003cSignature as sp_runtime::traits::Verify\u003e::Signer,\n\t\taccount: AccountId,\n\t\tindex: Index,\n\t) -\u003e Option\u003c(\n\t\tRuntimeCall,\n\t\t\u003cUncheckedExtrinsic as sp_runtime::traits::Extrinsic\u003e::SignaturePayload,\n\t)\u003e {\n\t\tlet period = BlockHashCount::get() as u64;\n\t\tlet current_block = System::block_number().saturated_into::\u003cu64\u003e().saturating_sub(1);\n\t\tlet tip = 0;\n\t\tlet extra: SignedExtra = (\n\t\t\tframe_system::CheckNonZeroSender::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckSpecVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckTxVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckGenesis::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckEra::\u003cRuntime\u003e::from(generic::Era::mortal(period, current_block)),\n\t\t\tframe_system::CheckNonce::\u003cRuntime\u003e::from(index),\n\t\t\tframe_system::CheckWeight::\u003cRuntime\u003e::new(),\n\t\t\tpallet_transaction_payment::ChargeTransactionPayment::\u003cRuntime\u003e::from(tip),\n\t\t);\n\n\t\tlet raw_payload = SignedPayload::new(call, extra).ok()?;\n\t\tlet signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;\n\t\tlet address = account;\n\t\tlet (call, extra, _) = raw_payload.deconstruct();\n\t\tSome((call, (sp_runtime::MultiAddress::Id(address), signature.into(), extra)))\n\t}\n}\n\npub struct CurrencyConvert;\n\nimpl currency::CurrencyConversion\u003ccurrency::Amount\u003cRuntime\u003e, CurrencyId\u003e for CurrencyConvert {\n\tfn convert(\n\t\tamount: \u0026currency::Amount\u003cRuntime\u003e,\n\t\tto: CurrencyId,\n\t) -\u003e Result\u003ccurrency::Amount\u003cRuntime\u003e, DispatchError\u003e {\n\t\tOracle::convert(amount, to)\n\t}\n}\nparameter_types! {\n\tpub const RelayChainCurrencyId: CurrencyId = XCM(0); // 0 is the index of the relay chain in our XCM mapping\n}\nimpl currency::Config for Runtime {\n\ttype UnsignedFixedPoint = UnsignedFixedPoint;\n\ttype SignedInner = SignedInner;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype Balance = Balance;\n\ttype GetRelayChainCurrencyId = RelayChainCurrencyId;\n\ttype AssetConversion = primitives::AssetConversion;\n\ttype BalanceConversion = primitives::BalanceConversion;\n\ttype CurrencyConversion = CurrencyConvert;\n\ttype AmountCompatibility = primitives::StellarCompatibility;\n}\n\nimpl security::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = security::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype SignedInner = SignedInner;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype CurrencyId = CurrencyId;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub struct DataFeederBenchmark\u003cK, V, A\u003e(PhantomData\u003c(K, V, A)\u003e);\n\n#[cfg(feature = \"runtime-benchmarks\")]\nimpl\u003cK, V, A\u003e orml_traits::DataFeeder\u003cK, V, A\u003e for DataFeederBenchmark\u003cK, V, A\u003e {\n\tfn feed_value(_who: A, _key: K, _value: V) -\u003e sp_runtime::DispatchResult {\n\t\tOk(())\n\t}\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nimpl\u003cK, V, A\u003e orml_traits::DataProvider\u003cK, V\u003e for DataFeederBenchmark\u003cK, V, A\u003e {\n\tfn get(_key: \u0026K) -\u003e Option\u003cV\u003e {\n\t\tNone\n\t}\n}\n\nimpl oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = oracle::SubstrateWeight\u003cRuntime\u003e;\n\ttype DataProvider = DataProviderImpl;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype DataFeedProvider = DataFeederBenchmark\u003c\n\t\toracle::OracleKey,\n\t\toracle::TimestampedValue\u003cUnsignedFixedPoint, Moment\u003e,\n\t\tSelf::AccountId,\n\t\u003e;\n}\n\nparameter_types! {\n\tpub const OrganizationLimit: u32 = 255;\n\tpub const ValidatorLimit: u32 = 255;\n\tpub const IsPublicNetwork: bool = true;\n}\n\nimpl stellar_relay::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OrganizationId = u128;\n\ttype OrganizationLimit = OrganizationLimit;\n\ttype ValidatorLimit = ValidatorLimit;\n\ttype IsPublicNetwork = IsPublicNetwork;\n\ttype WeightInfo = stellar_relay::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl reward::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype RewardId = VaultId;\n\ttype CurrencyId = CurrencyId;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n}\nparameter_types! {\n\tpub const FeePalletId: PalletId = PalletId(*b\"mod/fees\");\n\tpub const VaultRegistryPalletId: PalletId = PalletId(*b\"mod/vreg\");\n\tpub const MaxExpectedValue: UnsignedFixedPoint = UnsignedFixedPoint::from_inner(\u003cUnsignedFixedPoint as FixedPointNumber\u003e::DIV);\n\tpub FeeAccount: AccountId = FeePalletId::get().into_account_truncating();\n}\nimpl fee::Config for Runtime {\n\ttype FeePalletId = FeePalletId;\n\ttype WeightInfo = fee::SubstrateWeight\u003cRuntime\u003e;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype SignedInner = SignedInner;\n\ttype UnsignedFixedPoint = UnsignedFixedPoint;\n\ttype UnsignedInner = UnsignedInner;\n\ttype VaultRewards = VaultRewards;\n\ttype VaultStaking = VaultStaking;\n\ttype OnSweep = currency::SweepFunds\u003cRuntime, FeeAccount\u003e;\n\ttype MaxExpectedValue = MaxExpectedValue;\n}\n\nimpl vault_registry::Config for Runtime {\n\ttype PalletId = VaultRegistryPalletId;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype WeightInfo = vault_registry::SubstrateWeight\u003cRuntime\u003e;\n\ttype GetGriefingCollateralCurrencyId = NativeCurrencyId;\n}\n\nimpl redeem::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = redeem::SubstrateWeight\u003cRuntime\u003e;\n}\n\npub struct BlockNumberToBalance;\n\nimpl sp_runtime::traits::Convert\u003cBlockNumber, Balance\u003e for BlockNumberToBalance {\n\tfn convert(a: BlockNumber) -\u003e Balance {\n\t\ta.into()\n\t}\n}\n\nimpl issue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BlockNumberToBalance = BlockNumberToBalance;\n\ttype WeightInfo = issue::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl nomination::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = nomination::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl replace::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = replace::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const FarmingKeeperPalletId: PalletId = PalletId(*b\"am/fmkpr\");\n\tpub const FarmingRewardIssuerPalletId: PalletId = PalletId(*b\"am/fmrir\");\n\tpub AmplitudeTreasuryAccount: AccountId = TreasuryPalletId::get().into_account_truncating();\n}\n\nimpl farming::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CurrencyId = CurrencyId;\n\ttype MultiCurrency = Currencies;\n\ttype ControlOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype WeightInfo = farming::weights::BifrostWeight\u003cRuntime\u003e;\n\ttype TreasuryAccount = AmplitudeTreasuryAccount;\n\ttype Keeper = FarmingKeeperPalletId;\n\ttype RewardIssuer = FarmingRewardIssuerPalletId;\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\t// System support stuff.\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 0,\n\t\tParachainSystem: cumulus_pallet_parachain_system::{\n\t\t\tPallet, Call, Config, Storage, Inherent, Event\u003cT\u003e, ValidateUnsigned,\n\t\t} = 1,\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent} = 2,\n\t\tParachainInfo: parachain_info::{Pallet, Storage, Config} = 3,\n\n\t\t// Monetary stuff.\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 10,\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event\u003cT\u003e} = 11,\n\n\t\t// Governance\n\t\tDemocracy: pallet_democracy::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 13,\n\t\tCouncil: pallet_collective::\u003cInstance1\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e, Event\u003cT\u003e} = 14,\n\t\tTechnicalCommittee: pallet_collective::\u003cInstance2\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e,  Event\u003cT\u003e} = 15,\n\t\tScheduler: pallet_scheduler::{Pallet, Call, Storage, Event\u003cT\u003e} = 16,\n\t\tPreimage: pallet_preimage::{Pallet, Call, Storage, Event\u003cT\u003e} = 17,\n\t\tMultisig: pallet_multisig::{Pallet, Call, Storage, Event\u003cT\u003e} = 18,\n\t\tTreasury: pallet_treasury::{Pallet, Call, Storage, Event\u003cT\u003e} = 19,\n\t\tBounties: pallet_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 20,\n\t\tChildBounties: pallet_child_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 21,\n\n\t\t// Consensus support.\n\t\t// The following order MUST NOT be changed: Aura -\u003e Session -\u003e Staking -\u003e Authorship -\u003e AuraExt\n\t\t// Dependencies: AuraExt on Aura, Authorship and Session on ParachainStaking\n\t\tAura: pallet_aura::{Pallet, Storage, Config\u003cT\u003e} = 33,\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e} = 32,\n\t\tParachainStaking: parachain_staking::{Pallet, Call, Storage, Event\u003cT\u003e, Config\u003cT\u003e} = 35,\n\t\tAuthorship: pallet_authorship::{Pallet, Storage} = 30,\n\t\tAuraExt: cumulus_pallet_aura_ext::{Pallet, Storage, Config} = 34,\n\n\t\t// XCM helpers.\n\t\tXcmpQueue: cumulus_pallet_xcmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 40,\n\t\tPolkadotXcm: pallet_xcm::{Pallet, Call, Event\u003cT\u003e, Origin, Config} = 41,\n\t\tCumulusXcm: cumulus_pallet_xcm::{Pallet, Event\u003cT\u003e, Origin} = 42,\n\t\tDmpQueue: cumulus_pallet_dmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 43,\n\n\t\t// Amendments\n\t\tVesting: pallet_vesting::{Pallet, Call, Storage, Event\u003cT\u003e} = 50,\n\t\tUtility: pallet_utility::{Pallet, Call, Event} = 51,\n\t\tCurrencies: orml_currencies::{Pallet, Call, Storage} = 52,\n\t\tTokens: orml_tokens::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 53,\n\t\tXTokens: orml_xtokens::{Pallet, Storage, Call, Event\u003cT\u003e} = 54,\n\t\tIdentity: pallet_identity::{Pallet, Storage, Call, Event\u003cT\u003e} = 55,\n\t\tContracts: pallet_contracts::{Pallet, Storage, Call, Event\u003cT\u003e} = 56,\n\t\tRandomnessCollectiveFlip: pallet_insecure_randomness_collective_flip::{Pallet, Storage} = 57,\n\t\tDiaOracleModule: dia_oracle::{Pallet, Storage, Call, Config\u003cT\u003e, Event\u003cT\u003e} = 58,\n\n\t\tZenlinkProtocol: zenlink_protocol::{Pallet, Call, Storage, Event\u003cT\u003e}  = 59,\n\n\t\t// Spacewalk pallets\n\t\tCurrency: currency::{Pallet} = 60,\n\t\tFee: fee::{Pallet, Call, Config\u003cT\u003e, Storage} = 61,\n\t\tIssue: issue::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 62,\n\t\tNomination: nomination::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 63,\n\t\tOracle: oracle::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 64,\n\t\tRedeem: redeem::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 65,\n\t\tReplace: replace::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 66,\n\t\tSecurity: security::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 67,\n\t\tStellarRelay: stellar_relay::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 68,\n\t\tVaultRegistry: vault_registry::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e, ValidateUnsigned} = 69,\n\t\tVaultRewards: reward::{Pallet, Call, Storage, Event\u003cT\u003e} = 70,\n\t\tVaultStaking: staking::{Pallet, Storage, Event\u003cT\u003e} = 71,\n\n\t\tFarming: farming::{Pallet, Call, Storage, Event\u003cT\u003e} = 90,\n\n\t\t// Asset Metadata\n\t\tAssetRegistry: orml_asset_registry::{Pallet, Storage, Call, Event\u003cT\u003e, Config\u003cT\u003e} = 91,\n\n\t\tVestingManager: vesting_manager::{Pallet, Call, Event\u003cT\u003e} = 100\n\t}\n);\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!(\n\t\t[frame_benchmarking, BaselineBench::\u003cRuntime\u003e]\n\t\t[frame_system, SystemBench::\u003cRuntime\u003e]\n\t\t[pallet_balances, Balances]\n\t\t[pallet_session, SessionBench::\u003cRuntime\u003e]\n\t\t[pallet_timestamp, Timestamp]\n\t\t[cumulus_pallet_xcmp_queue, XcmpQueue]\n\n\t\t[fee, Fee]\n\t\t[issue, Issue]\n\t\t[nomination, Nomination]\n\t\t[oracle, Oracle]\n\t\t[redeem, Redeem]\n\t\t[replace, Replace]\n\t\t[stellar_relay, StellarRelay]\n\t\t[vault_registry, VaultRegistry]\n\n\t\t// Other\n\t\t[orml_asset_registry, runtime_common::benchmarking::orml_asset_registry::Pallet::\u003cRuntime\u003e]\n\t\t[pallet_xcm, PolkadotXcm]\n\t);\n}\n\nimpl_runtime_apis! {\n\timpl sp_consensus_aura::AuraApi\u003cBlock, AuraId\u003e for Runtime {\n\t\tfn slot_duration() -\u003e sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -\u003e Vec\u003cAuraId\u003e {\n\t\t\tAura::authorities().into_inner()\n\t\t}\n\t}\n\n\timpl sp_api::Core\u003cBlock\u003e for Runtime {\n\t\tfn version() -\u003e RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata\u003cBlock\u003e for Runtime {\n\t\tfn metadata() -\u003e OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder\u003cBlock\u003e for Runtime {\n\t\tfn apply_extrinsic(extrinsic: \u003cBlock as BlockT\u003e::Extrinsic) -\u003e ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -\u003e \u003cBlock as BlockT\u003e::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -\u003e Vec\u003c\u003cBlock as BlockT\u003e::Extrinsic\u003e {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(\u0026block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tblock_hash: \u003cBlock as BlockT\u003e::Hash,\n\t\t) -\u003e TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi\u003cBlock\u003e for Runtime {\n\t\tfn offchain_worker(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys\u003cBlock\u003e for Runtime {\n\t\tfn generate_session_keys(seed: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n\t\t\tSessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec\u003cu8\u003e,\n\t\t) -\u003e Option\u003cVec\u003c(Vec\u003cu8\u003e, KeyTypeId)\u003e\u003e {\n\t\t\tSessionKeys::decode_into_raw_public_keys(\u0026encoded)\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi\u003cBlock, AccountId, Index\u003e for Runtime {\n\t\tfn account_nonce(account: AccountId) -\u003e Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi\u003cBlock, Balance\u003e for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t\tfn query_fee_details(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment::FeeDetails\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t\tfn query_weight_to_fee(weight: Weight) -\u003e Balance {\n\t\t\tTransactionPayment::weight_to_fee(weight)\n\t\t}\n\t\tfn query_length_to_fee(length: u32) -\u003e Balance {\n\t\t\tTransactionPayment::length_to_fee(length)\n\t\t}\n\t}\n\n\timpl cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e for Runtime {\n\t\tfn collect_collation_info(header: \u0026\u003cBlock as BlockT\u003e::Header) -\u003e cumulus_primitives_core::CollationInfo {\n\t\t\tParachainSystem::collect_collation_info(header)\n\t\t}\n\t}\n\n\timpl parachain_staking::runtime_api::ParachainStakingApi\u003cBlock, AccountId, Balance\u003e for Runtime {\n\t\tfn get_unclaimed_staking_rewards(account: \u0026AccountId) -\u003e Balance {\n\t\t\tParachainStaking::get_unclaimed_staking_rewards(account)\n\t\t}\n\n\t\tfn get_staking_rates() -\u003e parachain_staking::runtime_api::StakingRates {\n\t\t\tParachainStaking::get_staking_rates()\n\t\t}\n\t}\n\n\timpl dia_oracle_runtime_api::DiaOracleApi\u003cBlock\u003e for Runtime{\n\t\tfn get_value(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::PriceInfo, sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_value(blockchain, symbol)\n\t\t}\n\n\t\tfn get_coin_info(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::CoinInfo,sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_coin_info(blockchain, symbol)\n\t\t}\n\t}\n\n\t// zenlink runtime outer apis\n\timpl zenlink_protocol_runtime_api::ZenlinkProtocolApi\u003cBlock, AccountId, ZenlinkAssetId\u003e for Runtime {\n\n\t\tfn get_balance(\n\t\t\tasset_id: ZenlinkAssetId,\n\t\t\towner: AccountId\n\t\t) -\u003e AssetBalance {\n\t\t\t\u003cRuntime as zenlink_protocol::Config\u003e::MultiAssetsHandler::balance_of(asset_id, \u0026owner)\n\t\t}\n\n\t\tfn get_pair_by_asset_id(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId\n\t\t) -\u003e Option\u003cPairInfo\u003cAccountId, AssetBalance, ZenlinkAssetId\u003e\u003e {\n\t\t\tZenlinkProtocol::get_pair_by_asset_id(asset_0, asset_1)\n\t\t}\n\n\t\tfn get_amount_in_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::desired_in_amount(supply, path)\n\t\t}\n\n\t\tfn get_amount_out_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::supply_out_amount(supply, path)\n\t\t}\n\n\t\tfn get_estimate_lptoken(\n\t\t\ttoken_0: ZenlinkAssetId,\n\t\t\ttoken_1: ZenlinkAssetId,\n\t\t\tamount_0_desired: AssetBalance,\n\t\t\tamount_1_desired: AssetBalance,\n\t\t\tamount_0_min: AssetBalance,\n\t\t\tamount_1_min: AssetBalance,\n\t\t) -\u003e AssetBalance{\n\t\t\tZenlinkProtocol::get_estimate_lptoken(\n\t\t\t\ttoken_0,\n\t\t\t\ttoken_1,\n\t\t\t\tamount_0_desired,\n\t\t\t\tamount_1_desired,\n\t\t\t\tamount_0_min,\n\t\t\t\tamount_1_min\n\t\t\t)\n\t\t}\n\n\t\tfn calculate_remove_liquidity(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId,\n\t\t\tamount: AssetBalance,\n\t\t) -\u003e Option\u003c(AssetBalance, AssetBalance)\u003e{\n\t\t\tZenlinkProtocol::calculate_remove_liquidity(\n\t\t\t\tasset_0,\n\t\t\t\tasset_1,\n\t\t\t\tamount,\n\t\t\t)\n\t\t}\n\t}\n\n\timpl farming_rpc_runtime_api::FarmingRuntimeApi\u003cBlock, AccountId, PoolId, CurrencyId\u003e for Runtime {\n\t\tfn get_farming_rewards(who: AccountId, pid: PoolId) -\u003e Vec\u003c(CurrencyId, Balance)\u003e {\n\t\t\tFarming::get_farming_rewards(\u0026who, pid).unwrap_or(Vec::new())\n\t\t}\n\n\t\tfn get_gauge_rewards(who: AccountId, pid: PoolId) -\u003e Vec\u003c(CurrencyId, Balance)\u003e {\n\t\t\tFarming::get_gauge_rewards(\u0026who, pid).unwrap_or(Vec::new())\n\t\t}\n\t}\n\n\n\t#[cfg(feature = \"try-runtime\")]\n\timpl frame_try_runtime::TryRuntime\u003cBlock\u003e for Runtime {\n\t\tfn on_runtime_upgrade() -\u003e (Weight, Weight) {\n\t\t\tlog::info!(\"try-runtime::on_runtime_upgrade amplitude.\");\n\t\t\tlet weight = Executive::try_runtime_upgrade().unwrap();\n\t\t\t(weight, RuntimeBlockWeights::get().max_block)\n\t\t}\n\n\t\tfn execute_block_no_check(block: Block) -\u003e Weight {\n\t\t\tExecutive::execute_block_no_check(block)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark\u003cBlock\u003e for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -\u003e (\n\t\t\tVec\u003cframe_benchmarking::BenchmarkList\u003e,\n\t\t\tVec\u003cframe_support::traits::StorageInfo\u003e,\n\t\t) {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\tlet mut list = Vec::\u003cBenchmarkList\u003e::new();\n\t\t\tlist_benchmarks!(list, extra);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -\u003e Result\u003cVec\u003cframe_benchmarking::BenchmarkBatch\u003e, sp_runtime::RuntimeString\u003e {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, TrackedStorageKey};\n\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\t\t\timpl baseline::Config for Runtime {}\n\t\t\timpl runtime_common::benchmarking::orml_asset_registry::Config for Runtime {}\n\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\timpl cumulus_pallet_session_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec\u003cTrackedStorageKey\u003e = vec![\n\t\t\t\t// Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t// Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t// Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t// Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t// System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::\u003cBenchmarkBatch\u003e::new();\n\t\t\tlet params = (\u0026config, \u0026whitelist);\n\t\t\tadd_benchmarks!(params, batches);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n\n\timpl module_issue_rpc_runtime_api::IssueApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tIssueRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_issue_requests(account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tIssue::get_issue_requests_for_account(account_id)\n\t\t}\n\t\tfn get_vault_issue_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tIssue::get_issue_requests_for_vault(vault_id)\n\t\t}\n\t}\n\timpl module_vault_registry_rpc_runtime_api::VaultRegistryApi\u003c\n\t\tBlock,\n\t\tVaultId,\n\t\tBalance,\n\t\tUnsignedFixedPoint,\n\t\tCurrencyId,\n\t\tAccountId,\n\t\u003e for Runtime {\n\t\tfn get_vault_collateral(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::compute_collateral(\u0026vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t\tfn get_vaults_by_account_id(account_id: AccountId) -\u003e Result\u003cVec\u003cVaultId\u003e, DispatchError\u003e {\n\t\t\tVaultRegistry::get_vaults_by_account_id(account_id)\n\t\t}\n\t\tfn get_vault_total_collateral(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_backing_collateral(\u0026vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t\tfn get_premium_redeem_vaults() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_premium_redeem_vaults()?;\n\t\t\tOk(result.iter().map(|v| (v.0.clone(), BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\t\tfn get_vaults_with_issuable_tokens() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_vaults_with_issuable_tokens()?;\n\t\t\tOk(result.into_iter().map(|v| (v.0, BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\t\tfn get_vaults_with_redeemable_tokens() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_vaults_with_redeemable_tokens()?;\n\t\t\tOk(result.into_iter().map(|v| (v.0, BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\t\tfn get_issuable_tokens_from_vault(vault: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_issuable_tokens_from_vault(\u0026vault)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t\tfn get_collateralization_from_vault(vault: VaultId, only_issued: bool) -\u003e Result\u003cUnsignedFixedPoint, DispatchError\u003e {\n\t\t\tVaultRegistry::get_collateralization_from_vault(vault, only_issued)\n\t\t}\n\t\tfn get_collateralization_from_vault_and_collateral(vault: VaultId, collateral: BalanceWrapper\u003cBalance\u003e, only_issued: bool) -\u003e Result\u003cUnsignedFixedPoint, DispatchError\u003e {\n\t\t\tlet amount = currency::Amount::new(collateral.amount, vault.collateral_currency());\n\t\t\tVaultRegistry::get_collateralization_from_vault_and_collateral(vault, \u0026amount, only_issued)\n\t\t}\n\t\tfn get_required_collateral_for_wrapped(amount_wrapped: BalanceWrapper\u003cBalance\u003e, wrapped_currency_id: CurrencyId, collateral_currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet amount_wrapped = currency::Amount::new(amount_wrapped.amount, wrapped_currency_id);\n\t\t\tlet result = VaultRegistry::get_required_collateral_for_wrapped(\u0026amount_wrapped, collateral_currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t\tfn get_required_collateral_for_vault(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_required_collateral_for_vault(vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t}\n\timpl module_redeem_rpc_runtime_api::RedeemApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tRedeemRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_redeem_requests(account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tRedeem::get_redeem_requests_for_account(account_id)\n\t\t}\n\t\tfn get_vault_redeem_requests(vault_account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tRedeem::get_redeem_requests_for_vault(vault_account_id)\n\t\t}\n\t}\n\timpl module_replace_rpc_runtime_api::ReplaceApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tReplaceRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_old_vault_replace_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tReplace::get_replace_requests_for_old_vault(vault_id)\n\t\t}\n\t\tfn get_new_vault_replace_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tReplace::get_replace_requests_for_new_vault(vault_id)\n\t\t}\n\t}\n\n\timpl pallet_contracts::ContractsApi\u003cBlock, AccountId, Balance, BlockNumber, Hash\u003e\n\t\tfor Runtime\n\t{\n\t\tfn call(\n\t\t\torigin: AccountId,\n\t\t\tdest: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tinput_data: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractExecResult\u003cBalance\u003e {\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_call(\n\t\t\t\torigin,\n\t\t\t\tdest,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tinput_data,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT,\n\t\t\t\tpallet_contracts::Determinism::Deterministic,\n\t\t\t)\n\t\t}\n\n\t\tfn instantiate(\n\t\t\torigin: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tcode: pallet_contracts_primitives::Code\u003cHash\u003e,\n\t\t\tdata: Vec\u003cu8\u003e,\n\t\t\tsalt: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractInstantiateResult\u003cAccountId, Balance\u003e\n\t\t{\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_instantiate(\n\t\t\t\torigin,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tcode,\n\t\t\t\tdata,\n\t\t\t\tsalt,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT\n\t\t\t)\n\t\t}\n\n\t\tfn upload_code(\n\t\t\torigin: AccountId,\n\t\t\tcode: Vec\u003cu8\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tdeterminism: pallet_contracts::Determinism,\n\t\t) -\u003e pallet_contracts_primitives::CodeUploadResult\u003cHash, Balance\u003e\n\t\t{\n\t\t\tContracts::bare_upload_code(origin, code, storage_deposit_limit, determinism)\n\t\t}\n\n\t\tfn get_storage(\n\t\t\taddress: AccountId,\n\t\t\tkey: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::GetStorageResult {\n\t\t\tContracts::get_storage(address, key)\n\t\t}\n\t}\n\n\timpl module_oracle_rpc_runtime_api::OracleApi\u003cBlock, Balance, CurrencyId\u003e for Runtime {\n\t\tfn currency_to_usd(amount:BalanceWrapper\u003cBalance\u003e, currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = Oracle::currency_to_usd(amount.amount, currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result})\n\t\t}\n\n\t\tfn usd_to_currency(amount:BalanceWrapper\u003cBalance\u003e, currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = Oracle::usd_to_currency(amount.amount, currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result})\n\t\t}\n\t}\n\n}\n\nstruct CheckInherents;\n\nimpl cumulus_pallet_parachain_system::CheckInherents\u003cBlock\u003e for CheckInherents {\n\tfn check_inherents(\n\t\tblock: \u0026Block,\n\t\trelay_state_proof: \u0026cumulus_pallet_parachain_system::RelayChainStateProof,\n\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\tlet relay_chain_slot = relay_state_proof\n\t\t\t.read_slot()\n\t\t\t.expect(\"Could not read the relay chain slot from the proof\");\n\n\t\tlet inherent_data =\n\t\t\tcumulus_primitives_timestamp::InherentDataProvider::from_relay_chain_slot_and_duration(\n\t\t\t\trelay_chain_slot,\n\t\t\t\tsp_std::time::Duration::from_secs(6),\n\t\t\t)\n\t\t\t.create_inherent_data()\n\t\t\t.expect(\"Could not create the timestamp inherent data\");\n\n\t\tinherent_data.check_extrinsics(block)\n\t}\n}\n\ncumulus_pallet_parachain_system::register_validate_block! {\n\tRuntime = Runtime,\n\tBlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::\u003cRuntime, Executive\u003e,\n\tCheckInherents = CheckInherents,\n}\n","traces":[{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1032,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1037,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":26},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","block_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Importing a block with 0 Extrinsics.\n\t\tpub const BlockExecutionWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::BlockExecutionWeight::get();\n\n\t\t\t// At least 100 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 100u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 100 µs.\"\n\t\t\t);\n\t\t\t// At most 50 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= 50u64 * constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 50 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","extrinsic_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Executing a NO-OP `System::remarks` Extrinsic.\n\t\tpub const ExtrinsicBaseWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::ExtrinsicBaseWeight::get();\n\n\t\t\t// At least 10 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 10u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 10 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","mod.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Expose the auto generated weight files.\n\npub mod block_weights;\npub mod extrinsic_weights;\npub mod orml_asset_registry;\npub mod pallet_xcm;\npub mod paritydb_weights;\npub mod rocksdb_weights;\n\npub use block_weights::constants::BlockExecutionWeight;\npub use extrinsic_weights::constants::ExtrinsicBaseWeight;\npub use paritydb_weights::constants::ParityDbWeight;\npub use rocksdb_weights::constants::RocksDbWeight;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","orml_asset_registry.rs"],"content":"\n//! Autogenerated weights for `orml_asset_registry`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-07-25, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Marcels-MBP`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"amplitude\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// amplitude\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet\n// orml-asset-registry\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// runtime/amplitude/src/weights/orml_asset_registry.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `orml_asset_registry`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e orml_asset_registry::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn register_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `104`\n\t\t//  Estimated: `7138`\n\t\t// Minimum execution time: 18_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 7138))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:2)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn update_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `745`\n\t\t//  Estimated: `8420`\n\t\t// Minimum execution time: 25_000_000 picoseconds.\n\t\tWeight::from_parts(26_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8420))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\tfn set_asset_location() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 0_000 picoseconds.\n\t\tWeight::from_parts(0, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","pallet_xcm.rs"],"content":"\n//! Autogenerated weights for `pallet_xcm`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-06-20, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Bs-MacBook-Pro.local`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"amplitude\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// amplitude\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet=pallet-xcm\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// pallet_xcm.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `pallet_xcm`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e pallet_xcm::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn send() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `212`\n\t\t//  Estimated: `10465`\n\t\t// Minimum execution time: 26_000_000 picoseconds.\n\t\tWeight::from_parts(27_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 10465))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: Benchmark Override (r:0 w:0)\n\t/// Proof Skipped: Benchmark Override (max_values: None, max_size: None, mode: Measured)\n\tfn teleport_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 18_446_744_073_709_551_000 picoseconds.\n\t\tWeight::from_parts(18_446_744_073_709_551_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: ParachainInfo ParachainId (r:1 w:0)\n\t/// Proof: ParachainInfo ParachainId (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn reserve_transfer_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 1489))\n\t\t\t.saturating_add(T::DbWeight::get().reads(1))\n\t}\n\tfn execute() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn force_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\tfn force_default_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 2_000_000 picoseconds.\n\t\tWeight::from_parts(3_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm QueryCounter (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm QueryCounter (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_subscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `212`\n\t\t//  Estimated: `16051`\n\t\t// Minimum execution time: 30_000_000 picoseconds.\n\t\tWeight::from_parts(31_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 16051))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_unsubscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `395`\n\t\t//  Estimated: `15635`\n\t\t// Minimum execution time: 31_000_000 picoseconds.\n\t\tWeight::from_parts(31_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 15635))\n\t\t\t.saturating_add(T::DbWeight::get().reads(6))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_supported_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `196`\n\t\t//  Estimated: `11086`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(17_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11086))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notifiers() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `200`\n\t\t//  Estimated: `11090`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11090))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:5 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn already_notified_target() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `207`\n\t\t//  Estimated: `13572`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 13572))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:2 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn notify_current_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `279`\n\t\t//  Estimated: `17019`\n\t\t// Minimum execution time: 29_000_000 picoseconds.\n\t\tWeight::from_parts(29_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 17019))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:3 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn notify_target_migration_fail() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `239`\n\t\t//  Estimated: `8654`\n\t\t// Minimum execution time: 10_000_000 picoseconds.\n\t\tWeight::from_parts(11_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8654))\n\t\t\t.saturating_add(T::DbWeight::get().reads(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notify_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `207`\n\t\t//  Estimated: `11097`\n\t\t// Minimum execution time: 18_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11097))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn migrate_and_notify_old_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `283`\n\t\t//  Estimated: `21993`\n\t\t// Minimum execution time: 37_000_000 picoseconds.\n\t\tWeight::from_parts(37_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 21993))\n\t\t\t.saturating_add(T::DbWeight::get().reads(9))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","paritydb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights\n\t\t/// are available for brave runtime engineers who may want to try this out as default.\n\t\tpub const ParityDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::ParityDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","rocksdb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// By default, Substrate uses `RocksDB`, so this will be the weight used throughout\n\t\t/// the runtime.\n\t\tpub const RocksDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::RocksDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","xcm_config.rs"],"content":"use super::{\n\tAccountId, Balance, Balances, CurrencyId, ParachainInfo, ParachainSystem, PolkadotXcm, Runtime,\n\tRuntimeCall, RuntimeEvent, RuntimeOrigin, Tokens, WeightToFee, XcmpQueue,\n};\nuse crate::ConstU32;\nuse core::marker::PhantomData;\nuse frame_support::{\n\tlog, match_types, parameter_types,\n\ttraits::{ContainsPair, Everything, Nothing},\n};\nuse orml_traits::{\n\tlocation::{RelativeReserveProvider, Reserve},\n\tparameter_type_with_key,\n};\nuse pallet_xcm::XcmPassthrough;\nuse polkadot_parachain::primitives::Sibling;\nuse polkadot_runtime_common::impls::ToAuthor;\nuse sp_runtime::traits::Convert;\nuse xcm::latest::{prelude::*, Weight as XCMWeight};\nuse xcm_builder::{\n\tAccountId32Aliases, AllowUnpaidExecutionFrom, ConvertedConcreteId, EnsureXcmOrigin,\n\tFixedWeightBounds, FungiblesAdapter, NoChecking, ParentIsPreset, RelayChainAsNative,\n\tSiblingParachainAsNative, SiblingParachainConvertsVia, SignedAccountId32AsNative,\n\tSignedToAccountId32, SovereignSignedViaLocation, UsingComponents,\n};\nuse xcm_executor::{\n\ttraits::{JustTry, ShouldExecute},\n\tXcmExecutor,\n};\nuse runtime_common::parachains::kusama::asset_hub;\n\nconst XCM_ASSET_RELAY_KSM: u8 = 0;\nconst XCM_ASSET_ASSETHUB_USDT: u8 = 1;\n\nparameter_types! {\n\tpub const RelayLocation: MultiLocation = MultiLocation::parent();\n\tpub const RelayNetwork: NetworkId = NetworkId::Kusama;\n\tpub RelayChainOrigin: RuntimeOrigin = cumulus_pallet_xcm::Origin::Relay.into();\n\tpub CheckingAccount: AccountId = PolkadotXcm::check_account();\n\tpub UniversalLocation: InteriorMultiLocation =\n\t\tX2(GlobalConsensus(RelayNetwork::get()), Parachain(ParachainInfo::parachain_id().into()));\n\n}\n\n/// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used\n/// when determining ownership of accounts for asset transacting and when attempting to use XCM\n/// `Transact` in order to determine the dispatch Origin.\npub type LocationToAccountId = (\n\t// The parent (Relay-chain) origin converts to the parent `AccountId`.\n\tParentIsPreset\u003cAccountId\u003e,\n\t// Sibling parachain origins convert to AccountId via the `ParaId::into`.\n\tSiblingParachainConvertsVia\u003cSibling, AccountId\u003e,\n\t// Straight up local `AccountId32` origins just alias directly to `AccountId`.\n\tAccountId32Aliases\u003cRelayNetwork, AccountId\u003e,\n);\n\n/// CurrencyIdConvert\n/// This type implements conversions from our `CurrencyId` type into `MultiLocation` and vice-versa.\n/// A currency locally is identified with a `CurrencyId` variant but in the network it is identified\n/// in the form of a `MultiLocation`, in this case a pCfg (Para-Id, Currency-Id).\npub struct CurrencyIdConvert;\n\nimpl Convert\u003cCurrencyId, Option\u003cMultiLocation\u003e\u003e for CurrencyIdConvert {\n\tfn convert(id: CurrencyId) -\u003e Option\u003cMultiLocation\u003e {\n\t\tmatch id {\n\t\t\tCurrencyId::XCM(index) =\u003e match index {\n\t\t\t\tXCM_ASSET_RELAY_KSM =\u003e Some(MultiLocation::parent()),\n\t\t\t\tXCM_ASSET_ASSETHUB_USDT =\u003e Some(MultiLocation::new(\n\t\t\t\t\t1,\n\t\t\t\t\tX3(\n\t\t\t\t\t\tParachain(asset_hub::PARA_ID),\n\t\t\t\t\t\tPalletInstance(asset_hub::ASSET_PALLET_ID),\n\t\t\t\t\t\tGeneralIndex(asset_hub::USDT_ASSET_ID),\n\t\t\t\t\t),\n\t\t\t\t)),\n\t\t\t\t_ =\u003e None,\n\t\t\t},\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Option\u003cCurrencyId\u003e {\n\t\tmatch location {\n\t\t\tMultiLocation { parents: 1, interior: Here } =\u003e Some(CurrencyId::XCM(XCM_ASSET_RELAY_KSM)),\n\t\t\tMultiLocation {\n\t\t\t\tparents: 1,\n\t\t\t\tinterior:\n\t\t\t\t\tX3(\n\t\t\t\t\t\tParachain(asset_hub::PARA_ID),\n\t\t\t\t\t\tPalletInstance(asset_hub::ASSET_PALLET_ID),\n\t\t\t\t\t\tGeneralIndex(asset_hub::USDT_ASSET_ID)\n\t\t\t\t\t)\n\t\t\t} =\u003e Some(CurrencyId::XCM(XCM_ASSET_ASSETHUB_USDT)),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiAsset, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(a: MultiAsset) -\u003e Option\u003cCurrencyId\u003e {\n\t\tif let MultiAsset { id: AssetId::Concrete(id), fun: _ } = a {\n\t\t\tSelf::convert(id)\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\n/// Convert an incoming `MultiLocation` into a `CurrencyId` if possible.\n/// Here we need to know the canonical representation of all the tokens we handle in order to\n/// correctly convert their `MultiLocation` representation into our internal `CurrencyId` type.\nimpl xcm_executor::traits::Convert\u003cMultiLocation, CurrencyId\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Result\u003cCurrencyId, MultiLocation\u003e {\n\t\t\u003cCurrencyIdConvert as Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e\u003e::convert(location.clone())\n\t\t\t.ok_or(location)\n\t}\n}\n\n/// A `FilterAssetLocation` implementation. Filters multi native assets whose\n/// reserve is same with `origin`.\npub struct MultiNativeAsset\u003cReserveProvider\u003e(PhantomData\u003cReserveProvider\u003e);\nimpl\u003cReserveProvider\u003e ContainsPair\u003cMultiAsset, MultiLocation\u003e for MultiNativeAsset\u003cReserveProvider\u003e\nwhere\n\tReserveProvider: Reserve,\n{\n\tfn contains(asset: \u0026MultiAsset, origin: \u0026MultiLocation) -\u003e bool {\n\t\tif let Some(ref reserve) = ReserveProvider::reserve(asset) {\n\t\t\tif reserve == origin {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tfalse\n\t}\n}\n\n/// Means for transacting the fungibles assets of ths parachain.\npub type FungiblesTransactor = FungiblesAdapter\u003c\n\t// Use this fungibles implementation\n\tTokens,\n\t// This means that this adapter should handle any token that `CurrencyIdConvert` can convert\n\t// to `CurrencyId`, the `CurrencyId` type of `Tokens`, the fungibles implementation it uses.\n\tConvertedConcreteId\u003cCurrencyId, Balance, CurrencyIdConvert, JustTry\u003e,\n\t// Convert an XCM MultiLocation into a local account id\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly)\n\tAccountId,\n\t// We dont allow teleports.\n\tNoChecking,\n\t// The account to use for tracking teleports.\n\tCheckingAccount,\n\u003e;\n\n/// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,\n/// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can\n/// biases the kind of local `Origin` it will become.\npub type XcmOriginToTransactDispatchOrigin = (\n\t// Sovereign account converter; this attempts to derive an `AccountId` from the origin location\n\t// using `LocationToAccountId` and then turn that into the usual `Signed` origin. Useful for\n\t// foreign chains who want to have a local sovereign account on this chain which they control.\n\tSovereignSignedViaLocation\u003cLocationToAccountId, RuntimeOrigin\u003e,\n\t// Native converter for Relay-chain (Parent) location; will converts to a `Relay` origin when\n\t// recognized.\n\tRelayChainAsNative\u003cRelayChainOrigin, RuntimeOrigin\u003e,\n\t// Native converter for sibling Parachains; will convert to a `SiblingPara` origin when\n\t// recognized.\n\tSiblingParachainAsNative\u003ccumulus_pallet_xcm::Origin, RuntimeOrigin\u003e,\n\t// Native signed account converter; this just converts an `AccountId32` origin into a normal\n\t// `Origin::Signed` origin of the same 32-byte value.\n\tSignedAccountId32AsNative\u003cRelayNetwork, RuntimeOrigin\u003e,\n\t// Xcm origins can be represented natively under the Xcm pallet's Xcm origin.\n\tXcmPassthrough\u003cRuntimeOrigin\u003e,\n);\n\nparameter_types! {\n\t// One XCM operation is 1_000_000_000 weight - almost certainly a conservative estimate.\n\tpub UnitWeightCost: XCMWeight = XCMWeight::from_parts(1_000_000_000,0);\n\tpub const MaxInstructions: u32 = 100;\n\tpub SelfLocation: MultiLocation = MultiLocation::new(1, X1(Parachain(ParachainInfo::parachain_id().into())));\n\tpub const BaseXcmWeight: XCMWeight = XCMWeight::from_parts(150_000_000,0);\n\tpub const MaxAssetsForTransfer: usize = 2;\n}\n\nmatch_types! {\n\tpub type ParentOrParentsExecutivePlurality: impl Contains\u003cMultiLocation\u003e = {\n\t\tMultiLocation { parents: 1, interior: Here } |\n\t\tMultiLocation { parents: 1, interior: X1(Plurality { id: BodyId::Executive, .. }) }\n\t};\n}\n\n//TODO: move DenyThenTry to polkadot's xcm module.\n/// Deny executing the xcm message if it matches any of the Deny filter regardless of anything else.\n/// If it passes the Deny, and matches one of the Allow cases then it is let through.\npub struct DenyThenTry\u003cDeny, Allow\u003e(PhantomData\u003cDeny\u003e, PhantomData\u003cAllow\u003e)\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute;\n\nimpl\u003cDeny, Allow\u003e ShouldExecute for DenyThenTry\u003cDeny, Allow\u003e\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute,\n{\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\tmax_weight: XCMWeight,\n\t\tweight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tDeny::should_execute(origin, instructions, max_weight, weight_credit)?;\n\t\tAllow::should_execute(origin, instructions, max_weight, weight_credit)\n\t}\n}\n\n// See issue #5233\npub struct DenyReserveTransferToRelayChain;\nimpl ShouldExecute for DenyReserveTransferToRelayChain {\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\t_max_weight: XCMWeight,\n\t\t_weight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tif instructions.iter().any(|inst| {\n\t\t\tmatches!(\n\t\t\t\tinst,\n\t\t\t\tInitiateReserveWithdraw {\n\t\t\t\t\treserve: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t..\n\t\t\t\t} | DepositReserveAsset { dest: MultiLocation { parents: 1, interior: Here }, .. } |\n\t\t\t\t\tTransferReserveAsset {\n\t\t\t\t\t\tdest: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t\t..\n\t\t\t\t\t}\n\t\t\t)\n\t\t}) {\n\t\t\treturn Err(()) // Deny\n\t\t}\n\n\t\t// allow reserve transfers to arrive from relay chain\n\t\tif matches!(origin, MultiLocation { parents: 1, interior: Here }) \u0026\u0026\n\t\t\tinstructions.iter().any(|inst| matches!(inst, ReserveAssetDeposited { .. }))\n\t\t{\n\t\t\tlog::warn!(\n\t\t\t\ttarget: \"xcm::barriers\",\n\t\t\t\t\"Unexpected ReserveAssetDeposited from the relay chain\",\n\t\t\t);\n\t\t}\n\t\t// Permit everything else\n\t\tOk(())\n\t}\n}\n\npub type Barrier = AllowUnpaidExecutionFrom\u003cEverything\u003e;\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n\ttype RuntimeCall = RuntimeCall;\n\ttype XcmSender = XcmRouter;\n\t// How to withdraw and deposit an asset.\n\ttype AssetTransactor = FungiblesTransactor;\n\ttype OriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype IsReserve = MultiNativeAsset\u003cRelativeReserveProvider\u003e;\n\t// Teleporting is disabled.\n\ttype IsTeleporter = ();\n\ttype UniversalLocation = UniversalLocation;\n\ttype Barrier = Barrier;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype Trader =\n\t\tUsingComponents\u003cWeightToFee, RelayLocation, AccountId, Balances, ToAuthor\u003cRuntime\u003e\u003e;\n\ttype ResponseHandler = PolkadotXcm;\n\ttype AssetTrap = PolkadotXcm;\n\ttype AssetLocker = ();\n\ttype AssetExchanger = ();\n\ttype AssetClaims = PolkadotXcm;\n\ttype SubscriptionService = PolkadotXcm;\n\ttype PalletInstancesInfo = crate::AllPalletsWithSystem;\n\ttype MaxAssetsIntoHolding = ConstU32\u003c8\u003e;\n\ttype FeeManager = ();\n\ttype MessageExporter = ();\n\ttype UniversalAliases = Nothing;\n\ttype CallDispatcher = RuntimeCall;\n\ttype SafeCallFilter = Everything;\n}\n\n/// No local origins on this chain are allowed to dispatch XCM sends/executions.\npub type LocalOriginToLocation = SignedToAccountId32\u003cRuntimeOrigin, AccountId, RelayNetwork\u003e;\n\n/// The means for routing XCM messages which are not for local execution into the right message\n/// queues.\npub type XcmRouter = (\n\t// Two routers - use UMP to communicate with the relay chain:\n\tcumulus_primitives_utility::ParentAsUmp\u003cParachainSystem, PolkadotXcm, ()\u003e,\n\t// ..and XCMP to communicate with the sibling chains.\n\tXcmpQueue,\n);\n\nimpl pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyMatcher = ();\n\ttype SendXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmRouter = XcmRouter;\n\ttype ExecuteXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmExecuteFilter = Everything;\n\t// ^ Disable dispatchable execute on the XCM pallet.\n\t// Needs to be `Everything` for local testing.\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype XcmTeleportFilter = Nothing;\n\ttype XcmReserveTransferFilter = Everything;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype UniversalLocation = UniversalLocation;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\n\tconst VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;\n\t// ^ Override for AdvertisedXcmVersion default\n\ttype AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;\n\ttype TrustedLockers = ();\n\ttype SovereignAccountOf = LocationToAccountId;\n\ttype MaxLockers = ConstU32\u003c8\u003e;\n\ttype WeightInfo = crate::weights::pallet_xcm::WeightInfo\u003cRuntime\u003e;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype ReachableDest = ReachableDest;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nparameter_types! {\n\tpub ReachableDest: Option\u003cMultiLocation\u003e = Some(Parent.into());\n}\n\nparameter_type_with_key! {\n\tpub ParachainMinFee: |_location: MultiLocation| -\u003e Option\u003cu128\u003e {\n\t\tNone\n\t};\n}\n\nimpl orml_xtokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype CurrencyId = CurrencyId;\n\ttype CurrencyIdConvert = CurrencyIdConvert;\n\ttype AccountIdToMultiLocation = AccountIdToMultiLocation;\n\ttype SelfLocation = SelfLocation;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype BaseXcmWeight = BaseXcmWeight;\n\ttype MaxAssetsForTransfer = MaxAssetsForTransfer;\n\ttype MinXcmFee = ParachainMinFee; //TODO to support hrmp transfer beetween parachain adjust this parameter\n\ttype MultiLocationsFilter = Everything;\n\ttype ReserveProvider = RelativeReserveProvider;\n\ttype UniversalLocation = UniversalLocation;\n}\n\npub struct AccountIdToMultiLocation;\nimpl Convert\u003cAccountId, MultiLocation\u003e for AccountIdToMultiLocation {\n\tfn convert(account: AccountId) -\u003e MultiLocation {\n\t\tMultiLocation {\n\t\t\tparents: 0,\n\t\t\tinterior: X1(AccountId32 { network: None, id: account.into() }),\n\t\t}\n\t}\n}\n\nimpl cumulus_pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n}\n","traces":[{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","zenlink.rs"],"content":"use core::convert::TryInto;\n\nuse super::*;\n\nuse orml_traits::MultiCurrency;\nuse sp_runtime::{DispatchError, DispatchResult};\nuse sp_std::marker::PhantomData;\n\nuse spacewalk_primitives::CurrencyId;\n\nuse zenlink_protocol::{\n\tAssetId, Config as ZenlinkConfig, GenerateLpAssetId, LocalAssetHandler, ZenlinkMultiAssets,\n};\npub type ZenlinkAssetId = zenlink_protocol::AssetId;\n\nuse runtime_common::{zenlink, zenlink::*};\n\npub struct ZenlinkLPGenerate\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: ZenlinkConfig\u003e GenerateLpAssetId\u003cZenlinkAssetId\u003e for ZenlinkLPGenerate\u003cT\u003e {\n\tfn generate_lp_asset_id(\n\t\tasset_0: ZenlinkAssetId,\n\t\tasset_1: ZenlinkAssetId,\n\t) -\u003e Option\u003cZenlinkAssetId\u003e {\n\t\tzenlink::generate_lp_asset_id(asset_0, asset_1, ParachainInfo::parachain_id().into())\n\t}\n}\n\nparameter_types! {\n\tpub SelfParaId: u32 = ParachainInfo::parachain_id().into();\n\tpub const ZenlinkPalletId: PalletId = PalletId(*b\"/zenlink\");\n\tpub ZenlinkRegisteredParaChains: Vec\u003c(MultiLocation, u128)\u003e = vec![];\n}\nimpl ZenlinkConfig for Runtime {\n\ttype RuntimeEvent = super::RuntimeEvent;\n\ttype MultiAssetsHandler = MultiAssets;\n\ttype PalletId = ZenlinkPalletId;\n\ttype AssetId = AssetId;\n\ttype LpGenerate = ZenlinkLPGenerate\u003cSelf\u003e;\n\ttype TargetChains = ZenlinkRegisteredParaChains;\n\ttype SelfParaId = SelfParaId;\n\ttype WeightInfo = ();\n}\n\ntype MultiAssets = ZenlinkMultiAssets\u003cZenlinkProtocol, Balances, LocalAssetAdaptor\u003cTokens\u003e\u003e;\n\npub struct LocalAssetAdaptor\u003cLocal\u003e(PhantomData\u003cLocal\u003e);\n\nimpl\u003cLocal, AccountId\u003e LocalAssetHandler\u003cAccountId\u003e for LocalAssetAdaptor\u003cLocal\u003e\nwhere\n\tLocal: MultiCurrency\u003cAccountId, CurrencyId = CurrencyId\u003e,\n{\n\tfn local_balance_of(asset_id: ZenlinkAssetId, who: \u0026AccountId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::free_balance(currency_id, \u0026who))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_total_supply(asset_id: ZenlinkAssetId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::total_issuance(currency_id))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_is_exists(asset_id: ZenlinkAssetId) -\u003e bool {\n\t\tmatch zenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into()) {\n\t\t\tOk(_) =\u003e true,\n\t\t\tErr(_) =\u003e false,\n\t\t}\n\t}\n\n\tfn local_transfer(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\ttarget: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e DispatchResult {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::transfer(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\t\u0026target,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local transfer\"))?,\n\t\t\t)\n\t\t} else {\n\t\t\tErr(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\t}\n\n\tfn local_deposit(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::deposit(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local deposit\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n\n\tfn local_withdraw(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::withdraw(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local withdraw\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":44},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","asset_registry.rs"],"content":"use crate::*;\nuse frame_support::traits::AsEnsureOriginWithArg;\nuse frame_system::EnsureRoot;\nuse orml_traits::asset_registry::{AssetMetadata, AssetProcessor};\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::DispatchError;\nuse spacewalk_primitives::CurrencyId;\n\npub use spacewalk_primitives::CustomMetadata;\n\n#[derive(\n\tClone, Copy, PartialOrd, Ord, PartialEq, Eq, Debug, Encode, Decode, TypeInfo, MaxEncodedLen,\n)]\npub struct CustomAssetProcessor;\n\nimpl AssetProcessor\u003cCurrencyId, AssetMetadata\u003cBalance, CustomMetadata\u003e\u003e for CustomAssetProcessor {\n\tfn pre_register(\n\t\tid: Option\u003cCurrencyId\u003e,\n\t\tmetadata: AssetMetadata\u003cBalance, CustomMetadata\u003e,\n\t) -\u003e Result\u003c(CurrencyId, AssetMetadata\u003cBalance, CustomMetadata\u003e), DispatchError\u003e {\n\t\tmatch id {\n\t\t\tSome(id) =\u003e Ok((id, metadata)),\n\t\t\tNone =\u003e Err(DispatchError::Other(\"asset-registry: AssetId is required\")),\n\t\t}\n\t}\n\n\tfn post_register(\n\t\t_id: CurrencyId,\n\t\t_asset_metadata: AssetMetadata\u003cBalance, CustomMetadata\u003e,\n\t) -\u003e Result\u003c(), DispatchError\u003e {\n\t\tOk(())\n\t}\n}\n\npub type AssetAuthority = AsEnsureOriginWithArg\u003cEnsureRoot\u003cAccountId\u003e\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","benchmarking","mod.rs"],"content":"pub mod orml_asset_registry;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","benchmarking","orml_asset_registry.rs"],"content":"use frame_benchmarking::v2::benchmarks;\nuse frame_support::assert_ok;\nuse frame_system::RawOrigin;\nuse orml_asset_registry::AssetMetadata;\nuse sp_std::{vec, vec::Vec};\nuse spacewalk_primitives::{CurrencyId, CustomMetadata};\nuse xcm::{\n\tlatest::MultiLocation,\n\topaque::lts::{Junction::*, Junctions::*},\n};\n\npub struct Pallet\u003cT: Config\u003e(orml_asset_registry::Pallet\u003cT\u003e);\npub trait Config:\n\torml_asset_registry::Config\u003cCustomMetadata = CustomMetadata, Balance = u128, AssetId = CurrencyId\u003e\n{\n}\n\n#[benchmarks]\npub mod benchmarks {\n\tuse super::{Config, Pallet, *};\n\tuse orml_asset_registry::Call;\n\n\tfn longest_vec() -\u003e Vec\u003cu8\u003e {\n\t\t// there is no fixed upperbound, but all actions are root-only so an assumed upperbound of 128 will do\n\t\tvec![b'a', 128]\n\t}\n\n\tfn longest_multilocation() -\u003e MultiLocation {\n\t\tlet key = GeneralKey { length: 32, data: [0; 32] };\n\t\tMultiLocation::new(1, X8(key, key, key, key, key, key, key, key))\n\t}\n\n\tfn get_asset_metadata() -\u003e AssetMetadata\u003cu128, CustomMetadata\u003e {\n\t\tAssetMetadata {\n\t\t\tdecimals: 12,\n\t\t\tname: longest_vec(),\n\t\t\tsymbol: longest_vec(),\n\t\t\texistential_deposit: 0,\n\t\t\tlocation: Some(longest_multilocation().into()),\n\t\t\tadditional: CustomMetadata,\n\t\t}\n\t}\n\n\t#[benchmark]\n\tfn register_asset() {\n\t\tlet metadata = get_asset_metadata();\n\n\t\t#[extrinsic_call]\n\t\tregister_asset(RawOrigin::Root, metadata, Some(CurrencyId::Native));\n\t}\n\n\t#[benchmark]\n\tfn update_asset() {\n\t\tlet metadata = get_asset_metadata();\n\n\t\tassert_ok!(orml_asset_registry::Pallet::\u003cT\u003e::register_asset(\n\t\t\tRawOrigin::Root.into(),\n\t\t\tmetadata,\n\t\t\tSome(CurrencyId::Native),\n\t\t));\n\n\t\t// update values, and make sure to change the actual values in case there is some optimization\n\t\t// somewhere in the codepath\n\t\tlet key = GeneralKey { length: 32, data: [1; 32] };\n\t\tlet location = MultiLocation::new(1, X8(key, key, key, key, key, key, key, key));\n\t\t#[extrinsic_call]\n\t\tupdate_asset(\n\t\t\tRawOrigin::Root,\n\t\t\tCurrencyId::Native,\n\t\t\tSome(123),\n\t\t\tSome(vec![b'b', 128]),\n\t\t\tSome(vec![b'b', 128]),\n\t\t\tSome(1234),\n\t\t\tSome(Some(location.into())),\n\t\t\tSome(CustomMetadata),\n\t\t);\n\t}\n\n\t#[benchmark]\n\tfn set_asset_location() {\n\t\t#[block]\n\t\t{\n\t\t\t// todo: remove this benchmark when this unused item is removed from the weight type upstream\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","chain_ext.rs"],"content":"use crate::*;\nuse dia_oracle::dia;\nuse scale_info::prelude::vec::Vec;\nuse sp_core::{Decode, Encode, MaxEncodedLen};\nuse sp_runtime::{codec, ArithmeticError, TokenError};\n\npub use spacewalk_primitives::{Asset, CurrencyId};\n\n/// Address is a type alias for easier readability of address (accountId) communicated between contract and chain extension.\npub type Address = [u8; 32];\n/// Amount is a type alias for easier readability of amount communicated between contract and chain extension.\npub type Amount = u128;\n/// Blockchain is a type alias for easier readability of dia blockchain name communicated between contract and chain extension.\npub type Blockchain = [u8; 32];\n/// Symbol is a type alias for easier readability of dia blockchain symbol communicated between contract and chain extension.\npub type Symbol = [u8; 32];\n\n/// ChainExtensionError is almost the same as DispatchError, but with some modifications to make it compatible with being communicated between contract and chain extension. It implements the necessary From\u003cT\u003e conversions with DispatchError and other nested errors.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Encode, Decode, MaxEncodedLen)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum ChainExtensionError {\n\t/// Some error occurred.\n\tOther,\n\t/// Failed to lookup some data.\n\tCannotLookup,\n\t/// A bad origin.\n\tBadOrigin,\n\t/// A custom error in a module.\n\tModule,\n\t/// At least one consumer is remaining so the account cannot be destroyed.\n\tConsumerRemaining,\n\t/// There are no providers so the account cannot be created.\n\tNoProviders,\n\t/// There are too many consumers so the account cannot be created.\n\tTooManyConsumers,\n\t/// An error to do with tokens.\n\tToken(ChainExtensionTokenError),\n\t/// An arithmetic error.\n\tArithmetic(ChainExtensionArithmeticError),\n\t/// Unknown error\n\tUnknown,\n}\n\n/// ChainExtensionTokenError is a nested error in ChainExtensionError, similar to DispatchError's TokenError.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Encode, Decode, MaxEncodedLen)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum ChainExtensionTokenError {\n\t/// Funds are unavailable.\n\tNoFunds,\n\t/// Account that must exist would die.\n\tWouldDie,\n\t/// Account cannot exist with the funds that would be given.\n\tBelowMinimum,\n\t/// Account cannot be created.\n\tCannotCreate,\n\t/// The asset in question is unknown.\n\tUnknownAsset,\n\t/// Funds exist but are frozen.\n\tFrozen,\n\t/// Operation is not supported by the asset.\n\tUnsupported,\n\t/// Unknown error\n\tUnknown,\n}\n\n/// ChainExtensionArithmeticError is a nested error in ChainExtensionError, similar to DispatchError's ArithmeticError.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Encode, Decode, MaxEncodedLen)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum ChainExtensionArithmeticError {\n\t/// Underflow.\n\tUnderflow,\n\t/// Overflow.\n\tOverflow,\n\t/// Division by zero.\n\tDivisionByZero,\n\t/// Unknown error\n\tUnknown,\n}\n\nimpl From\u003cDispatchError\u003e for ChainExtensionError {\n\tfn from(e: DispatchError) -\u003e Self {\n\t\tmatch e {\n\t\t\tDispatchError::Other(_) =\u003e ChainExtensionError::Other,\n\t\t\tDispatchError::CannotLookup =\u003e ChainExtensionError::CannotLookup,\n\t\t\tDispatchError::BadOrigin =\u003e ChainExtensionError::BadOrigin,\n\t\t\tDispatchError::Module(_) =\u003e ChainExtensionError::Module,\n\t\t\tDispatchError::ConsumerRemaining =\u003e ChainExtensionError::ConsumerRemaining,\n\t\t\tDispatchError::NoProviders =\u003e ChainExtensionError::NoProviders,\n\t\t\tDispatchError::TooManyConsumers =\u003e ChainExtensionError::TooManyConsumers,\n\t\t\tDispatchError::Token(token_err) =\u003e\n\t\t\t\tChainExtensionError::Token(ChainExtensionTokenError::from(token_err)),\n\t\t\tDispatchError::Arithmetic(arithmetic_error) =\u003e ChainExtensionError::Arithmetic(\n\t\t\t\tChainExtensionArithmeticError::from(arithmetic_error),\n\t\t\t),\n\t\t\t_ =\u003e ChainExtensionError::Unknown,\n\t\t}\n\t}\n}\n\nimpl From\u003cTokenError\u003e for ChainExtensionTokenError {\n\tfn from(e: TokenError) -\u003e Self {\n\t\tmatch e {\n\t\t\tTokenError::NoFunds =\u003e ChainExtensionTokenError::NoFunds,\n\t\t\tTokenError::WouldDie =\u003e ChainExtensionTokenError::WouldDie,\n\t\t\tTokenError::BelowMinimum =\u003e ChainExtensionTokenError::BelowMinimum,\n\t\t\tTokenError::CannotCreate =\u003e ChainExtensionTokenError::CannotCreate,\n\t\t\tTokenError::UnknownAsset =\u003e ChainExtensionTokenError::UnknownAsset,\n\t\t\tTokenError::Frozen =\u003e ChainExtensionTokenError::Frozen,\n\t\t\tTokenError::Unsupported =\u003e ChainExtensionTokenError::Unsupported,\n\t\t}\n\t}\n}\n\nimpl From\u003cArithmeticError\u003e for ChainExtensionArithmeticError {\n\tfn from(e: ArithmeticError) -\u003e Self {\n\t\tmatch e {\n\t\t\tArithmeticError::Underflow =\u003e ChainExtensionArithmeticError::Underflow,\n\t\t\tArithmeticError::Overflow =\u003e ChainExtensionArithmeticError::Overflow,\n\t\t\tArithmeticError::DivisionByZero =\u003e ChainExtensionArithmeticError::DivisionByZero,\n\t\t}\n\t}\n}\n\n/// ToTrimmedVec is a trait implemented for [u8; 32] to allow both types Blockchain and Symbol (which are [u8; 32]) to have the trim_trailing_zeros function.\npub trait ToTrimmedVec {\n\tfn to_trimmed_vec(\u0026self) -\u003e Vec\u003cu8\u003e;\n}\nimpl ToTrimmedVec for [u8; 32] {\n\tfn to_trimmed_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n\t\ttrim_trailing_zeros(self).to_vec()\n\t}\n}\n\n/// trim_trailing_zeros takes an input slice and returns it without the trailing zeros.\nfn trim_trailing_zeros(slice: \u0026[u8]) -\u003e \u0026[u8] {\n\tlet mut trim_amount = 0;\n\tfor el in slice.iter().rev() {\n\t\tif *el == 0 {\n\t\t\ttrim_amount += 1;\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\t\u0026slice[..slice.len() - trim_amount]\n}\n\n/// CoinInfo is almost the same as Dia's CoinInfo, but with Encode, Decode, and TypeInfo which are necessary for contract to chain extension communication. Implements From\u003cdia::CoinInfo\u003e to make conversion.\n#[derive(Debug, Clone, PartialEq, Eq, codec::Encode, codec::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct CoinInfo {\n\tpub symbol: Vec\u003cu8\u003e,\n\tpub name: Vec\u003cu8\u003e,\n\tpub blockchain: Vec\u003cu8\u003e,\n\tpub supply: u128,\n\tpub last_update_timestamp: u64,\n\tpub price: u128,\n}\nimpl From\u003cdia::CoinInfo\u003e for CoinInfo {\n\tfn from(coin_info: dia::CoinInfo) -\u003e Self {\n\t\tSelf {\n\t\t\tsymbol: coin_info.symbol,\n\t\t\tname: coin_info.name,\n\t\t\tblockchain: coin_info.blockchain,\n\t\t\tsupply: coin_info.supply,\n\t\t\tlast_update_timestamp: coin_info.last_update_timestamp,\n\t\t\tprice: coin_info.price,\n\t\t}\n\t}\n}\n\n\n/// decode gets the slice from a Vec\u003cu8\u003e to decode it into its scale encoded type.\npub fn decode\u003cT: Decode\u003e(input: Vec\u003cu8\u003e) -\u003e Result\u003cT, codec::Error\u003e {\n\tlet mut input = input.as_slice();\n\tT::decode(\u0026mut input)\n}\n","traces":[{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse sp_runtime::{\n\ttraits::{IdentifyAccount, Verify},\n\tDispatchError, MultiSignature,\n};\n\npub mod asset_registry;\npub mod chain_ext;\npub mod stellar;\npub mod zenlink;\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub mod benchmarking;\n\n/// Alias to 512-bit hash when used in the context of a transaction signature on the chain.\npub type Signature = MultiSignature;\n\n/// Some way of identifying an account on the chain. We intentionally make it equivalent\n/// to the public key of our transaction signing scheme.\npub type AccountId = \u003c\u003cSignature as Verify\u003e::Signer as IdentifyAccount\u003e::AccountId;\n\n/// Type for IDs of farming pools\npub type PoolId = u32;\n\npub use sp_consensus_aura::sr25519::AuthorityId as AuraId;\n\n/// Balance of an account.\npub type Balance = u128;\npub type Amount = i128;\n\npub type ReserveIdentifier = [u8; 8];\n\n// Unit = the base number of indivisible units for balances\npub const UNIT: Balance = 1_000_000_000_000;\npub const MILLIUNIT: Balance = 1_000_000_000;\npub const MICROUNIT: Balance = 1_000_000;\npub const NANOUNIT: Balance = 1_000;\n\n/// The existential deposit. Set to 1/10 of the Connected Relay Chain.\npub const EXISTENTIAL_DEPOSIT: Balance = MILLIUNIT;\n\n/// An index to a block.\npub type BlockNumber = u32;\n\n/// Index of a transaction in the chain.\npub type Index = u32;\n\n/// A hash of some data used by the chain.\npub type Hash = sp_core::H256;\n\n/// Opaque types. These are used by the CLI to instantiate machinery that don't need to know\n/// the specifics of the runtime. They can then be made to be agnostic over specific formats\n/// of data like extrinsics, allowing for them to continue syncing the network through upgrades\n/// to even the core data structures.\npub mod opaque {\n\tuse super::*;\n\tuse sp_runtime::{generic, traits::BlakeTwo256};\n\n\tpub use sp_runtime::OpaqueExtrinsic as UncheckedExtrinsic;\n\t/// Opaque block header type.\n\tpub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// Opaque block type.\n\tpub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\t/// Opaque block identifier type.\n\tpub type BlockId = generic::BlockId\u003cBlock\u003e;\n}\n\npub mod parachains {\n\tpub mod polkadot {\n\t\tpub mod asset_hub {\n\t\t\tpub const PARA_ID: u32 = 1000;\n\t\t\tpub const ASSET_PALLET_ID: u8 = 50;\n\n\t\t\tpub const USDC_ASSET_ID: u128 = 1337;\n\t\t\tpub const USDT_ASSET_ID: u128 = 1984;\n\t\t}\n\t}\n\n\tpub mod kusama {\n\t\tpub mod asset_hub {\n\t\t\tpub const PARA_ID: u32 = 1000;\n\t\t\tpub const ASSET_PALLET_ID: u8 = 50;\n\n\t\t\tpub const USDC_ASSET_ID: u128 = 1337;\n\t\t\tpub const USDT_ASSET_ID: u128 = 1984;\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","stellar.rs"],"content":"// GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN\npub const USDC_ISSUER: [u8; 32] = [\n\t59, 153, 17, 56, 14, 254, 152, 139, 160, 168, 144, 14, 177, 207, 228, 79, 54, 111, 125, 190,\n\t148, 107, 237, 7, 114, 64, 247, 246, 36, 223, 21, 197,\n];\n\n// GDVKY2GU2DRXWTBEYJJWSFXIGBZV6AZNBVVSUHEPZI54LIS6BA7DVVSP\npub const BRL_ISSUER: [u8; 32] = [\n\t234, 172, 104, 212, 208, 227, 123, 76, 36, 194, 83, 105, 22, 232, 48, 115, 95, 3, 45, 13, 107,\n\t42, 28, 143, 202, 59, 197, 162, 94, 8, 62, 58,\n];\n\n// GA2MSSZKJOU6RNL3EJKH3S5TB5CDYTFQFWRYFGUJVIN5I6AOIRTLUHTO \npub const TZS_ISSUER: [u8; 32] = [\n\t52, 201, 75, 42, 75, 169, 232, 181, 123, 34, 84, 125, 203, 179, 15, 68, 60, 76, 176, 45, 163,\n\t130, 154, 137, 170, 27, 212, 120, 14, 68, 102, 186,\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","zenlink.rs"],"content":"use crate::stellar::{BRL_ISSUER, TZS_ISSUER, USDC_ISSUER};\nuse spacewalk_primitives::{Asset, CurrencyId};\n\nuse zenlink_protocol::{LOCAL, NATIVE};\npub type ZenlinkAssetId = zenlink_protocol::AssetId;\n\nfn discriminant(currency: \u0026CurrencyId) -\u003e u8 {\n\tmatch currency {\n\t\tCurrencyId::Native =\u003e 0,\n\t\tCurrencyId::XCM(_) =\u003e 1,\n\t\tCurrencyId::Stellar(_) =\u003e 2,\n\t\tCurrencyId::ZenlinkLPToken(_, _, _, _) =\u003e 3,\n\t}\n}\n\npub fn generate_lp_asset_id(\n\tasset_0: ZenlinkAssetId,\n\tasset_1: ZenlinkAssetId,\n\tparachain_id: u32,\n) -\u003e Option\u003cZenlinkAssetId\u003e {\n\tlet currency_0 = (asset_0.asset_index \u0026 0x0000_0000_0000_ffff) \u003c\u003c 16;\n\tlet currency_1 = (asset_1.asset_index \u0026 0x0000_0000_0000_ffff) \u003c\u003c 32;\n\tlet discr = 3u64 \u003c\u003c 8;\n\tlet index = currency_0 + currency_1 + discr;\n\tSome(ZenlinkAssetId { chain_id: parachain_id, asset_type: LOCAL, asset_index: index })\n}\n\npub fn zenlink_id_to_currency_id(\n\tasset_id: ZenlinkAssetId,\n\tparachain_id: u32,\n) -\u003e Result\u003cCurrencyId, ()\u003e {\n\tif asset_id.chain_id != parachain_id {\n\t\treturn Err(())\n\t}\n\n\tlet index = asset_id.asset_index;\n\tlet asset_type = asset_id.asset_type;\n\tlet disc = ((index \u0026 0x0000_0000_0000_ff00) \u003e\u003e 8) as u8;\n\tlet symbol = (index \u0026 0x0000_0000_0000_00ff) as u8;\n\tmatch (disc, asset_type) {\n\t\t(0, NATIVE) =\u003e Ok(CurrencyId::Native),\n\t\t(1, LOCAL) =\u003e Ok(CurrencyId::XCM(symbol)),\n\t\t(2, LOCAL) =\u003e match symbol {\n\t\t\t0 =\u003e Ok(CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t1 =\u003e Ok(CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"USDC\", issuer: USDC_ISSUER })),\n\t\t\t2 =\u003e Ok(CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"TZS\\0\", issuer: TZS_ISSUER })),\n\t\t\t3 =\u003e Ok(CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"BRL\\0\", issuer: BRL_ISSUER })),\n\t\t\t_ =\u003e return Err(()),\n\t\t},\n\t\t(3, LOCAL) =\u003e {\n\t\t\tlet token1_id = ((index \u0026 0x0000_0000_00FF_0000) \u003e\u003e 16) as u8;\n\t\t\tlet token1_type = ((index \u0026 0x0000_0000_FF00_0000) \u003e\u003e 24) as u8;\n\n\t\t\tlet token2_id = ((index \u0026 0x0000_00FF_0000_0000) \u003e\u003e 32) as u8;\n\t\t\tlet token2_type = ((index \u0026 0x0000_FF00_0000_0000) \u003e\u003e 40) as u8;\n\n\t\t\tOk(CurrencyId::ZenlinkLPToken(token1_id, token1_type, token2_id, token2_type))\n\t\t},\n\t\t_ =\u003e Err(()),\n\t}\n}\n\npub fn currency_id_to_zenlink_id(\n\tcurrency_id: CurrencyId,\n\tparachain_id: u32,\n) -\u003e Result\u003cZenlinkAssetId, ()\u003e {\n\tlet disc = discriminant(\u0026currency_id) as u64;\n\tmatch currency_id {\n\t\tCurrencyId::Native =\u003e\n\t\t\tOk(ZenlinkAssetId { chain_id: parachain_id, asset_type: NATIVE, asset_index: 0 as u64 }),\n\t\tCurrencyId::XCM(token_id) =\u003e Ok(ZenlinkAssetId {\n\t\t\tchain_id: parachain_id,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: ((disc \u003c\u003c 8) + token_id as u64) as u64,\n\t\t}),\n\t\tCurrencyId::Stellar(asset) =\u003e {\n\t\t\tlet _id = match asset {\n\t\t\t\tAsset::StellarNative =\u003e 0u64,\n\t\t\t\tAsset::AlphaNum4 { code, issuer } =\u003e match (\u0026code, \u0026issuer) {\n\t\t\t\t\t(b\"USDC\", \u0026USDC_ISSUER) =\u003e 1u64,\n\t\t\t\t\t(b\"TZS\\0\", \u0026TZS_ISSUER) =\u003e 2u64,\n\t\t\t\t\t(b\"BRL\\0\", \u0026BRL_ISSUER) =\u003e 3u64,\n\t\t\t\t\t_ =\u003e return Err(()),\n\t\t\t\t},\n\t\t\t\t_ =\u003e return Err(()),\n\t\t\t};\n\t\t\tOk(ZenlinkAssetId {\n\t\t\t\tchain_id: parachain_id,\n\t\t\t\tasset_type: LOCAL,\n\t\t\t\tasset_index: ((disc \u003c\u003c 8) + _id) as u64,\n\t\t\t})\n\t\t},\n\t\tCurrencyId::ZenlinkLPToken(token1_id, token1_type, token2_id, token2_type) =\u003e {\n\t\t\tlet index = ((disc as u64) \u003c\u003c 8) +\n\t\t\t\t((token1_id as u64) \u003c\u003c 16) +\n\t\t\t\t((token1_type as u64) \u003c\u003c 24) +\n\t\t\t\t((token2_id as u64) \u003c\u003c 32) +\n\t\t\t\t((token2_type as u64) \u003c\u003c 40);\n\t\t\tOk(ZenlinkAssetId { chain_id: parachain_id, asset_type: LOCAL, asset_index: index })\n\t\t},\n\t}\n}\n\n#[cfg(test)]\nmod zenlink_tests {\n\tuse super::*;\n\n\t#[test]\n\tfn convert_zenlink_native_to_native_currency() {\n\t\t// Native ZenlinkAsset index = 0x0000_0000_0000_0000\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: NATIVE, asset_index: 0 as u64 };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(CurrencyId::Native));\n\t}\n\n\t#[test]\n\tfn convert_zenlink_xcm_to_xcm_currency() {\n\t\t// XCM(0) ZenlinkAsset index = 0x0000_0000_0000_0100\n\t\tlet index = 0x0100 as u64;\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: index };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(CurrencyId::XCM(0)));\n\t}\n\n\tfn get_stellar_asset(selector: u8) -\u003e spacewalk_primitives::CurrencyId {\n\t\tmatch selector {\n\t\t\t0 =\u003e CurrencyId::Stellar(Asset::StellarNative),\n\t\t\t1 =\u003e CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"USDC\", issuer: USDC_ISSUER }),\n\t\t\t2 =\u003e CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"TZS\\0\", issuer: TZS_ISSUER }),\n\t\t\t3 =\u003e CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"BRL\\0\", issuer: BRL_ISSUER }),\n\t\t\t_ =\u003e CurrencyId::Stellar(Asset::StellarNative),\n\t\t}\n\t}\n\n\t#[test]\n\tfn convert_zenlink_stellar_to_stellar_currency() {\n\t\t// Stellar Native ZenlinkAsset index = 0x0000_0000_0000_0200\n\t\tlet stellar_native_index = 0x0200 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: stellar_native_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(get_stellar_asset(0u8)));\n\n\t\t// Stellar USDC ZenlinkAsset index = 0x0000_0000_0000_0201\n\t\tlet usdc_index = 0x0201 as u64;\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: usdc_index };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(get_stellar_asset(1u8)));\n\n\t\t// Stellar TZS ZenlinkAsset index = 0x0000_0000_0000_0202\n\t\tlet tzs_index = 0x0202 as u64;\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: tzs_index };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(get_stellar_asset(2u8)));\n\n\t\t// Stellar BRL ZenlinkAsset index = 0x0000_0000_0000_0203\n\t\tlet brl_index = 0x0203 as u64;\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: brl_index };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(get_stellar_asset(3u8)));\n\t}\n\n\t#[test]\n\tfn convert_zenlink_lp_token_to_lp_token_currency() {\n\t\t// Native and XCM(0) LP token Zenlink index = 0x0000_0100_0000_0300\n\t\tlet native_xcm_lp_token_index = 0x0000_0100_0000_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: native_xcm_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 0, 0, 1);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\n\t\t// XCM(0) and XCM(1) LP token Zenlink index = 0x0000_0101_0100_0300\n\t\tlet xcm0_xcm1_lp_token_index = 0x0000_0101_0100_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: xcm0_xcm1_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 1, 1, 1);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\n\t\t// XCM(0) and Stellar Native LP Token Zenlink index = 0x0000_0200_0100_0300\n\t\tlet xcm0_stellar_native_lp_token_index = 0x0000_0200_0100_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: xcm0_stellar_native_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 1, 0, 2);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\n\t\t// XCM(0) and Stellar USDC LP Token Zenlink index = 0x0000_0201_0100_0300\n\t\tlet xcm0_stellar_usdc_lp_token_index = 0x0000_0201_0100_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: xcm0_stellar_usdc_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 1, 1, 2);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\n\t\t// Stellar Native and Stellar USDC LP Token Zenlink index = 0x0000_0201_0200_0300\n\t\tlet stellar_native_stellar_usdc_lp_token_index = 0x0000_0201_0200_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: stellar_native_stellar_usdc_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 2, 1, 2);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\t}\n\n\t#[test]\n\tfn convert_fake_zenlink_native_to_currency_id_error() {\n\t\t// Native ZenlinkAsset index = 0x0000_0000_0000_0000\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: 0 as u64 };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Err(()));\n\t}\n\n\t#[test]\n\tfn convert_zenlink_id_to_currency_id_error() {\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: 0u64 };\n\t\t// We pass a parachain_id different than the asset chain_id\n\t\tassert_eq!(zenlink_id_to_currency_id(fake_zenlink_asset, 1001u32), Err(()));\n\t}\n\n\t#[test]\n\tfn convert_native_currency_to_zenlink_native() {\n\t\tlet fake_currency_id = CurrencyId::Native;\n\t\tlet expected_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: NATIVE, asset_index: 0u64 };\n\t\tassert_eq!(currency_id_to_zenlink_id(fake_currency_id, 1000), Ok(expected_zenlink_asset));\n\t}\n\n\t#[test]\n\tfn convert_xcm_currency_to_zenlink_xcm() {\n\t\tlet fake_currency_id = CurrencyId::XCM(0);\n\t\tlet expected_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: 0x0100 as u64 };\n\t\tassert_eq!(currency_id_to_zenlink_id(fake_currency_id, 1000), Ok(expected_zenlink_asset));\n\t}\n\n\t#[test]\n\tfn convert_stellar_currency_to_stellar_zenlink() {\n\t\tlet stellar_assets_indexes: [u64; 4] = [0x0200u64, 0x0201u64, 0x0202u64, 0x0203u64];\n\n\t\tfor i in 0..=3usize {\n\t\t\tlet fake_currency_id = get_stellar_asset(i as u8);\n\t\t\tlet expected_zenlink_asset = ZenlinkAssetId {\n\t\t\t\tchain_id: 1000u32,\n\t\t\t\tasset_type: LOCAL,\n\t\t\t\tasset_index: stellar_assets_indexes[i],\n\t\t\t};\n\t\t\tassert_eq!(\n\t\t\t\tcurrency_id_to_zenlink_id(fake_currency_id, 1000),\n\t\t\t\tOk(expected_zenlink_asset)\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","build.rs"],"content":"use substrate_wasm_builder::WasmBuilder;\n\nfn main() {\n\tWasmBuilder::new()\n\t\t.with_current_project()\n\t\t.export_heap_base()\n\t\t.import_memory()\n\t\t.build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nmod weights;\npub mod xcm_config;\n\nuse smallvec::smallvec;\nuse sp_api::impl_runtime_apis;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{AccountIdLookup, BlakeTwo256, Block as BlockT},\n\ttransaction_validity::{TransactionSource, TransactionValidity},\n\tApplyExtrinsicResult,\n};\n\nuse sp_std::prelude::*;\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\nuse frame_support::{\n\tconstruct_runtime,\n\tdispatch::DispatchClass,\n\tparameter_types,\n\ttraits::Everything,\n\tweights::{\n\t\tconstants::WEIGHT_REF_TIME_PER_SECOND, ConstantMultiplier, Weight, WeightToFeeCoefficient,\n\t\tWeightToFeeCoefficients, WeightToFeePolynomial,\n\t},\n\tPalletId,\n};\nuse frame_system::{\n\tlimits::{BlockLength, BlockWeights},\n\tEnsureRoot,\n};\npub use sp_runtime::{MultiAddress, Perbill, Permill};\n\nuse runtime_common::{\n\topaque, AccountId, AuraId, Balance, BlockNumber, Hash, Index, Signature, EXISTENTIAL_DEPOSIT,\n\tMICROUNIT, MILLIUNIT,\n};\n\nuse cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;\n\nuse xcm_config::{XcmConfig, XcmOriginToTransactDispatchOrigin};\n\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\n\n// Polkadot imports\nuse polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};\n\nuse weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};\n\n// XCM Imports\nuse xcm::latest::prelude::BodyId;\nuse xcm_executor::XcmExecutor;\n\n/// The address format for describing accounts.\npub type Address = MultiAddress\u003cAccountId, ()\u003e;\n\n/// Block header type as expected by this runtime.\npub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\n/// Block type as expected by this runtime.\npub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock\u003cBlock\u003e;\n\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId\u003cBlock\u003e;\n\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender\u003cRuntime\u003e,\n\tframe_system::CheckSpecVersion\u003cRuntime\u003e,\n\tframe_system::CheckTxVersion\u003cRuntime\u003e,\n\tframe_system::CheckGenesis\u003cRuntime\u003e,\n\tframe_system::CheckEra\u003cRuntime\u003e,\n\tframe_system::CheckNonce\u003cRuntime\u003e,\n\tframe_system::CheckWeight\u003cRuntime\u003e,\n\tpallet_transaction_payment::ChargeTransactionPayment\u003cRuntime\u003e,\n);\n\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tgeneric::UncheckedExtrinsic\u003cAddress, RuntimeCall, Signature, SignedExtra\u003e;\n\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic\u003cAccountId, RuntimeCall, SignedExtra\u003e;\n\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive\u003c\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext\u003cRuntime\u003e,\n\tRuntime,\n\tAllPalletsWithSystem,\n\u003e;\n\n/// Handles converting a weight scalar to a fee value, based on the scale and granularity of the\n/// node's balance type.\n///\n/// This should typically create a mapping between the following ranges:\n///   - `[0, MAXIMUM_BLOCK_WEIGHT]`\n///   - `[Balance::min, Balance::max]`\n///\n/// Yet, it can be used for any other sort of change to weight-fee. Some examples being:\n///   - Setting it to `0` will essentially disable the weight fee.\n///   - Setting it to `1` will cause the literal `#[weight = x]` values to be charged.\npub struct WeightToFee;\nimpl WeightToFeePolynomial for WeightToFee {\n\ttype Balance = Balance;\n\tfn polynomial() -\u003e WeightToFeeCoefficients\u003cSelf::Balance\u003e {\n\t\tlet p = MILLIUNIT / 10;\n\t\tlet q = 100 * Balance::from(ExtrinsicBaseWeight::get().ref_time());\n\t\tsmallvec![WeightToFeeCoefficient {\n\t\t\tdegree: 1,\n\t\t\tnegative: false,\n\t\t\tcoeff_frac: Perbill::from_rational(p % q, q),\n\t\t\tcoeff_integer: p / q,\n\t\t}]\n\t}\n}\n\nimpl_opaque_keys! {\n\tpub struct SessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\n#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"pendulum-development\"),\n\timpl_name: create_runtime_str!(\"pendulum-development\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 0,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n\tstate_version: 1,\n};\n\n/// This determines the average expected block time that we are targeting.\n/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.\n/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked\n/// up by `pallet_aura` to implement `fn slot_duration()`.\n///\n/// Change this to adjust the block time.\npub const MILLISECS_PER_BLOCK: u64 = 12000;\n\n// NOTE: Currently it is not possible to change the slot duration after the chain has started.\n//       Attempting to do so will brick block production.\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\n\n/// We assume that ~5% of the block weight is consumed by `on_initialize` handlers. This is\n/// used to limit the maximal weight of a single extrinsic.\nconst AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(5);\n\n/// We allow `Normal` extrinsics to fill up the block up to 75%, the rest can be used by\n/// `Operational` extrinsics.\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\n/// We allow for 0.5 of a second of compute with a 12 second average block time.\nconst MAXIMUM_BLOCK_WEIGHT: Weight =\n\tWeight::from_parts(WEIGHT_REF_TIME_PER_SECOND.saturating_div(2), 0)\n\t\t.set_proof_size(cumulus_primitives_core::relay_chain::MAX_POV_SIZE as u64);\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -\u003e NativeVersion {\n\tNativeVersion { runtime_version: VERSION, can_author_with: Default::default() }\n}\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\n\t// This part is copied from Substrate's `bin/node/runtime/src/lib.rs`.\n\t//  The `RuntimeBlockLength` and `RuntimeBlockWeights` exist here because the\n\t// `DeletionWeightLimit` and `DeletionQueueDepth` depend on those to parameterize\n\t// the lazy contract deletion.\n\tpub RuntimeBlockLength: BlockLength =\n\t\tBlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub RuntimeBlockWeights: BlockWeights = BlockWeights::builder()\n\t\t.base_block(BlockExecutionWeight::get())\n\t\t.for_class(DispatchClass::all(), |weights| {\n\t\t\tweights.base_extrinsic = ExtrinsicBaseWeight::get();\n\t\t})\n\t\t.for_class(DispatchClass::Normal, |weights| {\n\t\t\tweights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);\n\t\t})\n\t\t.for_class(DispatchClass::Operational, |weights| {\n\t\t\tweights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);\n\t\t\t// Operational transactions have some extra reserved space, so that they\n\t\t\t// are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.\n\t\t\tweights.reserved = Some(\n\t\t\t\tMAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT\n\t\t\t);\n\t\t})\n\t\t.avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)\n\t\t.build_or_panic();\n\tpub const SS58Prefix: u16 = 42;\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype RuntimeCall = RuntimeCall;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup\u003cAccountId, ()\u003e;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\t/// The ubiquitous origin type.\n\ttype RuntimeOrigin = RuntimeOrigin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// Runtime version.\n\ttype Version = Version;\n\t/// Converts a module to an index of this module in the runtime.\n\ttype PalletInfo = PalletInfo;\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = Everything;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// Block \u0026 extrinsics weights: base values and limits.\n\ttype BlockWeights = RuntimeBlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = RuntimeBlockLength;\n\t/// This is used as an identifier of the chain. 42 is the generic substrate prefix.\n\ttype SS58Prefix = SS58Prefix;\n\t/// The action to take on a Runtime Upgrade\n\ttype OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode\u003cSelf\u003e;\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const UncleGenerations: u32 = 0;\n}\n\nimpl pallet_authorship::Config for Runtime {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = (CollatorSelection,);\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = EXISTENTIAL_DEPOSIT;\n\tpub const MaxLocks: u32 = 50;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = [u8; 8];\n}\n\nparameter_types! {\n\t/// Relay Chain `TransactionByteFee` / 10\n\tpub const TransactionByteFee: Balance = 10 * MICROUNIT;\n\tpub const OperationalFeeMultiplier: u8 = 5;\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter\u003cBalances, ()\u003e;\n\ttype WeightToFee = WeightToFee;\n\ttype LengthToFee = ConstantMultiplier\u003cBalance, TransactionByteFee\u003e;\n\ttype FeeMultiplierUpdate = SlowAdjustingFeeUpdate\u003cSelf\u003e;\n\ttype OperationalFeeMultiplier = OperationalFeeMultiplier;\n}\n\nparameter_types! {\n\tpub const ReservedXcmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n\tpub const ReservedDmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n}\n\nimpl cumulus_pallet_parachain_system::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSystemEvent = ();\n\ttype SelfParaId = parachain_info::Pallet\u003cRuntime\u003e;\n\ttype DmpMessageHandler = DmpQueue;\n\ttype ReservedDmpWeight = ReservedDmpWeight;\n\ttype OutboundXcmpMessageSource = XcmpQueue;\n\ttype XcmpMessageHandler = XcmpQueue;\n\ttype ReservedXcmpWeight = ReservedXcmpWeight;\n\ttype CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;\n}\n\nimpl parachain_info::Config for Runtime {}\n\nimpl cumulus_pallet_aura_ext::Config for Runtime {}\n\nimpl cumulus_pallet_xcmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ChannelInfo = ParachainSystem;\n\ttype VersionWrapper = ();\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype PriceForSiblingDelivery = ();\n\ttype WeightInfo = ();\n}\n\nimpl cumulus_pallet_dmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const Period: u32 = 6 * HOURS;\n\tpub const Offset: u32 = 0;\n\tpub const MaxAuthorities: u32 = 100_000;\n}\n\nimpl pallet_session::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\t// we don't have stash and controller, thus we don't need the convert as well.\n\ttype ValidatorIdOf = pallet_collator_selection::IdentityCollator;\n\ttype ShouldEndSession = pallet_session::PeriodicSessions\u003cPeriod, Offset\u003e;\n\ttype NextSessionRotation = pallet_session::PeriodicSessions\u003cPeriod, Offset\u003e;\n\ttype SessionManager = CollatorSelection;\n\t// Essentially just Aura, but lets be pedantic.\n\ttype SessionHandler = \u003cSessionKeys as sp_runtime::traits::OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = SessionKeys;\n\ttype WeightInfo = ();\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nparameter_types! {\n\tpub const PotId: PalletId = PalletId(*b\"PotStake\");\n\tpub const MaxCandidates: u32 = 1000;\n\tpub const MinCandidates: u32 = 5;\n\tpub const SessionLength: BlockNumber = 6 * HOURS;\n\tpub const MaxInvulnerables: u32 = 100;\n\tpub const ExecutiveBody: BodyId = BodyId::Executive;\n}\n\n// We allow root only to execute privileged collator selection operations.\npub type CollatorSelectionUpdateOrigin = EnsureRoot\u003cAccountId\u003e;\n\nimpl pallet_collator_selection::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype UpdateOrigin = CollatorSelectionUpdateOrigin;\n\ttype PotId = PotId;\n\ttype MaxCandidates = MaxCandidates;\n\ttype MinCandidates = MinCandidates;\n\ttype MaxInvulnerables = MaxInvulnerables;\n\t// should be a multiple of session or things will get inconsistent\n\ttype KickThreshold = Period;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\ttype ValidatorIdOf = pallet_collator_selection::IdentityCollator;\n\ttype ValidatorRegistration = Session;\n\ttype WeightInfo = ();\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\t// System support stuff.\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 0,\n\t\tParachainSystem: cumulus_pallet_parachain_system::{\n\t\t\tPallet, Call, Config, Storage, Inherent, Event\u003cT\u003e, ValidateUnsigned,\n\t\t} = 1,\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent} = 2,\n\t\tParachainInfo: parachain_info::{Pallet, Storage, Config} = 3,\n\n\t\t// Monetary stuff.\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 10,\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event\u003cT\u003e} = 11,\n\n\t\t// Collator support. The order of these 4 are important and shall not change.\n\t\tCollatorSelection: pallet_collator_selection::{Pallet, Call, Storage, Event\u003cT\u003e, Config\u003cT\u003e} = 21,\n\t\tAura: pallet_aura::{Pallet, Storage, Config\u003cT\u003e} = 23,\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e} = 22,\n\t\tAuthorship: pallet_authorship::{Pallet, Storage} = 20,\n\t\tAuraExt: cumulus_pallet_aura_ext::{Pallet, Storage, Config} = 24,\n\n\t\t// XCM helpers.\n\t\tXcmpQueue: cumulus_pallet_xcmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 30,\n\t\tPolkadotXcm: pallet_xcm::{Pallet, Call, Event\u003cT\u003e, Origin, Config} = 31,\n\t\tCumulusXcm: cumulus_pallet_xcm::{Pallet, Event\u003cT\u003e, Origin} = 32,\n\t\tDmpQueue: cumulus_pallet_dmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 33,\n\t}\n);\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!(\n\t\t[frame_system, SystemBench::\u003cRuntime\u003e]\n\t\t[pallet_balances, Balances]\n\t\t[pallet_session, SessionBench::\u003cRuntime\u003e]\n\t\t[pallet_timestamp, Timestamp]\n\t\t[pallet_collator_selection, CollatorSelection]\n\t\t[cumulus_pallet_xcmp_queue, XcmpQueue]\n\t);\n}\n\nimpl_runtime_apis! {\n\timpl sp_consensus_aura::AuraApi\u003cBlock, AuraId\u003e for Runtime {\n\t\tfn slot_duration() -\u003e sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -\u003e Vec\u003cAuraId\u003e {\n\t\t\tAura::authorities().into_inner()\n\t\t}\n\t}\n\n\timpl sp_api::Core\u003cBlock\u003e for Runtime {\n\t\tfn version() -\u003e RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata\u003cBlock\u003e for Runtime {\n\t\tfn metadata() -\u003e OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder\u003cBlock\u003e for Runtime {\n\t\tfn apply_extrinsic(extrinsic: \u003cBlock as BlockT\u003e::Extrinsic) -\u003e ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -\u003e \u003cBlock as BlockT\u003e::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -\u003e Vec\u003c\u003cBlock as BlockT\u003e::Extrinsic\u003e {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(\u0026block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tblock_hash: \u003cBlock as BlockT\u003e::Hash,\n\t\t) -\u003e TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi\u003cBlock\u003e for Runtime {\n\t\tfn offchain_worker(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys\u003cBlock\u003e for Runtime {\n\t\tfn generate_session_keys(seed: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n\t\t\tSessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec\u003cu8\u003e,\n\t\t) -\u003e Option\u003cVec\u003c(Vec\u003cu8\u003e, KeyTypeId)\u003e\u003e {\n\t\t\tSessionKeys::decode_into_raw_public_keys(\u0026encoded)\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi\u003cBlock, AccountId, Index\u003e for Runtime {\n\t\tfn account_nonce(account: AccountId) -\u003e Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi\u003cBlock, Balance\u003e for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t\tfn query_fee_details(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment::FeeDetails\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\n\t\tfn query_weight_to_fee(weight: Weight) -\u003e Balance {\n\t\t\tTransactionPayment::weight_to_fee(weight)\n\t\t}\n\n\t\tfn query_length_to_fee(length: u32) -\u003e Balance {\n\t\t\tTransactionPayment::length_to_fee(length)\n\t\t}\n\t}\n\n\timpl cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e for Runtime {\n\t\tfn collect_collation_info(header: \u0026\u003cBlock as BlockT\u003e::Header) -\u003e cumulus_primitives_core::CollationInfo {\n\t\t\tParachainSystem::collect_collation_info(header)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\timpl frame_try_runtime::TryRuntime\u003cBlock\u003e for Runtime {\n\t\tfn on_runtime_upgrade() -\u003e (Weight, Weight) {\n\t\t\tlog::info!(\"try-runtime::on_runtime_upgrade pendulum-development.\");\n\t\t\tlet weight = Executive::try_runtime_upgrade().unwrap();\n\t\t\t(weight, RuntimeBlockWeights::get().max_block)\n\t\t}\n\n\t\tfn execute_block_no_check(block: Block) -\u003e Weight {\n\t\t\tExecutive::execute_block_no_check(block)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark\u003cBlock\u003e for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -\u003e (\n\t\t\tVec\u003cframe_benchmarking::BenchmarkList\u003e,\n\t\t\tVec\u003cframe_support::traits::StorageInfo\u003e,\n\t\t) {\n\t\t\tuse frame_benchmarking::{list_benchmark as frame_list_benchmark, Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\n\t\t\tlet mut list = Vec::\u003cBenchmarkList\u003e::new();\n\t\t\tframe_list_benchmark!(list, extra,cumulus_pallet_session_benchmarking, SessionBench::\u003cRuntime\u003e);\n\t\t\tlist_benchmarks!(list, extra);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -\u003e Result\u003cVec\u003cframe_benchmarking::BenchmarkBatch\u003e, sp_runtime::RuntimeString\u003e {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, TrackedStorageKey};\n\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\t\t\timpl baseline::Config for Runtime {}\n\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\timpl cumulus_pallet_session_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec\u003cTrackedStorageKey\u003e = vec![\n\t\t\t\t// Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t// Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t// Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t// Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t// System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::\u003cBenchmarkBatch\u003e::new();\n\t\t\tlet params = (\u0026config, \u0026whitelist);\n\t\t\tadd_benchmarks!(params, batches);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n}\n\nstruct CheckInherents;\n\nimpl cumulus_pallet_parachain_system::CheckInherents\u003cBlock\u003e for CheckInherents {\n\tfn check_inherents(\n\t\tblock: \u0026Block,\n\t\trelay_state_proof: \u0026cumulus_pallet_parachain_system::RelayChainStateProof,\n\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\tlet relay_chain_slot = relay_state_proof\n\t\t\t.read_slot()\n\t\t\t.expect(\"Could not read the relay chain slot from the proof\");\n\n\t\tlet inherent_data =\n\t\t\tcumulus_primitives_timestamp::InherentDataProvider::from_relay_chain_slot_and_duration(\n\t\t\t\trelay_chain_slot,\n\t\t\t\tsp_std::time::Duration::from_secs(6),\n\t\t\t)\n\t\t\t.create_inherent_data()\n\t\t\t.expect(\"Could not create the timestamp inherent data\");\n\n\t\tinherent_data.check_extrinsics(block)\n\t}\n}\n\ncumulus_pallet_parachain_system::register_validate_block! {\n\tRuntime = Runtime,\n\tBlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::\u003cRuntime, Executive\u003e,\n\tCheckInherents = CheckInherents,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","block_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Importing a block with 0 Extrinsics.\n\t\tpub const BlockExecutionWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::BlockExecutionWeight::get();\n\n\t\t\t// At least 100 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 100u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 100 µs.\"\n\t\t\t);\n\t\t\t// At most 50 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= 50u64 * constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 50 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","extrinsic_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Executing a NO-OP `System::remarks` Extrinsic.\n\t\tpub const ExtrinsicBaseWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::ExtrinsicBaseWeight::get();\n\n\t\t\t// At least 10 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 10u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 10 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","mod.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Expose the auto generated weight files.\n\npub mod block_weights;\npub mod extrinsic_weights;\npub mod paritydb_weights;\npub mod rocksdb_weights;\n\npub use block_weights::constants::BlockExecutionWeight;\npub use extrinsic_weights::constants::ExtrinsicBaseWeight;\npub use paritydb_weights::constants::ParityDbWeight;\npub use rocksdb_weights::constants::RocksDbWeight;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","paritydb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights\n\t\t/// are available for brave runtime engineers who may want to try this out as default.\n\t\tpub const ParityDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::ParityDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","rocksdb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// By default, Substrate uses `RocksDB`, so this will be the weight used throughout\n\t\t/// the runtime.\n\t\tpub const RocksDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::RocksDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","xcm_config.rs"],"content":"use super::{\n\tAccountId, AllPalletsWithSystem, Balances, ParachainInfo, ParachainSystem, PolkadotXcm,\n\tRuntime, RuntimeCall, RuntimeEvent, RuntimeOrigin, WeightToFee, XcmpQueue,\n};\nuse core::marker::PhantomData;\nuse frame_support::{\n\tlog, match_types, parameter_types,\n\ttraits::{Everything, Nothing},\n\tweights::Weight,\n};\nuse pallet_xcm::XcmPassthrough;\nuse polkadot_parachain::primitives::Sibling;\nuse polkadot_runtime_common::impls::ToAuthor;\nuse sp_core::ConstU32;\nuse xcm::latest::{prelude::*, Weight as XCMWeight};\nuse xcm_builder::{\n\tAccountId32Aliases, AllowTopLevelPaidExecutionFrom, AllowUnpaidExecutionFrom, CurrencyAdapter,\n\tEnsureXcmOrigin, FixedWeightBounds, IsConcrete, NativeAsset, ParentIsPreset,\n\tRelayChainAsNative, SiblingParachainAsNative, SiblingParachainConvertsVia,\n\tSignedAccountId32AsNative, SignedToAccountId32, SovereignSignedViaLocation, TakeWeightCredit,\n\tUsingComponents,\n};\nuse xcm_executor::{traits::ShouldExecute, XcmExecutor};\n\nparameter_types! {\n\tpub const RelayLocation: MultiLocation = MultiLocation::parent();\n\tpub const RelayNetwork: NetworkId = NetworkId::Rococo;\n\tpub RelayChainOrigin: RuntimeOrigin = cumulus_pallet_xcm::Origin::Relay.into();\n\tpub Ancestry: MultiLocation = Parachain(ParachainInfo::parachain_id().into()).into();\n\tpub UniversalLocation: InteriorMultiLocation = Parachain(ParachainInfo::parachain_id().into()).into();\n}\n\n/// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used\n/// when determining ownership of accounts for asset transacting and when attempting to use XCM\n/// `Transact` in order to determine the dispatch Origin.\npub type LocationToAccountId = (\n\t// The parent (Relay-chain) origin converts to the parent `AccountId`.\n\tParentIsPreset\u003cAccountId\u003e,\n\t// Sibling parachain origins convert to AccountId via the `ParaId::into`.\n\tSiblingParachainConvertsVia\u003cSibling, AccountId\u003e,\n\t// Straight up local `AccountId32` origins just alias directly to `AccountId`.\n\tAccountId32Aliases\u003cRelayNetwork, AccountId\u003e,\n);\n\n/// Means for transacting assets on this chain.\npub type LocalAssetTransactor = CurrencyAdapter\u003c\n\t// Use this currency:\n\tBalances,\n\t// Use this currency when it is a fungible asset matching the given location or name:\n\tIsConcrete\u003cRelayLocation\u003e,\n\t// Do a simple punn to convert an AccountId32 MultiLocation into a native chain account ID:\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly):\n\tAccountId,\n\t// We don't track any teleports.\n\t(),\n\u003e;\n\n/// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,\n/// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can\n/// biases the kind of local `Origin` it will become.\npub type XcmOriginToTransactDispatchOrigin = (\n\t// Sovereign account converter; this attempts to derive an `AccountId` from the origin location\n\t// using `LocationToAccountId` and then turn that into the usual `Signed` origin. Useful for\n\t// foreign chains who want to have a local sovereign account on this chain which they control.\n\tSovereignSignedViaLocation\u003cLocationToAccountId, RuntimeOrigin\u003e,\n\t// Native converter for Relay-chain (Parent) location; will converts to a `Relay` origin when\n\t// recognized.\n\tRelayChainAsNative\u003cRelayChainOrigin, RuntimeOrigin\u003e,\n\t// Native converter for sibling Parachains; will convert to a `SiblingPara` origin when\n\t// recognized.\n\tSiblingParachainAsNative\u003ccumulus_pallet_xcm::Origin, RuntimeOrigin\u003e,\n\t// Native signed account converter; this just converts an `AccountId32` origin into a normal\n\t// `Origin::Signed` origin of the same 32-byte value.\n\tSignedAccountId32AsNative\u003cRelayNetwork, RuntimeOrigin\u003e,\n\t// Xcm origins can be represented natively under the Xcm pallet's Xcm origin.\n\tXcmPassthrough\u003cRuntimeOrigin\u003e,\n);\n\nparameter_types! {\n\t// One XCM operation is 1_000_000_000 weight - almost certainly a conservative estimate.\n\t// The default POV size used by Polkadot/Kusama was 64 kB but that has been updated here: https://github.com/paritytech/polkadot/pull/7081\n\t// We should properly benchmark instructions and get rid of fixed weights.\n\tpub UnitWeightCost: Weight = Weight::from_parts(1_000_000_000, 1024);\n\tpub const MaxInstructions: u32 = 100;\n}\n\nmatch_types! {\n\tpub type ParentOrParentsExecutivePlurality: impl Contains\u003cMultiLocation\u003e = {\n\t\tMultiLocation { parents: 1, interior: Here } |\n\t\tMultiLocation { parents: 1, interior: X1(Plurality { id: BodyId::Executive, .. }) }\n\t};\n}\n\n//TODO: move DenyThenTry to polkadot's xcm module.\n/// Deny executing the xcm message if it matches any of the Deny filter regardless of anything else.\n/// If it passes the Deny, and matches one of the Allow cases then it is let through.\npub struct DenyThenTry\u003cDeny, Allow\u003e(PhantomData\u003cDeny\u003e, PhantomData\u003cAllow\u003e)\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute;\n\nimpl\u003cDeny, Allow\u003e ShouldExecute for DenyThenTry\u003cDeny, Allow\u003e\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute,\n{\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\tmax_weight: XCMWeight,\n\t\tweight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tDeny::should_execute(origin, instructions, max_weight, weight_credit)?;\n\t\tAllow::should_execute(origin, instructions, max_weight, weight_credit)\n\t}\n}\n\n// See issue #5233\npub struct DenyReserveTransferToRelayChain;\nimpl ShouldExecute for DenyReserveTransferToRelayChain {\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\t_max_weight: XCMWeight,\n\t\t_weight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tif instructions.iter().any(|inst| {\n\t\t\tmatches!(\n\t\t\t\tinst,\n\t\t\t\tInitiateReserveWithdraw {\n\t\t\t\t\treserve: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t..\n\t\t\t\t} | DepositReserveAsset { dest: MultiLocation { parents: 1, interior: Here }, .. } |\n\t\t\t\t\tTransferReserveAsset {\n\t\t\t\t\t\tdest: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t\t..\n\t\t\t\t\t}\n\t\t\t)\n\t\t}) {\n\t\t\treturn Err(()) // Deny\n\t\t}\n\n\t\t// allow reserve transfers to arrive from relay chain\n\t\tif matches!(origin, MultiLocation { parents: 1, interior: Here }) \u0026\u0026\n\t\t\tinstructions.iter().any(|inst| matches!(inst, ReserveAssetDeposited { .. }))\n\t\t{\n\t\t\tlog::warn!(\n\t\t\t\ttarget: \"xcm::barriers\",\n\t\t\t\t\"Unexpected ReserveAssetDeposited from the relay chain\",\n\t\t\t);\n\t\t}\n\t\t// Permit everything else\n\t\tOk(())\n\t}\n}\n\npub type Barrier = DenyThenTry\u003c\n\tDenyReserveTransferToRelayChain,\n\t(\n\t\tTakeWeightCredit,\n\t\tAllowTopLevelPaidExecutionFrom\u003cEverything\u003e,\n\t\tAllowUnpaidExecutionFrom\u003cParentOrParentsExecutivePlurality\u003e,\n\t\t// ^^^ Parent and its exec plurality get free execution\n\t),\n\u003e;\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n\ttype RuntimeCall = RuntimeCall;\n\ttype XcmSender = XcmRouter;\n\t// How to withdraw and deposit an asset.\n\ttype AssetTransactor = LocalAssetTransactor;\n\ttype OriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype IsReserve = NativeAsset;\n\t// Teleporting is disabled.\n\ttype IsTeleporter = ();\n\ttype UniversalLocation = UniversalLocation;\n\ttype Barrier = Barrier;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype Trader =\n\t\tUsingComponents\u003cWeightToFee, RelayLocation, AccountId, Balances, ToAuthor\u003cRuntime\u003e\u003e;\n\ttype ResponseHandler = PolkadotXcm;\n\ttype AssetTrap = PolkadotXcm;\n\ttype AssetLocker = ();\n\ttype AssetExchanger = ();\n\ttype AssetClaims = PolkadotXcm;\n\ttype SubscriptionService = PolkadotXcm;\n\ttype PalletInstancesInfo = AllPalletsWithSystem;\n\ttype MaxAssetsIntoHolding = ConstU32\u003c8\u003e;\n\ttype FeeManager = ();\n\ttype MessageExporter = ();\n\ttype UniversalAliases = Nothing;\n\ttype CallDispatcher = RuntimeCall;\n\ttype SafeCallFilter = Everything;\n}\n\n/// No local origins on this chain are allowed to dispatch XCM sends/executions.\npub type LocalOriginToLocation = SignedToAccountId32\u003cRuntimeOrigin, AccountId, RelayNetwork\u003e;\n\n/// The means for routing XCM messages which are not for local execution into the right message\n/// queues.\npub type XcmRouter = (\n\t// Two routers - use UMP to communicate with the relay chain:\n\tcumulus_primitives_utility::ParentAsUmp\u003cParachainSystem, PolkadotXcm, ()\u003e,\n\t// ..and XCMP to communicate with the sibling chains.\n\tXcmpQueue,\n);\n\nimpl pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyMatcher = ();\n\ttype SendXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmRouter = XcmRouter;\n\ttype ExecuteXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmExecuteFilter = Nothing;\n\t// ^ Disable dispatchable execute on the XCM pallet.\n\t// Needs to be `Everything` for local testing.\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype XcmTeleportFilter = Everything;\n\ttype XcmReserveTransferFilter = Nothing;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype UniversalLocation = UniversalLocation;\n\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\n\tconst VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;\n\t// ^ Override for AdvertisedXcmVersion default\n\ttype AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;\n\ttype TrustedLockers = ();\n\ttype SovereignAccountOf = LocationToAccountId;\n\ttype MaxLockers = ConstU32\u003c8\u003e;\n\ttype WeightInfo = pallet_xcm::TestWeightInfo;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype ReachableDest = ReachableDest;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nparameter_types! {\n\tpub ReachableDest: Option\u003cMultiLocation\u003e = Some(Parent.into());\n}\n\nimpl cumulus_pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n}\n","traces":[{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","build.rs"],"content":"use substrate_wasm_builder::WasmBuilder;\n\nfn main() {\n\tWasmBuilder::new()\n\t\t.with_current_project()\n\t\t.export_heap_base()\n\t\t.import_memory()\n\t\t.build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nmod weights;\npub mod xcm_config;\npub mod zenlink;\nuse crate::zenlink::*;\nuse xcm::v3::MultiLocation;\nuse zenlink_protocol::{AssetBalance, MultiAssetsHandler, PairInfo};\n\npub use parachain_staking::InflationInfo;\n\nuse bifrost_farming as farming;\nuse bifrost_farming_rpc_runtime_api as farming_rpc_runtime_api;\nuse orml_traits::MultiCurrency;\n\nuse codec::Encode;\n\nuse smallvec::smallvec;\nuse sp_api::impl_runtime_apis;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata, H256};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{\n\t\tAccountIdConversion, AccountIdLookup, BlakeTwo256, Block as BlockT, Convert, ConvertInto,\n\t},\n\ttransaction_validity::{TransactionSource, TransactionValidity},\n\tApplyExtrinsicResult, DispatchError, FixedPointNumber, SaturatedConversion,\n};\n\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\nuse frame_support::{\n\tconstruct_runtime,\n\tdispatch::DispatchClass,\n\tparameter_types,\n\ttraits::{\n\t\tConstBool, ConstU32, Contains, Currency as FrameCurrency, EitherOfDiverse,\n\t\tEqualPrivilegeOnly, Imbalance, OnUnbalanced, WithdrawReasons,\n\t},\n\tweights::{\n\t\tconstants::WEIGHT_REF_TIME_PER_SECOND, ConstantMultiplier, Weight, WeightToFeeCoefficient,\n\t\tWeightToFeeCoefficients, WeightToFeePolynomial,\n\t},\n\tPalletId,\n};\nuse frame_system::{\n\tlimits::{BlockLength, BlockWeights},\n\tEnsureRoot, EnsureSigned,\n};\npub use sp_runtime::{MultiAddress, Perbill, Permill, Perquintill};\n\nuse runtime_common::{\n\tasset_registry, chain_ext, opaque, AccountId, Amount, AuraId, Balance, BlockNumber, Hash,\n\tIndex, PoolId, ReserveIdentifier, Signature, EXISTENTIAL_DEPOSIT, MILLIUNIT, NANOUNIT, UNIT,\n};\n\nuse cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;\n\nuse dia_oracle::DiaOracle;\n\nuse xcm_config::{XcmConfig, XcmOriginToTransactDispatchOrigin};\n\nuse orml_currencies::BasicCurrencyAdapter;\nuse orml_traits::{currency::MutationHooks, parameter_type_with_key};\n\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\n\npub use dia_oracle::dia::AssetId;\npub use issue::{Event as IssueEvent, IssueRequest};\npub use nomination::Event as NominationEvent;\npub use redeem::{Event as RedeemEvent, RedeemRequest};\npub use replace::{Event as ReplaceEvent, ReplaceRequest};\npub use security::StatusCode;\npub use stellar_relay::traits::{FieldLength, Organization, Validator};\n\nconst CONTRACTS_DEBUG_OUTPUT: bool = true;\n\npub use module_oracle_rpc_runtime_api::BalanceWrapper;\nuse oracle::dia::{DiaOracleAdapter, XCMCurrencyConversion};\n\n// Polkadot imports\nuse polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};\n\nuse spacewalk_primitives::{\n\tself as primitives, CurrencyId, CurrencyId::XCM, Moment, SignedFixedPoint, SignedInner,\n\tUnsignedFixedPoint, UnsignedInner,\n};\n\nuse orml_currencies::WeightInfo;\nuse weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};\n\nuse orml_currencies_allowance_extension::{\n\tdefault_weights::WeightInfo as AllowanceWeightInfo, Config as AllowanceConfig,\n};\n\nuse frame_support::{\n\tlog::{error, warn},\n\tpallet_prelude::*,\n};\nuse sp_std::vec::Vec;\n\nuse pallet_contracts::chain_extension::{\n\tChainExtension, Environment, Ext, InitState, RetVal, SysConfig,\n};\nuse sp_core::crypto::UncheckedFrom;\n\n// XCM Imports\nuse xcm_executor::XcmExecutor;\n\npub type VaultId = primitives::VaultId\u003cAccountId, CurrencyId\u003e;\n\n/// The address format for describing accounts.\npub type Address = MultiAddress\u003cAccountId, ()\u003e;\n\n/// Block header type as expected by this runtime.\npub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\n/// Block type as expected by this runtime.\npub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock\u003cBlock\u003e;\n\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId\u003cBlock\u003e;\n\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender\u003cRuntime\u003e,\n\tframe_system::CheckSpecVersion\u003cRuntime\u003e,\n\tframe_system::CheckTxVersion\u003cRuntime\u003e,\n\tframe_system::CheckGenesis\u003cRuntime\u003e,\n\tframe_system::CheckEra\u003cRuntime\u003e,\n\tframe_system::CheckNonce\u003cRuntime\u003e,\n\tframe_system::CheckWeight\u003cRuntime\u003e,\n\tpallet_transaction_payment::ChargeTransactionPayment\u003cRuntime\u003e,\n);\n\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tgeneric::UncheckedExtrinsic\u003cAddress, RuntimeCall, Signature, SignedExtra\u003e;\n\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic\u003cAccountId, RuntimeCall, SignedExtra\u003e;\n\npub type SignedPayload = generic::SignedPayload\u003cRuntimeCall, SignedExtra\u003e;\n\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive\u003c\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext\u003cRuntime\u003e,\n\tRuntime,\n\tAllPalletsWithSystem,\n\u003e;\n\npub struct SpacewalkNativeCurrency;\nimpl oracle::dia::NativeCurrencyKey for SpacewalkNativeCurrency {\n\tfn native_symbol() -\u003e Vec\u003cu8\u003e {\n\t\t\"AMPE\".as_bytes().to_vec()\n\t}\n\n\tfn native_chain() -\u003e Vec\u003cu8\u003e {\n\t\t\"AMPLITUDE\".as_bytes().to_vec()\n\t}\n}\n\nimpl XCMCurrencyConversion for SpacewalkNativeCurrency {\n\tfn convert_to_dia_currency_id(token_symbol: u8) -\u003e Option\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e)\u003e {\n\t\tmatch token_symbol {\n\t\t\t0 =\u003e Some((b\"Kusama\".to_vec(), b\"KSM\".to_vec())),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n\n\tfn convert_from_dia_currency_id(blockchain: Vec\u003cu8\u003e, symbol: Vec\u003cu8\u003e) -\u003e Option\u003cu8\u003e {\n\t\tmatch (blockchain.as_slice(), symbol.as_slice()) {\n\t\t\t(b\"Kusama\", b\"KSM\") =\u003e Some(0),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\ntype DataProviderImpl = DiaOracleAdapter\u003c\n\tDiaOracleModule,\n\tUnsignedFixedPoint,\n\tMoment,\n\toracle::dia::DiaOracleKeyConvertor\u003cSpacewalkNativeCurrency\u003e,\n\tConvertPrice,\n\tConvertMoment,\n\u003e;\n\npub struct ConvertPrice;\nimpl Convert\u003cu128, Option\u003cUnsignedFixedPoint\u003e\u003e for ConvertPrice {\n\tfn convert(price: u128) -\u003e Option\u003cUnsignedFixedPoint\u003e {\n\t\tSome(UnsignedFixedPoint::from_inner(price))\n\t}\n}\n\npub struct ConvertMoment;\nimpl Convert\u003cu64, Option\u003cMoment\u003e\u003e for ConvertMoment {\n\tfn convert(moment: u64) -\u003e Option\u003cMoment\u003e {\n\t\t// The provided moment is in seconds, but we need milliseconds\n\t\tSome(moment.saturating_mul(1000))\n\t}\n}\n\n/// Handles converting a weight scalar to a fee value, based on the scale and granularity of the\n/// node's balance type.\n///\n/// This should typically create a mapping between the following ranges:\n///   - `[0, MAXIMUM_BLOCK_WEIGHT]`\n///   - `[Balance::min, Balance::max]`\n///\n/// Yet, it can be used for any other sort of change to weight-fee. Some examples being:\n///   - Setting it to `0` will essentially disable the weight fee.\n///   - Setting it to `1` will cause the literal `#[weight = x]` values to be charged.\npub struct WeightToFee;\nimpl WeightToFeePolynomial for WeightToFee {\n\ttype Balance = Balance;\n\tfn polynomial() -\u003e WeightToFeeCoefficients\u003cSelf::Balance\u003e {\n\t\tlet p = MILLIUNIT;\n\t\tlet q = 10 * Balance::from(ExtrinsicBaseWeight::get().ref_time());\n\t\tsmallvec![WeightToFeeCoefficient {\n\t\t\tdegree: 1,\n\t\t\tnegative: false,\n\t\t\tcoeff_frac: Perbill::from_rational(p % q, q),\n\t\t\tcoeff_integer: p / q,\n\t\t}]\n\t}\n}\n\nimpl_opaque_keys! {\n\tpub struct SessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\n#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"foucoco\"),\n\timpl_name: create_runtime_str!(\"foucoco\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 0,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n\tstate_version: 1,\n};\n\n/// This determines the average expected block time that we are targeting.\n/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.\n/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked\n/// up by `pallet_aura` to implement `fn slot_duration()`.\n///\n/// Change this to adjust the block time.\npub const MILLISECS_PER_BLOCK: u64 = 12000;\n\n// NOTE: Currently it is not possible to change the slot duration after the chain has started.\n//       Attempting to do so will brick block production.\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\npub const BLOCKS_PER_YEAR: BlockNumber = DAYS * 36525 / 100;\n\n/// We assume that ~5% of the block weight is consumed by `on_initialize` handlers. This is\n/// used to limit the maximal weight of a single extrinsic.\nconst AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(5);\n\n/// We allow `Normal` extrinsics to fill up the block up to 75%, the rest can be used by\n/// `Operational` extrinsics.\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\n/// We allow for 0.5 of a second of compute with a 12 second average block time.\nconst MAXIMUM_BLOCK_WEIGHT: Weight =\n\tWeight::from_parts(WEIGHT_REF_TIME_PER_SECOND.saturating_div(2), 0)\n\t\t.set_proof_size(cumulus_primitives_core::relay_chain::MAX_POV_SIZE as u64);\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -\u003e NativeVersion {\n\tNativeVersion { runtime_version: VERSION, can_author_with: Default::default() }\n}\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\n\t// This part is copied from Substrate's `bin/node/runtime/src/lib.rs`.\n\t//  The `RuntimeBlockLength` and `RuntimeBlockWeights` exist here because the\n\t// `DeletionWeightLimit` and `DeletionQueueDepth` depend on those to parameterize\n\t// the lazy contract deletion.\n\tpub RuntimeBlockLength: BlockLength =\n\t\tBlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub RuntimeBlockWeights: BlockWeights = BlockWeights::builder()\n\t\t.base_block(BlockExecutionWeight::get())\n\t\t.for_class(DispatchClass::all(), |weights| {\n\t\t\tweights.base_extrinsic = ExtrinsicBaseWeight::get();\n\t\t})\n\t\t.for_class(DispatchClass::Normal, |weights| {\n\t\t\tweights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);\n\t\t})\n\t\t.for_class(DispatchClass::Operational, |weights| {\n\t\t\tweights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);\n\t\t\t// Operational transactions have some extra reserved space, so that they\n\t\t\t// are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.\n\t\t\tweights.reserved = Some(\n\t\t\t\tMAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT\n\t\t\t);\n\t\t})\n\t\t.avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)\n\t\t.build_or_panic();\n\tpub const SS58Prefix: u16 = 57;\n}\n\npub struct BaseFilter;\nimpl Contains\u003cRuntimeCall\u003e for BaseFilter {\n\tfn contains(call: \u0026RuntimeCall) -\u003e bool {\n\t\tmatch call {\n\t\t\t// These modules are all allowed to be called by transactions:\n\t\t\tRuntimeCall::Bounties(_) |\n\t\t\tRuntimeCall::ChildBounties(_) |\n\t\t\tRuntimeCall::Treasury(_) |\n\t\t\tRuntimeCall::Tokens(_) |\n\t\t\tRuntimeCall::Currencies(_) |\n\t\t\tRuntimeCall::ParachainStaking(_) |\n\t\t\tRuntimeCall::Democracy(_) |\n\t\t\tRuntimeCall::Council(_) |\n\t\t\tRuntimeCall::TechnicalCommittee(_) |\n\t\t\tRuntimeCall::System(_) |\n\t\t\tRuntimeCall::Scheduler(_) |\n\t\t\tRuntimeCall::Preimage(_) |\n\t\t\tRuntimeCall::Timestamp(_) |\n\t\t\tRuntimeCall::Balances(_) |\n\t\t\tRuntimeCall::Session(_) |\n\t\t\tRuntimeCall::ParachainSystem(_) |\n\t\t\tRuntimeCall::Sudo(_) |\n\t\t\tRuntimeCall::XcmpQueue(_) |\n\t\t\tRuntimeCall::PolkadotXcm(_) |\n\t\t\tRuntimeCall::DmpQueue(_) |\n\t\t\tRuntimeCall::Utility(_) |\n\t\t\tRuntimeCall::Vesting(_) |\n\t\t\tRuntimeCall::XTokens(_) |\n\t\t\tRuntimeCall::Multisig(_) |\n\t\t\tRuntimeCall::Identity(_) |\n\t\t\tRuntimeCall::Contracts(_) |\n\t\t\tRuntimeCall::ZenlinkProtocol(_) |\n\t\t\tRuntimeCall::DiaOracleModule(_) |\n\t\t\tRuntimeCall::Fee(_) |\n\t\t\tRuntimeCall::Issue(_) |\n\t\t\tRuntimeCall::Nomination(_) |\n\t\t\tRuntimeCall::Oracle(_) |\n\t\t\tRuntimeCall::Redeem(_) |\n\t\t\tRuntimeCall::Replace(_) |\n\t\t\tRuntimeCall::Security(_) |\n\t\t\tRuntimeCall::StellarRelay(_) |\n\t\t\tRuntimeCall::VaultRegistry(_) |\n\t\t\tRuntimeCall::VaultRewards(_) |\n\t\t\tRuntimeCall::Farming(_) |\n\t\t\tRuntimeCall::TokenAllowance(_) |\n\t\t\tRuntimeCall::AssetRegistry(_) =\u003e true,\n\t\t\t// All pallets are allowed, but exhaustive match is defensive\n\t\t\t// in the case of adding new pallets.\n\t\t}\n\t}\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype RuntimeCall = RuntimeCall;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup\u003cAccountId, ()\u003e;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\t/// The ubiquitous origin type.\n\ttype RuntimeOrigin = RuntimeOrigin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// Runtime version.\n\ttype Version = Version;\n\t/// Converts a module to an index of this module in the runtime.\n\ttype PalletInfo = PalletInfo;\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = BaseFilter;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// Block \u0026 extrinsics weights: base values and limits.\n\ttype BlockWeights = RuntimeBlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = RuntimeBlockLength;\n\t/// This is used as an identifier of the chain. 57 is the prefix for Foucoco\n\ttype SS58Prefix = SS58Prefix;\n\t/// The action to take on a Runtime Upgrade\n\ttype OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode\u003cSelf\u003e;\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = pallet_timestamp::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const UncleGenerations: u32 = 2;\n}\n\nimpl pallet_authorship::Config for Runtime {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = ParachainStaking;\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = EXISTENTIAL_DEPOSIT;\n\tpub const MaxLocks: u32 = 50;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 100 * NANOUNIT;\n\tpub const OperationalFeeMultiplier: u8 = 5;\n}\n\ntype NegativeImbalance = \u003cBalances as FrameCurrency\u003cAccountId\u003e\u003e::NegativeImbalance;\n\npub struct DealWithFees;\nimpl OnUnbalanced\u003cNegativeImbalance\u003e for DealWithFees {\n\tfn on_unbalanceds\u003cB\u003e(mut fees_then_tips: impl Iterator\u003cItem = NegativeImbalance\u003e) {\n\t\tif let Some(mut fees) = fees_then_tips.next() {\n\t\t\tif let Some(tips) = fees_then_tips.next() {\n\t\t\t\ttips.merge_into(\u0026mut fees);\n\t\t\t}\n\t\t\t// for fees and tips, 100% to treasury\n\t\t\tTreasury::on_unbalanced(fees);\n\t\t}\n\t}\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter\u003cBalances, DealWithFees\u003e;\n\ttype WeightToFee = WeightToFee;\n\ttype LengthToFee = ConstantMultiplier\u003cBalance, TransactionByteFee\u003e;\n\ttype FeeMultiplierUpdate = SlowAdjustingFeeUpdate\u003cSelf\u003e;\n\ttype OperationalFeeMultiplier = OperationalFeeMultiplier;\n}\n\nparameter_types! {\n\tpub const ReservedXcmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n\tpub const ReservedDmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n}\n\nimpl cumulus_pallet_parachain_system::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSystemEvent = ();\n\ttype SelfParaId = parachain_info::Pallet\u003cRuntime\u003e;\n\ttype DmpMessageHandler = DmpQueue;\n\ttype ReservedDmpWeight = ReservedDmpWeight;\n\ttype OutboundXcmpMessageSource = XcmpQueue;\n\ttype XcmpMessageHandler = XcmpQueue;\n\ttype ReservedXcmpWeight = ReservedXcmpWeight;\n\ttype CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;\n}\n\nimpl parachain_info::Config for Runtime {}\n\nimpl cumulus_pallet_aura_ext::Config for Runtime {}\n\nimpl cumulus_pallet_xcmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ChannelInfo = ParachainSystem;\n\ttype VersionWrapper = ();\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype PriceForSiblingDelivery = ();\n\ttype WeightInfo = cumulus_pallet_xcmp_queue::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl cumulus_pallet_dmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const Offset: u32 = 0;\n\tpub const MaxAuthorities: u32 = 200;\n}\n\nimpl pallet_session::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\ttype ValidatorIdOf = ConvertInto;\n\ttype ShouldEndSession = ParachainStaking;\n\ttype NextSessionRotation = ParachainStaking;\n\ttype SessionManager = ParachainStaking;\n\ttype SessionHandler = \u003cSessionKeys as sp_runtime::traits::OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = SessionKeys;\n\ttype WeightInfo = pallet_session::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nparameter_types! {\n\tpub const LaunchPeriod: BlockNumber = 4 * DAYS;\n\tpub const VotingPeriod: BlockNumber = 4 * DAYS;\n\tpub const FastTrackVotingPeriod: BlockNumber = 3 * HOURS;\n\tpub const MinimumDeposit: Balance = 1 * UNIT;\n\tpub const EnactmentPeriod: BlockNumber = 4 * DAYS;\n\tpub const CooloffPeriod: BlockNumber = 4 * DAYS;\n\tpub const MaxProposals: u32 = 100;\n}\n\nimpl pallet_democracy::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype EnactmentPeriod = EnactmentPeriod;\n\ttype LaunchPeriod = LaunchPeriod;\n\ttype VotingPeriod = VotingPeriod;\n\ttype VoteLockingPeriod = EnactmentPeriod; // Same as EnactmentPeriod\n\ttype MinimumDeposit = MinimumDeposit;\n\t/// A straight majority of the council can decide what their next motion is.\n\ttype ExternalOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A super-majority can have the next scheduled referendum be a straight majority-carries vote.\n\ttype ExternalMajorityOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A unanimous council can have the next scheduled referendum be a straight default-carries\n\t/// (NTB) vote.\n\ttype ExternalDefaultOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 1\u003e;\n\t/// Two thirds of the technical committee can have an ExternalMajority/ExternalDefault vote\n\t/// be tabled immediately and with a shorter voting/enactment period.\n\ttype FastTrackOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 2, 3\u003e;\n\ttype InstantOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e;\n\ttype InstantAllowed = frame_support::traits::ConstBool\u003ctrue\u003e;\n\ttype FastTrackVotingPeriod = FastTrackVotingPeriod;\n\t// To cancel a proposal which has been passed, 2/3 of the council must agree to it.\n\ttype CancellationOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 2, 3\u003e;\n\t// To cancel a proposal before it has been passed, the technical committee must be unanimous or\n\t// Root must agree.\n\ttype CancelProposalOrigin = EitherOfDiverse\u003c\n\t\tEnsureRoot\u003cAccountId\u003e,\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e,\n\t\u003e;\n\ttype BlacklistOrigin = EnsureRoot\u003cAccountId\u003e;\n\t// Any single technical committee member may veto a coming council proposal, however they can\n\t// only do it once and it lasts only for the cool-off period.\n\ttype VetoOrigin = pallet_collective::EnsureMember\u003cAccountId, TechnicalCollective\u003e;\n\ttype CooloffPeriod = CooloffPeriod;\n\ttype Slash = ();\n\ttype Scheduler = Scheduler;\n\ttype PalletsOrigin = OriginCaller;\n\ttype MaxVotes = ConstU32\u003c100\u003e;\n\ttype WeightInfo = pallet_democracy::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxProposals = MaxProposals;\n\ttype Preimages = Preimage;\n\ttype MaxDeposits = ConstU32\u003c100\u003e;\n\ttype MaxBlacklisted = ConstU32\u003c100\u003e;\n\ttype SubmitOrigin = EnsureSigned\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const CouncilMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const CouncilMaxProposals: u32 = 100;\n\tpub const CouncilMaxMembers: u32 = 100;\n}\n\ntype CouncilCollective = pallet_collective::Instance1;\nimpl pallet_collective::Config\u003cCouncilCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = CouncilMotionDuration;\n\ttype MaxProposals = CouncilMaxProposals;\n\ttype MaxMembers = CouncilMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const TechnicalMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const TechnicalMaxProposals: u32 = 100;\n\tpub const TechnicalMaxMembers: u32 = 100;\n}\n\ntype TechnicalCollective = pallet_collective::Instance2;\nimpl pallet_collective::Config\u003cTechnicalCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = TechnicalMotionDuration;\n\ttype MaxProposals = TechnicalMaxProposals;\n\ttype MaxMembers = TechnicalMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub MaximumSchedulerWeight: Weight = Perbill::from_percent(80) *\n\t\tRuntimeBlockWeights::get().max_block;\n}\n\nimpl pallet_scheduler::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype PalletsOrigin = OriginCaller;\n\ttype RuntimeCall = RuntimeCall;\n\ttype MaximumWeight = MaximumSchedulerWeight;\n\ttype ScheduleOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype MaxScheduledPerBlock = ConstU32\u003c50\u003e;\n\ttype WeightInfo = pallet_scheduler::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype OriginPrivilegeCmp = EqualPrivilegeOnly;\n\ttype Preimages = Preimage;\n}\n\nparameter_types! {\n\tpub const PreimageMaxSize: u32 = 4096 * 1024;\n\tpub const PreimageBaseDeposit: Balance = 1 * UNIT;\n\t// One cent: $10,000 / MB\n\tpub const PreimageByteDeposit: Balance = 10 * MILLIUNIT;\n}\n\nimpl pallet_preimage::Config for Runtime {\n\ttype WeightInfo = pallet_preimage::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype ManagerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype BaseDeposit = PreimageBaseDeposit;\n\ttype ByteDeposit = PreimageByteDeposit;\n}\n\nparameter_types! {\n\tpub const ProposalBond: Permill = Permill::from_percent(5);\n\tpub const ProposalBondMinimum: Balance = 10 * UNIT;\n\tpub const SpendPeriod: BlockNumber = 7 * DAYS;\n\tpub const Burn: Permill = Permill::from_percent(0);\n\tpub const TreasuryPalletId: PalletId = PalletId(*b\"py/trsry\");\n\tpub const MaxApprovals: u32 = 100;\n}\n\ntype TreasuryApproveOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 3, 5\u003e,\n\u003e;\n\ntype TreasuryRejectOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_treasury::Config for Runtime {\n\ttype PalletId = TreasuryPalletId;\n\ttype Currency = Balances;\n\ttype ApproveOrigin = TreasuryApproveOrigin;\n\ttype RejectOrigin = TreasuryRejectOrigin;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSlash = Treasury;\n\ttype ProposalBond = ProposalBond;\n\ttype ProposalBondMinimum = ProposalBondMinimum;\n\ttype ProposalBondMaximum = ();\n\ttype SpendPeriod = SpendPeriod;\n\ttype Burn = Burn;\n\ttype BurnDestination = ();\n\ttype SpendFunds = Bounties;\n\ttype WeightInfo = pallet_treasury::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxApprovals = MaxApprovals;\n\ttype SpendOrigin = frame_support::traits::NeverEnsureOrigin\u003cu128\u003e;\n}\n\nparameter_types! {\n\tpub const BountyCuratorDeposit: Permill = Permill::from_percent(50);\n\tpub const BountyValueMinimum: Balance = 5 * UNIT;\n\tpub const BountyDepositBase: Balance = 1 * UNIT;\n\tpub const CuratorDepositMultiplier: Permill = Permill::from_percent(50);\n\tpub const CuratorDepositMin: Balance = 1 * UNIT;\n\tpub const CuratorDepositMax: Balance = 100 * UNIT;\n\tpub const DataDepositPerByte: Balance = 30 * MILLIUNIT;\n\tpub const BountyDepositPayoutDelay: BlockNumber = 4 * DAYS;\n\tpub const BountyUpdatePeriod: BlockNumber = 20 * DAYS;\n\tpub const MaximumReasonLength: u32 = 5000;\n}\n\nimpl pallet_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BountyDepositBase = BountyDepositBase;\n\ttype BountyDepositPayoutDelay = BountyDepositPayoutDelay;\n\ttype BountyUpdatePeriod = BountyUpdatePeriod;\n\ttype CuratorDepositMultiplier = CuratorDepositMultiplier;\n\ttype CuratorDepositMin = CuratorDepositMin;\n\ttype CuratorDepositMax = CuratorDepositMax;\n\ttype BountyValueMinimum = BountyValueMinimum;\n\ttype DataDepositPerByte = DataDepositPerByte;\n\ttype MaximumReasonLength = MaximumReasonLength;\n\ttype WeightInfo = pallet_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype ChildBountyManager = ChildBounties;\n}\n\nparameter_types! {\n\tpub const ChildBountyValueMinimum: Balance = 1 * UNIT;\n}\n\nimpl pallet_child_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MaxActiveChildBountyCount = ConstU32\u003c10\u003e;\n\ttype ChildBountyValueMinimum = ChildBountyValueMinimum;\n\ttype WeightInfo = pallet_child_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_type_with_key! {\n\tpub ExistentialDeposits: |_currency_id: CurrencyId| -\u003e Balance {\n\t\tNANOUNIT\n\t};\n}\n\npub fn get_all_module_accounts() -\u003e Vec\u003cAccountId\u003e {\n\tvec![Treasury::account_id()]\n}\n\npub struct DustRemovalWhitelist;\nimpl Contains\u003cAccountId\u003e for DustRemovalWhitelist {\n\tfn contains(a: \u0026AccountId) -\u003e bool {\n\t\tget_all_module_accounts().contains(a)\n\t}\n}\n\npub struct CurrencyHooks\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: orml_tokens::Config\u003e MutationHooks\u003cT::AccountId, T::CurrencyId, T::Balance\u003e\n\tfor CurrencyHooks\u003cT\u003e\n{\n\ttype OnDust = orml_tokens::BurnDust\u003cT\u003e;\n\ttype OnSlash = ();\n\ttype PreDeposit = ();\n\ttype PostDeposit = ();\n\ttype PreTransfer = ();\n\ttype PostTransfer = ();\n\ttype OnNewTokenAccount = ();\n\ttype OnKilledTokenAccount = ();\n}\n\nimpl orml_tokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype Amount = Amount;\n\ttype CurrencyId = CurrencyId;\n\ttype WeightInfo = ();\n\ttype ExistentialDeposits = ExistentialDeposits;\n\ttype CurrencyHooks = CurrencyHooks\u003cRuntime\u003e;\n\ttype MaxLocks = ConstU32\u003c50\u003e;\n\ttype DustRemovalWhitelist = DustRemovalWhitelist;\n\ttype MaxReserves = ConstU32\u003c0\u003e;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const NativeCurrencyId: CurrencyId = CurrencyId::Native;\n}\n\nimpl orml_currencies::Config for Runtime {\n\ttype MultiCurrency = Tokens;\n\ttype NativeCurrency = BasicCurrencyAdapter\u003cRuntime, Balances, Amount, BlockNumber\u003e;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype WeightInfo = ();\n}\n\nimpl orml_asset_registry::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CustomMetadata = asset_registry::CustomMetadata;\n\ttype AssetId = CurrencyId;\n\ttype AuthorityOrigin = asset_registry::AssetAuthority;\n\ttype AssetProcessor = asset_registry::CustomAssetProcessor;\n\ttype Balance = Balance;\n\ttype WeightInfo = weights::orml_asset_registry::WeightInfo\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinBlocksPerRound: BlockNumber = HOURS;\n\tpub const DefaultBlocksPerRound: BlockNumber = 2 * HOURS;\n\tpub const StakeDuration: BlockNumber = 7 * DAYS;\n\tpub const ExitQueueDelay: u32 = 2;\n\tpub const MinCollators: u32 = 8;\n\tpub const MinRequiredCollators: u32 = 2;\n\tpub const MaxDelegationsPerRound: u32 = 1;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxDelegatorsPerCollator: u32 = 40;\n\tpub const MinCollatorStake: Balance = 5_000 * UNIT;\n\tpub const MinDelegatorStake: Balance = 10 * UNIT;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxCollatorCandidates: u32 = 40;\n\tpub const MaxUnstakeRequests: u32 = 10;\n\tpub const NetworkRewardStart: BlockNumber = BlockNumber::MAX;\n\tpub const NetworkRewardRate: Perquintill = Perquintill::from_percent(0);\n\tpub const CollatorRewardRateDecay: Perquintill = Perquintill::from_parts(936_879_853_200_000_000u64);\n}\n\nimpl parachain_staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyBalance = Balance;\n\n\ttype MinBlocksPerRound = MinBlocksPerRound;\n\ttype DefaultBlocksPerRound = DefaultBlocksPerRound;\n\ttype StakeDuration = StakeDuration;\n\ttype ExitQueueDelay = ExitQueueDelay;\n\ttype MinCollators = MinCollators;\n\ttype MinRequiredCollators = MinRequiredCollators;\n\ttype MaxDelegationsPerRound = MaxDelegationsPerRound;\n\ttype MaxDelegatorsPerCollator = MaxDelegatorsPerCollator;\n\ttype MinCollatorStake = MinCollatorStake;\n\ttype MinCollatorCandidateStake = MinCollatorStake;\n\ttype MaxTopCandidates = MaxCollatorCandidates;\n\ttype MinDelegatorStake = MinDelegatorStake;\n\ttype MaxUnstakeRequests = MaxUnstakeRequests;\n\ttype NetworkRewardRate = NetworkRewardRate;\n\ttype NetworkRewardStart = NetworkRewardStart;\n\ttype NetworkRewardBeneficiary = Treasury;\n\ttype CollatorRewardRateDecay = CollatorRewardRateDecay;\n\ttype WeightInfo = parachain_staking::default_weights::SubstrateWeight\u003cRuntime\u003e;\n\n\tconst BLOCKS_PER_YEAR: BlockNumber = BLOCKS_PER_YEAR;\n}\n\nimpl pallet_sudo::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n}\n\nparameter_types! {\n\tpub const DepositBase: Balance = 300 * MILLIUNIT;\n\tpub const DepositFactor: Balance = 50 * MILLIUNIT;\n}\n\nimpl pallet_multisig::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Currency = Balances;\n\ttype DepositBase = DepositBase;\n\ttype DepositFactor = DepositFactor;\n\ttype MaxSignatories = ConstU32\u003c20\u003e;\n\ttype WeightInfo = pallet_multisig::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_utility::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype PalletsOrigin = OriginCaller;\n\ttype WeightInfo = pallet_utility::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinVestedTransfer: Balance = 0;\n\tpub UnvestedFundsAllowedWithdrawReasons: WithdrawReasons =\n\t\tWithdrawReasons::except(WithdrawReasons::TRANSFER | WithdrawReasons::RESERVE);\n}\n\nimpl pallet_vesting::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BlockNumberToBalance = ConvertInto;\n\ttype MinVestedTransfer = MinVestedTransfer;\n\ttype UnvestedFundsAllowedWithdrawReasons = UnvestedFundsAllowedWithdrawReasons;\n\ttype WeightInfo = pallet_vesting::weights::SubstrateWeight\u003cRuntime\u003e;\n\tconst MAX_VESTING_SCHEDULES: u32 = 10;\n}\n\nconst fn deposit(items: u32, bytes: u32) -\u003e Balance {\n\t(items as Balance * UNIT + (bytes as Balance) * (5 * MILLIUNIT / 100)) / 10\n}\n\nparameter_types! {\n\tpub const DepositPerItem: Balance = deposit(1, 0);\n\tpub const DepositPerByte: Balance = deposit(0, 1);\n\tpub const DeletionQueueDepth: u32 = 128;\n\tpub DeletionWeightLimit: Weight = RuntimeBlockWeights::get()\n\t\t.per_class\n\t\t.get(DispatchClass::Normal)\n\t\t.max_total\n\t\t.unwrap_or(RuntimeBlockWeights::get().max_block);\n\tpub Schedule: pallet_contracts::Schedule\u003cRuntime\u003e = pallet_contracts::Schedule::\u003cRuntime\u003e{\n\t\tlimits: pallet_contracts::Limits{\n\t\t\tparameters: 256,\n\t\t\t..Default::default()\n\t\t},\n\t\t..Default::default()\n\t};\n}\n#[derive(Default)]\npub struct Psp22Extension;\n\nuse runtime_common::chain_ext::*;\npub(crate) type BalanceOfForChainExt\u003cT\u003e =\n\t\u003c\u003cT as orml_currencies::Config\u003e::MultiCurrency as orml_traits::MultiCurrency\u003c\n\t\t\u003cT as frame_system::Config\u003e::AccountId,\n\t\u003e\u003e::Balance;\n\nimpl\u003cT\u003e ChainExtension\u003cT\u003e for Psp22Extension\nwhere\n\tT: SysConfig\n\t\t+ orml_tokens::Config\u003cCurrencyId = CurrencyId\u003e\n\t\t+ pallet_contracts::Config\n\t\t+ orml_currencies::Config\u003cMultiCurrency = Tokens, AccountId = AccountId\u003e\n\t\t+ orml_currencies_allowance_extension::Config\n\t\t+ dia_oracle::Config,\n\t\u003cT as SysConfig\u003e::AccountId: UncheckedFrom\u003c\u003cT as SysConfig\u003e::Hash\u003e + AsRef\u003c[u8]\u003e,\n{\n\tfn call\u003cE: Ext\u003e(\u0026mut self, mut env: Environment\u003cE, InitState\u003e) -\u003e Result\u003cRetVal, DispatchError\u003e\n\twhere\n\t\tE: Ext\u003cT = T\u003e,\n\t\t\u003cE::T as SysConfig\u003e::AccountId: UncheckedFrom\u003c\u003cE::T as SysConfig\u003e::Hash\u003e + AsRef\u003c[u8]\u003e,\n\t{\n\t\tlet func_id = env.func_id();\n\n\t\twarn!(\"Calling function with ID {} from Psp22Extension\", func_id);\n\n\t\t// debug_message weight is a good approximation of the additional overhead of going\n\t\t// from contract layer to substrate layer.\n\t\tlet overhead_weight = Weight::from_parts(\n\t\t\t\u003cT as pallet_contracts::Config\u003e::Schedule::get()\n\t\t\t\t.host_fn_weights\n\t\t\t\t.debug_message\n\t\t\t\t.ref_time(),\n\t\t\t0,\n\t\t);\n\n\t\tmatch func_id {\n\t\t\t// totalSupply(currency)\n\t\t\t1101 =\u003e {\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight = \u003cT as frame_system::Config\u003e::DbWeight::get().reads(1);\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet currency_id: CurrencyId = chain_ext::decode(input)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to decode input\"))?;\n\n\t\t\t\twarn!(\"Calling totalSupply() for currency {:?}\", currency_id);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to decode input\")\n\t\t\t\t);\n\n\t\t\t\tlet total_supply =\n\t\t\t\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::total_issuance(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t);\n\n\t\t\t\tenv.write(\u0026total_supply.encode(), false, None).map_err(|_| {\n\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to call total_issuance\")\n\t\t\t\t})?;\n\t\t\t},\n\t\t\t// balanceOf(currency, account)\n\t\t\t1102 =\u003e {\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight = \u003cT as frame_system::Config\u003e::DbWeight::get().reads(1);\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (currency_id, account_id): (CurrencyId, T::AccountId) =\n\t\t\t\t\tchain_ext::decode(input).map_err(|_| {\n\t\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to decode input\")\n\t\t\t\t\t})?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling balanceOf() for currency {:?} and account {:?}\",\n\t\t\t\t\tcurrency_id, account_id\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\",)\n\t\t\t\t);\n\n\t\t\t\tlet balance =\n\t\t\t\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::free_balance(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\t\u0026account_id,\n\t\t\t\t\t);\n\n\t\t\t\tenv.write(\u0026balance.encode(), false, None)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to call balance\"))?;\n\t\t\t},\n\t\t\t// transfer(currency, recipient, amount)\n\t\t\t1103 =\u003e {\n\t\t\t\tlet ext = env.ext();\n\t\t\t\tlet caller = ext.caller().clone();\n\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\t// Here we use weights for non native currency as worst case scenario, since we can't know whether it's native or not until we've already read from contract env.\n\t\t\t\tlet base_weight =\n\t\t\t\t\t\u003cT as orml_currencies::Config\u003e::WeightInfo::transfer_non_native_currency();\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (currency_id, recipient, amount): (\n\t\t\t\t\tCurrencyId,\n\t\t\t\t\tT::AccountId,\n\t\t\t\t\tBalanceOfForChainExt\u003cT\u003e,\n\t\t\t\t) = chain_ext::decode(input)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to decode input\"))?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling transfer() sending {:?} {:?}, from {:?} to {:?}\",\n\t\t\t\t\tamount, currency_id, caller, recipient\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\",)\n\t\t\t\t);\n\n\t\t\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::transfer(\n\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\u0026caller,\n\t\t\t\t\t\u0026recipient,\n\t\t\t\t\tamount,\n\t\t\t\t)?;\n\t\t\t},\n\t\t\t// allowance(currency, owner, spender)\n\t\t\t1104 =\u003e {\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight = \u003cT as frame_system::Config\u003e::DbWeight::get().reads(1);\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (currency_id, owner, spender): (CurrencyId, T::AccountId, T::AccountId) =\n\t\t\t\t\tchain_ext::decode(input).map_err(|_| {\n\t\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to decode input\")\n\t\t\t\t\t})?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling allowance() for currency {:?}, owner {:?} and spender {:?}\",\n\t\t\t\t\tcurrency_id, owner, spender\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\")\n\t\t\t\t);\n\n\t\t\t\tlet allowance = orml_currencies_allowance_extension::Pallet::\u003cT\u003e::allowance(\n\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\u0026owner,\n\t\t\t\t\t\u0026spender,\n\t\t\t\t);\n\n\t\t\t\tenv.write(\u0026allowance.encode(), false, None)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to call balance\"))?;\n\t\t\t},\n\t\t\t// approve(currency, spender, amount)\n\t\t\t1105 =\u003e {\n\t\t\t\tlet ext = env.ext();\n\t\t\t\tlet caller = ext.caller().clone();\n\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight =\n\t\t\t\t\t\u003c\u003cT as AllowanceConfig\u003e::WeightInfo as AllowanceWeightInfo\u003e::approve();\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (currency_id, spender, amount): (\n\t\t\t\t\tCurrencyId,\n\t\t\t\t\tT::AccountId,\n\t\t\t\t\tBalanceOfForChainExt\u003cT\u003e,\n\t\t\t\t) = chain_ext::decode(input)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to decode input\"))?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling approve() allowing spender {:?} to transfer {:?} {:?} from {:?}\",\n\t\t\t\t\tspender, amount, currency_id, caller\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\",)\n\t\t\t\t);\n\n\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::do_approve_transfer(\n\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\u0026caller,\n\t\t\t\t\t\u0026spender,\n\t\t\t\t\tamount,\n\t\t\t\t)?;\n\t\t\t},\n\t\t\t// transfer_from(sender, currency, recipient, amount)\n\t\t\t1106 =\u003e {\n\t\t\t\tlet ext = env.ext();\n\t\t\t\tlet caller = ext.caller().clone();\n\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight =\n\t\t\t\t\t\u003c\u003cT as AllowanceConfig\u003e::WeightInfo as AllowanceWeightInfo\u003e::transfer_from();\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (owner, currency_id, recipient, amount): (\n\t\t\t\t\tT::AccountId,\n\t\t\t\t\tCurrencyId,\n\t\t\t\t\tT::AccountId,\n\t\t\t\t\tBalanceOfForChainExt\u003cT\u003e,\n\t\t\t\t) = chain_ext::decode(input)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to decode input\"))?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling transfer_from() for caller {:?}, sending {:?} {:?}, from {:?} to {:?}\",\n\t\t\t\t\tcaller, amount, currency_id, owner, recipient\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\",)\n\t\t\t\t);\n\n\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::do_transfer_approved(\n\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\u0026owner,\n\t\t\t\t\t\u0026caller,\n\t\t\t\t\t\u0026recipient,\n\t\t\t\t\tamount,\n\t\t\t\t)?;\n\t\t\t},\n\n\t\t\t// get_coin_info(blockchain, symbol)\n\t\t\t1200 =\u003e {\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight = \u003cT as frame_system::Config\u003e::DbWeight::get().reads(1);\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet (blockchain, symbol): (Blockchain, Symbol) = env.read_as()?;\n\n\t\t\t\tlet result = \u003cdia_oracle::Pallet\u003cT\u003e as DiaOracle\u003e::get_coin_info(\n\t\t\t\t\tblockchain.to_trimmed_vec(),\n\t\t\t\t\tsymbol.to_trimmed_vec(),\n\t\t\t\t);\n\n\t\t\t\twarn!(\"Calling get_coin_info() for: {:?}:{:?}\", blockchain, symbol);\n\n\t\t\t\tlet result = match result {\n\t\t\t\t\tOk(coin_info) =\u003e\n\t\t\t\t\t\tResult::\u003cCoinInfo, ChainExtensionError\u003e::Ok(CoinInfo::from(coin_info)),\n\t\t\t\t\tErr(e) =\u003e\n\t\t\t\t\t\tResult::\u003cCoinInfo, ChainExtensionError\u003e::Err(ChainExtensionError::from(e)),\n\t\t\t\t};\n\t\t\t\tenv.write(\u0026result.encode(), false, None).map_err(|_| {\n\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to call 'price feed'\")\n\t\t\t\t})?;\n\t\t\t},\n\t\t\t_ =\u003e {\n\t\t\t\terror!(\"Called an unregistered `func_id`: {:}\", func_id);\n\t\t\t\treturn Err(DispatchError::Other(\"Unimplemented func_id\"))\n\t\t\t},\n\t\t}\n\n\t\tOk(RetVal::Converging(0))\n\t}\n\n\tfn enabled() -\u003e bool {\n\t\ttrue\n\t}\n}\n\nimpl pallet_contracts::Config for Runtime {\n\ttype Time = Timestamp;\n\ttype Randomness = RandomnessCollectiveFlip;\n\ttype Currency = Balances;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype CallFilter = frame_support::traits::Nothing;\n\ttype DepositPerItem = DepositPerItem;\n\ttype DepositPerByte = DepositPerByte;\n\ttype CallStack = [pallet_contracts::Frame\u003cSelf\u003e; 5];\n\ttype WeightPrice = pallet_transaction_payment::Pallet\u003cSelf\u003e;\n\ttype WeightInfo = pallet_contracts::weights::SubstrateWeight\u003cSelf\u003e;\n\ttype ChainExtension = Psp22Extension;\n\ttype DeletionQueueDepth = DeletionQueueDepth;\n\ttype DeletionWeightLimit = DeletionWeightLimit;\n\ttype Schedule = Schedule;\n\ttype AddressGenerator = pallet_contracts::DefaultAddressGenerator;\n\ttype MaxCodeLen = ConstU32\u003c{ 123 * 1024 }\u003e;\n\ttype MaxStorageKeyLen = ConstU32\u003c128\u003e;\n\ttype UnsafeUnstableInterface = ConstBool\u003ctrue\u003e;\n\ttype MaxDebugBufferLen = ConstU32\u003c{ 2 * 1024 * 1024 }\u003e;\n}\n\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {}\n\nimpl orml_currencies_allowance_extension::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo =\n\t\torml_currencies_allowance_extension::default_weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxAllowedCurrencies = ConstU32\u003c256\u003e;\n}\n\nparameter_types! {\n\tpub const BasicDeposit: Balance = 10 * UNIT;       // 258 bytes on-chain\n\tpub const FieldDeposit: Balance = 25 * MILLIUNIT;  // 66 bytes on-chain\n\tpub const SubAccountDeposit: Balance = 2 * UNIT;   // 53 bytes on-chain\n\tpub const MaxSubAccounts: u32 = 100;\n\tpub const MaxAdditionalFields: u32 = 100;\n\tpub const MaxRegistrars: u32 = 20;\n}\n\ntype EnsureRootOrHalfCouncil = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_identity::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BasicDeposit = BasicDeposit;\n\ttype FieldDeposit = FieldDeposit;\n\ttype SubAccountDeposit = SubAccountDeposit;\n\ttype MaxSubAccounts = MaxSubAccounts;\n\ttype MaxAdditionalFields = MaxAdditionalFields;\n\ttype MaxRegistrars = MaxRegistrars;\n\ttype Slashed = Treasury;\n\ttype ForceOrigin = EnsureRootOrHalfCouncil;\n\ttype RegistrarOrigin = EnsureRootOrHalfCouncil;\n\ttype WeightInfo = pallet_identity::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl dia_oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype AuthorityId = dia_oracle::crypto::DiaAuthId;\n\ttype WeightInfo = dia_oracle::weights::DiaWeightInfo\u003cRuntime\u003e;\n}\n\nimpl frame_system::offchain::SigningTypes for Runtime {\n\ttype Public = \u003cSignature as sp_runtime::traits::Verify\u003e::Signer;\n\ttype Signature = Signature;\n}\n\nimpl\u003cLocalCall\u003e frame_system::offchain::CreateSignedTransaction\u003cLocalCall\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cLocalCall\u003e,\n{\n\tfn create_transaction\u003cC: frame_system::offchain::AppCrypto\u003cSelf::Public, Self::Signature\u003e\u003e(\n\t\tcall: RuntimeCall,\n\t\tpublic: \u003cSignature as sp_runtime::traits::Verify\u003e::Signer,\n\t\taccount: AccountId,\n\t\tindex: Index,\n\t) -\u003e Option\u003c(\n\t\tRuntimeCall,\n\t\t\u003cUncheckedExtrinsic as sp_runtime::traits::Extrinsic\u003e::SignaturePayload,\n\t)\u003e {\n\t\tlet period = BlockHashCount::get() as u64;\n\t\tlet current_block = System::block_number().saturated_into::\u003cu64\u003e().saturating_sub(1);\n\t\tlet tip = 0;\n\t\tlet extra: SignedExtra = (\n\t\t\tframe_system::CheckNonZeroSender::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckSpecVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckTxVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckGenesis::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckEra::\u003cRuntime\u003e::from(generic::Era::mortal(period, current_block)),\n\t\t\tframe_system::CheckNonce::\u003cRuntime\u003e::from(index),\n\t\t\tframe_system::CheckWeight::\u003cRuntime\u003e::new(),\n\t\t\tpallet_transaction_payment::ChargeTransactionPayment::\u003cRuntime\u003e::from(tip),\n\t\t);\n\n\t\tlet raw_payload = SignedPayload::new(call, extra).ok()?;\n\t\tlet signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;\n\t\tlet address = account;\n\t\tlet (call, extra, _) = raw_payload.deconstruct();\n\t\tSome((call, (sp_runtime::MultiAddress::Id(address), signature.into(), extra)))\n\t}\n}\n\npub struct CurrencyConvert;\nimpl currency::CurrencyConversion\u003ccurrency::Amount\u003cRuntime\u003e, CurrencyId\u003e for CurrencyConvert {\n\tfn convert(\n\t\tamount: \u0026currency::Amount\u003cRuntime\u003e,\n\t\tto: CurrencyId,\n\t) -\u003e Result\u003ccurrency::Amount\u003cRuntime\u003e, DispatchError\u003e {\n\t\tOracle::convert(amount, to)\n\t}\n}\n\nparameter_types! {\n\tpub const RelayChainCurrencyId: CurrencyId = XCM(0);\n}\nimpl currency::Config for Runtime {\n\ttype UnsignedFixedPoint = UnsignedFixedPoint;\n\ttype SignedInner = SignedInner;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype Balance = Balance;\n\ttype GetRelayChainCurrencyId = RelayChainCurrencyId;\n\ttype AssetConversion = primitives::AssetConversion;\n\ttype BalanceConversion = primitives::BalanceConversion;\n\ttype CurrencyConversion = CurrencyConvert;\n\ttype AmountCompatibility = primitives::StellarCompatibility;\n}\n\nparameter_types! {\n\tpub const FarmingKeeperPalletId: PalletId = PalletId(*b\"fo/fmkpr\");\n\tpub const FarmingRewardIssuerPalletId: PalletId = PalletId(*b\"fo/fmrir\");\n\tpub FoucocoTreasuryAccount: AccountId = TreasuryPalletId::get().into_account_truncating();\n}\n\nimpl farming::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CurrencyId = CurrencyId;\n\ttype MultiCurrency = Currencies;\n\ttype ControlOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype WeightInfo = farming::weights::BifrostWeight\u003cRuntime\u003e;\n\ttype TreasuryAccount = FoucocoTreasuryAccount;\n\ttype Keeper = FarmingKeeperPalletId;\n\ttype RewardIssuer = FarmingRewardIssuerPalletId;\n}\n\nimpl security::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = security::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype SignedInner = SignedInner;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype CurrencyId = CurrencyId;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub struct DataFeederBenchmark\u003cK, V, A\u003e(PhantomData\u003c(K, V, A)\u003e);\n\n#[cfg(feature = \"runtime-benchmarks\")]\nimpl\u003cK, V, A\u003e orml_traits::DataFeeder\u003cK, V, A\u003e for DataFeederBenchmark\u003cK, V, A\u003e {\n\tfn feed_value(_who: A, _key: K, _value: V) -\u003e DispatchResult {\n\t\tOk(())\n\t}\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nimpl\u003cK, V, A\u003e orml_traits::DataProvider\u003cK, V\u003e for DataFeederBenchmark\u003cK, V, A\u003e {\n\tfn get(_key: \u0026K) -\u003e Option\u003cV\u003e {\n\t\tNone\n\t}\n}\n\nimpl oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = oracle::SubstrateWeight\u003cRuntime\u003e;\n\ttype DataProvider = DataProviderImpl;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype DataFeedProvider = DataFeederBenchmark\u003c\n\t\toracle::OracleKey,\n\t\toracle::TimestampedValue\u003cUnsignedFixedPoint, Moment\u003e,\n\t\tSelf::AccountId,\n\t\u003e;\n}\n\nparameter_types! {\n\tpub const OrganizationLimit: u32 = 255;\n\tpub const ValidatorLimit: u32 = 255;\n\tpub const IsPublicNetwork: bool = false;\n}\n\nimpl stellar_relay::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OrganizationId = u128;\n\ttype OrganizationLimit = OrganizationLimit;\n\ttype ValidatorLimit = ValidatorLimit;\n\ttype IsPublicNetwork = IsPublicNetwork;\n\ttype WeightInfo = stellar_relay::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl reward::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype RewardId = VaultId;\n\ttype CurrencyId = CurrencyId;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n}\n\nparameter_types! {\n\tpub const FeePalletId: PalletId = PalletId(*b\"mod/fees\");\n\tpub const VaultRegistryPalletId: PalletId = PalletId(*b\"mod/vreg\");\n\n\tpub const MaxExpectedValue: UnsignedFixedPoint = UnsignedFixedPoint::from_inner(\u003cUnsignedFixedPoint as FixedPointNumber\u003e::DIV);\n\tpub FeeAccount: AccountId = FeePalletId::get().into_account_truncating();\n}\n\nimpl fee::Config for Runtime {\n\ttype FeePalletId = FeePalletId;\n\ttype WeightInfo = fee::SubstrateWeight\u003cRuntime\u003e;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype SignedInner = SignedInner;\n\ttype UnsignedFixedPoint = UnsignedFixedPoint;\n\ttype UnsignedInner = UnsignedInner;\n\ttype VaultRewards = VaultRewards;\n\ttype VaultStaking = VaultStaking;\n\ttype OnSweep = currency::SweepFunds\u003cRuntime, FeeAccount\u003e;\n\ttype MaxExpectedValue = MaxExpectedValue;\n}\n\nimpl vault_registry::Config for Runtime {\n\ttype PalletId = VaultRegistryPalletId;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype WeightInfo = vault_registry::SubstrateWeight\u003cRuntime\u003e;\n\ttype GetGriefingCollateralCurrencyId = NativeCurrencyId;\n}\n\nimpl redeem::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = redeem::SubstrateWeight\u003cRuntime\u003e;\n}\n\npub struct BlockNumberToBalance;\n\nimpl sp_runtime::traits::Convert\u003cBlockNumber, Balance\u003e for BlockNumberToBalance {\n\tfn convert(a: BlockNumber) -\u003e Balance {\n\t\ta.into()\n\t}\n}\n\nimpl issue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BlockNumberToBalance = BlockNumberToBalance;\n\ttype WeightInfo = issue::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl nomination::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = nomination::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl replace::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = replace::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl\u003cC\u003e frame_system::offchain::SendTransactionTypes\u003cC\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cC\u003e,\n{\n\ttype Extrinsic = UncheckedExtrinsic;\n\ttype OverarchingCall = RuntimeCall;\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\t// System support stuff.\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 0,\n\t\tParachainSystem: cumulus_pallet_parachain_system::{\n\t\t\tPallet, Call, Config, Storage, Inherent, Event\u003cT\u003e, ValidateUnsigned,\n\t\t} = 1,\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent} = 2,\n\t\tParachainInfo: parachain_info::{Pallet, Storage, Config} = 3,\n\n\t\t// Monetary stuff.\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 10,\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event\u003cT\u003e} = 11,\n\n\t\t// Governance\n\t\tSudo: pallet_sudo::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 12,\n\t\tDemocracy: pallet_democracy::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 13,\n\t\tCouncil: pallet_collective::\u003cInstance1\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e, Event\u003cT\u003e} = 14,\n\t\tTechnicalCommittee: pallet_collective::\u003cInstance2\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e,  Event\u003cT\u003e} = 15,\n\t\tScheduler: pallet_scheduler::{Pallet, Call, Storage, Event\u003cT\u003e} = 16,\n\t\tPreimage: pallet_preimage::{Pallet, Call, Storage, Event\u003cT\u003e} = 17,\n\t\tMultisig: pallet_multisig::{Pallet, Call, Storage, Event\u003cT\u003e} = 18,\n\t\tTreasury: pallet_treasury::{Pallet, Call, Storage, Event\u003cT\u003e} = 19,\n\t\tBounties: pallet_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 20,\n\t\tChildBounties: pallet_child_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 21,\n\n\t\t// Consensus support.\n\t\t// The following order MUST NOT be changed: Aura -\u003e Session -\u003e Staking -\u003e Authorship -\u003e AuraExt\n\t\t// Dependencies: AuraExt on Aura, Authorship and Session on ParachainStaking\n\t\tAura: pallet_aura::{Pallet, Storage, Config\u003cT\u003e} = 33,\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e} = 32,\n\t\tParachainStaking: parachain_staking::{Pallet, Call, Storage, Event\u003cT\u003e, Config\u003cT\u003e} = 35,\n\t\tAuthorship: pallet_authorship::{Pallet, Storage} = 30,\n\t\tAuraExt: cumulus_pallet_aura_ext::{Pallet, Storage, Config} = 34,\n\n\t\t// XCM helpers.\n\t\tXcmpQueue: cumulus_pallet_xcmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 40,\n\t\tPolkadotXcm: pallet_xcm::{Pallet, Call, Event\u003cT\u003e, Origin, Config} = 41,\n\t\tCumulusXcm: cumulus_pallet_xcm::{Pallet, Event\u003cT\u003e, Origin} = 42,\n\t\tDmpQueue: cumulus_pallet_dmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 43,\n\n\t\t// Amendments\n\t\tVesting: pallet_vesting::{Pallet, Call, Storage, Event\u003cT\u003e} = 50,\n\t\tUtility: pallet_utility::{Pallet, Call, Event} = 51,\n\t\tCurrencies: orml_currencies::{Pallet, Call, Storage} = 52,\n\t\tTokens: orml_tokens::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 53,\n\t\tXTokens: orml_xtokens::{Pallet, Storage, Call, Event\u003cT\u003e} = 54,\n\t\tIdentity: pallet_identity::{Pallet, Storage, Call, Event\u003cT\u003e} = 55,\n\t\tContracts: pallet_contracts::{Pallet, Storage, Call, Event\u003cT\u003e} = 56,\n\t\tRandomnessCollectiveFlip: pallet_insecure_randomness_collective_flip::{Pallet, Storage} = 57,\n\t\tDiaOracleModule: dia_oracle::{Pallet, Storage, Call, Config\u003cT\u003e, Event\u003cT\u003e} = 58,\n\n\t\tZenlinkProtocol: zenlink_protocol::{Pallet, Call, Storage, Event\u003cT\u003e}  = 59,\n\n\t\t// Spacewalk pallets\n\t\tCurrency: currency::{Pallet} = 60,\n\t\tFee: fee::{Pallet, Call, Config\u003cT\u003e, Storage} = 61,\n\t\tIssue: issue::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 62,\n\t\tNomination: nomination::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 63,\n\t\tOracle: oracle::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 64,\n\t\tRedeem: redeem::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 65,\n\t\tReplace: replace::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 66,\n\t\tSecurity: security::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 67,\n\t\tStellarRelay: stellar_relay::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 68,\n\t\tVaultRegistry: vault_registry::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e, ValidateUnsigned} = 69,\n\t\tVaultRewards: reward::{Pallet, Call, Storage, Event\u003cT\u003e} = 70,\n\t\tVaultStaking: staking::{Pallet, Storage, Event\u003cT\u003e} = 71,\n\n\t\tTokenAllowance: orml_currencies_allowance_extension::{Pallet, Storage, Call, Event\u003cT\u003e} = 80,\n\n\t\tFarming: farming::{Pallet, Call, Storage, Event\u003cT\u003e} = 90,\n\n\t\t// Asset Metadata\n\t\tAssetRegistry: orml_asset_registry::{Pallet, Storage, Call, Event\u003cT\u003e, Config\u003cT\u003e} = 91,\n\t}\n);\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!(\n\t\t[frame_benchmarking, BaselineBench::\u003cRuntime\u003e]\n\t\t[frame_system, SystemBench::\u003cRuntime\u003e]\n\t\t[pallet_balances, Balances]\n\t\t[pallet_session, SessionBench::\u003cRuntime\u003e]\n\t\t[pallet_timestamp, Timestamp]\n\t\t[cumulus_pallet_xcmp_queue, XcmpQueue]\n\n\t\t[fee, Fee]\n\t\t[issue, Issue]\n\t\t[nomination, Nomination]\n\t\t[oracle, Oracle]\n\t\t[redeem, Redeem]\n\t\t[replace, Replace]\n\t\t[stellar_relay, StellarRelay]\n\t\t[vault_registry, VaultRegistry]\n\n\t\t// Other\n\t\t[orml_asset_registry, runtime_common::benchmarking::orml_asset_registry::Pallet::\u003cRuntime\u003e]\n\t\t[pallet_xcm, PolkadotXcm]\n\n\t\t[orml_currencies_allowance_extension, TokenAllowance]\n\t);\n}\n\nimpl_runtime_apis! {\n\timpl sp_consensus_aura::AuraApi\u003cBlock, AuraId\u003e for Runtime {\n\t\tfn slot_duration() -\u003e sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -\u003e Vec\u003cAuraId\u003e {\n\t\t\tAura::authorities().into_inner()\n\t\t}\n\t}\n\n\timpl sp_api::Core\u003cBlock\u003e for Runtime {\n\t\tfn version() -\u003e RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata\u003cBlock\u003e for Runtime {\n\t\tfn metadata() -\u003e OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder\u003cBlock\u003e for Runtime {\n\t\tfn apply_extrinsic(extrinsic: \u003cBlock as BlockT\u003e::Extrinsic) -\u003e ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -\u003e \u003cBlock as BlockT\u003e::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -\u003e Vec\u003c\u003cBlock as BlockT\u003e::Extrinsic\u003e {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(\u0026block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tblock_hash: \u003cBlock as BlockT\u003e::Hash,\n\t\t) -\u003e TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi\u003cBlock\u003e for Runtime {\n\t\tfn offchain_worker(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys\u003cBlock\u003e for Runtime {\n\t\tfn generate_session_keys(seed: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n\t\t\tSessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec\u003cu8\u003e,\n\t\t) -\u003e Option\u003cVec\u003c(Vec\u003cu8\u003e, KeyTypeId)\u003e\u003e {\n\t\t\tSessionKeys::decode_into_raw_public_keys(\u0026encoded)\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi\u003cBlock, AccountId, Index\u003e for Runtime {\n\t\tfn account_nonce(account: AccountId) -\u003e Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi\u003cBlock, Balance\u003e for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t\tfn query_fee_details(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment::FeeDetails\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t\tfn query_weight_to_fee(weight: Weight) -\u003e Balance {\n\t\t\tTransactionPayment::weight_to_fee(weight)\n\t\t}\n\t\tfn query_length_to_fee(length: u32) -\u003e Balance {\n\t\t\tTransactionPayment::length_to_fee(length)\n\t\t}\n\t}\n\n\timpl cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e for Runtime {\n\t\tfn collect_collation_info(header: \u0026\u003cBlock as BlockT\u003e::Header) -\u003e cumulus_primitives_core::CollationInfo {\n\t\t\tParachainSystem::collect_collation_info(header)\n\t\t}\n\t}\n\n\timpl parachain_staking::runtime_api::ParachainStakingApi\u003cBlock, AccountId, Balance\u003e for Runtime {\n\t\tfn get_unclaimed_staking_rewards(account: \u0026AccountId) -\u003e Balance {\n\t\t\tParachainStaking::get_unclaimed_staking_rewards(account)\n\t\t}\n\n\t\tfn get_staking_rates() -\u003e parachain_staking::runtime_api::StakingRates {\n\t\t\tParachainStaking::get_staking_rates()\n\t\t}\n\t}\n\n\timpl dia_oracle_runtime_api::DiaOracleApi\u003cBlock\u003e for Runtime{\n\t\tfn get_value(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::PriceInfo, sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_value(blockchain, symbol)\n\t\t}\n\n\t\tfn get_coin_info(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::CoinInfo,sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_coin_info(blockchain, symbol)\n\t\t}\n\t}\n\n\n\t// zenlink runtime outer apis\n\timpl zenlink_protocol_runtime_api::ZenlinkProtocolApi\u003cBlock, AccountId, ZenlinkAssetId\u003e for Runtime {\n\n\t\tfn get_balance(\n\t\t\tasset_id: ZenlinkAssetId,\n\t\t\towner: AccountId\n\t\t) -\u003e AssetBalance {\n\t\t\t\u003cRuntime as zenlink_protocol::Config\u003e::MultiAssetsHandler::balance_of(asset_id, \u0026owner)\n\t\t}\n\n\n\t\tfn get_pair_by_asset_id(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId\n\t\t) -\u003e Option\u003cPairInfo\u003cAccountId, AssetBalance, ZenlinkAssetId\u003e\u003e {\n\t\t\tZenlinkProtocol::get_pair_by_asset_id(asset_0, asset_1)\n\t\t}\n\n\t\tfn get_amount_in_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::desired_in_amount(supply, path)\n\t\t}\n\n\t\tfn get_amount_out_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::supply_out_amount(supply, path)\n\t\t}\n\n\t\tfn get_estimate_lptoken(\n\t\t\ttoken_0: ZenlinkAssetId,\n\t\t\ttoken_1: ZenlinkAssetId,\n\t\t\tamount_0_desired: AssetBalance,\n\t\t\tamount_1_desired: AssetBalance,\n\t\t\tamount_0_min: AssetBalance,\n\t\t\tamount_1_min: AssetBalance,\n\t\t) -\u003e AssetBalance{\n\t\t\tZenlinkProtocol::get_estimate_lptoken(\n\t\t\t\ttoken_0,\n\t\t\t\ttoken_1,\n\t\t\t\tamount_0_desired,\n\t\t\t\tamount_1_desired,\n\t\t\t\tamount_0_min,\n\t\t\t\tamount_1_min\n\t\t\t)\n\t\t}\n\n\t\tfn calculate_remove_liquidity(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId,\n\t\t\tamount: AssetBalance,\n\t\t) -\u003e Option\u003c(AssetBalance, AssetBalance)\u003e{\n\t\t\tZenlinkProtocol::calculate_remove_liquidity(\n\t\t\t\tasset_0,\n\t\t\t\tasset_1,\n\t\t\t\tamount,\n\t\t\t)\n\t\t}\n\t}\n\n\timpl farming_rpc_runtime_api::FarmingRuntimeApi\u003cBlock, AccountId, PoolId, CurrencyId\u003e for Runtime {\n\t\tfn get_farming_rewards(who: AccountId, pid: PoolId) -\u003e Vec\u003c(CurrencyId, Balance)\u003e {\n\t\t\tFarming::get_farming_rewards(\u0026who, pid).unwrap_or(Vec::new())\n\t\t}\n\n\t\tfn get_gauge_rewards(who: AccountId, pid: PoolId) -\u003e Vec\u003c(CurrencyId, Balance)\u003e {\n\t\t\tFarming::get_gauge_rewards(\u0026who, pid).unwrap_or(Vec::new())\n\t\t}\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\timpl frame_try_runtime::TryRuntime\u003cBlock\u003e for Runtime {\n\t\tfn on_runtime_upgrade() -\u003e (Weight, Weight) {\n\t\t\tlog::info!(\"try-runtime::on_runtime_upgrade foucoco.\");\n\t\t\tlet weight = Executive::try_runtime_upgrade().unwrap();\n\t\t\t(weight, RuntimeBlockWeights::get().max_block)\n\t\t}\n\n\t\tfn execute_block_no_check(block: Block) -\u003e Weight {\n\t\t\tExecutive::execute_block_no_check(block)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark\u003cBlock\u003e for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -\u003e (\n\t\t\tVec\u003cframe_benchmarking::BenchmarkList\u003e,\n\t\t\tVec\u003cframe_support::traits::StorageInfo\u003e,\n\t\t) {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\tlet mut list = Vec::\u003cBenchmarkList\u003e::new();\n\t\t\tlist_benchmarks!(list, extra);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -\u003e Result\u003cVec\u003cframe_benchmarking::BenchmarkBatch\u003e, sp_runtime::RuntimeString\u003e {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, TrackedStorageKey};\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\t\t\timpl baseline::Config for Runtime {}\n\t\t\timpl runtime_common::benchmarking::orml_asset_registry::Config for Runtime {}\n\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\timpl cumulus_pallet_session_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec\u003cTrackedStorageKey\u003e = vec![\n\t\t\t\t// Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t// Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t// Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t// Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t// System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::\u003cBenchmarkBatch\u003e::new();\n\t\t\tlet params = (\u0026config, \u0026whitelist);\n\t\t\tadd_benchmarks!(params, batches);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n\n\timpl module_issue_rpc_runtime_api::IssueApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tIssueRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_issue_requests(account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tIssue::get_issue_requests_for_account(account_id)\n\t\t}\n\n\t\tfn get_vault_issue_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tIssue::get_issue_requests_for_vault(vault_id)\n\t\t}\n\t}\n\n\timpl module_vault_registry_rpc_runtime_api::VaultRegistryApi\u003c\n\t\tBlock,\n\t\tVaultId,\n\t\tBalance,\n\t\tUnsignedFixedPoint,\n\t\tCurrencyId,\n\t\tAccountId,\n\t\u003e for Runtime {\n\t\tfn get_vault_collateral(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::compute_collateral(\u0026vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\n\t\tfn get_vaults_by_account_id(account_id: AccountId) -\u003e Result\u003cVec\u003cVaultId\u003e, DispatchError\u003e {\n\t\t\tVaultRegistry::get_vaults_by_account_id(account_id)\n\t\t}\n\n\t\tfn get_vault_total_collateral(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_backing_collateral(\u0026vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\n\t\tfn get_premium_redeem_vaults() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_premium_redeem_vaults()?;\n\t\t\tOk(result.iter().map(|v| (v.0.clone(), BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\n\t\tfn get_vaults_with_issuable_tokens() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_vaults_with_issuable_tokens()?;\n\t\t\tOk(result.into_iter().map(|v| (v.0, BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\n\t\tfn get_vaults_with_redeemable_tokens() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_vaults_with_redeemable_tokens()?;\n\t\t\tOk(result.into_iter().map(|v| (v.0, BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\n\t\tfn get_issuable_tokens_from_vault(vault: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_issuable_tokens_from_vault(\u0026vault)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\n\t\tfn get_collateralization_from_vault(vault: VaultId, only_issued: bool) -\u003e Result\u003cUnsignedFixedPoint, DispatchError\u003e {\n\t\t\tVaultRegistry::get_collateralization_from_vault(vault, only_issued)\n\t\t}\n\n\t\tfn get_collateralization_from_vault_and_collateral(vault: VaultId, collateral: BalanceWrapper\u003cBalance\u003e, only_issued: bool) -\u003e Result\u003cUnsignedFixedPoint, DispatchError\u003e {\n\t\t\tlet amount = currency::Amount::new(collateral.amount, vault.collateral_currency());\n\t\t\tVaultRegistry::get_collateralization_from_vault_and_collateral(vault, \u0026amount, only_issued)\n\t\t}\n\n\t\tfn get_required_collateral_for_wrapped(amount_wrapped: BalanceWrapper\u003cBalance\u003e, wrapped_currency_id: CurrencyId, collateral_currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet amount_wrapped = currency::Amount::new(amount_wrapped.amount, wrapped_currency_id);\n\t\t\tlet result = VaultRegistry::get_required_collateral_for_wrapped(\u0026amount_wrapped, collateral_currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\n\t\tfn get_required_collateral_for_vault(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_required_collateral_for_vault(vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t}\n\n\timpl module_redeem_rpc_runtime_api::RedeemApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tRedeemRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_redeem_requests(account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tRedeem::get_redeem_requests_for_account(account_id)\n\t\t}\n\n\t\tfn get_vault_redeem_requests(vault_account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tRedeem::get_redeem_requests_for_vault(vault_account_id)\n\t\t}\n\t}\n\n\timpl module_replace_rpc_runtime_api::ReplaceApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tReplaceRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_old_vault_replace_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tReplace::get_replace_requests_for_old_vault(vault_id)\n\t\t}\n\n\t\tfn get_new_vault_replace_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tReplace::get_replace_requests_for_new_vault(vault_id)\n\t\t}\n\t}\n\n\timpl pallet_contracts::ContractsApi\u003cBlock, AccountId, Balance, BlockNumber, Hash\u003e\n\t\tfor Runtime\n\t{\n\t\tfn call(\n\t\t\torigin: AccountId,\n\t\t\tdest: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tinput_data: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractExecResult\u003cBalance\u003e {\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_call(\n\t\t\t\torigin,\n\t\t\t\tdest,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tinput_data,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT,\n\t\t\t\tpallet_contracts::Determinism::Deterministic,\n\t\t\t)\n\t\t}\n\n\t\tfn instantiate(\n\t\t\torigin: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tcode: pallet_contracts_primitives::Code\u003cHash\u003e,\n\t\t\tdata: Vec\u003cu8\u003e,\n\t\t\tsalt: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractInstantiateResult\u003cAccountId, Balance\u003e\n\t\t{\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_instantiate(\n\t\t\t\torigin,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tcode,\n\t\t\t\tdata,\n\t\t\t\tsalt,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT\n\t\t\t)\n\t\t}\n\n\t\tfn upload_code(\n\t\t\torigin: AccountId,\n\t\t\tcode: Vec\u003cu8\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tdeterminism: pallet_contracts::Determinism,\n\t\t) -\u003e pallet_contracts_primitives::CodeUploadResult\u003cHash, Balance\u003e\n\t\t{\n\t\t\tContracts::bare_upload_code(origin, code, storage_deposit_limit, determinism)\n\t\t}\n\n\t\tfn get_storage(\n\t\t\taddress: AccountId,\n\t\t\tkey: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::GetStorageResult {\n\t\t\tContracts::get_storage(address, key)\n\t\t}\n\t}\n\n\timpl module_oracle_rpc_runtime_api::OracleApi\u003cBlock, Balance, CurrencyId\u003e for Runtime {\n\t\tfn currency_to_usd(amount:BalanceWrapper\u003cBalance\u003e, currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = Oracle::currency_to_usd(amount.amount, currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result})\n\t\t}\n\n\t\tfn usd_to_currency(amount:BalanceWrapper\u003cBalance\u003e, currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = Oracle::usd_to_currency(amount.amount, currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result})\n\t\t}\n\t}\n\n}\n\nstruct CheckInherents;\n\nimpl cumulus_pallet_parachain_system::CheckInherents\u003cBlock\u003e for CheckInherents {\n\tfn check_inherents(\n\t\tblock: \u0026Block,\n\t\trelay_state_proof: \u0026cumulus_pallet_parachain_system::RelayChainStateProof,\n\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\tlet relay_chain_slot = relay_state_proof\n\t\t\t.read_slot()\n\t\t\t.expect(\"Could not read the relay chain slot from the proof\");\n\n\t\tlet inherent_data =\n\t\t\tcumulus_primitives_timestamp::InherentDataProvider::from_relay_chain_slot_and_duration(\n\t\t\t\trelay_chain_slot,\n\t\t\t\tsp_std::time::Duration::from_secs(6),\n\t\t\t)\n\t\t\t.create_inherent_data()\n\t\t\t.expect(\"Could not create the timestamp inherent data\");\n\n\t\tinherent_data.check_extrinsics(block)\n\t}\n}\n\ncumulus_pallet_parachain_system::register_validate_block! {\n\tRuntime = Runtime,\n\tBlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::\u003cRuntime, Executive\u003e,\n\tCheckInherents = CheckInherents,\n}\n","traces":[{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1003,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1026,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1041,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1048,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1058,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1059,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1060,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1061,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1063,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1064,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1065,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1066,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1073,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1074,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1077,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1088,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1089,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1098,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":182},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","block_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Importing a block with 0 Extrinsics.\n\t\tpub const BlockExecutionWeight: Weight =  Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000),0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::BlockExecutionWeight::get();\n\n\t\t\t// At least 100 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 100u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 100 µs.\"\n\t\t\t);\n\t\t\t// At most 50 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= 50u64 * constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 50 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","extrinsic_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Executing a NO-OP `System::remarks` Extrinsic.\n\t\tpub const ExtrinsicBaseWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::ExtrinsicBaseWeight::get();\n\n\t\t\t// At least 10 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 10u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 10 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","mod.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Expose the auto generated weight files.\n\npub mod block_weights;\npub mod extrinsic_weights;\npub mod orml_asset_registry;\npub mod pallet_xcm;\npub mod paritydb_weights;\npub mod rocksdb_weights;\n\npub use block_weights::constants::BlockExecutionWeight;\npub use extrinsic_weights::constants::ExtrinsicBaseWeight;\npub use paritydb_weights::constants::ParityDbWeight;\npub use rocksdb_weights::constants::RocksDbWeight;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","orml_asset_registry.rs"],"content":"\n//! Autogenerated weights for `orml_asset_registry`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-07-25, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Marcels-MBP`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"foucoco\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// foucoco\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet\n// orml-asset-registry\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// runtime/foucoco/src/weights/orml_asset_registry.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `orml_asset_registry`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e orml_asset_registry::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn register_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `104`\n\t\t//  Estimated: `7138`\n\t\t// Minimum execution time: 18_000_000 picoseconds.\n\t\tWeight::from_parts(19_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 7138))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:2)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn update_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `745`\n\t\t//  Estimated: `8420`\n\t\t// Minimum execution time: 25_000_000 picoseconds.\n\t\tWeight::from_parts(26_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8420))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\tfn set_asset_location() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 0_000 picoseconds.\n\t\tWeight::from_parts(0, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","pallet_xcm.rs"],"content":"\n//! Autogenerated weights for `pallet_xcm`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-06-20, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Bs-MacBook-Pro.local`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"foucoco\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// foucoco\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet=pallet-xcm\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// pallet_xcm.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `pallet_xcm`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e pallet_xcm::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn send() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `245`\n\t\t//  Estimated: `10630`\n\t\t// Minimum execution time: 26_000_000 picoseconds.\n\t\tWeight::from_parts(27_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 10630))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: Benchmark Override (r:0 w:0)\n\t/// Proof Skipped: Benchmark Override (max_values: None, max_size: None, mode: Measured)\n\tfn teleport_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 18_446_744_073_709_551_000 picoseconds.\n\t\tWeight::from_parts(18_446_744_073_709_551_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: ParachainInfo ParachainId (r:1 w:0)\n\t/// Proof: ParachainInfo ParachainId (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn reserve_transfer_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 1489))\n\t\t\t.saturating_add(T::DbWeight::get().reads(1))\n\t}\n\tfn execute() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 8_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn force_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\tfn force_default_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 3_000_000 picoseconds.\n\t\tWeight::from_parts(3_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm QueryCounter (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm QueryCounter (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_subscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `245`\n\t\t//  Estimated: `16315`\n\t\t// Minimum execution time: 30_000_000 picoseconds.\n\t\tWeight::from_parts(31_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 16315))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_unsubscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `428`\n\t\t//  Estimated: `15866`\n\t\t// Minimum execution time: 31_000_000 picoseconds.\n\t\tWeight::from_parts(32_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 15866))\n\t\t\t.saturating_add(T::DbWeight::get().reads(6))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_supported_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `229`\n\t\t//  Estimated: `11119`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(17_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11119))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notifiers() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `233`\n\t\t//  Estimated: `11123`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11123))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:5 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn already_notified_target() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `240`\n\t\t//  Estimated: `13605`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 13605))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:2 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn notify_current_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `312`\n\t\t//  Estimated: `17217`\n\t\t// Minimum execution time: 28_000_000 picoseconds.\n\t\tWeight::from_parts(29_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 17217))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:3 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn notify_target_migration_fail() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `272`\n\t\t//  Estimated: `8687`\n\t\t// Minimum execution time: 10_000_000 picoseconds.\n\t\tWeight::from_parts(11_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8687))\n\t\t\t.saturating_add(T::DbWeight::get().reads(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notify_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `240`\n\t\t//  Estimated: `11130`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11130))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn migrate_and_notify_old_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `316`\n\t\t//  Estimated: `22191`\n\t\t// Minimum execution time: 36_000_000 picoseconds.\n\t\tWeight::from_parts(38_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 22191))\n\t\t\t.saturating_add(T::DbWeight::get().reads(9))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","paritydb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights\n\t\t/// are available for brave runtime engineers who may want to try this out as default.\n\t\tpub const ParityDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::ParityDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","rocksdb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// By default, Substrate uses `RocksDB`, so this will be the weight used throughout\n\t\t/// the runtime.\n\t\tpub const RocksDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::RocksDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","xcm_config.rs"],"content":"use super::{\n\tAccountId, Balance, Balances, CurrencyId, ParachainInfo, ParachainSystem, PolkadotXcm, Runtime,\n\tRuntimeCall, RuntimeEvent, RuntimeOrigin, Tokens, WeightToFee, XcmpQueue,\n};\nuse core::marker::PhantomData;\nuse frame_support::{\n\tlog, match_types, parameter_types,\n\ttraits::{ConstU32, ContainsPair, Everything, Nothing},\n};\nuse orml_traits::{\n\tlocation::{RelativeReserveProvider, Reserve},\n\tparameter_type_with_key,\n};\nuse pallet_xcm::XcmPassthrough;\nuse polkadot_parachain::primitives::Sibling;\nuse polkadot_runtime_common::impls::ToAuthor;\nuse sp_runtime::traits::Convert;\nuse xcm::latest::{prelude::*, Weight as XCMWeight};\nuse xcm_builder::{\n\tAccountId32Aliases, AllowUnpaidExecutionFrom, ConvertedConcreteId, CurrencyAdapter,\n\tEnsureXcmOrigin, FixedWeightBounds, FungiblesAdapter, IsConcrete, NoChecking, ParentIsPreset,\n\tRelayChainAsNative, SiblingParachainAsNative, SiblingParachainConvertsVia,\n\tSignedAccountId32AsNative, SignedToAccountId32, SovereignSignedViaLocation, UsingComponents,\n};\nuse xcm_executor::{\n\ttraits::{JustTry, ShouldExecute},\n\tXcmExecutor,\n};\n\nparameter_types! {\n\tpub const RelayLocation: MultiLocation = MultiLocation::parent();\n\tpub const RelayNetwork: NetworkId = NetworkId::Rococo;\n\tpub RelayChainOrigin: RuntimeOrigin = cumulus_pallet_xcm::Origin::Relay.into();\n\tpub Ancestry: MultiLocation = Parachain(ParachainInfo::parachain_id().into()).into();\n\tpub CheckingAccount: AccountId = PolkadotXcm::check_account();\n\tpub UniversalLocation: InteriorMultiLocation =\n\t\tX2(GlobalConsensus(RelayNetwork::get()), Parachain(ParachainInfo::parachain_id().into()));\n}\n\n/// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used\n/// when determining ownership of accounts for asset transacting and when attempting to use XCM\n/// `Transact` in order to determine the dispatch Origin.\npub type LocationToAccountId = (\n\t// The parent (Relay-chain) origin converts to the parent `AccountId`.\n\tParentIsPreset\u003cAccountId\u003e,\n\t// Sibling parachain origins convert to AccountId via the `ParaId::into`.\n\tSiblingParachainConvertsVia\u003cSibling, AccountId\u003e,\n\t// Straight up local `AccountId32` origins just alias directly to `AccountId`.\n\tAccountId32Aliases\u003cRelayNetwork, AccountId\u003e,\n);\n\n/// CurrencyIdConvert\n/// This type implements conversions from our `CurrencyId` type into `MultiLocation` and vice-versa.\n/// A currency locally is identified with a `CurrencyId` variant but in the network it is identified\n/// in the form of a `MultiLocation`, in this case a pCfg (Para-Id, Currency-Id).\npub struct CurrencyIdConvert;\n\nimpl Convert\u003cCurrencyId, Option\u003cMultiLocation\u003e\u003e for CurrencyIdConvert {\n\tfn convert(id: CurrencyId) -\u003e Option\u003cMultiLocation\u003e {\n\t\tmatch id {\n\t\t\t// CurrencyId::KSM =\u003e Some(MultiLocation::parent()),\n\t\t\tCurrencyId::XCM(f) =\u003e match f {\n\t\t\t\t0 =\u003e Some(MultiLocation::parent()),\n\t\t\t\t_ =\u003e None,\n\t\t\t},\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Option\u003cCurrencyId\u003e {\n\t\tmatch location {\n\t\t\tMultiLocation { parents: 1, interior: Here } =\u003e Some(CurrencyId::XCM(0)),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiAsset, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(a: MultiAsset) -\u003e Option\u003cCurrencyId\u003e {\n\t\tif let MultiAsset { id: AssetId::Concrete(id), fun: _ } = a {\n\t\t\tSelf::convert(id)\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\n/// Convert an incoming `MultiLocation` into a `CurrencyId` if possible.\n/// Here we need to know the canonical representation of all the tokens we handle in order to\n/// correctly convert their `MultiLocation` representation into our internal `CurrencyId` type.\nimpl xcm_executor::traits::Convert\u003cMultiLocation, CurrencyId\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Result\u003cCurrencyId, MultiLocation\u003e {\n\t\tif location == MultiLocation::parent() {\n\t\t\treturn Ok(CurrencyId::XCM(0))\n\t\t}\n\t\tErr(location.clone())\n\t}\n}\n\n/// A `FilterAssetLocation` implementation. Filters multi native assets whose\n/// reserve is same with `origin`.\npub struct MultiNativeAsset\u003cReserveProvider\u003e(PhantomData\u003cReserveProvider\u003e);\nimpl\u003cReserveProvider\u003e ContainsPair\u003cMultiAsset, MultiLocation\u003e for MultiNativeAsset\u003cReserveProvider\u003e\nwhere\n\tReserveProvider: Reserve,\n{\n\tfn contains(asset: \u0026MultiAsset, origin: \u0026MultiLocation) -\u003e bool {\n\t\tif let Some(ref reserve) = ReserveProvider::reserve(asset) {\n\t\t\tif reserve == origin {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tfalse\n\t}\n}\n\n/// Means for transacting assets besides the native currency on this chain.\npub type FungiblesTransactor = FungiblesAdapter\u003c\n\t// Use this fungibles implementation\n\tTokens,\n\t// This means that this adapter should handle any token that `CurrencyIdConvert` can convert\n\t// to `CurrencyId`, the `CurrencyId` type of `Tokens`, the fungibles implementation it uses.\n\tConvertedConcreteId\u003cCurrencyId, Balance, CurrencyIdConvert, JustTry\u003e,\n\t// Convert an XCM MultiLocation into a local account id\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly)\n\tAccountId,\n\t// We dont allow teleports.\n\tNoChecking,\n\t// The account to use for tracking teleports.\n\tCheckingAccount,\n\u003e;\n\n/// Means for transacting the native currency on this chain.\npub type CurrencyTransactor = CurrencyAdapter\u003c\n\t// Use this currency:\n\tBalances,\n\t// Use this currency when it is a fungible asset matching the given location or name:\n\tIsConcrete\u003cRelayLocation\u003e,\n\t// Convert an XCM MultiLocation into a local account id:\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly):\n\tAccountId,\n\t// We don't track any teleports of `Balances`.\n\t(),\n\u003e;\n\n/// Means for transacting assets on this chain.\npub type AssetTransactors = (CurrencyTransactor, FungiblesTransactor);\n\n/// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,\n/// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can\n/// biases the kind of local `Origin` it will become.\npub type XcmOriginToTransactDispatchOrigin = (\n\t// Sovereign account converter; this attempts to derive an `AccountId` from the origin location\n\t// using `LocationToAccountId` and then turn that into the usual `Signed` origin. Useful for\n\t// foreign chains who want to have a local sovereign account on this chain which they control.\n\tSovereignSignedViaLocation\u003cLocationToAccountId, RuntimeOrigin\u003e,\n\t// Native converter for Relay-chain (Parent) location; will converts to a `Relay` origin when\n\t// recognized.\n\tRelayChainAsNative\u003cRelayChainOrigin, RuntimeOrigin\u003e,\n\t// Native converter for sibling Parachains; will convert to a `SiblingPara` origin when\n\t// recognized.\n\tSiblingParachainAsNative\u003ccumulus_pallet_xcm::Origin, RuntimeOrigin\u003e,\n\t// Native signed account converter; this just converts an `AccountId32` origin into a normal\n\t// `Origin::Signed` origin of the same 32-byte value.\n\tSignedAccountId32AsNative\u003cRelayNetwork, RuntimeOrigin\u003e,\n\t// Xcm origins can be represented natively under the Xcm pallet's Xcm origin.\n\tXcmPassthrough\u003cRuntimeOrigin\u003e,\n);\n\nparameter_types! {\n\t// One XCM operation is 1_000_000_000 weight - almost certainly a conservative estimate.\n\tpub UnitWeightCost: XCMWeight = XCMWeight::from_parts(1_000_000_000,0);\n\tpub const MaxInstructions: u32 = 100;\n\tpub SelfLocation: MultiLocation = MultiLocation::new(1, X1(Parachain(ParachainInfo::parachain_id().into())));\n\tpub const BaseXcmWeight: XCMWeight = XCMWeight::from_parts(150_000_000, 0);\n\tpub const MaxAssetsForTransfer: usize = 2;\n}\n\nmatch_types! {\n\tpub type ParentOrParentsExecutivePlurality: impl Contains\u003cMultiLocation\u003e = {\n\t\tMultiLocation { parents: 1, interior: Here } |\n\t\tMultiLocation { parents: 1, interior: X1(Plurality { id: BodyId::Executive, .. }) }\n\t};\n}\n\n//TODO: move DenyThenTry to polkadot's xcm module.\n/// Deny executing the xcm message if it matches any of the Deny filter regardless of anything else.\n/// If it passes the Deny, and matches one of the Allow cases then it is let through.\npub struct DenyThenTry\u003cDeny, Allow\u003e(PhantomData\u003cDeny\u003e, PhantomData\u003cAllow\u003e)\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute;\n\nimpl\u003cDeny, Allow\u003e ShouldExecute for DenyThenTry\u003cDeny, Allow\u003e\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute,\n{\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\tmax_weight: XCMWeight,\n\t\tweight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tDeny::should_execute(origin, instructions, max_weight, weight_credit)?;\n\t\tAllow::should_execute(origin, instructions, max_weight, weight_credit)\n\t}\n}\n\n// See issue #5233\npub struct DenyReserveTransferToRelayChain;\nimpl ShouldExecute for DenyReserveTransferToRelayChain {\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\t_max_weight: XCMWeight,\n\t\t_weight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tif instructions.iter().any(|inst| {\n\t\t\tmatches!(\n\t\t\t\tinst,\n\t\t\t\tInitiateReserveWithdraw {\n\t\t\t\t\treserve: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t..\n\t\t\t\t} | DepositReserveAsset { dest: MultiLocation { parents: 1, interior: Here }, .. } |\n\t\t\t\t\tTransferReserveAsset {\n\t\t\t\t\t\tdest: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t\t..\n\t\t\t\t\t}\n\t\t\t)\n\t\t}) {\n\t\t\treturn Err(()) // Deny\n\t\t}\n\n\t\t// allow reserve transfers to arrive from relay chain\n\t\tif matches!(origin, MultiLocation { parents: 1, interior: Here }) \u0026\u0026\n\t\t\tinstructions.iter().any(|inst| matches!(inst, ReserveAssetDeposited { .. }))\n\t\t{\n\t\t\tlog::warn!(\n\t\t\t\ttarget: \"xcm::barriers\",\n\t\t\t\t\"Unexpected ReserveAssetDeposited from the relay chain\",\n\t\t\t);\n\t\t}\n\t\t// Permit everything else\n\t\tOk(())\n\t}\n}\n\npub type Barrier = AllowUnpaidExecutionFrom\u003cEverything\u003e;\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n\ttype RuntimeCall = RuntimeCall;\n\ttype XcmSender = XcmRouter;\n\t// How to withdraw and deposit an asset.\n\ttype AssetTransactor = AssetTransactors;\n\ttype OriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype IsReserve = MultiNativeAsset\u003cRelativeReserveProvider\u003e;\n\t// Teleporting is disabled.\n\ttype IsTeleporter = ();\n\ttype UniversalLocation = UniversalLocation;\n\ttype Barrier = Barrier;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype Trader =\n\t\tUsingComponents\u003cWeightToFee, RelayLocation, AccountId, Balances, ToAuthor\u003cRuntime\u003e\u003e;\n\ttype ResponseHandler = PolkadotXcm;\n\ttype AssetTrap = PolkadotXcm;\n\ttype AssetLocker = ();\n\ttype AssetExchanger = ();\n\ttype AssetClaims = PolkadotXcm;\n\ttype SubscriptionService = PolkadotXcm;\n\ttype PalletInstancesInfo = crate::AllPalletsWithSystem;\n\ttype MaxAssetsIntoHolding = ConstU32\u003c8\u003e;\n\ttype FeeManager = ();\n\ttype MessageExporter = ();\n\ttype UniversalAliases = Nothing;\n\ttype CallDispatcher = RuntimeCall;\n\ttype SafeCallFilter = Everything;\n}\n\n/// No local origins on this chain are allowed to dispatch XCM sends/executions.\npub type LocalOriginToLocation = SignedToAccountId32\u003cRuntimeOrigin, AccountId, RelayNetwork\u003e;\n\n/// The means for routing XCM messages which are not for local execution into the right message\n/// queues.\npub type XcmRouter = (\n\t// Two routers - use UMP to communicate with the relay chain:\n\tcumulus_primitives_utility::ParentAsUmp\u003cParachainSystem, PolkadotXcm, ()\u003e,\n\t// ..and XCMP to communicate with the sibling chains.\n\tXcmpQueue,\n);\n\nimpl pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyMatcher = ();\n\ttype SendXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmRouter = XcmRouter;\n\ttype ExecuteXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmExecuteFilter = Everything;\n\t// ^ Disable dispatchable execute on the XCM pallet.\n\t// Needs to be `Everything` for local testing.\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype XcmTeleportFilter = Nothing;\n\ttype XcmReserveTransferFilter = Everything;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype UniversalLocation = UniversalLocation;\n\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\n\tconst VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;\n\t// ^ Override for AdvertisedXcmVersion default\n\ttype AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;\n\ttype TrustedLockers = ();\n\ttype SovereignAccountOf = LocationToAccountId;\n\ttype MaxLockers = ConstU32\u003c8\u003e;\n\ttype WeightInfo = crate::weights::pallet_xcm::WeightInfo\u003cRuntime\u003e;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype ReachableDest = ReachableDest;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nparameter_types! {\n\tpub ReachableDest: Option\u003cMultiLocation\u003e = Some(Parent.into());\n}\n\nparameter_type_with_key! {\n\tpub ParachainMinFee: |_location: MultiLocation| -\u003e Option\u003cu128\u003e {\n\t\tNone\n\t};\n}\n\nimpl orml_xtokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype CurrencyId = CurrencyId;\n\ttype CurrencyIdConvert = CurrencyIdConvert;\n\ttype AccountIdToMultiLocation = AccountIdToMultiLocation;\n\ttype SelfLocation = SelfLocation;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype BaseXcmWeight = BaseXcmWeight;\n\ttype MaxAssetsForTransfer = MaxAssetsForTransfer;\n\ttype MinXcmFee = ParachainMinFee; //TODO to support hrmp transfer beetween parachain adjust this parameter\n\ttype MultiLocationsFilter = Everything;\n\ttype ReserveProvider = RelativeReserveProvider;\n\ttype UniversalLocation = UniversalLocation;\n}\n\npub struct AccountIdToMultiLocation;\nimpl Convert\u003cAccountId, MultiLocation\u003e for AccountIdToMultiLocation {\n\tfn convert(account: AccountId) -\u003e MultiLocation {\n\t\tMultiLocation {\n\t\t\tparents: 0,\n\t\t\tinterior: X1(AccountId32 { network: None, id: account.into() }),\n\t\t}\n\t}\n}\n\nimpl cumulus_pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n}\n","traces":[{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","zenlink.rs"],"content":"use core::convert::TryInto;\n\nuse super::*;\n\nuse orml_traits::MultiCurrency;\nuse sp_runtime::{DispatchError, DispatchResult};\nuse sp_std::marker::PhantomData;\n\nuse spacewalk_primitives::CurrencyId;\n\nuse zenlink_protocol::{\n\tAssetId, Config as ZenlinkConfig, GenerateLpAssetId, LocalAssetHandler, ZenlinkMultiAssets,\n};\npub type ZenlinkAssetId = zenlink_protocol::AssetId;\n\nuse runtime_common::{zenlink, zenlink::*};\n\npub struct ZenlinkLPGenerate\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: ZenlinkConfig\u003e GenerateLpAssetId\u003cZenlinkAssetId\u003e for ZenlinkLPGenerate\u003cT\u003e {\n\tfn generate_lp_asset_id(\n\t\tasset_0: ZenlinkAssetId,\n\t\tasset_1: ZenlinkAssetId,\n\t) -\u003e Option\u003cZenlinkAssetId\u003e {\n\t\tzenlink::generate_lp_asset_id(asset_0, asset_1, ParachainInfo::parachain_id().into())\n\t}\n}\n\nparameter_types! {\n\tpub SelfParaId: u32 = ParachainInfo::parachain_id().into();\n\tpub const ZenlinkPalletId: PalletId = PalletId(*b\"/zenlink\");\n\tpub ZenlinkRegisteredParaChains: Vec\u003c(MultiLocation, u128)\u003e = vec![];\n}\nimpl ZenlinkConfig for Runtime {\n\ttype RuntimeEvent = super::RuntimeEvent;\n\ttype MultiAssetsHandler = MultiAssets;\n\ttype PalletId = ZenlinkPalletId;\n\ttype AssetId = AssetId;\n\ttype LpGenerate = ZenlinkLPGenerate\u003cSelf\u003e;\n\ttype TargetChains = ZenlinkRegisteredParaChains;\n\ttype SelfParaId = SelfParaId;\n\ttype WeightInfo = ();\n}\n\ntype MultiAssets = ZenlinkMultiAssets\u003cZenlinkProtocol, Balances, LocalAssetAdaptor\u003cTokens\u003e\u003e;\n\npub struct LocalAssetAdaptor\u003cLocal\u003e(PhantomData\u003cLocal\u003e);\n\nimpl\u003cLocal, AccountId\u003e LocalAssetHandler\u003cAccountId\u003e for LocalAssetAdaptor\u003cLocal\u003e\nwhere\n\tLocal: MultiCurrency\u003cAccountId, CurrencyId = CurrencyId\u003e,\n{\n\tfn local_balance_of(asset_id: ZenlinkAssetId, who: \u0026AccountId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::free_balance(currency_id, \u0026who))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_total_supply(asset_id: ZenlinkAssetId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::total_issuance(currency_id))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_is_exists(asset_id: ZenlinkAssetId) -\u003e bool {\n\t\tmatch zenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into()) {\n\t\t\tOk(_) =\u003e true,\n\t\t\tErr(_) =\u003e false,\n\t\t}\n\t}\n\n\tfn local_transfer(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\ttarget: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e DispatchResult {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::transfer(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\t\u0026target,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local transfer\"))?,\n\t\t\t)\n\t\t} else {\n\t\t\tErr(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\t}\n\n\tfn local_deposit(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::deposit(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local deposit\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n\n\tfn local_withdraw(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::withdraw(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local withdraw\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":44},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","amplitude_tests.rs"],"content":"use crate::{\n\tmock::{kusama_relay_ext, para_ext, ParachainType, USDT_ASSET_ID},\n\ttest_macros::{\n\t\tparachain1_transfer_asset_to_parachain2, parachain1_transfer_asset_to_parachain2_and_back,\n\t\tparachain1_transfer_incorrect_asset_to_parachain2_should_fail,\n\t\ttransfer_10_relay_token_from_parachain_to_relay_chain,\n\t\ttransfer_20_relay_token_from_relay_chain_to_parachain,\n\t},\n\tAMPLITUDE_ID, KUSAMA_ASSETHUB_ID,\n};\n\nuse frame_support::assert_ok;\nuse statemine_runtime as kusama_asset_hub_runtime;\nuse xcm::latest::NetworkId;\nuse xcm_emulator::{decl_test_network, decl_test_parachain, decl_test_relay_chain, TestExt};\n\nconst KSM_FEE_WHEN_TRANSFER_TO_PARACHAIN: polkadot_core_primitives::Balance = 3200000000;\n\ndecl_test_relay_chain! {\n\tpub struct KusamaRelay {\n\t\tRuntime = kusama_runtime::Runtime,\n\t\tXcmConfig = kusama_runtime::xcm_config::XcmConfig,\n\t\tnew_ext = kusama_relay_ext(),\n\t}\n}\n\ndecl_test_parachain! {\n\tpub struct AmplitudeParachain {\n\t\tRuntime = amplitude_runtime::Runtime,\n\t\tRuntimeOrigin = amplitude_runtime::RuntimeOrigin,\n\t\tXcmpMessageHandler = amplitude_runtime::XcmpQueue,\n\t\tDmpMessageHandler = amplitude_runtime::DmpQueue,\n\t\tnew_ext = para_ext(ParachainType::Amplitude),\n\t}\n}\n\ndecl_test_parachain! {\n\tpub struct AssetHubParachain {\n\t\tRuntime = kusama_asset_hub_runtime::Runtime,\n\t\tRuntimeOrigin = kusama_asset_hub_runtime::RuntimeOrigin,\n\t\tXcmpMessageHandler = kusama_asset_hub_runtime::XcmpQueue,\n\t\tDmpMessageHandler = kusama_asset_hub_runtime::DmpQueue,\n\t\tnew_ext = para_ext(ParachainType::KusamaAssetHub),\n\t}\n}\n\ndecl_test_network! {\n\tpub struct KusamaMockNet {\n\t\trelay_chain = KusamaRelay,\n\t\tparachains = vec![\n\t\t\t(1000, AssetHubParachain),\n\t\t\t(2124, AmplitudeParachain),\n\t\t],\n\t}\n}\n\n#[test]\nfn transfer_ksm_from_kusama_to_amplitude() {\n\ttransfer_20_relay_token_from_relay_chain_to_parachain!(\n\t\tKusamaMockNet,\n\t\tkusama_runtime,\n\t\tKusamaRelay,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain,\n\t\tAMPLITUDE_ID,\n\t\tKSM_FEE_WHEN_TRANSFER_TO_PARACHAIN\n\t);\n}\n\n#[test]\nfn transfer_ksm_from_amplitude_to_kusama() {\n\ttransfer_10_relay_token_from_parachain_to_relay_chain!(\n\t\tKusamaMockNet,\n\t\tkusama_runtime,\n\t\tKusamaRelay,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain\n\t);\n}\n\n#[test]\nfn assethub_transfer_incorrect_asset_to_amplitude_should_fail() {\n\tparachain1_transfer_incorrect_asset_to_parachain2_should_fail!(\n\t\tkusama_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain,\n\t\tAMPLITUDE_ID\n\t);\n}\n\n#[test]\nfn assethub_transfer_asset_to_amplitude() {\n\tparachain1_transfer_asset_to_parachain2!(\n\t\tkusama_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tUSDT_ASSET_ID,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain,\n\t\tAMPLITUDE_ID\n\t);\n}\n\n#[test]\nfn assethub_transfer_asset_to_amplitude_and_back() {\n\tlet network_id = NetworkId::Kusama;\n\n\tparachain1_transfer_asset_to_parachain2_and_back!(\n\t\tkusama_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tKUSAMA_ASSETHUB_ID,\n\t\tUSDT_ASSET_ID,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain,\n\t\tAMPLITUDE_ID,\n\t\tnetwork_id\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","lib.rs"],"content":"#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod pendulum_tests;\n\n#[cfg(test)]\nmod amplitude_tests;\n\n#[cfg(test)]\nmod test_macros;\n\npub const PENDULUM_ID: u32 = 2094;\npub const POLKADOT_ASSETHUB_ID: u32 = 1000;\n\npub const AMPLITUDE_ID: u32 = 2124;\npub const KUSAMA_ASSETHUB_ID: u32 = 1000;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","mock.rs"],"content":"use crate::{AMPLITUDE_ID, PENDULUM_ID, KUSAMA_ASSETHUB_ID, POLKADOT_ASSETHUB_ID};\nuse frame_support::traits::GenesisBuild;\nuse pendulum_runtime::CurrencyId;\nuse polkadot_core_primitives::{AccountId, Balance, BlockNumber};\nuse polkadot_parachain::primitives::Id as ParaId;\nuse polkadot_primitives::v2::{MAX_CODE_SIZE, MAX_POV_SIZE};\nuse polkadot_runtime_parachains::configuration::HostConfiguration;\nuse sp_io::TestExternalities;\nuse sp_runtime::traits::AccountIdConversion;\nuse xcm_emulator::Weight;\n\nuse statemint_runtime as polkadot_asset_hub_runtime;\nuse statemine_runtime as kusama_asset_hub_runtime;\n\npub const ALICE: [u8; 32] = [4u8; 32];\npub const BOB: [u8; 32] = [5u8; 32];\n\npub const UNIT: Balance = 1_000_000_000_000;\npub const TEN_UNITS: Balance = 10_000_000_000_000;\n\npub const USDT_ASSET_ID: u32 = 1984; //Real USDT Asset ID of both Polkadot's and Kusama's Asset Hub\npub const INCORRECT_ASSET_ID: u32 = 0; //asset id that pendulum/amplitude does NOT SUPPORT\n\npub const INITIAL_BALANCE: Balance = 1_000_000_000;\npub const ORML_INITIAL_BALANCE: Balance = 100;\n\nmacro_rules! create_test_externalities {\n\t($runtime:ty, $system:ident, $storage:ident) =\u003e {{\n\t\t\u003cpallet_xcm::GenesisConfig as GenesisBuild\u003c$runtime\u003e\u003e::assimilate_storage(\n\t\t\t\u0026pallet_xcm::GenesisConfig { safe_xcm_version: Some(2) },\n\t\t\t\u0026mut $storage,\n\t\t)\n\t\t.unwrap();\n\t\tlet mut ext = sp_io::TestExternalities::new($storage);\n\t\text.execute_with(|| $system::set_block_number(1));\n\t\text\n\t}};\n}\n\nmacro_rules! build_relaychain {\n\t($runtime:ty, $system:tt, $para_account_id: ident) =\u003e {{\n\t\tlet mut t = frame_system::GenesisConfig::default().build_storage::\u003c$runtime\u003e().unwrap();\n\t\tpallet_balances::GenesisConfig::\u003c$runtime\u003e {\n\t\t\tbalances: vec![\n\t\t\t\t(AccountId::from(ALICE), units(100000)),\n\t\t\t\t(AccountId::from(BOB), units(100)),\n\t\t\t\t(para_account_id($para_account_id), 10 * units(100000)),\n\t\t\t],\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.unwrap();\n\t\tpolkadot_runtime_parachains::configuration::GenesisConfig::\u003c$runtime\u003e {\n\t\t\tconfig: default_parachains_host_configuration(),\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.unwrap();\n\n\t\tcreate_test_externalities!($runtime, $system, t)\n\t}};\n}\n\nmacro_rules! build_parachain_with_orml {\n\t($self:ident, $runtime:ty, $system:tt, $balance:tt, $orml_balance:tt) =\u003e {{\n\t\tlet mut t = frame_system::GenesisConfig::default().build_storage::\u003c$runtime\u003e().unwrap();\n\t\tpallet_balances::GenesisConfig::\u003c$runtime\u003e {\n\t\t\tbalances: vec![(AccountId::from(ALICE), $balance), (AccountId::from(BOB), $balance)],\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.unwrap();\n\n\t\torml_tokens::GenesisConfig::\u003c$runtime\u003e {\n\t\t\tbalances: vec![(AccountId::from(BOB), CurrencyId::XCM(0), units($orml_balance))],\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.unwrap();\n\n\t\tbuild_parachain!($self, $runtime, $system, t)\n\t}};\n}\n\nmacro_rules! build_parachain {\n\t($self:ident, $runtime:ty, $system:tt) =\u003e {{\n\t\tlet mut t = frame_system::GenesisConfig::default().build_storage::\u003c$runtime\u003e().unwrap();\n\n\t\tpallet_balances::GenesisConfig::\u003c$runtime\u003e { balances: vec![] }\n\t\t\t.assimilate_storage(\u0026mut t)\n\t\t\t.unwrap();\n\n\t\tbuild_parachain!($self, $runtime, $system, t)\n\t}};\n\n\t($self:ident, $runtime:ty, $system:tt, $storage:ident) =\u003e {{\n\t\t\u003cparachain_info::GenesisConfig as GenesisBuild\u003c$runtime\u003e\u003e::assimilate_storage(\n\t\t\t\u0026parachain_info::GenesisConfig { parachain_id: $self.get_parachain_id().into() },\n\t\t\t\u0026mut $storage,\n\t\t)\n\t\t.unwrap();\n\n\t\tcreate_test_externalities!($runtime, $system, $storage)\n\t}};\n}\n\npub trait Builder\u003cCurrency\u003e {\n\tfn balances(self, balances: Vec\u003c(AccountId, Currency, Balance)\u003e) -\u003e Self;\n\tfn build(self) -\u003e TestExternalities;\n}\n\npub enum ParachainType {\n\tPolkadotAssetHub,\n\tKusamaAssetHub,\n\tPendulum,\n\tAmplitude,\n}\n\npub struct ExtBuilderParachain\u003cCurrency\u003e {\n\tbalances: Vec\u003c(AccountId, Currency, Balance)\u003e,\n\tchain: ParachainType,\n}\n\npub fn units(amount: Balance) -\u003e Balance {\n\tamount * 10u128.saturating_pow(9)\n}\n\npub fn para_account_id(id: u32) -\u003e polkadot_core_primitives::AccountId {\n\tParaId::from(id).into_account_truncating()\n}\n\npub fn polkadot_relay_ext() -\u003e sp_io::TestExternalities {\n\tuse polkadot_runtime::{Runtime, System};\n\tbuild_relaychain!(Runtime, System, PENDULUM_ID)\n}\n\npub fn kusama_relay_ext() -\u003e sp_io::TestExternalities {\n\tuse kusama_runtime::{Runtime, System};\n\tbuild_relaychain!(Runtime, System, AMPLITUDE_ID)\n}\n\nfn default_parachains_host_configuration() -\u003e HostConfiguration\u003cBlockNumber\u003e {\n\tHostConfiguration {\n\t\tminimum_validation_upgrade_delay: 5,\n\t\tvalidation_upgrade_cooldown: 5u32,\n\t\tvalidation_upgrade_delay: 5,\n\t\tcode_retention_period: 1200,\n\t\tmax_code_size: MAX_CODE_SIZE,\n\t\tmax_pov_size: MAX_POV_SIZE,\n\t\tmax_head_data_size: 32 * 1024,\n\t\tgroup_rotation_frequency: 20,\n\t\tchain_availability_period: 4,\n\t\tthread_availability_period: 4,\n\t\tmax_upward_queue_count: 8,\n\t\tmax_upward_queue_size: 1024 * 1024,\n\t\tmax_downward_message_size: 1024,\n\t\tump_service_total_weight: Weight::from_parts(4 * 1_000_000_000, 0),\n\t\tmax_upward_message_size: 50 * 1024,\n\t\tmax_upward_message_num_per_candidate: 5,\n\t\thrmp_sender_deposit: 0,\n\t\thrmp_recipient_deposit: 0,\n\t\thrmp_channel_max_capacity: 8,\n\t\thrmp_channel_max_total_size: 8 * 1024,\n\t\thrmp_max_parachain_inbound_channels: 4,\n\t\thrmp_max_parathread_inbound_channels: 4,\n\t\thrmp_channel_max_message_size: 1024 * 1024,\n\t\thrmp_max_parachain_outbound_channels: 4,\n\t\thrmp_max_parathread_outbound_channels: 4,\n\t\thrmp_max_message_num_per_candidate: 5,\n\t\tdispute_period: 6,\n\t\tno_show_slots: 2,\n\t\tn_delay_tranches: 25,\n\t\tneeded_approvals: 2,\n\t\trelay_vrf_modulo_samples: 2,\n\t\tzeroth_delay_tranche_width: 0,\n\t\t..Default::default()\n\t}\n}\n\npub fn para_ext(chain: ParachainType) -\u003e sp_io::TestExternalities {\n\tmatch chain {\n\t\tParachainType::PolkadotAssetHub =\u003e\n\t\t\tExtBuilderParachain::polkadot_asset_hub_default().balances(vec![]).build(),\n\t\tParachainType::KusamaAssetHub =\u003e\n\t\t\tExtBuilderParachain::kusama_asset_hub_default().balances(vec![]).build(),\n\t\tParachainType::Pendulum =\u003e ExtBuilderParachain::pendulum_default().balances(vec![]).build(),\n\t\tParachainType::Amplitude =\u003e\n\t\t\tExtBuilderParachain::amplitude_default().balances(vec![]).build(),\n\t}\n}\n\nimpl\u003cCurrency\u003e ExtBuilderParachain\u003cCurrency\u003e {\n\tfn get_parachain_id(\u0026self) -\u003e u32 {\n\t\tmatch self.chain {\n\t\t\tParachainType::PolkadotAssetHub =\u003e POLKADOT_ASSETHUB_ID,\n\t\t\tParachainType::KusamaAssetHub =\u003e KUSAMA_ASSETHUB_ID,\n\t\t\tParachainType::Pendulum =\u003e PENDULUM_ID,\n\t\t\tParachainType::Amplitude =\u003e AMPLITUDE_ID,\n\t\t}\n\t}\n}\n\n// ------------------- for Pendulum and Amplitude -------------------\nimpl ExtBuilderParachain\u003cCurrencyId\u003e {\n\tpub fn pendulum_default() -\u003e Self {\n\t\tSelf { balances: vec![], chain: ParachainType::Pendulum }\n\t}\n\n\tpub fn amplitude_default() -\u003e Self {\n\t\tSelf { balances: vec![], chain: ParachainType::Amplitude }\n\t}\n}\n\nimpl Builder\u003cCurrencyId\u003e for ExtBuilderParachain\u003cCurrencyId\u003e {\n\tfn balances(mut self, balances: Vec\u003c(AccountId, CurrencyId, Balance)\u003e) -\u003e Self {\n\t\tself.balances = balances;\n\t\tself\n\t}\n\n\tfn build(self) -\u003e TestExternalities {\n\t\tmatch self.chain {\n\t\t\tParachainType::Pendulum =\u003e {\n\t\t\t\tuse pendulum_runtime::{Runtime, System};\n\t\t\t\tbuild_parachain_with_orml!(\n\t\t\t\t\tself,\n\t\t\t\t\tRuntime,\n\t\t\t\t\tSystem,\n\t\t\t\t\tINITIAL_BALANCE,\n\t\t\t\t\tORML_INITIAL_BALANCE\n\t\t\t\t)\n\t\t\t},\n\t\t\tParachainType::Amplitude =\u003e {\n\t\t\t\tuse amplitude_runtime::{Runtime, System};\n\t\t\t\tbuild_parachain_with_orml!(\n\t\t\t\t\tself,\n\t\t\t\t\tRuntime,\n\t\t\t\t\tSystem,\n\t\t\t\t\tINITIAL_BALANCE,\n\t\t\t\t\tORML_INITIAL_BALANCE\n\t\t\t\t)\n\t\t\t},\n\t\t\t_ =\u003e panic!(\"cannot use this chain to build\"),\n\t\t}\n\t}\n}\n\n// ------------------- for Statemint and Statemine -------------------\nimpl ExtBuilderParachain\u003cu128\u003e {\n\tpub fn polkadot_asset_hub_default() -\u003e Self {\n\t\tSelf { balances: vec![], chain: ParachainType::PolkadotAssetHub }\n\t}\n\n\tpub fn kusama_asset_hub_default() -\u003e Self {\n\t\tSelf { balances: vec![], chain: ParachainType::KusamaAssetHub }\n\t}\n}\n\nimpl Builder\u003cu128\u003e for ExtBuilderParachain\u003cu128\u003e {\n\tfn balances(mut self, balances: Vec\u003c(AccountId, u128, Balance)\u003e) -\u003e Self {\n\t\tself.balances = balances;\n\t\tself\n\t}\n\n\tfn build(self) -\u003e TestExternalities {\n\t\tmatch self.chain {\n\t\t\tParachainType::PolkadotAssetHub =\u003e {\n\t\t\t\tuse polkadot_asset_hub_runtime::{Runtime, System};\n\t\t\t\tbuild_parachain!(self, Runtime, System)\n\t\t\t},\n\t\t\tParachainType::KusamaAssetHub =\u003e {\n\t\t\t\tuse kusama_asset_hub_runtime::{Runtime, System};\n\t\t\t\tbuild_parachain!(self, Runtime, System)\n\t\t\t},\n\t\t\t_ =\u003e panic!(\"cannot use this chain to build\"),\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","pendulum_tests.rs"],"content":"use crate::{\n\tmock::{para_ext, polkadot_relay_ext, ParachainType, USDT_ASSET_ID},\n\ttest_macros::{\n\t\tparachain1_transfer_asset_to_parachain2, parachain1_transfer_asset_to_parachain2_and_back,\n\t\tparachain1_transfer_incorrect_asset_to_parachain2_should_fail,\n\t\ttransfer_10_relay_token_from_parachain_to_relay_chain,\n\t\ttransfer_20_relay_token_from_relay_chain_to_parachain,\n\t},\n\tPENDULUM_ID, POLKADOT_ASSETHUB_ID,\n};\n\nuse frame_support::assert_ok;\nuse statemint_runtime as polkadot_asset_hub_runtime;\nuse xcm::latest::NetworkId;\nuse xcm_emulator::{decl_test_network, decl_test_parachain, decl_test_relay_chain, TestExt};\n\nconst DOT_FEE_WHEN_TRANSFER_TO_PARACHAIN: polkadot_core_primitives::Balance = 3200000000; //The fees that relay chain will charge when transfer DOT to parachain. sovereign account of some parachain will receive transfer_amount - DOT_FEE\n\ndecl_test_relay_chain! {\n\tpub struct PolkadotRelay {\n\t\tRuntime = polkadot_runtime::Runtime,\n\t\tXcmConfig = polkadot_runtime::xcm_config::XcmConfig,\n\t\tnew_ext = polkadot_relay_ext(),\n\t}\n}\n\ndecl_test_parachain! {\n\tpub struct PendulumParachain {\n\t\tRuntime = pendulum_runtime::Runtime,\n\t\tRuntimeOrigin = pendulum_runtime::RuntimeOrigin,\n\t\tXcmpMessageHandler = pendulum_runtime::XcmpQueue,\n\t\tDmpMessageHandler = pendulum_runtime::DmpQueue,\n\t\tnew_ext = para_ext(ParachainType::Pendulum),\n\t}\n}\n\ndecl_test_parachain! {\n\tpub struct AssetHubParachain {\n\t\tRuntime = polkadot_asset_hub_runtime::Runtime,\n\t\tRuntimeOrigin = polkadot_asset_hub_runtime::RuntimeOrigin,\n\t\tXcmpMessageHandler = polkadot_asset_hub_runtime::XcmpQueue,\n\t\tDmpMessageHandler = polkadot_asset_hub_runtime::DmpQueue,\n\t\tnew_ext = para_ext(ParachainType::PolkadotAssetHub),\n\t}\n}\n\ndecl_test_network! {\n\tpub struct PolkadotMockNet {\n\t\trelay_chain = PolkadotRelay,\n\t\tparachains = vec![\n\t\t\t(1000, AssetHubParachain),\n\t\t\t(2094, PendulumParachain),\n\t\t],\n\t}\n}\n\n#[test]\nfn transfer_dot_from_polkadot_to_pendulum() {\n\ttransfer_20_relay_token_from_relay_chain_to_parachain!(\n\t\tPolkadotMockNet,\n\t\tpolkadot_runtime,\n\t\tPolkadotRelay,\n\t\tpendulum_runtime,\n\t\tPendulumParachain,\n\t\tPENDULUM_ID,\n\t\tDOT_FEE_WHEN_TRANSFER_TO_PARACHAIN\n\t)\n}\n\n#[test]\nfn transfer_dot_from_pendulum_to_polkadot() {\n\ttransfer_10_relay_token_from_parachain_to_relay_chain!(\n\t\tPolkadotMockNet,\n\t\tpolkadot_runtime,\n\t\tPolkadotRelay,\n\t\tpendulum_runtime,\n\t\tPendulumParachain\n\t);\n}\n\n#[test]\nfn assethub_transfer_incorrect_asset_to_pendulum_should_fail() {\n\tparachain1_transfer_incorrect_asset_to_parachain2_should_fail!(\n\t\tpolkadot_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tpendulum_runtime,\n\t\tPendulumParachain,\n\t\tPENDULUM_ID\n\t);\n}\n\n#[test]\nfn assethub_transfer_asset_to_pendulum() {\n\tparachain1_transfer_asset_to_parachain2!(\n\t\tpolkadot_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tUSDT_ASSET_ID,\n\t\tpendulum_runtime,\n\t\tPendulumParachain,\n\t\tPENDULUM_ID\n\t);\n}\n\n#[test]\nfn assethub_transfer_asset_to_pendulum_and_back() {\n\tlet network_id = NetworkId::Polkadot;\n\n\tparachain1_transfer_asset_to_parachain2_and_back!(\n\t\tpolkadot_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tPOLKADOT_ASSETHUB_ID,\n\t\tUSDT_ASSET_ID,\n\t\tpendulum_runtime,\n\t\tPendulumParachain,\n\t\tPENDULUM_ID,\n\t\tnetwork_id\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","test_macros.rs"],"content":"macro_rules! transfer_20_relay_token_from_relay_chain_to_parachain {\n\t(\n\t\t$mocknet:ident,\n\t\t$relay_runtime:ident,\n\t\t$relaychain:ident,\n\t\t$para_runtime:ident,\n\t\t$parachain: ident,\n\t\t$parachain_id:ident,\n\t\t$tx_fee:ident\n\t) =\u003e {{\n\t\tuse crate::mock::{units, ALICE};\n\t\tuse frame_support::traits::fungibles::Inspect;\n\t\tuse polkadot_core_primitives::Balance;\n\t\tuse xcm::latest::{Junction, Junction::Parachain, Junctions::Here};\n\t\tuse $para_runtime::CurrencyId;\n\n\t\t$mocknet::reset();\n\t\tlet transfer_amount: Balance = units(20);\n\t\tlet mut orml_tokens_before = 0;\n\n\t\t// get ALICE's balance before the transfer\n\t\t$parachain::execute_with(|| {\n\t\t\torml_tokens_before = $para_runtime::Tokens::balance(CurrencyId::XCM(0), \u0026ALICE.into());\n\t\t});\n\n\t\t// execute the transfer from relay chain\n\t\t$relaychain::execute_with(|| {\n\t\t\tassert_ok!($relay_runtime::XcmPallet::reserve_transfer_assets(\n\t\t\t\t$relay_runtime::RuntimeOrigin::signed(ALICE.into()),\n\t\t\t\tBox::new(Parachain($parachain_id).into_versioned()),\n\t\t\t\tBox::new(\n\t\t\t\t\tJunction::AccountId32 { network: None, id: ALICE }\n\t\t\t\t\t\t.into_location()\n\t\t\t\t\t\t.into_versioned()\n\t\t\t\t),\n\t\t\t\tBox::new((Here, transfer_amount).into()),\n\t\t\t\t0\n\t\t\t));\n\t\t});\n\n\t\t// a \"Deposited\" event occurred is proof that the transfer was successful\n\t\t$parachain::execute_with(|| {\n\t\t\tuse $para_runtime::{RuntimeEvent, System};\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::Tokens(orml_tokens::Event::Deposited { .. })\n\t\t\t)));\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::DmpQueue(cumulus_pallet_dmp_queue::Event::ExecutedDownward { .. })\n\t\t\t)));\n\t\t});\n\n\t\t$parachain::execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\t$para_runtime::Tokens::balance(CurrencyId::XCM(0), \u0026ALICE.into()),\n\t\t\t\torml_tokens_before + transfer_amount - $tx_fee\n\t\t\t);\n\t\t});\n\t}};\n}\n\nmacro_rules! transfer_10_relay_token_from_parachain_to_relay_chain {(\n\t\t$mocknet:ident,\n\t\t$relay_runtime:ident,\n\t\t$relaychain:ident,\n\t\t$para_runtime:ident,\n\t\t$parachain: ident\n\t) =\u003e {{\n\t\tuse crate::mock::{BOB, units};\n\t\tuse polkadot_core_primitives::Balance;\n\t\tuse xcm::latest::{Junction::AccountId32, Junctions::X1, MultiLocation, WeightLimit};\n\t\tuse xcm_emulator::TestExt;\n\n\t\t$mocknet::reset();\n\t\tlet transfer_amount: Balance = units(10);\n\t\tlet expected_base_balance = units(100);\n\n\t\t// get BOB's balance in the relay chain, before the transfer.\n\t\t$relaychain::execute_with(|| {\n\t\t\tlet before_bob_free_balance = $relay_runtime::Balances::free_balance(\u0026BOB.into());\n\t\t\tassert_eq!(before_bob_free_balance, expected_base_balance);\n\t\t});\n\n\t\t// execute th transfer in the parachain.\n\t\t$parachain::execute_with(|| {\n\t\t\tassert_ok!($para_runtime::XTokens::transfer(\n\t\t\t\t$para_runtime::RuntimeOrigin::signed(BOB.into()),\n\t\t\t\t$para_runtime::CurrencyId::XCM(0),\n\t\t\t\ttransfer_amount,\n\t\t\t\tBox::new(\n\t\t\t\t\tMultiLocation { parents: 1, interior: X1(AccountId32 { network: None, id: BOB }) }\n\t\t\t\t\t\t.into()\n\t\t\t\t),\n\t\t\t\tWeightLimit::Unlimited\n\t\t\t));\n\t\t});\n\n\t\t// check events in Parachain for proof of transfer\n\t\t$parachain::execute_with(|| {\n\t\t\tuse $para_runtime::{System, RuntimeEvent};\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::Tokens(orml_tokens::Event::Withdrawn { .. })\n\t\t\t)));\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::XTokens(orml_xtokens::Event::TransferredMultiAssets { .. })\n\t\t\t)));\n\t\t});\n\n\t\t// check events in the Relaychain for proof of transfer\n\t\t$relaychain::execute_with(|| {\n\t\t\tuse $relay_runtime::{RuntimeEvent, System, Balances};\n\n\t\t\tlet events = System::events();\n\t\t\tassert_eq!(events.len(), 3);\n\n\t\t\tlet withdrawn_balance = match \u0026events[0].event {\n\t\t\t\tRuntimeEvent::Balances(pallet_balances::Event::Withdraw { who: _, amount }) =\u003e amount,\n\t\t\t\tother =\u003e panic!(\"wrong event: {:#?}\", other),\n\t\t\t};\n\n\t\t\tlet deposited_balance = match \u0026events[1].event {\n\t\t\t\tRuntimeEvent::Balances(pallet_balances::Event::Deposit { who: _, amount }) =\u003e amount,\n\t\t\t\tother =\u003e panic!(\"wrong event: {:#?}\", other),\n\t\t\t};\n\n\t\t\tmatch \u0026events[2].event {\n\t\t\t\tRuntimeEvent::Ump(polkadot_runtime_parachains::ump::Event::ExecutedUpward(..)) =\u003e\n\t\t\t\t\tassert!(true),\n\t\t\t\tother =\u003e panic!(\"wrong event: {:#?}\", other),\n\t\t\t};\n\n\t\t\t//This fee will taken to transfer assets(Polkadot) from sovereign parachain account to destination user account;\n\t\t\tlet fee_when_transferring_to_relay_chain = withdrawn_balance - deposited_balance;\n\n\t\t\tlet after_bob_free_balance = Balances::free_balance(\u0026BOB.into());\n\t\t\tassert_eq!(\n\t\t\t\tafter_bob_free_balance,\n\t\t\t\texpected_base_balance + transfer_amount - fee_when_transferring_to_relay_chain\n\t\t\t);\n\t\t});\n\n\t}};\n}\n\n// the CurrencyId::XCM(1) is the representation of USDT from Statemint/Statemine on Pendulum/Amplitude chain.\n// The asset id for USDT on Statemint/Statemine is 1984, and our chain support only this asset id.\n// we are going to execute XCM call to sent incorrect Asset Id and expect to see cumulus_pallet_xcmp_queue::Event::Fail event with an error FailedToTransactAsset.\n// we want to be sure that the initial USDT balance for BOB is the same after XCM call from statemint/statemine when we tried to send wrong ASSET_ID.\nmacro_rules! parachain1_transfer_incorrect_asset_to_parachain2_should_fail {\n\t(\n\t\t$para1_runtime:ident,\n\t\t$parachain1:ident,\n\t\t$para2_runtime:ident,\n\t\t$parachain2: ident,\n\t\t$parachain2_id:ident\n\t) =\u003e {{\n\t\tuse crate::mock::{ALICE, BOB, INCORRECT_ASSET_ID, TEN_UNITS, UNIT};\n\t\tuse frame_support::traits::{fungibles::Inspect, Currency};\n\t\tuse polkadot_core_primitives::AccountId;\n\t\tuse polkadot_parachain::primitives::Sibling;\n\t\tuse sp_runtime::{traits::AccountIdConversion, MultiAddress};\n\t\tuse xcm::latest::{\n\t\t\tJunction,\n\t\t\tJunction::{GeneralIndex, PalletInstance, Parachain},\n\t\t\tJunctions::{X1, X2},\n\t\t\tMultiLocation, WeightLimit,\n\t\t};\n\t\tuse $para2_runtime::CurrencyId;\n\n\t\tlet parachain2_account: AccountId = Sibling::from($parachain2_id).into_account_truncating();\n\n\t\tlet expected_base_usdt_balance = 0;\n\t\t// make sure the account does not have any usdt.\n\t\t$parachain2::execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\t$para2_runtime::Tokens::balance(CurrencyId::XCM(1), \u0026BOB.into()),\n\t\t\t\texpected_base_usdt_balance\n\t\t\t);\n\t\t});\n\n\t\t$parachain1::execute_with(|| {\n\t\t\tuse $para1_runtime::*;\n\n\t\t\tlet origin = RuntimeOrigin::signed(ALICE.into());\n\t\t\tBalances::make_free_balance_be(\u0026ALICE.into(), TEN_UNITS);\n\t\t\tBalances::make_free_balance_be(\u0026BOB.into(), UNIT);\n\n\t\t\t// If using non root, create custom asset cost 0.1 Dot\n\t\t\t// We're using force_create here to make sure asset is sufficient.\n\t\t\tassert_ok!(Assets::force_create(\n\t\t\t\tRuntimeOrigin::root(),\n\t\t\t\tINCORRECT_ASSET_ID.into(),\n\t\t\t\tMultiAddress::Id(ALICE.into()),\n\t\t\t\ttrue,\n\t\t\t\tUNIT / 100\n\t\t\t));\n\n\t\t\tassert_ok!(Assets::mint(\n\t\t\t\torigin.clone(),\n\t\t\t\tINCORRECT_ASSET_ID.into(),\n\t\t\t\tMultiAddress::Id(ALICE.into()),\n\t\t\t\t1000 * UNIT\n\t\t\t));\n\n\t\t\t// need to have some balance to be able to receive user assets\n\t\t\tBalances::make_free_balance_be(\u0026parachain2_account, UNIT);\n\n\t\t\tassert_ok!(PolkadotXcm::limited_reserve_transfer_assets(\n\t\t\t\torigin.clone(),\n\t\t\t\tBox::new(MultiLocation::new(1, X1(Parachain($parachain2_id))).into()),\n\t\t\t\tBox::new(Junction::AccountId32 { id: BOB, network: None }.into()),\n\t\t\t\tBox::new(\n\t\t\t\t\t(X2(PalletInstance(50), GeneralIndex(INCORRECT_ASSET_ID as u128)), TEN_UNITS)\n\t\t\t\t\t\t.into()\n\t\t\t\t),\n\t\t\t\t0,\n\t\t\t\tWeightLimit::Unlimited\n\t\t\t));\n\n\t\t\tassert_eq!(990 * UNIT, Assets::balance(INCORRECT_ASSET_ID, \u0026AccountId::from(ALICE)));\n\t\t\tassert_eq!(0, Assets::balance(INCORRECT_ASSET_ID, \u0026AccountId::from(BOB)));\n\n\t\t\tassert_eq!(TEN_UNITS, Assets::balance(INCORRECT_ASSET_ID, \u0026parachain2_account));\n\t\t\t// the balance of sibling parachain sovereign account is not changed\n\t\t\tassert_eq!(UNIT, Balances::free_balance(\u0026parachain2_account));\n\t\t});\n\n\t\t// Rerun $parachain1 to actually send the egress message via XCM\n\t\t$parachain1::execute_with(|| {});\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tuse $para2_runtime::{RuntimeEvent, System};\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::XcmpQueue(cumulus_pallet_xcmp_queue::Event::Fail {\n\t\t\t\t\tmessage_hash: _,\n\t\t\t\t\terror: xcm::v3::Error::FailedToTransactAsset(..),\n\t\t\t\t\tweight: _\n\t\t\t\t})\n\t\t\t)));\n\t\t});\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\t$para2_runtime::Tokens::balance(CurrencyId::XCM(1), \u0026BOB.into()),\n\t\t\t\texpected_base_usdt_balance\n\t\t\t);\n\t\t});\n\t}};\n}\n\nmacro_rules! parachain1_transfer_asset_to_parachain2 {\n\t(\n\t\t$para1_runtime:ident,\n\t\t$parachain1:ident,\n\t\t$para1_asset_id:ident,\n\t\t$para2_runtime:ident,\n\t\t$parachain2: ident,\n\t\t$parachain2_id:ident\n\t) =\u003e {{\n\t\tuse crate::mock::{ALICE, BOB, TEN_UNITS, UNIT};\n\t\tuse frame_support::traits::{fungibles::Inspect, Currency};\n\t\tuse polkadot_core_primitives::AccountId;\n\t\tuse polkadot_parachain::primitives::Sibling;\n\t\tuse sp_runtime::{traits::AccountIdConversion, MultiAddress};\n\t\tuse xcm::latest::{\n\t\t\tJunction,\n\t\t\tJunction::{GeneralIndex, PalletInstance, Parachain},\n\t\t\tJunctions::{X1, X2},\n\t\t\tMultiLocation, WeightLimit,\n\t\t};\n\t\tuse $para2_runtime::CurrencyId;\n\n\t\tlet parachain2_account: AccountId = Sibling::from($parachain2_id).into_account_truncating();\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tassert_eq!($para2_runtime::Tokens::balance(CurrencyId::XCM(1), \u0026BOB.into()), 0);\n\t\t});\n\n\t\t$parachain1::execute_with(|| {\n\t\t\tuse $para1_runtime::*;\n\n\t\t\tlet origin = RuntimeOrigin::signed(ALICE.into());\n\t\t\tBalances::make_free_balance_be(\u0026ALICE.into(), TEN_UNITS);\n\t\t\tBalances::make_free_balance_be(\u0026BOB.into(), UNIT);\n\n\t\t\t// If using non root, create custom asset cost 0.1 Dot\n\t\t\t// We're using force_create here to make sure asset is sufficient.\n\t\t\tassert_ok!(Assets::force_create(\n\t\t\t\tRuntimeOrigin::root(),\n\t\t\t\t$para1_asset_id.into(),\n\t\t\t\tMultiAddress::Id(ALICE.into()),\n\t\t\t\ttrue,\n\t\t\t\tUNIT / 100\n\t\t\t));\n\n\t\t\tassert_ok!(Assets::mint(\n\t\t\t\torigin.clone(),\n\t\t\t\t$para1_asset_id.into(),\n\t\t\t\tMultiAddress::Id(ALICE.into()),\n\t\t\t\t1000 * UNIT\n\t\t\t));\n\n\t\t\t// need to have some KSM to be able to receive user assets\n\t\t\tBalances::make_free_balance_be(\u0026parachain2_account, UNIT);\n\n\t\t\tassert_ok!(PolkadotXcm::limited_reserve_transfer_assets(\n\t\t\t\torigin.clone(),\n\t\t\t\tBox::new(MultiLocation::new(1, X1(Parachain($parachain2_id))).into()),\n\t\t\t\tBox::new(Junction::AccountId32 { id: BOB, network: None }.into()),\n\t\t\t\tBox::new(\n\t\t\t\t\t(X2(PalletInstance(50), GeneralIndex($para1_asset_id as u128)), TEN_UNITS)\n\t\t\t\t\t\t.into()\n\t\t\t\t),\n\t\t\t\t0,\n\t\t\t\tWeightLimit::Unlimited\n\t\t\t));\n\n\t\t\tassert_eq!(990 * UNIT, Assets::balance($para1_asset_id, \u0026AccountId::from(ALICE)));\n\t\t\tassert_eq!(0, Assets::balance($para1_asset_id, \u0026AccountId::from(BOB)));\n\n\t\t\tassert_eq!(TEN_UNITS, Assets::balance($para1_asset_id, \u0026parachain2_account));\n\t\t\t// the balance of sibling parachain sovereign account is not changed\n\t\t\tassert_eq!(UNIT, Balances::free_balance(\u0026parachain2_account));\n\t\t});\n\n\t\t// Rerun the StatemintParachain::execute to actually send the egress message via XCM\n\t\t$parachain1::execute_with(|| {});\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tuse $para2_runtime::{RuntimeEvent, System};\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::Tokens(orml_tokens::Event::Endowed { .. })\n\t\t\t)));\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::Tokens(orml_tokens::Event::Deposited { .. })\n\t\t\t)));\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::XcmpQueue(cumulus_pallet_xcmp_queue::Event::Success { .. })\n\t\t\t)));\n\n\t\t\tassert_eq!(\n\t\t\t\t$para2_runtime::Tokens::balance($para2_runtime::CurrencyId::XCM(1), \u0026BOB.into()),\n\t\t\t\tTEN_UNITS\n\t\t\t);\n\t\t});\n\t}};\n}\n\nmacro_rules! parachain1_transfer_asset_to_parachain2_and_back {\n\t(\n\t\t$para1_runtime:ident,\n\t\t$parachain1:ident,\n\t\t$parachain1_id:ident,\n\t\t$para1_asset_id:ident,\n\t\t$para2_runtime:ident,\n\t\t$parachain2: ident,\n\t\t$parachain2_id:ident,\n\t\t$network_id: ident\n\t) =\u003e {{\n\t\tuse crate::mock::{BOB, TEN_UNITS, UNIT};\n\t\tuse frame_support::traits::{fungible::Mutate, fungibles::Inspect};\n\t\tuse polkadot_core_primitives::AccountId;\n\t\tuse xcm::latest::{\n\t\t\tJunction, Junction::Parachain, Junctions::X2, MultiLocation, WeightLimit,\n\t\t};\n\n\t\t//first we need to set up USDT balance on pendulum chain before to start transfer it back.\n\t\tparachain1_transfer_asset_to_parachain2!(\n\t\t\t$para1_runtime,\n\t\t\t$parachain1,\n\t\t\t$para1_asset_id,\n\t\t\t$para2_runtime,\n\t\t\t$parachain2,\n\t\t\t$parachain2_id\n\t\t);\n\n\t\t$parachain1::execute_with(|| {});\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tuse $para2_runtime::{\n\t\t\t\tBalances, CurrencyId, RuntimeEvent, RuntimeOrigin, System, Tokens, XTokens,\n\t\t\t};\n\n\t\t\tassert_eq!(TEN_UNITS, Tokens::balance(CurrencyId::XCM(1), \u0026AccountId::from(BOB)));\n\t\t\t// ensure sender has enough balance to be charged as fee\n\t\t\tassert_ok!(Balances::mint_into(\u0026AccountId::from(BOB), TEN_UNITS));\n\n\t\t\tassert_ok!(XTokens::transfer(\n\t\t\t\tRuntimeOrigin::signed(BOB.into()),\n\t\t\t\tCurrencyId::XCM(1),\n\t\t\t\tUNIT * 1,\n\t\t\t\tBox::new(\n\t\t\t\t\tMultiLocation::new(\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tX2(\n\t\t\t\t\t\t\tParachain($parachain1_id),\n\t\t\t\t\t\t\tJunction::AccountId32 { network: Some($network_id), id: BOB.into() }\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.into()\n\t\t\t\t),\n\t\t\t\tWeightLimit::Unlimited\n\t\t\t));\n\n\t\t\tassert_eq!(\n\t\t\t\tTEN_UNITS - 1 * UNIT, //initial balance - one unit\n\t\t\t\tTokens::balance(CurrencyId::XCM(1), \u0026AccountId::from(BOB))\n\t\t\t);\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::XcmpQueue(cumulus_pallet_xcmp_queue::Event::XcmpMessageSent { .. })\n\t\t\t)));\n\n\t\t\tfor i in System::events().iter() {\n\t\t\t\tprintln!(\"{}: {:?}\\n\", stringify!($para2_runtime), i);\n\t\t\t}\n\t\t});\n\n\t\t$parachain1::execute_with(|| {\n\t\t\tuse $para1_runtime::*;\n\n\t\t\tfor i in System::events().iter() {\n\t\t\t\tprintln!(\"{}: {:?}\\n\", stringify!($para1_runtime), i);\n\t\t\t}\n\n\t\t\tlet events = System::events();\n\t\t\tmatch \u0026events[events.len() - 2] {\n\t\t\t\t\u0026frame_system::EventRecord {\n\t\t\t\t\tphase: frame_system::Phase::Initialization,\n\t\t\t\t\tevent:\n\t\t\t\t\t\tRuntimeEvent::Assets(pallet_assets::Event::Issued {\n\t\t\t\t\t\t\tasset_id: $para1_asset_id,\n\t\t\t\t\t\t\towner: _,\n\t\t\t\t\t\t\tamount,\n\t\t\t\t\t\t}),\n\t\t\t\t\ttopics: _,\n\t\t\t\t} =\u003e {\n\t\t\t\t\t// https://github.com/paritytech/cumulus/pull/1278 support using self sufficient asset\n\t\t\t\t\t// for paying xcm execution fee.\n\t\t\t\t\t// 990_000_000_000 for Statemint\n\t\t\t\t\t// 988_423_297_485 for Statemine\n\t\t\t\t\tassert_eq!(amount, Assets::balance($para1_asset_id, \u0026AccountId::from(BOB)));\n\t\t\t\t},\n\t\t\t\tother =\u003e panic!(\"wrong event: {other:?}\"),\n\t\t\t}\n\t\t});\n\t}};\n}\n\n// macros defined at the bottom of this file to prevent unresolved imports\npub(super) use parachain1_transfer_asset_to_parachain2;\npub(super) use parachain1_transfer_asset_to_parachain2_and_back;\npub(super) use parachain1_transfer_incorrect_asset_to_parachain2_should_fail;\npub(super) use transfer_10_relay_token_from_parachain_to_relay_chain;\npub(super) use transfer_20_relay_token_from_relay_chain_to_parachain;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","build.rs"],"content":"use substrate_wasm_builder::WasmBuilder;\n\nfn main() {\n\tWasmBuilder::new()\n\t\t.with_current_project()\n\t\t.export_heap_base()\n\t\t.import_memory()\n\t\t.build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nmod weights;\npub mod xcm_config;\npub mod zenlink;\nuse crate::zenlink::*;\nuse xcm::v3::MultiLocation;\nuse zenlink_protocol::{AssetBalance, MultiAssetsHandler, PairInfo};\n\npub use parachain_staking::InflationInfo;\n\nuse codec::Encode;\n\nuse smallvec::smallvec;\nuse sp_api::impl_runtime_apis;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{AccountIdLookup, BlakeTwo256, Block as BlockT, ConvertInto},\n\ttransaction_validity::{TransactionSource, TransactionValidity},\n\tApplyExtrinsicResult, SaturatedConversion,\n};\n\npub use spacewalk_primitives::CurrencyId;\n\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\nuse frame_support::{\n\tconstruct_runtime,\n\tdispatch::DispatchClass,\n\tparameter_types,\n\ttraits::{\n\t\tConstBool, ConstU32, Contains, Currency, EitherOfDiverse, EqualPrivilegeOnly, Imbalance,\n\t\tOnUnbalanced, WithdrawReasons,\n\t},\n\tweights::{\n\t\tconstants::WEIGHT_REF_TIME_PER_SECOND, ConstantMultiplier, Weight, WeightToFeeCoefficient,\n\t\tWeightToFeeCoefficients, WeightToFeePolynomial,\n\t},\n\tPalletId,\n};\nuse frame_system::{\n\tlimits::{BlockLength, BlockWeights},\n\tEnsureRoot, EnsureSigned,\n};\npub use sp_runtime::{traits::AccountIdConversion, MultiAddress, Perbill, Permill, Perquintill};\n\nuse runtime_common::{\n\tasset_registry, opaque, AccountId, Amount, AuraId, Balance, BlockNumber, Hash, Index,\n\tReserveIdentifier, Signature, EXISTENTIAL_DEPOSIT, MILLIUNIT, NANOUNIT, UNIT,\n};\n\nuse cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;\n\nuse dia_oracle::DiaOracle;\n\nuse xcm_config::{XcmConfig, XcmOriginToTransactDispatchOrigin};\n\nuse orml_currencies::BasicCurrencyAdapter;\nuse orml_traits::{currency::MutationHooks, parameter_type_with_key};\n\nconst CONTRACTS_DEBUG_OUTPUT: bool = true;\n\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\n\n// Polkadot imports\nuse polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};\n\nuse weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};\n\n// XCM Imports\nuse xcm_executor::XcmExecutor;\n\n/// The address format for describing accounts.\npub type Address = MultiAddress\u003cAccountId, ()\u003e;\n\n/// Block header type as expected by this runtime.\npub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\n/// Block type as expected by this runtime.\npub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock\u003cBlock\u003e;\n\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId\u003cBlock\u003e;\n\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender\u003cRuntime\u003e,\n\tframe_system::CheckSpecVersion\u003cRuntime\u003e,\n\tframe_system::CheckTxVersion\u003cRuntime\u003e,\n\tframe_system::CheckGenesis\u003cRuntime\u003e,\n\tframe_system::CheckEra\u003cRuntime\u003e,\n\tframe_system::CheckNonce\u003cRuntime\u003e,\n\tframe_system::CheckWeight\u003cRuntime\u003e,\n\tpallet_transaction_payment::ChargeTransactionPayment\u003cRuntime\u003e,\n);\n\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tgeneric::UncheckedExtrinsic\u003cAddress, RuntimeCall, Signature, SignedExtra\u003e;\n\npub type SignedPayload = generic::SignedPayload\u003cRuntimeCall, SignedExtra\u003e;\n\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic\u003cAccountId, RuntimeCall, SignedExtra\u003e;\n\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive\u003c\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext\u003cRuntime\u003e,\n\tRuntime,\n\tAllPalletsWithSystem,\n\u003e;\n\n/// Handles converting a weight scalar to a fee value, based on the scale and granularity of the\n/// node's balance type.\n///\n/// This should typically create a mapping between the following ranges:\n///   - `[0, MAXIMUM_BLOCK_WEIGHT]`\n///   - `[Balance::min, Balance::max]`\n///\n/// Yet, it can be used for any other sort of change to weight-fee. Some examples being:\n///   - Setting it to `0` will essentially disable the weight fee.\n///   - Setting it to `1` will cause the literal `#[weight = x]` values to be charged.\npub struct WeightToFee;\nimpl WeightToFeePolynomial for WeightToFee {\n\ttype Balance = Balance;\n\tfn polynomial() -\u003e WeightToFeeCoefficients\u003cSelf::Balance\u003e {\n\t\tlet p = MILLIUNIT;\n\t\tlet q = 10 * Balance::from(ExtrinsicBaseWeight::get().ref_time());\n\t\tsmallvec![WeightToFeeCoefficient {\n\t\t\tdegree: 1,\n\t\t\tnegative: false,\n\t\t\tcoeff_frac: Perbill::from_rational(p % q, q),\n\t\t\tcoeff_integer: p / q,\n\t\t}]\n\t}\n}\n\nimpl_opaque_keys! {\n\tpub struct SessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\n#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"pendulum\"),\n\timpl_name: create_runtime_str!(\"pendulum\"),\n\tauthoring_version: 1,\n\tspec_version: 8,\n\timpl_version: 0,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 8,\n\tstate_version: 1,\n};\n\n/// This determines the average expected block time that we are targeting.\n/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.\n/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked\n/// up by `pallet_aura` to implement `fn slot_duration()`.\n///\n/// Change this to adjust the block time.\npub const MILLISECS_PER_BLOCK: u64 = 12000;\n\n// NOTE: Currently it is not possible to change the slot duration after the chain has started.\n//       Attempting to do so will brick block production.\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\npub const BLOCKS_PER_YEAR: BlockNumber = DAYS * 36525 / 100;\n\n/// We assume that ~5% of the block weight is consumed by `on_initialize` handlers. This is\n/// used to limit the maximal weight of a single extrinsic.\nconst AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(5);\n\n/// We allow `Normal` extrinsics to fill up the block up to 75%, the rest can be used by\n/// `Operational` extrinsics.\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\n/// We allow for 0.5 of a second of compute with a 12 second average block time.\nconst MAXIMUM_BLOCK_WEIGHT: Weight =\n\tWeight::from_parts(WEIGHT_REF_TIME_PER_SECOND.saturating_div(2), 0)\n\t\t.set_proof_size(cumulus_primitives_core::relay_chain::MAX_POV_SIZE as u64);\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -\u003e NativeVersion {\n\tNativeVersion { runtime_version: VERSION, can_author_with: Default::default() }\n}\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\n\t// This part is copied from Substrate's `bin/node/runtime/src/lib.rs`.\n\t//  The `RuntimeBlockLength` and `RuntimeBlockWeights` exist here because the\n\t// `DeletionWeightLimit` and `DeletionQueueDepth` depend on those to parameterize\n\t// the lazy contract deletion.\n\tpub RuntimeBlockLength: BlockLength =\n\t\tBlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub RuntimeBlockWeights: BlockWeights = BlockWeights::builder()\n\t\t.base_block(BlockExecutionWeight::get())\n\t\t.for_class(DispatchClass::all(), |weights| {\n\t\t\tweights.base_extrinsic = ExtrinsicBaseWeight::get();\n\t\t})\n\t\t.for_class(DispatchClass::Normal, |weights| {\n\t\t\tweights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);\n\t\t})\n\t\t.for_class(DispatchClass::Operational, |weights| {\n\t\t\tweights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);\n\t\t\t// Operational transactions have some extra reserved space, so that they\n\t\t\t// are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.\n\t\t\tweights.reserved = Some(\n\t\t\t\tMAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT\n\t\t\t);\n\t\t})\n\t\t.avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)\n\t\t.build_or_panic();\n\tpub const SS58Prefix: u16 = 56;\n}\n\npub struct BaseFilter;\nimpl Contains\u003cRuntimeCall\u003e for BaseFilter {\n\tfn contains(call: \u0026RuntimeCall) -\u003e bool {\n\t\tmatch call {\n\t\t\t// These modules are all allowed to be called by transactions:\n\t\t\tRuntimeCall::Bounties(_) |\n\t\t\tRuntimeCall::ChildBounties(_) |\n\t\t\tRuntimeCall::Treasury(_) |\n\t\t\tRuntimeCall::Tokens(_) |\n\t\t\tRuntimeCall::Currencies(_) |\n\t\t\tRuntimeCall::ParachainStaking(_) |\n\t\t\tRuntimeCall::Democracy(_) |\n\t\t\tRuntimeCall::Council(_) |\n\t\t\tRuntimeCall::TechnicalCommittee(_) |\n\t\t\tRuntimeCall::System(_) |\n\t\t\tRuntimeCall::Scheduler(_) |\n\t\t\tRuntimeCall::Preimage(_) |\n\t\t\tRuntimeCall::Timestamp(_) |\n\t\t\tRuntimeCall::Balances(_) |\n\t\t\tRuntimeCall::Session(_) |\n\t\t\tRuntimeCall::ParachainSystem(_) |\n\t\t\tRuntimeCall::XcmpQueue(_) |\n\t\t\tRuntimeCall::PolkadotXcm(_) |\n\t\t\tRuntimeCall::DmpQueue(_) |\n\t\t\tRuntimeCall::Utility(_) |\n\t\t\tRuntimeCall::Vesting(_) |\n\t\t\tRuntimeCall::XTokens(_) |\n\t\t\tRuntimeCall::Multisig(_) |\n\t\t\tRuntimeCall::Identity(_) |\n\t\t\tRuntimeCall::Contracts(_) |\n\t\t\tRuntimeCall::ZenlinkProtocol(_) |\n\t\t\tRuntimeCall::DiaOracleModule(_) |\n\t\t\tRuntimeCall::VestingManager(_) |\n\t\t\tRuntimeCall::AssetRegistry(_) =\u003e true,\n\t\t\t// All pallets are allowed, but exhaustive match is defensive\n\t\t\t// in the case of adding new pallets.\n\t\t}\n\t}\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype RuntimeCall = RuntimeCall;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup\u003cAccountId, ()\u003e;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\t/// The ubiquitous origin type.\n\ttype RuntimeOrigin = RuntimeOrigin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// Runtime version.\n\ttype Version = Version;\n\t/// Converts a module to an index of this module in the runtime.\n\ttype PalletInfo = PalletInfo;\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = BaseFilter;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// Block \u0026 extrinsics weights: base values and limits.\n\ttype BlockWeights = RuntimeBlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = RuntimeBlockLength;\n\t/// This is used as an identifier of the chain. 56 is the prefix for Pendulum\n\ttype SS58Prefix = SS58Prefix;\n\t/// The action to take on a Runtime Upgrade\n\ttype OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode\u003cSelf\u003e;\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = pallet_timestamp::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const UncleGenerations: u32 = 2;\n}\n\nimpl pallet_authorship::Config for Runtime {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = ParachainStaking;\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = EXISTENTIAL_DEPOSIT;\n\tpub const MaxLocks: u32 = 50;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = Treasury;\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 100 * NANOUNIT;\n\tpub const OperationalFeeMultiplier: u8 = 5;\n}\n\ntype NegativeImbalance = \u003cBalances as Currency\u003cAccountId\u003e\u003e::NegativeImbalance;\n\npub struct DealWithFees;\nimpl OnUnbalanced\u003cNegativeImbalance\u003e for DealWithFees {\n\tfn on_unbalanceds\u003cB\u003e(mut fees_then_tips: impl Iterator\u003cItem = NegativeImbalance\u003e) {\n\t\tif let Some(mut fees) = fees_then_tips.next() {\n\t\t\tif let Some(tips) = fees_then_tips.next() {\n\t\t\t\ttips.merge_into(\u0026mut fees);\n\t\t\t}\n\t\t\t// for fees and tips, 100% to treasury\n\t\t\tTreasury::on_unbalanced(fees);\n\t\t}\n\t}\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter\u003cBalances, DealWithFees\u003e;\n\ttype WeightToFee = WeightToFee;\n\ttype LengthToFee = ConstantMultiplier\u003cBalance, TransactionByteFee\u003e;\n\ttype FeeMultiplierUpdate = SlowAdjustingFeeUpdate\u003cSelf\u003e;\n\ttype OperationalFeeMultiplier = OperationalFeeMultiplier;\n}\n\nparameter_types! {\n\tpub const ReservedXcmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n\tpub const ReservedDmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n}\n\nimpl cumulus_pallet_parachain_system::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSystemEvent = ();\n\ttype SelfParaId = parachain_info::Pallet\u003cRuntime\u003e;\n\ttype DmpMessageHandler = DmpQueue;\n\ttype ReservedDmpWeight = ReservedDmpWeight;\n\ttype OutboundXcmpMessageSource = XcmpQueue;\n\ttype XcmpMessageHandler = XcmpQueue;\n\ttype ReservedXcmpWeight = ReservedXcmpWeight;\n\ttype CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;\n}\n\nimpl parachain_info::Config for Runtime {}\n\nimpl cumulus_pallet_aura_ext::Config for Runtime {}\n\nimpl cumulus_pallet_xcmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ChannelInfo = ParachainSystem;\n\ttype VersionWrapper = ();\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype PriceForSiblingDelivery = ();\n\ttype WeightInfo = cumulus_pallet_xcmp_queue::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl cumulus_pallet_dmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const Offset: u32 = 0;\n\tpub const MaxAuthorities: u32 = 200;\n}\n\nimpl pallet_session::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\ttype ValidatorIdOf = ConvertInto;\n\ttype ShouldEndSession = ParachainStaking;\n\ttype NextSessionRotation = ParachainStaking;\n\ttype SessionManager = ParachainStaking;\n\ttype SessionHandler = \u003cSessionKeys as sp_runtime::traits::OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = SessionKeys;\n\ttype WeightInfo = pallet_session::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nparameter_types! {\n\tpub const LaunchPeriod: BlockNumber = 5 * DAYS;\n\tpub const VotingPeriod: BlockNumber = 5 * DAYS;\n\tpub const FastTrackVotingPeriod: BlockNumber = 3 * HOURS;\n\tpub const MinimumDeposit: Balance = 1 * UNIT;\n\tpub const EnactmentPeriod: BlockNumber = 2 * DAYS;\n\tpub const CooloffPeriod: BlockNumber = 7 * DAYS;\n\tpub const MaxProposals: u32 = 100;\n\tpub const VoteLockingPeriod: u32 = 7 * DAYS;\n}\n\nimpl pallet_democracy::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype EnactmentPeriod = EnactmentPeriod;\n\ttype LaunchPeriod = LaunchPeriod;\n\ttype VotingPeriod = VotingPeriod;\n\ttype VoteLockingPeriod = VoteLockingPeriod;\n\ttype MinimumDeposit = MinimumDeposit;\n\t/// A straight majority of the council can decide what their next motion is.\n\ttype ExternalOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A super-majority can have the next scheduled referendum be a straight majority-carries vote.\n\ttype ExternalMajorityOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A unanimous council can have the next scheduled referendum be a straight default-carries\n\t/// (NTB) vote.\n\ttype ExternalDefaultOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 1\u003e;\n\t/// Two thirds of the technical committee can have an ExternalMajority/ExternalDefault vote\n\t/// be tabled immediately and with a shorter voting/enactment period.\n\ttype FastTrackOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 2, 3\u003e;\n\ttype InstantOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e;\n\ttype InstantAllowed = frame_support::traits::ConstBool\u003ctrue\u003e;\n\ttype FastTrackVotingPeriod = FastTrackVotingPeriod;\n\t// To cancel a proposal which has been passed, 2/3 of the council must agree to it.\n\ttype CancellationOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 2, 3\u003e;\n\t// To cancel a proposal before it has been passed, the technical committee must be unanimous or\n\t// Root must agree.\n\ttype CancelProposalOrigin = EitherOfDiverse\u003c\n\t\tEnsureRoot\u003cAccountId\u003e,\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e,\n\t\u003e;\n\ttype BlacklistOrigin = EnsureRoot\u003cAccountId\u003e;\n\t// Any single technical committee member may veto a coming council proposal, however they can\n\t// only do it once and it lasts only for the cool-off period.\n\ttype VetoOrigin = pallet_collective::EnsureMember\u003cAccountId, TechnicalCollective\u003e;\n\ttype CooloffPeriod = CooloffPeriod;\n\ttype Slash = ();\n\ttype Scheduler = Scheduler;\n\ttype PalletsOrigin = OriginCaller;\n\ttype MaxVotes = ConstU32\u003c100\u003e;\n\ttype WeightInfo = pallet_democracy::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxProposals = MaxProposals;\n\ttype Preimages = Preimage;\n\ttype MaxDeposits = ConstU32\u003c100\u003e;\n\ttype MaxBlacklisted = ConstU32\u003c100\u003e;\n\ttype SubmitOrigin = EnsureSigned\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const CouncilMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const CouncilMaxProposals: u32 = 100;\n\tpub const CouncilMaxMembers: u32 = 100;\n}\n\ntype CouncilCollective = pallet_collective::Instance1;\nimpl pallet_collective::Config\u003cCouncilCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = CouncilMotionDuration;\n\ttype MaxProposals = CouncilMaxProposals;\n\ttype MaxMembers = CouncilMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cSelf::AccountId\u003e;\n}\n\nparameter_types! {\n\tpub const TechnicalMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const TechnicalMaxProposals: u32 = 100;\n\tpub const TechnicalMaxMembers: u32 = 100;\n}\n\ntype TechnicalCollective = pallet_collective::Instance2;\nimpl pallet_collective::Config\u003cTechnicalCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = TechnicalMotionDuration;\n\ttype MaxProposals = TechnicalMaxProposals;\n\ttype MaxMembers = TechnicalMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cSelf::AccountId\u003e;\n}\n\nparameter_types! {\n\tpub MaximumSchedulerWeight: Weight = Perbill::from_percent(80) *\n\t\tRuntimeBlockWeights::get().max_block;\n}\n\nimpl pallet_scheduler::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype PalletsOrigin = OriginCaller;\n\ttype RuntimeCall = RuntimeCall;\n\ttype MaximumWeight = MaximumSchedulerWeight;\n\ttype ScheduleOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype MaxScheduledPerBlock = ConstU32\u003c50\u003e;\n\ttype WeightInfo = pallet_scheduler::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype OriginPrivilegeCmp = EqualPrivilegeOnly;\n\ttype Preimages = Preimage;\n}\n\nparameter_types! {\n\tpub const PreimageMaxSize: u32 = 4096 * 1024;\n\tpub const PreimageBaseDeposit: Balance = 1 * UNIT;\n\t// One cent: $10,000 / MB\n\tpub const PreimageByteDeposit: Balance = 10 * MILLIUNIT;\n}\n\nimpl pallet_preimage::Config for Runtime {\n\ttype WeightInfo = pallet_preimage::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype ManagerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype BaseDeposit = PreimageBaseDeposit;\n\ttype ByteDeposit = PreimageByteDeposit;\n}\n\nparameter_types! {\n\tpub const ProposalBond: Permill = Permill::from_percent(5);\n\tpub const ProposalBondMinimum: Balance = 10 * UNIT;\n\tpub const SpendPeriod: BlockNumber = 7 * DAYS;\n\tpub const Burn: Permill = Permill::from_percent(0);\n\tpub const TreasuryPalletId: PalletId = PalletId(*b\"py/trsry\");\n\tpub const MaxApprovals: u32 = 100;\n}\n\ntype TreasuryApproveOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 3, 5\u003e,\n\u003e;\n\ntype TreasuryRejectOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_treasury::Config for Runtime {\n\ttype PalletId = TreasuryPalletId;\n\ttype Currency = Balances;\n\ttype ApproveOrigin = TreasuryApproveOrigin;\n\ttype RejectOrigin = TreasuryRejectOrigin;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSlash = Treasury;\n\ttype ProposalBond = ProposalBond;\n\ttype ProposalBondMinimum = ProposalBondMinimum;\n\ttype ProposalBondMaximum = ();\n\ttype SpendPeriod = SpendPeriod;\n\ttype Burn = Burn;\n\ttype BurnDestination = ();\n\ttype SpendFunds = Bounties;\n\ttype WeightInfo = pallet_treasury::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxApprovals = MaxApprovals;\n\ttype SpendOrigin = frame_support::traits::NeverEnsureOrigin\u003cu128\u003e;\n}\n\nparameter_types! {\n\tpub const BountyCuratorDeposit: Permill = Permill::from_percent(50);\n\tpub const BountyValueMinimum: Balance = 5 * UNIT;\n\tpub const BountyDepositBase: Balance = 1 * UNIT;\n\tpub const CuratorDepositMultiplier: Permill = Permill::from_percent(50);\n\tpub const CuratorDepositMin: Balance = 1 * UNIT;\n\tpub const CuratorDepositMax: Balance = 100 * UNIT;\n\tpub const DataDepositPerByte: Balance = 30 * MILLIUNIT;\n\tpub const BountyDepositPayoutDelay: BlockNumber = 4 * DAYS;\n\tpub const BountyUpdatePeriod: BlockNumber = 20 * DAYS;\n\tpub const MaximumReasonLength: u32 = 5000;\n}\n\nimpl pallet_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BountyDepositBase = BountyDepositBase;\n\ttype BountyDepositPayoutDelay = BountyDepositPayoutDelay;\n\ttype BountyUpdatePeriod = BountyUpdatePeriod;\n\ttype CuratorDepositMultiplier = CuratorDepositMultiplier;\n\ttype CuratorDepositMin = CuratorDepositMin;\n\ttype CuratorDepositMax = CuratorDepositMax;\n\ttype BountyValueMinimum = BountyValueMinimum;\n\ttype DataDepositPerByte = DataDepositPerByte;\n\ttype MaximumReasonLength = MaximumReasonLength;\n\ttype WeightInfo = pallet_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype ChildBountyManager = ChildBounties;\n}\n\nparameter_types! {\n\tpub const ChildBountyValueMinimum: Balance = 1 * UNIT;\n}\n\nimpl pallet_child_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MaxActiveChildBountyCount = ConstU32\u003c10\u003e;\n\ttype ChildBountyValueMinimum = ChildBountyValueMinimum;\n\ttype WeightInfo = pallet_child_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_type_with_key! {\n\tpub ExistentialDeposits: |_currency_id: CurrencyId| -\u003e Balance {\n\t\tNANOUNIT\n\t};\n}\n\npub fn get_all_module_accounts() -\u003e Vec\u003cAccountId\u003e {\n\tvec![Treasury::account_id()]\n}\n\npub struct DustRemovalWhitelist;\nimpl Contains\u003cAccountId\u003e for DustRemovalWhitelist {\n\tfn contains(a: \u0026AccountId) -\u003e bool {\n\t\tget_all_module_accounts().contains(a)\n\t}\n}\n\npub struct CurrencyHooks\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: orml_tokens::Config\u003e MutationHooks\u003cT::AccountId, T::CurrencyId, T::Balance\u003e\n\tfor CurrencyHooks\u003cT\u003e\n{\n\ttype OnDust = orml_tokens::BurnDust\u003cT\u003e;\n\ttype OnSlash = ();\n\ttype PreDeposit = ();\n\ttype PostDeposit = ();\n\ttype PreTransfer = ();\n\ttype PostTransfer = ();\n\ttype OnNewTokenAccount = ();\n\ttype OnKilledTokenAccount = ();\n}\n\nimpl orml_tokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype Amount = Amount;\n\ttype CurrencyId = CurrencyId;\n\ttype WeightInfo = ();\n\ttype ExistentialDeposits = ExistentialDeposits;\n\ttype CurrencyHooks = CurrencyHooks\u003cRuntime\u003e;\n\ttype MaxLocks = ConstU32\u003c50\u003e;\n\ttype DustRemovalWhitelist = DustRemovalWhitelist;\n\ttype MaxReserves = ConstU32\u003c0\u003e;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const NativeCurrencyId: CurrencyId = CurrencyId::Native;\n}\n\nimpl orml_currencies::Config for Runtime {\n\ttype MultiCurrency = Tokens;\n\ttype NativeCurrency = BasicCurrencyAdapter\u003cRuntime, Balances, Amount, BlockNumber\u003e;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype WeightInfo = ();\n}\n\nimpl orml_asset_registry::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CustomMetadata = asset_registry::CustomMetadata;\n\ttype AssetId = CurrencyId;\n\ttype AuthorityOrigin = asset_registry::AssetAuthority;\n\ttype AssetProcessor = asset_registry::CustomAssetProcessor;\n\ttype Balance = Balance;\n\ttype WeightInfo = weights::orml_asset_registry::WeightInfo\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinBlocksPerRound: BlockNumber = HOURS;\n\tpub const DefaultBlocksPerRound: BlockNumber = 2 * HOURS;\n\tpub const StakeDuration: BlockNumber = 7 * DAYS;\n\tpub const ExitQueueDelay: u32 = 2;\n\tpub const MinCollators: u32 = 8;\n\tpub const MinRequiredCollators: u32 = 4;\n\tpub const MaxDelegationsPerRound: u32 = 1;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxDelegatorsPerCollator: u32 = 40;\n\tpub const MinCollatorStake: Balance = 5_000 * UNIT;\n\tpub const MinDelegatorStake: Balance = 10 * UNIT;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxTopCandidates: u32 = 50;\n\tpub const MaxUnstakeRequests: u32 = 10;\n\tpub const NetworkRewardStart: BlockNumber = BlockNumber::MAX;\n\tpub const NetworkRewardRate: Perquintill = Perquintill::from_percent(0);\n\tpub const CollatorRewardRateDecay: Perquintill = Perquintill::from_parts(938_252_045_000_000_000u64);\n}\n\nimpl parachain_staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyBalance = Balance;\n\n\ttype MinBlocksPerRound = MinBlocksPerRound;\n\ttype DefaultBlocksPerRound = DefaultBlocksPerRound;\n\ttype StakeDuration = StakeDuration;\n\ttype ExitQueueDelay = ExitQueueDelay;\n\ttype MinCollators = MinCollators;\n\ttype MinRequiredCollators = MinRequiredCollators;\n\ttype MaxDelegationsPerRound = MaxDelegationsPerRound;\n\ttype MaxDelegatorsPerCollator = MaxDelegatorsPerCollator;\n\ttype MinCollatorStake = MinCollatorStake;\n\ttype MinCollatorCandidateStake = MinCollatorStake;\n\ttype MaxTopCandidates = MaxTopCandidates;\n\ttype MinDelegatorStake = MinDelegatorStake;\n\ttype MaxUnstakeRequests = MaxUnstakeRequests;\n\ttype NetworkRewardRate = NetworkRewardRate;\n\ttype NetworkRewardStart = NetworkRewardStart;\n\ttype NetworkRewardBeneficiary = Treasury;\n\ttype CollatorRewardRateDecay = CollatorRewardRateDecay;\n\ttype WeightInfo = parachain_staking::default_weights::SubstrateWeight\u003cRuntime\u003e;\n\n\tconst BLOCKS_PER_YEAR: BlockNumber = BLOCKS_PER_YEAR;\n}\n\nparameter_types! {\n\tpub const DepositBase: Balance = 300 * MILLIUNIT;\n\tpub const DepositFactor: Balance = 50 * MILLIUNIT;\n}\n\nimpl pallet_multisig::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Currency = Balances;\n\ttype DepositBase = DepositBase;\n\ttype DepositFactor = DepositFactor;\n\ttype MaxSignatories = ConstU32\u003c20\u003e;\n\ttype WeightInfo = pallet_multisig::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_utility::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype PalletsOrigin = OriginCaller;\n\ttype WeightInfo = pallet_utility::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinVestedTransfer: Balance = 0;\n\tpub UnvestedFundsAllowedWithdrawReasons: WithdrawReasons =\n\t\tWithdrawReasons::except(WithdrawReasons::TRANSFER | WithdrawReasons::RESERVE);\n}\n\nimpl pallet_vesting::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BlockNumberToBalance = ConvertInto;\n\ttype MinVestedTransfer = MinVestedTransfer;\n\ttype UnvestedFundsAllowedWithdrawReasons = UnvestedFundsAllowedWithdrawReasons;\n\ttype WeightInfo = pallet_vesting::weights::SubstrateWeight\u003cRuntime\u003e;\n\tconst MAX_VESTING_SCHEDULES: u32 = 10;\n}\n\nimpl vesting_manager::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype VestingSchedule = Vesting;\n}\n\nconst fn deposit(items: u32, bytes: u32) -\u003e Balance {\n\t(items as Balance * UNIT + (bytes as Balance) * (5 * MILLIUNIT / 100)) / 10\n}\n\nparameter_types! {\n\tpub const DepositPerItem: Balance = deposit(1, 0);\n\tpub const DepositPerByte: Balance = deposit(0, 1);\n\tpub const DeletionQueueDepth: u32 = 128;\n\tpub DeletionWeightLimit: Weight = RuntimeBlockWeights::get()\n\t\t.per_class\n\t\t.get(DispatchClass::Normal)\n\t\t.max_total\n\t\t.unwrap_or(RuntimeBlockWeights::get().max_block);\n\tpub Schedule: pallet_contracts::Schedule\u003cRuntime\u003e = Default::default();\n}\n\nimpl pallet_contracts::Config for Runtime {\n\ttype Time = Timestamp;\n\ttype Randomness = RandomnessCollectiveFlip;\n\ttype Currency = Balances;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype CallFilter = frame_support::traits::Nothing;\n\ttype DepositPerItem = DepositPerItem;\n\ttype DepositPerByte = DepositPerByte;\n\ttype CallStack = [pallet_contracts::Frame\u003cSelf\u003e; 5];\n\ttype WeightPrice = pallet_transaction_payment::Pallet\u003cSelf\u003e;\n\ttype WeightInfo = pallet_contracts::weights::SubstrateWeight\u003cSelf\u003e;\n\ttype ChainExtension = ();\n\ttype DeletionQueueDepth = DeletionQueueDepth;\n\ttype DeletionWeightLimit = DeletionWeightLimit;\n\ttype Schedule = Schedule;\n\ttype AddressGenerator = pallet_contracts::DefaultAddressGenerator;\n\ttype MaxCodeLen = ConstU32\u003c{ 123 * 1024 }\u003e;\n\ttype MaxStorageKeyLen = ConstU32\u003c128\u003e;\n\ttype UnsafeUnstableInterface = ConstBool\u003ctrue\u003e;\n\ttype MaxDebugBufferLen = ConstU32\u003c{ 2 * 1024 * 1024 }\u003e;\n}\n\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {}\n\nparameter_types! {\n\tpub const BasicDeposit: Balance = 10 * UNIT;       // 258 bytes on-chain\n\tpub const FieldDeposit: Balance = 25 * MILLIUNIT;  // 66 bytes on-chain\n\tpub const SubAccountDeposit: Balance = 2 * UNIT;   // 53 bytes on-chain\n\tpub const MaxSubAccounts: u32 = 100;\n\tpub const MaxAdditionalFields: u32 = 100;\n\tpub const MaxRegistrars: u32 = 20;\n}\n\ntype EnsureRootOrHalfCouncil = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_identity::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BasicDeposit = BasicDeposit;\n\ttype FieldDeposit = FieldDeposit;\n\ttype SubAccountDeposit = SubAccountDeposit;\n\ttype MaxSubAccounts = MaxSubAccounts;\n\ttype MaxAdditionalFields = MaxAdditionalFields;\n\ttype MaxRegistrars = MaxRegistrars;\n\ttype Slashed = Treasury;\n\ttype ForceOrigin = EnsureRootOrHalfCouncil;\n\ttype RegistrarOrigin = EnsureRootOrHalfCouncil;\n\ttype WeightInfo = pallet_identity::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl dia_oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype AuthorityId = dia_oracle::crypto::DiaAuthId;\n\ttype WeightInfo = dia_oracle::weights::DiaWeightInfo\u003cRuntime\u003e;\n}\n\nimpl frame_system::offchain::SigningTypes for Runtime {\n\ttype Public = \u003cSignature as sp_runtime::traits::Verify\u003e::Signer;\n\ttype Signature = Signature;\n}\n\nimpl\u003cC\u003e frame_system::offchain::SendTransactionTypes\u003cC\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cC\u003e,\n{\n\ttype OverarchingCall = RuntimeCall;\n\ttype Extrinsic = UncheckedExtrinsic;\n}\n\nimpl\u003cLocalCall\u003e frame_system::offchain::CreateSignedTransaction\u003cLocalCall\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cLocalCall\u003e,\n{\n\tfn create_transaction\u003cC: frame_system::offchain::AppCrypto\u003cSelf::Public, Self::Signature\u003e\u003e(\n\t\tcall: RuntimeCall,\n\t\tpublic: \u003cSignature as sp_runtime::traits::Verify\u003e::Signer,\n\t\taccount: AccountId,\n\t\tindex: Index,\n\t) -\u003e Option\u003c(\n\t\tRuntimeCall,\n\t\t\u003cUncheckedExtrinsic as sp_runtime::traits::Extrinsic\u003e::SignaturePayload,\n\t)\u003e {\n\t\tlet period = BlockHashCount::get() as u64;\n\t\tlet current_block = System::block_number().saturated_into::\u003cu64\u003e().saturating_sub(1);\n\t\tlet tip = 0;\n\t\tlet extra: SignedExtra = (\n\t\t\tframe_system::CheckNonZeroSender::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckSpecVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckTxVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckGenesis::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckEra::\u003cRuntime\u003e::from(generic::Era::mortal(period, current_block)),\n\t\t\tframe_system::CheckNonce::\u003cRuntime\u003e::from(index),\n\t\t\tframe_system::CheckWeight::\u003cRuntime\u003e::new(),\n\t\t\tpallet_transaction_payment::ChargeTransactionPayment::\u003cRuntime\u003e::from(tip),\n\t\t);\n\n\t\tlet raw_payload = SignedPayload::new(call, extra).ok()?;\n\t\tlet signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;\n\t\tlet address = account;\n\t\tlet (call, extra, _) = raw_payload.deconstruct();\n\t\tSome((call, (sp_runtime::MultiAddress::Id(address), signature.into(), extra)))\n\t}\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\t// System support stuff.\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 0,\n\t\tParachainSystem: cumulus_pallet_parachain_system::{\n\t\t\tPallet, Call, Config, Storage, Inherent, Event\u003cT\u003e, ValidateUnsigned,\n\t\t} = 1,\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent} = 2,\n\t\tParachainInfo: parachain_info::{Pallet, Storage, Config} = 3,\n\n\t\t// Monetary stuff.\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 10,\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event\u003cT\u003e} = 11,\n\n\t\t// Governance\n\t\tDemocracy: pallet_democracy::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 13,\n\t\tCouncil: pallet_collective::\u003cInstance1\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e, Event\u003cT\u003e} = 14,\n\t\tTechnicalCommittee: pallet_collective::\u003cInstance2\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e,  Event\u003cT\u003e} = 15,\n\t\tScheduler: pallet_scheduler::{Pallet, Call, Storage, Event\u003cT\u003e} = 16,\n\t\tPreimage: pallet_preimage::{Pallet, Call, Storage, Event\u003cT\u003e} = 17,\n\t\tMultisig: pallet_multisig::{Pallet, Call, Storage, Event\u003cT\u003e} = 18,\n\t\tTreasury: pallet_treasury::{Pallet, Call, Storage, Event\u003cT\u003e} = 19,\n\t\tBounties: pallet_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 20,\n\t\tChildBounties: pallet_child_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 21,\n\n\t\t// Consensus support.\n\t\t// The following order MUST NOT be changed: Aura -\u003e Session -\u003e Staking -\u003e Authorship -\u003e AuraExt\n\t\t// Dependencies: AuraExt on Aura, Authorship and Session on ParachainStaking\n\t\tAura: pallet_aura::{Pallet, Storage, Config\u003cT\u003e} = 33,\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e} = 32,\n\t\tParachainStaking: parachain_staking::{Pallet, Call, Storage, Event\u003cT\u003e, Config\u003cT\u003e} = 35,\n\t\tAuthorship: pallet_authorship::{Pallet, Storage} = 30,\n\t\tAuraExt: cumulus_pallet_aura_ext::{Pallet, Storage, Config} = 34,\n\n\t\t// XCM helpers.\n\t\tXcmpQueue: cumulus_pallet_xcmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 40,\n\t\tPolkadotXcm: pallet_xcm::{Pallet, Call, Event\u003cT\u003e, Origin, Config} = 41,\n\t\tCumulusXcm: cumulus_pallet_xcm::{Pallet, Event\u003cT\u003e, Origin} = 42,\n\t\tDmpQueue: cumulus_pallet_dmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 43,\n\n\t\t// Amendments\n\t\tVesting: pallet_vesting::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 50,\n\t\tUtility: pallet_utility::{Pallet, Call, Event} = 51,\n\t\tCurrencies: orml_currencies::{Pallet, Call, Storage} = 52,\n\t\tTokens: orml_tokens::{Pallet, Call, Storage, Event\u003cT\u003e} = 53,\n\t\tXTokens: orml_xtokens::{Pallet, Storage, Call, Event\u003cT\u003e} = 54,\n\t\tIdentity: pallet_identity::{Pallet, Storage, Call, Event\u003cT\u003e} = 55,\n\t\tContracts: pallet_contracts::{Pallet, Storage, Call, Event\u003cT\u003e} = 56,\n\t\tRandomnessCollectiveFlip: pallet_insecure_randomness_collective_flip::{Pallet, Storage} = 57,\n\t\tDiaOracleModule: dia_oracle::{Pallet, Storage, Call, Event\u003cT\u003e} = 58,\n\n\t\tZenlinkProtocol: zenlink_protocol::{Pallet, Call, Storage, Event\u003cT\u003e}  = 59,\n\n\t\t// Asset Metadata\n\t\tAssetRegistry: orml_asset_registry::{Pallet, Storage, Call, Event\u003cT\u003e, Config\u003cT\u003e} = 91,\n\n\t\tVestingManager: vesting_manager::{Pallet, Call, Event\u003cT\u003e} = 100\n\t}\n);\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!(\n\t\t[frame_benchmarking, BaselineBench::\u003cRuntime\u003e]\n\t\t[frame_system, SystemBench::\u003cRuntime\u003e]\n\t\t[pallet_balances, Balances]\n\t\t[pallet_session, SessionBench::\u003cRuntime\u003e]\n\t\t[pallet_timestamp, Timestamp]\n\t\t[cumulus_pallet_xcmp_queue, XcmpQueue]\n\n\t\t// Other\n\t\t[orml_asset_registry, runtime_common::benchmarking::orml_asset_registry::Pallet::\u003cRuntime\u003e]\n\t\t[pallet_xcm, PolkadotXcm]\n\t);\n}\n\nimpl_runtime_apis! {\n\timpl sp_consensus_aura::AuraApi\u003cBlock, AuraId\u003e for Runtime {\n\t\tfn slot_duration() -\u003e sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -\u003e Vec\u003cAuraId\u003e {\n\t\t\tAura::authorities().into_inner()\n\t\t}\n\t}\n\n\timpl sp_api::Core\u003cBlock\u003e for Runtime {\n\t\tfn version() -\u003e RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata\u003cBlock\u003e for Runtime {\n\t\tfn metadata() -\u003e OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder\u003cBlock\u003e for Runtime {\n\t\tfn apply_extrinsic(extrinsic: \u003cBlock as BlockT\u003e::Extrinsic) -\u003e ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -\u003e \u003cBlock as BlockT\u003e::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -\u003e Vec\u003c\u003cBlock as BlockT\u003e::Extrinsic\u003e {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(\u0026block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tblock_hash: \u003cBlock as BlockT\u003e::Hash,\n\t\t) -\u003e TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi\u003cBlock\u003e for Runtime {\n\t\tfn offchain_worker(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys\u003cBlock\u003e for Runtime {\n\t\tfn generate_session_keys(seed: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n\t\t\tSessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec\u003cu8\u003e,\n\t\t) -\u003e Option\u003cVec\u003c(Vec\u003cu8\u003e, KeyTypeId)\u003e\u003e {\n\t\t\tSessionKeys::decode_into_raw_public_keys(\u0026encoded)\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi\u003cBlock, AccountId, Index\u003e for Runtime {\n\t\tfn account_nonce(account: AccountId) -\u003e Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi\u003cBlock, Balance\u003e for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t\tfn query_fee_details(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment::FeeDetails\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t\tfn query_weight_to_fee(weight: Weight) -\u003e Balance {\n\t\t\tTransactionPayment::weight_to_fee(weight)\n\t\t}\n\t\tfn query_length_to_fee(length: u32) -\u003e Balance {\n\t\t\tTransactionPayment::length_to_fee(length)\n\t\t}\n\t}\n\n\timpl cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e for Runtime {\n\t\tfn collect_collation_info(header: \u0026\u003cBlock as BlockT\u003e::Header) -\u003e cumulus_primitives_core::CollationInfo {\n\t\t\tParachainSystem::collect_collation_info(header)\n\t\t}\n\t}\n\n\timpl parachain_staking::runtime_api::ParachainStakingApi\u003cBlock, AccountId, Balance\u003e for Runtime {\n\t\tfn get_unclaimed_staking_rewards(account: \u0026AccountId) -\u003e Balance {\n\t\t\tParachainStaking::get_unclaimed_staking_rewards(account)\n\t\t}\n\n\t\tfn get_staking_rates() -\u003e parachain_staking::runtime_api::StakingRates {\n\t\t\tParachainStaking::get_staking_rates()\n\t\t}\n\t}\n\n\timpl dia_oracle_runtime_api::DiaOracleApi\u003cBlock\u003e for Runtime{\n\t\tfn get_value(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::PriceInfo, sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_value(blockchain, symbol)\n\t\t}\n\n\t\tfn get_coin_info(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::CoinInfo,sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_coin_info(blockchain, symbol)\n\t\t}\n\t}\n\n\t// zenlink runtime outer apis\n\timpl zenlink_protocol_runtime_api::ZenlinkProtocolApi\u003cBlock, AccountId, ZenlinkAssetId\u003e for Runtime {\n\n\t\tfn get_balance(\n\t\t\tasset_id: ZenlinkAssetId,\n\t\t\towner: AccountId\n\t\t) -\u003e AssetBalance {\n\t\t\t\u003cRuntime as zenlink_protocol::Config\u003e::MultiAssetsHandler::balance_of(asset_id, \u0026owner)\n\t\t}\n\n\t\tfn get_pair_by_asset_id(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId\n\t\t) -\u003e Option\u003cPairInfo\u003cAccountId, AssetBalance, ZenlinkAssetId\u003e\u003e {\n\t\t\tZenlinkProtocol::get_pair_by_asset_id(asset_0, asset_1)\n\t\t}\n\n\t\tfn get_amount_in_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::desired_in_amount(supply, path)\n\t\t}\n\n\t\tfn get_amount_out_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::supply_out_amount(supply, path)\n\t\t}\n\n\t\tfn get_estimate_lptoken(\n\t\t\ttoken_0: ZenlinkAssetId,\n\t\t\ttoken_1: ZenlinkAssetId,\n\t\t\tamount_0_desired: AssetBalance,\n\t\t\tamount_1_desired: AssetBalance,\n\t\t\tamount_0_min: AssetBalance,\n\t\t\tamount_1_min: AssetBalance,\n\t\t) -\u003e AssetBalance{\n\t\t\tZenlinkProtocol::get_estimate_lptoken(\n\t\t\t\ttoken_0,\n\t\t\t\ttoken_1,\n\t\t\t\tamount_0_desired,\n\t\t\t\tamount_1_desired,\n\t\t\t\tamount_0_min,\n\t\t\t\tamount_1_min\n\t\t\t)\n\t\t}\n\n\t\tfn calculate_remove_liquidity(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId,\n\t\t\tamount: AssetBalance,\n\t\t) -\u003e Option\u003c(AssetBalance, AssetBalance)\u003e{\n\t\t\tZenlinkProtocol::calculate_remove_liquidity(\n\t\t\t\tasset_0,\n\t\t\t\tasset_1,\n\t\t\t\tamount,\n\t\t\t)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\timpl frame_try_runtime::TryRuntime\u003cBlock\u003e for Runtime {\n\t\tfn on_runtime_upgrade() -\u003e (Weight, Weight) {\n\t\t\tlog::info!(\"try-runtime::on_runtime_upgrade pendulum.\");\n\t\t\tlet weight = Executive::try_runtime_upgrade().unwrap();\n\t\t\t(weight, RuntimeBlockWeights::get().max_block)\n\t\t}\n\n\t\tfn execute_block_no_check(block: Block) -\u003e Weight {\n\t\t\tExecutive::execute_block_no_check(block)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark\u003cBlock\u003e for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -\u003e (\n\t\t\tVec\u003cframe_benchmarking::BenchmarkList\u003e,\n\t\t\tVec\u003cframe_support::traits::StorageInfo\u003e,\n\t\t) {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\tlet mut list = Vec::\u003cBenchmarkList\u003e::new();\n\t\t\tlist_benchmarks!(list, extra);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -\u003e Result\u003cVec\u003cframe_benchmarking::BenchmarkBatch\u003e, sp_runtime::RuntimeString\u003e {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, TrackedStorageKey};\n\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\t\t\timpl baseline::Config for Runtime {}\n\t\t\timpl runtime_common::benchmarking::orml_asset_registry::Config for Runtime {}\n\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\timpl cumulus_pallet_session_benchmarking::Config for Runtime {}\n\n\n\t\t\tlet whitelist: Vec\u003cTrackedStorageKey\u003e = vec![\n\t\t\t\t// Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t// Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t// Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t// Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t// System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::\u003cBenchmarkBatch\u003e::new();\n\t\t\tlet params = (\u0026config, \u0026whitelist);\n\t\t\tadd_benchmarks!(params, batches);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n\n\timpl pallet_contracts::ContractsApi\u003cBlock, AccountId, Balance, BlockNumber, Hash\u003e\n\t\tfor Runtime\n\t{\n\t\tfn call(\n\t\t\torigin: AccountId,\n\t\t\tdest: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tinput_data: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractExecResult\u003cBalance\u003e {\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_call(\n\t\t\t\torigin,\n\t\t\t\tdest,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tinput_data,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT,\n\t\t\t\tpallet_contracts::Determinism::Deterministic,\n\t\t\t)\n\t\t}\n\n\t\tfn instantiate(\n\t\t\torigin: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tcode: pallet_contracts_primitives::Code\u003cHash\u003e,\n\t\t\tdata: Vec\u003cu8\u003e,\n\t\t\tsalt: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractInstantiateResult\u003cAccountId, Balance\u003e\n\t\t{\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_instantiate(\n\t\t\t\torigin,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tcode,\n\t\t\t\tdata,\n\t\t\t\tsalt,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT\n\t\t\t)\n\t\t}\n\n\t\tfn upload_code(\n\t\t\torigin: AccountId,\n\t\t\tcode: Vec\u003cu8\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tdeterminism: pallet_contracts::Determinism,\n\t\t) -\u003e pallet_contracts_primitives::CodeUploadResult\u003cHash, Balance\u003e\n\t\t{\n\t\t\tContracts::bare_upload_code(origin, code, storage_deposit_limit, determinism)\n\t\t}\n\n\t\tfn get_storage(\n\t\t\taddress: AccountId,\n\t\t\tkey: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::GetStorageResult {\n\t\t\tContracts::get_storage(address, key)\n\t\t}\n\t}\n\n}\n\nstruct CheckInherents;\n\nimpl cumulus_pallet_parachain_system::CheckInherents\u003cBlock\u003e for CheckInherents {\n\tfn check_inherents(\n\t\tblock: \u0026Block,\n\t\trelay_state_proof: \u0026cumulus_pallet_parachain_system::RelayChainStateProof,\n\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\tlet relay_chain_slot = relay_state_proof\n\t\t\t.read_slot()\n\t\t\t.expect(\"Could not read the relay chain slot from the proof\");\n\n\t\tlet inherent_data =\n\t\t\tcumulus_primitives_timestamp::InherentDataProvider::from_relay_chain_slot_and_duration(\n\t\t\t\trelay_chain_slot,\n\t\t\t\tsp_std::time::Duration::from_secs(6),\n\t\t\t)\n\t\t\t.create_inherent_data()\n\t\t\t.expect(\"Could not create the timestamp inherent data\");\n\n\t\tinherent_data.check_extrinsics(block)\n\t}\n}\n\ncumulus_pallet_parachain_system::register_validate_block! {\n\tRuntime = Runtime,\n\tBlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::\u003cRuntime, Executive\u003e,\n\tCheckInherents = CheckInherents,\n}\n","traces":[{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":948,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":949,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","block_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Importing a block with 0 Extrinsics.\n\t\tpub const BlockExecutionWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::BlockExecutionWeight::get();\n\n\t\t\t// At least 100 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 100u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 100 µs.\"\n\t\t\t);\n\t\t\t// At most 50 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= 50u64 * constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 50 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","extrinsic_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Executing a NO-OP `System::remarks` Extrinsic.\n\t\tpub const ExtrinsicBaseWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::ExtrinsicBaseWeight::get();\n\n\t\t\t// At least 10 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 10u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 10 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","mod.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Expose the auto generated weight files.\n\npub mod block_weights;\npub mod extrinsic_weights;\npub mod orml_asset_registry;\npub mod pallet_xcm;\npub mod paritydb_weights;\npub mod rocksdb_weights;\n\npub use block_weights::constants::BlockExecutionWeight;\npub use extrinsic_weights::constants::ExtrinsicBaseWeight;\npub use paritydb_weights::constants::ParityDbWeight;\npub use rocksdb_weights::constants::RocksDbWeight;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","orml_asset_registry.rs"],"content":"\n//! Autogenerated weights for `orml_asset_registry`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-07-25, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Marcels-MBP`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"pendulum\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// pendulum\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet\n// *\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// runtime/pendulum/src/weights/\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `orml_asset_registry`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e orml_asset_registry::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn register_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `66`\n\t\t//  Estimated: `7062`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 7062))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:2)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn update_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `707`\n\t\t//  Estimated: `8344`\n\t\t// Minimum execution time: 25_000_000 picoseconds.\n\t\tWeight::from_parts(26_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8344))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\tfn set_asset_location() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 0_000 picoseconds.\n\t\tWeight::from_parts(0, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","pallet_xcm.rs"],"content":"\n//! Autogenerated weights for `pallet_xcm`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-06-20, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Bs-MacBook-Pro.local`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"pendulum\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// pendulum\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet=pallet-xcm\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// pallet_xcm.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `pallet_xcm`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e pallet_xcm::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn send() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `145`\n\t\t//  Estimated: `10130`\n\t\t// Minimum execution time: 25_000_000 picoseconds.\n\t\tWeight::from_parts(26_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 10130))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: Benchmark Override (r:0 w:0)\n\t/// Proof Skipped: Benchmark Override (max_values: None, max_size: None, mode: Measured)\n\tfn teleport_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 18_446_744_073_709_551_000 picoseconds.\n\t\tWeight::from_parts(18_446_744_073_709_551_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: ParachainInfo ParachainId (r:1 w:0)\n\t/// Proof: ParachainInfo ParachainId (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn reserve_transfer_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(19_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 1489))\n\t\t\t.saturating_add(T::DbWeight::get().reads(1))\n\t}\n\tfn execute() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn force_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\tfn force_default_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 3_000_000 picoseconds.\n\t\tWeight::from_parts(3_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm QueryCounter (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm QueryCounter (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_subscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `145`\n\t\t//  Estimated: `15515`\n\t\t// Minimum execution time: 29_000_000 picoseconds.\n\t\tWeight::from_parts(30_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 15515))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_unsubscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `328`\n\t\t//  Estimated: `15166`\n\t\t// Minimum execution time: 30_000_000 picoseconds.\n\t\tWeight::from_parts(31_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 15166))\n\t\t\t.saturating_add(T::DbWeight::get().reads(6))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_supported_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `162`\n\t\t//  Estimated: `11052`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11052))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notifiers() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `166`\n\t\t//  Estimated: `11056`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11056))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:5 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn already_notified_target() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `173`\n\t\t//  Estimated: `13538`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 13538))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:2 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn notify_current_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `212`\n\t\t//  Estimated: `16617`\n\t\t// Minimum execution time: 28_000_000 picoseconds.\n\t\tWeight::from_parts(28_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 16617))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:3 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn notify_target_migration_fail() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `206`\n\t\t//  Estimated: `8621`\n\t\t// Minimum execution time: 10_000_000 picoseconds.\n\t\tWeight::from_parts(11_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8621))\n\t\t\t.saturating_add(T::DbWeight::get().reads(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notify_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `173`\n\t\t//  Estimated: `11063`\n\t\t// Minimum execution time: 18_000_000 picoseconds.\n\t\tWeight::from_parts(19_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11063))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn migrate_and_notify_old_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `215`\n\t\t//  Estimated: `21585`\n\t\t// Minimum execution time: 36_000_000 picoseconds.\n\t\tWeight::from_parts(37_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 21585))\n\t\t\t.saturating_add(T::DbWeight::get().reads(9))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","paritydb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights\n\t\t/// are available for brave runtime engineers who may want to try this out as default.\n\t\tpub const ParityDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::ParityDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","rocksdb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// By default, Substrate uses `RocksDB`, so this will be the weight used throughout\n\t\t/// the runtime.\n\t\tpub const RocksDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::RocksDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","xcm_config.rs"],"content":"use super::{\n\tAccountId, Balance, Balances, CurrencyId, ParachainInfo, ParachainSystem, PolkadotXcm, Runtime,\n\tRuntimeCall, RuntimeEvent, RuntimeOrigin, Tokens, WeightToFee, XcmpQueue,\n};\nuse crate::ConstU32;\nuse core::marker::PhantomData;\nuse frame_support::{\n\tlog, match_types, parameter_types,\n\ttraits::{ContainsPair, Everything, Nothing},\n};\nuse orml_traits::{\n\tlocation::{RelativeReserveProvider, Reserve},\n\tparameter_type_with_key,\n};\nuse pallet_xcm::XcmPassthrough;\nuse polkadot_parachain::primitives::Sibling;\nuse polkadot_runtime_common::impls::ToAuthor;\nuse runtime_common::parachains::polkadot::asset_hub;\nuse sp_runtime::traits::Convert;\nuse xcm::latest::{prelude::*, Weight as XCMWeight};\nuse xcm_builder::{\n\tAccountId32Aliases, AllowUnpaidExecutionFrom, ConvertedConcreteId, EnsureXcmOrigin,\n\tFixedWeightBounds, FungiblesAdapter, NoChecking, ParentIsPreset, RelayChainAsNative,\n\tSiblingParachainAsNative, SiblingParachainConvertsVia, SignedAccountId32AsNative,\n\tSignedToAccountId32, SovereignSignedViaLocation, UsingComponents,\n};\nuse xcm_executor::{\n\ttraits::{JustTry, ShouldExecute},\n\tXcmExecutor,\n};\n\nconst XCM_ASSET_RELAY_DOT: u8 = 0;\nconst XCM_ASSET_ASSETHUB_USDT: u8 = 1;\n\nparameter_types! {\n\tpub const RelayLocation: MultiLocation = MultiLocation::parent();\n\tpub const RelayNetwork: NetworkId = NetworkId::Polkadot;\n\tpub RelayChainOrigin: RuntimeOrigin = cumulus_pallet_xcm::Origin::Relay.into();\n\tpub CheckingAccount: AccountId = PolkadotXcm::check_account();\n\tpub UniversalLocation: InteriorMultiLocation =\n\t\tX2(GlobalConsensus(RelayNetwork::get()), Parachain(ParachainInfo::parachain_id().into()));\n\n}\n\n/// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used\n/// when determining ownership of accounts for asset transacting and when attempting to use XCM\n/// `Transact` in order to determine the dispatch Origin.\npub type LocationToAccountId = (\n\t// The parent (Relay-chain) origin converts to the parent `AccountId`.\n\tParentIsPreset\u003cAccountId\u003e,\n\t// Sibling parachain origins convert to AccountId via the `ParaId::into`.\n\tSiblingParachainConvertsVia\u003cSibling, AccountId\u003e,\n\t// Straight up local `AccountId32` origins just alias directly to `AccountId`.\n\tAccountId32Aliases\u003cRelayNetwork, AccountId\u003e,\n);\n\n/// CurrencyIdConvert\n/// This type implements conversions from our `CurrencyId` type into `MultiLocation` and vice-versa.\n/// A currency locally is identified with a `CurrencyId` variant but in the network it is identified\n/// in the form of a `MultiLocation`, in this case a pCfg (Para-Id, Currency-Id).\npub struct CurrencyIdConvert;\n\nimpl Convert\u003cCurrencyId, Option\u003cMultiLocation\u003e\u003e for CurrencyIdConvert {\n\tfn convert(id: CurrencyId) -\u003e Option\u003cMultiLocation\u003e {\n\t\tmatch id {\n\t\t\t// CurrencyId::KSM =\u003e Some(MultiLocation::parent()),\n\t\t\tCurrencyId::XCM(f) =\u003e match f {\n\t\t\t\tXCM_ASSET_RELAY_DOT =\u003e Some(MultiLocation::parent()),\n\t\t\t\tXCM_ASSET_ASSETHUB_USDT =\u003e Some(MultiLocation::new(\n\t\t\t\t\t1,\n\t\t\t\t\tX3(\n\t\t\t\t\t\tParachain(asset_hub::PARA_ID),\n\t\t\t\t\t\tPalletInstance(asset_hub::ASSET_PALLET_ID),\n\t\t\t\t\t\tGeneralIndex(asset_hub::USDT_ASSET_ID),\n\t\t\t\t\t),\n\t\t\t\t)),\n\t\t\t\t_ =\u003e None,\n\t\t\t},\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Option\u003cCurrencyId\u003e {\n\t\tmatch location {\n\t\t\tMultiLocation { parents: 1, interior: Here } =\u003e\n\t\t\t\tSome(CurrencyId::XCM(XCM_ASSET_RELAY_DOT)),\n\t\t\tMultiLocation {\n\t\t\t\tparents: 1,\n\t\t\t\tinterior:\n\t\t\t\t\tX3(\n\t\t\t\t\t\tParachain(asset_hub::PARA_ID),\n\t\t\t\t\t\tPalletInstance(asset_hub::ASSET_PALLET_ID),\n\t\t\t\t\t\tGeneralIndex(asset_hub::USDT_ASSET_ID),\n\t\t\t\t\t),\n\t\t\t} =\u003e Some(CurrencyId::XCM(XCM_ASSET_ASSETHUB_USDT)),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiAsset, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(a: MultiAsset) -\u003e Option\u003cCurrencyId\u003e {\n\t\tif let MultiAsset { id: AssetId::Concrete(id), fun: _ } = a {\n\t\t\tSelf::convert(id)\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\n/// Convert an incoming `MultiLocation` into a `CurrencyId` if possible.\n/// Here we need to know the canonical representation of all the tokens we handle in order to\n/// correctly convert their `MultiLocation` representation into our internal `CurrencyId` type.\nimpl xcm_executor::traits::Convert\u003cMultiLocation, CurrencyId\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Result\u003cCurrencyId, MultiLocation\u003e {\n\t\t\u003cCurrencyIdConvert as Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e\u003e::convert(location.clone())\n\t\t\t.ok_or(location)\n\t}\n}\n\n/// A `FilterAssetLocation` implementation. Filters multi native assets whose\n/// reserve is same with `origin`.\npub struct MultiNativeAsset\u003cReserveProvider\u003e(PhantomData\u003cReserveProvider\u003e);\nimpl\u003cReserveProvider\u003e ContainsPair\u003cMultiAsset, MultiLocation\u003e for MultiNativeAsset\u003cReserveProvider\u003e\nwhere\n\tReserveProvider: Reserve,\n{\n\tfn contains(asset: \u0026MultiAsset, origin: \u0026MultiLocation) -\u003e bool {\n\t\tif let Some(ref reserve) = ReserveProvider::reserve(asset) {\n\t\t\tif reserve == origin {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tfalse\n\t}\n}\n\n/// Means for transacting the fungibles assets of ths parachain.\npub type FungiblesTransactor = FungiblesAdapter\u003c\n\t// Use this fungibles implementation\n\tTokens,\n\t// This means that this adapter should handle any token that `CurrencyIdConvert` can convert\n\t// to `CurrencyId`, the `CurrencyId` type of `Tokens`, the fungibles implementation it uses.\n\tConvertedConcreteId\u003cCurrencyId, Balance, CurrencyIdConvert, JustTry\u003e,\n\t// Convert an XCM MultiLocation into a local account id\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly)\n\tAccountId,\n\t// We dont allow teleports.\n\tNoChecking,\n\t// The account to use for tracking teleports.\n\tCheckingAccount,\n\u003e;\n\n/// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,\n/// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can\n/// biases the kind of local `Origin` it will become.\npub type XcmOriginToTransactDispatchOrigin = (\n\t// Sovereign account converter; this attempts to derive an `AccountId` from the origin location\n\t// using `LocationToAccountId` and then turn that into the usual `Signed` origin. Useful for\n\t// foreign chains who want to have a local sovereign account on this chain which they control.\n\tSovereignSignedViaLocation\u003cLocationToAccountId, RuntimeOrigin\u003e,\n\t// Native converter for Relay-chain (Parent) location; will converts to a `Relay` origin when\n\t// recognized.\n\tRelayChainAsNative\u003cRelayChainOrigin, RuntimeOrigin\u003e,\n\t// Native converter for sibling Parachains; will convert to a `SiblingPara` origin when\n\t// recognized.\n\tSiblingParachainAsNative\u003ccumulus_pallet_xcm::Origin, RuntimeOrigin\u003e,\n\t// Native signed account converter; this just converts an `AccountId32` origin into a normal\n\t// `Origin::Signed` origin of the same 32-byte value.\n\tSignedAccountId32AsNative\u003cRelayNetwork, RuntimeOrigin\u003e,\n\t// Xcm origins can be represented natively under the Xcm pallet's Xcm origin.\n\tXcmPassthrough\u003cRuntimeOrigin\u003e,\n);\n\nparameter_types! {\n\t// One XCM operation is 1_000_000_000 weight - almost certainly a conservative estimate.\n\tpub UnitWeightCost: XCMWeight = XCMWeight::from_parts(1_000_000_000, 0);\n\tpub const MaxInstructions: u32 = 100;\n\tpub SelfLocation: MultiLocation = MultiLocation::new(1, X1(Parachain(ParachainInfo::parachain_id().into())));\n\tpub const BaseXcmWeight: XCMWeight = XCMWeight::from_parts(150_000_000, 0);\n\tpub const MaxAssetsForTransfer: usize = 2;\n}\n\nmatch_types! {\n\tpub type ParentOrParentsExecutivePlurality: impl Contains\u003cMultiLocation\u003e = {\n\t\tMultiLocation { parents: 1, interior: Here } |\n\t\tMultiLocation { parents: 1, interior: X1(Plurality { id: BodyId::Executive, .. }) }\n\t};\n}\n\n//TODO: move DenyThenTry to polkadot's xcm module.\n/// Deny executing the xcm message if it matches any of the Deny filter regardless of anything else.\n/// If it passes the Deny, and matches one of the Allow cases then it is let through.\npub struct DenyThenTry\u003cDeny, Allow\u003e(PhantomData\u003cDeny\u003e, PhantomData\u003cAllow\u003e)\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute;\n\nimpl\u003cDeny, Allow\u003e ShouldExecute for DenyThenTry\u003cDeny, Allow\u003e\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute,\n{\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\tmax_weight: XCMWeight,\n\t\tweight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tDeny::should_execute(origin, instructions, max_weight, weight_credit)?;\n\t\tAllow::should_execute(origin, instructions, max_weight, weight_credit)\n\t}\n}\n\n// See issue #5233\npub struct DenyReserveTransferToRelayChain;\nimpl ShouldExecute for DenyReserveTransferToRelayChain {\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\t_max_weight: XCMWeight,\n\t\t_weight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tif instructions.iter().any(|inst| {\n\t\t\tmatches!(\n\t\t\t\tinst,\n\t\t\t\tInitiateReserveWithdraw {\n\t\t\t\t\treserve: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t..\n\t\t\t\t} | DepositReserveAsset { dest: MultiLocation { parents: 1, interior: Here }, .. } |\n\t\t\t\t\tTransferReserveAsset {\n\t\t\t\t\t\tdest: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t\t..\n\t\t\t\t\t}\n\t\t\t)\n\t\t}) {\n\t\t\treturn Err(()) // Deny\n\t\t}\n\n\t\t// allow reserve transfers to arrive from relay chain\n\t\tif matches!(origin, MultiLocation { parents: 1, interior: Here }) \u0026\u0026\n\t\t\tinstructions.iter().any(|inst| matches!(inst, ReserveAssetDeposited { .. }))\n\t\t{\n\t\t\tlog::warn!(\n\t\t\t\ttarget: \"xcm::barriers\",\n\t\t\t\t\"Unexpected ReserveAssetDeposited from the relay chain\",\n\t\t\t);\n\t\t}\n\t\t// Permit everything else\n\t\tOk(())\n\t}\n}\n\npub type Barrier = AllowUnpaidExecutionFrom\u003cEverything\u003e;\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n\ttype RuntimeCall = RuntimeCall;\n\ttype XcmSender = XcmRouter;\n\t// How to withdraw and deposit an asset.\n\ttype AssetTransactor = FungiblesTransactor;\n\ttype OriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype IsReserve = MultiNativeAsset\u003cRelativeReserveProvider\u003e;\n\t// Teleporting is disabled.\n\ttype IsTeleporter = ();\n\ttype UniversalLocation = UniversalLocation;\n\ttype Barrier = Barrier;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype Trader =\n\t\tUsingComponents\u003cWeightToFee, RelayLocation, AccountId, Balances, ToAuthor\u003cRuntime\u003e\u003e;\n\ttype ResponseHandler = PolkadotXcm;\n\ttype AssetTrap = PolkadotXcm;\n\ttype AssetLocker = ();\n\ttype AssetExchanger = ();\n\ttype AssetClaims = PolkadotXcm;\n\ttype SubscriptionService = PolkadotXcm;\n\ttype PalletInstancesInfo = crate::AllPalletsWithSystem;\n\ttype MaxAssetsIntoHolding = ConstU32\u003c8\u003e;\n\ttype FeeManager = ();\n\ttype MessageExporter = ();\n\ttype UniversalAliases = Nothing;\n\ttype CallDispatcher = RuntimeCall;\n\ttype SafeCallFilter = Everything;\n}\n\n/// No local origins on this chain are allowed to dispatch XCM sends/executions.\npub type LocalOriginToLocation = SignedToAccountId32\u003cRuntimeOrigin, AccountId, RelayNetwork\u003e;\n\n/// The means for routing XCM messages which are not for local execution into the right message\n/// queues.\npub type XcmRouter = (\n\t// Two routers - use UMP to communicate with the relay chain:\n\tcumulus_primitives_utility::ParentAsUmp\u003cParachainSystem, PolkadotXcm, ()\u003e,\n\t// ..and XCMP to communicate with the sibling chains.\n\tXcmpQueue,\n);\n\nimpl pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyMatcher = ();\n\ttype SendXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmRouter = XcmRouter;\n\ttype ExecuteXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmExecuteFilter = Everything;\n\t// ^ Disable dispatchable execute on the XCM pallet.\n\t// Needs to be `Everything` for local testing.\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype XcmTeleportFilter = Nothing;\n\ttype XcmReserveTransferFilter = Everything;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype UniversalLocation = UniversalLocation;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\n\tconst VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;\n\t// ^ Override for AdvertisedXcmVersion default\n\ttype AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;\n\ttype TrustedLockers = ();\n\ttype SovereignAccountOf = LocationToAccountId;\n\ttype MaxLockers = ConstU32\u003c8\u003e;\n\ttype WeightInfo = crate::weights::pallet_xcm::WeightInfo\u003cRuntime\u003e;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype ReachableDest = ReachableDest;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nparameter_types! {\n\tpub ReachableDest: Option\u003cMultiLocation\u003e = Some(Parent.into());\n}\n\nparameter_type_with_key! {\n\tpub ParachainMinFee: |_location: MultiLocation| -\u003e Option\u003cu128\u003e {\n\t\tNone\n\t};\n}\n\nimpl orml_xtokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype CurrencyId = CurrencyId;\n\ttype CurrencyIdConvert = CurrencyIdConvert;\n\ttype AccountIdToMultiLocation = AccountIdToMultiLocation;\n\ttype SelfLocation = SelfLocation;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype BaseXcmWeight = BaseXcmWeight;\n\ttype MaxAssetsForTransfer = MaxAssetsForTransfer;\n\ttype MinXcmFee = ParachainMinFee; //TODO to support hrmp transfer beetween parachain adjust this parameter\n\ttype MultiLocationsFilter = Everything;\n\ttype ReserveProvider = RelativeReserveProvider;\n\ttype UniversalLocation = UniversalLocation;\n}\n\npub struct AccountIdToMultiLocation;\nimpl Convert\u003cAccountId, MultiLocation\u003e for AccountIdToMultiLocation {\n\tfn convert(account: AccountId) -\u003e MultiLocation {\n\t\tMultiLocation {\n\t\t\tparents: 0,\n\t\t\tinterior: X1(AccountId32 { network: None, id: account.into() }),\n\t\t}\n\t}\n}\n\nimpl cumulus_pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n}\n","traces":[{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","zenlink.rs"],"content":"use core::convert::TryInto;\n\nuse super::*;\n\nuse orml_traits::MultiCurrency;\nuse sp_runtime::{DispatchError, DispatchResult};\nuse sp_std::marker::PhantomData;\n\nuse spacewalk_primitives::CurrencyId;\n\nuse zenlink_protocol::{\n\tAssetId, Config as ZenlinkConfig, GenerateLpAssetId, LocalAssetHandler, ZenlinkMultiAssets,\n};\npub type ZenlinkAssetId = zenlink_protocol::AssetId;\n\nuse runtime_common::{zenlink, zenlink::*};\n\npub struct ZenlinkLPGenerate\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: ZenlinkConfig\u003e GenerateLpAssetId\u003cZenlinkAssetId\u003e for ZenlinkLPGenerate\u003cT\u003e {\n\tfn generate_lp_asset_id(\n\t\tasset_0: ZenlinkAssetId,\n\t\tasset_1: ZenlinkAssetId,\n\t) -\u003e Option\u003cZenlinkAssetId\u003e {\n\t\tzenlink::generate_lp_asset_id(asset_0, asset_1, ParachainInfo::parachain_id().into())\n\t}\n}\n\nparameter_types! {\n\tpub SelfParaId: u32 = ParachainInfo::parachain_id().into();\n\tpub const ZenlinkPalletId: PalletId = PalletId(*b\"/zenlink\");\n\tpub ZenlinkRegisteredParaChains: Vec\u003c(MultiLocation, u128)\u003e = vec![];\n}\nimpl ZenlinkConfig for Runtime {\n\ttype RuntimeEvent = super::RuntimeEvent;\n\ttype MultiAssetsHandler = MultiAssets;\n\ttype PalletId = ZenlinkPalletId;\n\ttype AssetId = AssetId;\n\ttype LpGenerate = ZenlinkLPGenerate\u003cSelf\u003e;\n\ttype TargetChains = ZenlinkRegisteredParaChains;\n\ttype SelfParaId = SelfParaId;\n\ttype WeightInfo = ();\n}\n\ntype MultiAssets = ZenlinkMultiAssets\u003cZenlinkProtocol, Balances, LocalAssetAdaptor\u003cTokens\u003e\u003e;\n\npub struct LocalAssetAdaptor\u003cLocal\u003e(PhantomData\u003cLocal\u003e);\n\nimpl\u003cLocal, AccountId\u003e LocalAssetHandler\u003cAccountId\u003e for LocalAssetAdaptor\u003cLocal\u003e\nwhere\n\tLocal: MultiCurrency\u003cAccountId, CurrencyId = CurrencyId\u003e,\n{\n\tfn local_balance_of(asset_id: ZenlinkAssetId, who: \u0026AccountId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::free_balance(currency_id, \u0026who))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_total_supply(asset_id: ZenlinkAssetId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::total_issuance(currency_id))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_is_exists(asset_id: ZenlinkAssetId) -\u003e bool {\n\t\tmatch zenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into()) {\n\t\t\tOk(_) =\u003e true,\n\t\t\tErr(_) =\u003e false,\n\t\t}\n\t}\n\n\tfn local_transfer(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\ttarget: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e DispatchResult {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::transfer(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\t\u0026target,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local transfer\"))?,\n\t\t\t)\n\t\t} else {\n\t\t\tErr(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\t}\n\n\tfn local_deposit(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::deposit(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local deposit\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n\n\tfn local_withdraw(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::withdraw(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local withdraw\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":44}]};
        var previousData = {"files":[{"path":["/","Users","marcel","Documents","pendulum","node","build.rs"],"content":"use substrate_build_script_utils::{generate_cargo_keys, rerun_if_git_head_changed};\n\nfn main() {\n\tgenerate_cargo_keys();\n\n\trerun_if_git_head_changed();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","chain_spec.rs"],"content":"use cumulus_primitives_core::ParaId;\nuse runtime_common::{\n\tAccountId, AuraId, Balance, BlockNumber, Signature, EXISTENTIAL_DEPOSIT, UNIT,\n};\nuse sc_chain_spec::{ChainSpecExtension, ChainSpecGroup};\nuse sc_service::ChainType;\nuse serde::{Deserialize, Serialize};\nuse sp_core::{\n\tcrypto::{Ss58Codec, UncheckedInto},\n\tsr25519, Pair, Public,\n};\nuse sp_runtime::{\n\ttraits::{IdentifyAccount, Verify},\n\tFixedPointNumber, FixedU128, Perquintill,\n};\nuse spacewalk_primitives::{oracle::Key, Asset, CurrencyId, CurrencyId::XCM, VaultCurrencyPair};\n\nuse crate::constants::{\n\tamplitude, foucoco, pendulum, MAINNET_BRL_CURRENCY_ID, MAINNET_TZS_CURRENCY_ID,\n\tMAINNET_USDC_CURRENCY_ID,\n};\n\n/// Specialized `ChainSpec` for the normal parachain runtime.\npub type AmplitudeChainSpec =\n\tsc_service::GenericChainSpec\u003camplitude_runtime::GenesisConfig, ParachainExtensions\u003e;\n\npub type FoucocoChainSpec =\n\tsc_service::GenericChainSpec\u003cfoucoco_runtime::GenesisConfig, ParachainExtensions\u003e;\n\npub type PendulumChainSpec =\n\tsc_service::GenericChainSpec\u003cpendulum_runtime::GenesisConfig, ParachainExtensions\u003e;\n\npub type DevelopmentChainSpec =\n\tsc_service::GenericChainSpec\u003cdevelopment_runtime::GenesisConfig, ParachainExtensions\u003e;\n\n/// The default XCM version to set in genesis config.\nconst SAFE_XCM_VERSION: u32 = xcm::prelude::XCM_VERSION;\n\n/// Helper function to generate a crypto pair from seed\npub fn get_public_from_seed\u003cTPublic: Public\u003e(seed: \u0026str) -\u003e \u003cTPublic::Pair as Pair\u003e::Public {\n\t\u003cTPublic::Pair as Pair\u003e::from_string(\u0026format!(\"//{}\", seed), None)\n\t\t.expect(\"static values are valid; qed\")\n\t\t.public()\n}\n\npub fn create_pendulum_multisig_account(id: \u0026str) -\u003e AccountId {\n\tlet mut signatories: Vec\u003c_\u003e = pendulum::SUDO_SIGNATORIES\n\t\t.iter()\n\t\t.chain(vec![id].iter())\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\tsignatories.sort();\n\n\tpallet_multisig::Pallet::\u003cpendulum_runtime::Runtime\u003e::multi_account_id(\u0026signatories[..], 4)\n}\n\n/// The extensions for the [`ChainSpec`].\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, ChainSpecGroup, ChainSpecExtension)]\n#[serde(deny_unknown_fields)]\npub struct ParachainExtensions {\n\t/// The relay chain of the Parachain.\n\tpub relay_chain: String,\n\t/// The id of the Parachain.\n\tpub para_id: u32,\n}\n\nimpl ParachainExtensions {\n\t/// Try to get the extension from the given `ChainSpec`.\n\tpub fn try_get(chain_spec: \u0026dyn sc_service::ChainSpec) -\u003e Option\u003c\u0026Self\u003e {\n\t\tsc_chain_spec::get_extension(chain_spec.extensions())\n\t}\n}\n\ntype AccountPublic = \u003cSignature as Verify\u003e::Signer;\n\n/// Generate collator keys from seed.\n///\n/// This function's return type must always match the session keys of the chain in tuple format.\npub fn get_collator_keys_from_seed(seed: \u0026str) -\u003e AuraId {\n\tget_public_from_seed::\u003cAuraId\u003e(seed)\n}\n\n/// Helper function to generate an account ID from seed\npub fn get_account_id_from_seed\u003cTPublic: Public\u003e(seed: \u0026str) -\u003e AccountId\nwhere\n\tAccountPublic: From\u003c\u003cTPublic::Pair as Pair\u003e::Public\u003e,\n{\n\tAccountPublic::from(get_public_from_seed::\u003cTPublic\u003e(seed)).into_account()\n}\n\n/// Generate the session keys from individual elements.\n///\n/// The input must be a tuple of individual keys (a single arg for now since we have just one key).\npub fn get_amplitude_session_keys(keys: AuraId) -\u003e amplitude_runtime::SessionKeys {\n\tamplitude_runtime::SessionKeys { aura: keys }\n}\n\npub fn get_foucoco_session_keys(keys: AuraId) -\u003e foucoco_runtime::SessionKeys {\n\tfoucoco_runtime::SessionKeys { aura: keys }\n}\n\npub fn get_pendulum_session_keys(keys: AuraId) -\u003e pendulum_runtime::SessionKeys {\n\tpendulum_runtime::SessionKeys { aura: keys }\n}\n\npub fn get_development_session_keys(keys: AuraId) -\u003e development_runtime::SessionKeys {\n\tdevelopment_runtime::SessionKeys { aura: keys }\n}\n\npub fn amplitude_config() -\u003e AmplitudeChainSpec {\n\tsp_core::crypto::set_default_ss58_version(amplitude_runtime::SS58Prefix::get().into());\n\n\t// Give your base currency a unit name and decimal places\n\tlet mut properties = sc_chain_spec::Properties::new();\n\tproperties.insert(\"tokenSymbol\".into(), \"AMPE\".into());\n\tproperties.insert(\"tokenDecimals\".into(), amplitude::TOKEN_DECIMALS.into());\n\tproperties.insert(\"ss58Format\".into(), amplitude_runtime::SS58Prefix::get().into());\n\n\tlet mut signatories: Vec\u003c_\u003e = amplitude::INITIAL_SUDO_SIGNATORIES\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\tsignatories.sort();\n\n\tlet invulnerables: Vec\u003c_\u003e = amplitude::INITIAL_COLLATORS\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\n\tlet sudo_account = pallet_multisig::Pallet::\u003camplitude_runtime::Runtime\u003e::multi_account_id(\n\t\t\u0026signatories[..],\n\t\t3,\n\t);\n\n\tAmplitudeChainSpec::from_genesis(\n\t\t// Name\n\t\t\"Amplitude\",\n\t\t// ID\n\t\t\"amplitude\",\n\t\tChainType::Live,\n\t\tmove || {\n\t\t\tamplitude_genesis(\n\t\t\t\t// initial collators.\n\t\t\t\tinvulnerables.clone(),\n\t\t\t\tsignatories.clone(),\n\t\t\t\tvec![sudo_account.clone()],\n\t\t\t\tsudo_account.clone(),\n\t\t\t\tamplitude::PARACHAIN_ID.into(),\n\t\t\t\tfalse,\n\t\t\t)\n\t\t},\n\t\t// Bootnodes\n\t\tVec::new(),\n\t\t// Telemetry\n\t\tNone,\n\t\t// Protocol ID\n\t\tSome(\"amplitude\"),\n\t\t// Fork ID\n\t\tNone,\n\t\t// Properties\n\t\tSome(properties),\n\t\t// Extensions\n\t\tParachainExtensions {\n\t\t\trelay_chain: \"kusama\".into(), // You MUST set this to the correct network!\n\t\t\tpara_id: amplitude::PARACHAIN_ID,\n\t\t},\n\t)\n}\n\npub fn foucoco_config() -\u003e FoucocoChainSpec {\n\tsp_core::crypto::set_default_ss58_version(foucoco_runtime::SS58Prefix::get().into());\n\n\t// Give your base currency a unit name and decimal places\n\tlet mut properties = sc_chain_spec::Properties::new();\n\tproperties.insert(\"tokenSymbol\".into(), \"AMPE\".into());\n\tproperties.insert(\"tokenDecimals\".into(), foucoco::TOKEN_DECIMALS.into());\n\tproperties.insert(\"ss58Format\".into(), foucoco_runtime::SS58Prefix::get().into());\n\n\tlet mut signatories: Vec\u003c_\u003e = foucoco::INITIAL_SUDO_SIGNATORIES\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\tsignatories.sort();\n\n\tlet invulnerables: Vec\u003c_\u003e = foucoco::INITIAL_COLLATORS\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\n\tlet sudo_account =\n\t\tpallet_multisig::Pallet::\u003cfoucoco_runtime::Runtime\u003e::multi_account_id(\u0026signatories[..], 3);\n\n\tlet offchain_worker_price_feeder =\n\t\tAccountId::from_ss58check(foucoco::OFF_CHAIN_WORKER_ADDRESS).unwrap();\n\n\tFoucocoChainSpec::from_genesis(\n\t\t// Name\n\t\t\"Foucoco\",\n\t\t// ID\n\t\t\"foucoco\",\n\t\tChainType::Live,\n\t\tmove || {\n\t\t\tfoucoco_genesis(\n\t\t\t\t// initial collators.\n\t\t\t\tinvulnerables.clone(),\n\t\t\t\tsignatories.clone(),\n\t\t\t\tvec![sudo_account.clone(), offchain_worker_price_feeder.clone()],\n\t\t\t\tsudo_account.clone(),\n\t\t\t\tfoucoco::PARACHAIN_ID.into(),\n\t\t\t\tfalse,\n\t\t\t)\n\t\t},\n\t\t// Bootnodes\n\t\tVec::new(),\n\t\t// Telemetry\n\t\tNone,\n\t\t// Protocol ID\n\t\tSome(\"foucoco\"),\n\t\t// Fork ID\n\t\tNone,\n\t\t// Properties\n\t\tSome(properties),\n\t\t// Extensions\n\t\tParachainExtensions {\n\t\t\trelay_chain: \"kusama\".into(), // You MUST set this to the correct network!\n\t\t\tpara_id: foucoco::PARACHAIN_ID,\n\t\t},\n\t)\n}\n\npub fn pendulum_config() -\u003e PendulumChainSpec {\n\t// Give your base currency a unit name and decimal places\n\n\tsp_core::crypto::set_default_ss58_version(pendulum_runtime::SS58Prefix::get().into());\n\n\tlet mut properties = sc_chain_spec::Properties::new();\n\tproperties.insert(\"tokenSymbol\".into(), \"PEN\".into());\n\tproperties.insert(\"tokenDecimals\".into(), pendulum::TOKEN_DECIMALS.into());\n\tproperties.insert(\"ss58Format\".into(), pendulum_runtime::SS58Prefix::get().into());\n\n\tlet multisig_genesis = create_pendulum_multisig_account(pendulum::MULTISIG_ID_GENESIS);\n\tlet multisig_cl_reserves = create_pendulum_multisig_account(pendulum::MULTISIG_ID_CL_RESERVES);\n\tlet multisig_incentives = create_pendulum_multisig_account(pendulum::MULTISIG_ID_INCENTIVES);\n\tlet multisig_marketing = create_pendulum_multisig_account(pendulum::MULTISIG_ID_MARKETING);\n\n\tlet collators: Vec\u003c_\u003e = pendulum::INITIAL_COLLATORS\n\t\t.iter()\n\t\t.map(|ss58| AccountId::from_ss58check(ss58).unwrap())\n\t\t.collect();\n\n\tlet mut vesting_schedules = vec![];\n\tlet mut balances = vec![];\n\tlet blocks_per_year = pendulum_runtime::BLOCKS_PER_YEAR;\n\n\tlet treasury = pallet_treasury::Pallet::\u003cpendulum_runtime::Runtime\u003e::account_id();\n\n\tfor pendulum::Allocation { address, amount } in pendulum::ALLOCATIONS_10_24 {\n\t\tlet account_id = AccountId::from_ss58check(address).unwrap();\n\t\tbalances.push((account_id.clone(), amount * UNIT));\n\t\tvesting_schedules.push((account_id, 0, blocks_per_year * 2, amount * UNIT / 10))\n\t}\n\n\tfor pendulum::Allocation { address, amount } in pendulum::ALLOCATIONS_12_36 {\n\t\tlet account_id = AccountId::from_ss58check(address).unwrap();\n\t\tbalances.push((account_id.clone(), amount * UNIT));\n\t\tvesting_schedules.push((account_id.clone(), blocks_per_year, 1, amount * UNIT * 2 / 3));\n\t\tvesting_schedules.push((\n\t\t\taccount_id,\n\t\t\tblocks_per_year,\n\t\t\tblocks_per_year * 2,\n\t\t\tamount * UNIT / 3,\n\t\t));\n\t}\n\n\tfor collator in collators.clone() {\n\t\tbalances\n\t\t\t.push((collator, pendulum::INITIAL_COLLATOR_STAKING + pendulum::COLLATOR_ADDITIONAL));\n\t}\n\n\tbalances.push((multisig_cl_reserves.clone(), pendulum::CL_RESERVES_ALLOCATION));\n\tvesting_schedules.push((multisig_cl_reserves, 0, blocks_per_year * 22 / 12, 0));\n\n\tbalances.push((multisig_incentives.clone(), pendulum::INCENTIVES_ALLOCATION));\n\tvesting_schedules.push((\n\t\tmultisig_incentives,\n\t\t0,\n\t\tblocks_per_year * 3,\n\t\tpendulum::INCENTIVES_ALLOCATION * 30 / 100,\n\t));\n\n\tbalances.push((multisig_marketing.clone(), pendulum::MARKETING_ALLOCATION));\n\tvesting_schedules.push((\n\t\tmultisig_marketing,\n\t\t0,\n\t\tblocks_per_year * 3,\n\t\tpendulum::MARKETING_ALLOCATION * 10 / 100,\n\t));\n\n\tbalances.push((treasury.clone(), pendulum::TREASURY_ALLOCATION));\n\tvesting_schedules.push((\n\t\ttreasury,\n\t\t0,\n\t\tblocks_per_year * 3,\n\t\tpendulum::TREASURY_ALLOCATION * 20 / 100,\n\t));\n\n\tlet multisig_identifiers = vec![\n\t\tpendulum::MULTISIG_ID_GENESIS,\n\t\tpendulum::MULTISIG_ID_TEAM,\n\t\tpendulum::MULTISIG_ID_CL_RESERVES,\n\t\tpendulum::MULTISIG_ID_INCENTIVES,\n\t\tpendulum::MULTISIG_ID_MARKETING,\n\t];\n\n\tfor signatory in pendulum::SUDO_SIGNATORIES.iter().chain(multisig_identifiers.iter()) {\n\t\tlet account_id = AccountId::from_ss58check(signatory).unwrap();\n\t\tbalances.push((account_id, pendulum::INITIAL_ISSUANCE_PER_SIGNATORY));\n\t}\n\n\tPendulumChainSpec::from_genesis(\n\t\t// Name\n\t\t\"Pendulum\",\n\t\t// ID\n\t\t\"pendulum\",\n\t\tChainType::Live,\n\t\tmove || {\n\t\t\tpendulum_genesis(\n\t\t\t\t// initial collators.\n\t\t\t\tcollators.clone(),\n\t\t\t\tbalances.clone(),\n\t\t\t\tvesting_schedules.clone(),\n\t\t\t\tmultisig_genesis.clone(),\n\t\t\t\tpendulum::PARACHAIN_ID.into(),\n\t\t\t)\n\t\t},\n\t\t// Bootnodes\n\t\tVec::new(),\n\t\t// Telemetry\n\t\tNone,\n\t\t// Protocol ID\n\t\tSome(\"pendulum\"),\n\t\t// Fork ID\n\t\tNone,\n\t\t// Properties\n\t\tSome(properties),\n\t\t// Extensions\n\t\tParachainExtensions {\n\t\t\trelay_chain: \"polkadot\".into(), // You MUST set this to the correct network!\n\t\t\tpara_id: pendulum::PARACHAIN_ID,\n\t\t},\n\t)\n}\n\npub fn development_config() -\u003e DevelopmentChainSpec {\n\t// Give your base currency a unit name and decimal places\n\tlet mut properties = sc_chain_spec::Properties::new();\n\tproperties.insert(\"tokenSymbol\".into(), \"UNIT\".into());\n\tproperties.insert(\"tokenDecimals\".into(), foucoco::TOKEN_DECIMALS.into());\n\tproperties.insert(\"ss58Format\".into(), 42.into());\n\n\tDevelopmentChainSpec::from_genesis(\n\t\t// Name\n\t\t\"Development\",\n\t\t// ID\n\t\t\"dev\",\n\t\tChainType::Development,\n\t\tmove || {\n\t\t\ttestnet_genesis(\n\t\t\t\t// initial collators.\n\t\t\t\tvec![\n\t\t\t\t\t(\n\t\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Alice\"),\n\t\t\t\t\t\tget_collator_keys_from_seed(\"Alice\"),\n\t\t\t\t\t),\n\t\t\t\t\t(\n\t\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Bob\"),\n\t\t\t\t\t\tget_collator_keys_from_seed(\"Bob\"),\n\t\t\t\t\t),\n\t\t\t\t],\n\t\t\t\tvec![\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Alice\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Bob\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Charlie\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Dave\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Eve\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Ferdie\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Alice//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Bob//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Charlie//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Dave//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Eve//stash\"),\n\t\t\t\t\tget_account_id_from_seed::\u003csr25519::Public\u003e(\"Ferdie//stash\"),\n\t\t\t\t],\n\t\t\t\t1000.into(),\n\t\t\t)\n\t\t},\n\t\t// Bootnodes\n\t\tVec::new(),\n\t\t// Telemetry\n\t\tNone,\n\t\t// Protocol ID\n\t\tSome(\"pendulum-development\"),\n\t\t// Fork ID\n\t\tNone,\n\t\t// Properties\n\t\tSome(properties),\n\t\t// Extensions\n\t\tParachainExtensions {\n\t\t\trelay_chain: \"rococo-local\".into(), // You MUST set this to the correct network!\n\t\t\tpara_id: 1000,\n\t\t},\n\t)\n}\n\nfn amplitude_genesis(\n\tinvulnerables: Vec\u003cAccountId\u003e,\n\tsignatories: Vec\u003cAccountId\u003e,\n\tauthorized_oracles: Vec\u003cAccountId\u003e,\n\tsudo_account: AccountId,\n\tid: ParaId,\n\tstart_shutdown: bool,\n) -\u003e amplitude_runtime::GenesisConfig {\n\tfn default_pair(currency_id: CurrencyId) -\u003e VaultCurrencyPair\u003cCurrencyId\u003e {\n\t\tVaultCurrencyPair { collateral: currency_id, wrapped: MAINNET_USDC_CURRENCY_ID }\n\t}\n\n\tlet mut balances: Vec\u003c_\u003e = signatories\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|k| (k, amplitude::INITIAL_ISSUANCE_PER_SIGNATORY))\n\t\t.chain(\n\t\t\tinvulnerables\n\t\t\t\t.iter()\n\t\t\t\t.cloned()\n\t\t\t\t.map(|k| (k, amplitude::INITIAL_COLLATOR_STAKING + amplitude::COLLATOR_ADDITIONAL)),\n\t\t)\n\t\t.collect();\n\n\tbalances.push((\n\t\tsudo_account.clone(),\n\t\tamplitude::INITIAL_ISSUANCE\n\t\t\t.saturating_sub(\n\t\t\t\tamplitude::INITIAL_ISSUANCE_PER_SIGNATORY\n\t\t\t\t\t.saturating_mul(balances.len().try_into().unwrap()),\n\t\t\t)\n\t\t\t.saturating_sub(\n\t\t\t\tamplitude::INITIAL_COLLATOR_STAKING\n\t\t\t\t\t.saturating_mul(invulnerables.len().try_into().unwrap()),\n\t\t\t),\n\t));\n\n\tlet token_balances = vec![];\n\n\tlet stakers: Vec\u003c_\u003e = invulnerables\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|account_id| (account_id, None, amplitude::INITIAL_COLLATOR_STAKING))\n\t\t.collect();\n\n\tlet inflation_config = amplitude_runtime::InflationInfo::new(\n\t\tamplitude_runtime::BLOCKS_PER_YEAR.into(),\n\t\tPerquintill::from_percent(10),\n\t\tPerquintill::from_percent(11),\n\t\tPerquintill::from_percent(40),\n\t\tPerquintill::from_percent(9),\n\t);\n\n\tamplitude_runtime::GenesisConfig {\n\t\tasset_registry: Default::default(),\n\t\tsystem: amplitude_runtime::SystemConfig {\n\t\t\tcode: amplitude_runtime::WASM_BINARY\n\t\t\t\t.expect(\"WASM binary was not build, please build it!\")\n\t\t\t\t.to_vec(),\n\t\t},\n\t\tbalances: amplitude_runtime::BalancesConfig { balances },\n\t\tparachain_info: amplitude_runtime::ParachainInfoConfig { parachain_id: id },\n\t\tparachain_staking: amplitude_runtime::ParachainStakingConfig {\n\t\t\tstakers,\n\t\t\tinflation_config,\n\t\t\tmax_candidate_stake: 400_000 * UNIT,\n\t\t\tmax_selected_candidates: 40,\n\t\t},\n\t\tsession: amplitude_runtime::SessionConfig {\n\t\t\tkeys: invulnerables\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|acc| {\n\t\t\t\t\t(\n\t\t\t\t\t\tacc.clone(),\n\t\t\t\t\t\tacc.clone(),\n\t\t\t\t\t\tget_amplitude_session_keys(Into::\u003c[u8; 32]\u003e::into(acc).unchecked_into()),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.collect(),\n\t\t},\n\t\t// no need to pass anything to aura, in fact it will panic if we do. Session will take care\n\t\t// of this.\n\t\taura: Default::default(),\n\t\taura_ext: Default::default(),\n\t\tparachain_system: Default::default(),\n\t\tpolkadot_xcm: amplitude_runtime::PolkadotXcmConfig {\n\t\t\tsafe_xcm_version: Some(SAFE_XCM_VERSION),\n\t\t},\n\t\tcouncil: amplitude_runtime::CouncilConfig {\n\t\t\tmembers: signatories.clone(),\n\t\t\t..Default::default()\n\t\t},\n\t\tdemocracy: Default::default(),\n\t\ttechnical_committee: amplitude_runtime::TechnicalCommitteeConfig {\n\t\t\tmembers: signatories.clone(),\n\t\t\t..Default::default()\n\t\t},\n\t\ttokens: amplitude_runtime::TokensConfig {\n\t\t\t// Configure the initial token supply\n\t\t\tbalances: token_balances,\n\t\t},\n\t\tissue: amplitude_runtime::IssueConfig {\n\t\t\tissue_period: amplitude_runtime::DAYS,\n\t\t\tissue_minimum_transfer_amount: 1000,\n\t\t\tlimit_volume_amount: None,\n\t\t\tlimit_volume_currency_id: XCM(0),\n\t\t\tcurrent_volume_amount: 0u32.into(),\n\t\t\tinterval_length: (60u32 * 60 * 24).into(),\n\t\t\tlast_interval_index: 0u32.into(),\n\t\t},\n\t\tredeem: amplitude_runtime::RedeemConfig {\n\t\t\tredeem_period: foucoco_runtime::DAYS,\n\t\t\tredeem_minimum_transfer_amount: 1000,\n\t\t\tlimit_volume_amount: None,\n\t\t\tlimit_volume_currency_id: XCM(0),\n\t\t\tcurrent_volume_amount: 0u32.into(),\n\t\t\tinterval_length: (60u32 * 60 * 24).into(),\n\t\t\tlast_interval_index: 0u32.into(),\n\t\t},\n\t\treplace: amplitude_runtime::ReplaceConfig {\n\t\t\treplace_period: foucoco_runtime::DAYS,\n\t\t\treplace_minimum_transfer_amount: 1000,\n\t\t},\n\t\tsecurity: amplitude_runtime::SecurityConfig {\n\t\t\tinitial_status: if start_shutdown {\n\t\t\t\tamplitude_runtime::StatusCode::Shutdown\n\t\t\t} else {\n\t\t\t\tamplitude_runtime::StatusCode::Error\n\t\t\t},\n\t\t},\n\t\toracle: amplitude_runtime::OracleConfig {\n\t\t\tmax_delay: u32::MAX,\n\t\t\toracle_keys: vec![\n\t\t\t\tKey::ExchangeRate(CurrencyId::XCM(0)),\n\t\t\t\tKey::ExchangeRate(MAINNET_USDC_CURRENCY_ID),\n\t\t\t],\n\t\t},\n\t\tvault_registry: amplitude_runtime::VaultRegistryConfig {\n\t\t\tminimum_collateral_vault: vec![(XCM(0), 0)],\n\t\t\tpunishment_delay: foucoco_runtime::DAYS,\n\t\t\tsecure_collateral_threshold: vec![(\n\t\t\t\tdefault_pair(XCM(0)),\n\t\t\t\tFixedU128::checked_from_rational(150, 100).unwrap(),\n\t\t\t)],\n\t\t\t/* 150% */\n\t\t\tpremium_redeem_threshold: vec![(\n\t\t\t\tdefault_pair(XCM(0)),\n\t\t\t\tFixedU128::checked_from_rational(130, 100).unwrap(),\n\t\t\t)],\n\t\t\t/* 130% */\n\t\t\tliquidation_collateral_threshold: vec![(\n\t\t\t\tdefault_pair(XCM(0)),\n\t\t\t\tFixedU128::checked_from_rational(120, 100).unwrap(),\n\t\t\t)],\n\t\t\t/* 120% */\n\t\t\tsystem_collateral_ceiling: vec![(\n\t\t\t\tdefault_pair(XCM(0)),\n\t\t\t\t60_000 * 10u128.pow(amplitude::TOKEN_DECIMALS),\n\t\t\t)],\n\t\t},\n\t\tstellar_relay: amplitude_runtime::StellarRelayConfig::default(),\n\t\tfee: amplitude_runtime::FeeConfig {\n\t\t\tissue_fee: FixedU128::checked_from_rational(15, 10000).unwrap(), // 0.15%\n\t\t\tissue_griefing_collateral: FixedU128::checked_from_rational(5, 100000).unwrap(), // 0.005%\n\t\t\tredeem_fee: FixedU128::checked_from_rational(5, 1000).unwrap(),  // 0.5%\n\t\t\tpremium_redeem_fee: FixedU128::checked_from_rational(5, 100).unwrap(), // 5%\n\t\t\tpunishment_fee: FixedU128::checked_from_rational(1, 10).unwrap(), // 10%\n\t\t\treplace_griefing_collateral: FixedU128::checked_from_rational(1, 10).unwrap(), // 10%\n\t\t},\n\t\tnomination: amplitude_runtime::NominationConfig { is_nomination_enabled: false },\n\t\tdia_oracle_module: amplitude_runtime::DiaOracleModuleConfig {\n\t\t\tauthorized_accounts: authorized_oracles,\n\t\t\tsupported_currencies: vec![foucoco_runtime::AssetId::new(\n\t\t\t\tb\"Polkadot\".to_vec(),\n\t\t\t\tb\"DOT\".to_vec(),\n\t\t\t)],\n\t\t\tbatching_api: b\"http://dia-00.pendulumchain.tech:8070/currencies\".to_vec(),\n\t\t\tcoin_infos_map: vec![],\n\t\t},\n\t}\n}\n\nfn foucoco_genesis(\n\tinvulnerables: Vec\u003cAccountId\u003e,\n\tsignatories: Vec\u003cAccountId\u003e,\n\tauthorized_oracles: Vec\u003cAccountId\u003e,\n\tsudo_account: AccountId,\n\tid: ParaId,\n\tstart_shutdown: bool,\n) -\u003e foucoco_runtime::GenesisConfig {\n\tfn get_vault_currency_pair(\n\t\tcollateral: CurrencyId,\n\t\twrapped: CurrencyId,\n\t) -\u003e VaultCurrencyPair\u003cCurrencyId\u003e {\n\t\tVaultCurrencyPair { collateral, wrapped }\n\t}\n\n\tlet mut balances: Vec\u003c_\u003e = signatories\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|k| (k, foucoco::INITIAL_ISSUANCE_PER_SIGNATORY))\n\t\t.chain(\n\t\t\tinvulnerables\n\t\t\t\t.iter()\n\t\t\t\t.cloned()\n\t\t\t\t.map(|k| (k, foucoco::INITIAL_COLLATOR_STAKING + foucoco::COLLATOR_ADDITIONAL)),\n\t\t)\n\t\t.collect();\n\n\tbalances.push((\n\t\tsudo_account.clone(),\n\t\tfoucoco::INITIAL_ISSUANCE\n\t\t\t.saturating_sub(\n\t\t\t\tfoucoco::INITIAL_ISSUANCE_PER_SIGNATORY\n\t\t\t\t\t.saturating_mul(balances.len().try_into().unwrap()),\n\t\t\t)\n\t\t\t.saturating_sub(\n\t\t\t\tfoucoco::INITIAL_COLLATOR_STAKING\n\t\t\t\t\t.saturating_mul(invulnerables.len().try_into().unwrap()),\n\t\t\t),\n\t));\n\n\tlet token_balances = balances\n\t\t.iter()\n\t\t.flat_map(|k| vec![(k.0.clone(), XCM(0), u128::pow(10, 18))])\n\t\t.collect();\n\n\tlet stakers: Vec\u003c_\u003e = invulnerables\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|account_id| (account_id, None, foucoco::INITIAL_COLLATOR_STAKING))\n\t\t.collect();\n\n\tlet inflation_config = foucoco_runtime::InflationInfo::new(\n\t\tfoucoco_runtime::BLOCKS_PER_YEAR.into(),\n\t\tPerquintill::from_percent(10),\n\t\tPerquintill::from_percent(11),\n\t\tPerquintill::from_percent(40),\n\t\tPerquintill::from_percent(9),\n\t);\n\n\tfoucoco_runtime::GenesisConfig {\n\t\tasset_registry: Default::default(),\n\t\tsystem: foucoco_runtime::SystemConfig {\n\t\t\tcode: foucoco_runtime::WASM_BINARY\n\t\t\t\t.expect(\"WASM binary was not build, please build it!\")\n\t\t\t\t.to_vec(),\n\t\t},\n\t\tbalances: foucoco_runtime::BalancesConfig { balances },\n\t\tparachain_info: foucoco_runtime::ParachainInfoConfig { parachain_id: id },\n\t\tparachain_staking: foucoco_runtime::ParachainStakingConfig {\n\t\t\tstakers,\n\t\t\tinflation_config,\n\t\t\tmax_candidate_stake: 400_000 * UNIT,\n\t\t\tmax_selected_candidates: 40,\n\t\t},\n\t\tsession: foucoco_runtime::SessionConfig {\n\t\t\tkeys: invulnerables\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|acc| {\n\t\t\t\t\t(\n\t\t\t\t\t\tacc.clone(),\n\t\t\t\t\t\tacc.clone(),\n\t\t\t\t\t\tget_foucoco_session_keys(Into::\u003c[u8; 32]\u003e::into(acc).unchecked_into()),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.collect(),\n\t\t},\n\t\t// no need to pass anything to aura, in fact it will panic if we do. Session will take care\n\t\t// of this.\n\t\taura: Default::default(),\n\t\taura_ext: Default::default(),\n\t\tparachain_system: Default::default(),\n\t\tpolkadot_xcm: foucoco_runtime::PolkadotXcmConfig {\n\t\t\tsafe_xcm_version: Some(SAFE_XCM_VERSION),\n\t\t},\n\t\tcouncil: foucoco_runtime::CouncilConfig {\n\t\t\tmembers: signatories.clone(),\n\t\t\t..Default::default()\n\t\t},\n\t\tdemocracy: Default::default(),\n\t\tsudo: foucoco_runtime::SudoConfig { key: Some(sudo_account.clone()) },\n\t\ttechnical_committee: foucoco_runtime::TechnicalCommitteeConfig {\n\t\t\tmembers: signatories.clone(),\n\t\t\t..Default::default()\n\t\t},\n\t\ttokens: foucoco_runtime::TokensConfig {\n\t\t\t// Configure the initial token supply for the native currency and USDC asset\n\t\t\tbalances: token_balances,\n\t\t},\n\t\tissue: foucoco_runtime::IssueConfig {\n\t\t\tissue_period: foucoco_runtime::DAYS,\n\t\t\tissue_minimum_transfer_amount: 1_000_000_000,\n\t\t\tlimit_volume_amount: None,\n\t\t\tlimit_volume_currency_id: XCM(0),\n\t\t\tcurrent_volume_amount: 0u32.into(),\n\t\t\tinterval_length: (60u32 * 60 * 24).into(),\n\t\t\tlast_interval_index: 0u32.into(),\n\t\t},\n\t\tredeem: foucoco_runtime::RedeemConfig {\n\t\t\tredeem_period: foucoco_runtime::DAYS,\n\t\t\tredeem_minimum_transfer_amount: 1_000_000_000,\n\t\t\tlimit_volume_amount: None,\n\t\t\tlimit_volume_currency_id: XCM(0),\n\t\t\tcurrent_volume_amount: 0u32.into(),\n\t\t\tinterval_length: (60u32 * 60 * 24).into(),\n\t\t\tlast_interval_index: 0u32.into(),\n\t\t},\n\t\treplace: foucoco_runtime::ReplaceConfig {\n\t\t\treplace_period: foucoco_runtime::DAYS,\n\t\t\treplace_minimum_transfer_amount: 1_000_000_000,\n\t\t},\n\t\tsecurity: foucoco_runtime::SecurityConfig {\n\t\t\tinitial_status: if start_shutdown {\n\t\t\t\tfoucoco_runtime::StatusCode::Shutdown\n\t\t\t} else {\n\t\t\t\tfoucoco_runtime::StatusCode::Error\n\t\t\t},\n\t\t},\n\t\toracle: foucoco_runtime::OracleConfig {\n\t\t\tmax_delay: 604_800_000, // 7 days\n\t\t\toracle_keys: vec![\n\t\t\t\tKey::ExchangeRate(CurrencyId::XCM(0)),\n\t\t\t\tKey::ExchangeRate(CurrencyId::Native),\n\t\t\t\tKey::ExchangeRate(CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\tKey::ExchangeRate(MAINNET_USDC_CURRENCY_ID),\n\t\t\t\tKey::ExchangeRate(MAINNET_BRL_CURRENCY_ID),\n\t\t\t\tKey::ExchangeRate(MAINNET_TZS_CURRENCY_ID),\n\t\t\t],\n\t\t},\n\t\tvault_registry: foucoco_runtime::VaultRegistryConfig {\n\t\t\tminimum_collateral_vault: vec![(XCM(0), 3_000_000_000_000)],\n\t\t\tpunishment_delay: foucoco_runtime::DAYS * 2,\n\t\t\tsecure_collateral_threshold: vec![\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_USDC_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(160, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_BRL_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(160, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_TZS_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(160, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\t\tFixedU128::checked_from_rational(160, 100).unwrap(),\n\t\t\t\t),\n\t\t\t],\n\t\t\t/* 140% */\n\t\t\tpremium_redeem_threshold: vec![\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_USDC_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(140, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_BRL_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(140, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_TZS_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(140, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\t\tFixedU128::checked_from_rational(140, 100).unwrap(),\n\t\t\t\t),\n\t\t\t],\n\t\t\t/* 125% */\n\t\t\tliquidation_collateral_threshold: vec![\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_USDC_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(125, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_BRL_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(125, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_TZS_CURRENCY_ID),\n\t\t\t\t\tFixedU128::checked_from_rational(125, 100).unwrap(),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\t\tFixedU128::checked_from_rational(125, 100).unwrap(),\n\t\t\t\t),\n\t\t\t],\n\t\t\tsystem_collateral_ceiling: vec![\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_USDC_CURRENCY_ID),\n\t\t\t\t\t50 * 10u128.pow(foucoco::TOKEN_DECIMALS),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_BRL_CURRENCY_ID),\n\t\t\t\t\t25 * 10u128.pow(foucoco::TOKEN_DECIMALS),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), MAINNET_TZS_CURRENCY_ID),\n\t\t\t\t\t25 * 10u128.pow(foucoco::TOKEN_DECIMALS),\n\t\t\t\t),\n\t\t\t\t(\n\t\t\t\t\tget_vault_currency_pair(XCM(0), CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t\t\t50 * 10u128.pow(foucoco::TOKEN_DECIMALS),\n\t\t\t\t),\n\t\t\t],\n\t\t},\n\t\tstellar_relay: foucoco_runtime::StellarRelayConfig::default(),\n\t\tfee: foucoco_runtime::FeeConfig {\n\t\t\tissue_fee: FixedU128::checked_from_rational(1, 1000).unwrap(), // 0.1%\n\t\t\tissue_griefing_collateral: FixedU128::checked_from_rational(5, 1000).unwrap(), // 0.5%\n\t\t\tredeem_fee: FixedU128::checked_from_rational(1, 1000).unwrap(), // 0.1%\n\t\t\tpremium_redeem_fee: FixedU128::checked_from_rational(5, 100).unwrap(), // 5%\n\t\t\tpunishment_fee: FixedU128::checked_from_rational(1, 10).unwrap(), // 10%\n\t\t\treplace_griefing_collateral: FixedU128::checked_from_rational(1, 10).unwrap(), // 10%\n\t\t},\n\t\tnomination: foucoco_runtime::NominationConfig { is_nomination_enabled: false },\n\t\tdia_oracle_module: foucoco_runtime::DiaOracleModuleConfig {\n\t\t\tauthorized_accounts: authorized_oracles,\n\t\t\tsupported_currencies: vec![\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"Kusama\".to_vec(), b\"KSM\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"Stellar\".to_vec(), b\"XLM\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"FIAT\".to_vec(), b\"BRL-USD\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"FIAT\".to_vec(), b\"USD-USD\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"FIAT\".to_vec(), b\"TZS-USD\".to_vec()),\n\t\t\t\tfoucoco_runtime::AssetId::new(b\"FIAT\".to_vec(), b\"MXN-USD\".to_vec()),\n\t\t\t],\n\t\t\tbatching_api: b\"https://dia-00.pendulumchain.tech/currencies\".to_vec(),\n\t\t\tcoin_infos_map: vec![],\n\t\t},\n\t}\n}\n\nfn pendulum_genesis(\n\tcollators: Vec\u003cAccountId\u003e,\n\tmut balances: Vec\u003c(AccountId, Balance)\u003e,\n\tvesting_schedules: Vec\u003c(AccountId, BlockNumber, BlockNumber, Balance)\u003e,\n\tsudo_account: AccountId,\n\tid: ParaId,\n) -\u003e pendulum_runtime::GenesisConfig {\n\tlet mut genesis_issuance = pendulum::TOTAL_INITIAL_ISSUANCE;\n\tfor balance in balances.clone() {\n\t\tgenesis_issuance -= balance.1;\n\t}\n\n\tbalances.push((sudo_account.clone(), genesis_issuance));\n\n\tlet stakers: Vec\u003c_\u003e = collators\n\t\t.iter()\n\t\t.cloned()\n\t\t.map(|account_id| (account_id, None, pendulum::INITIAL_COLLATOR_STAKING))\n\t\t.collect();\n\n\tlet inflation_config = pendulum_runtime::InflationInfo::new(\n\t\tpendulum_runtime::BLOCKS_PER_YEAR.into(),\n\t\tPerquintill::from_percent(10),\n\t\tPerquintill::from_percent(11),\n\t\tPerquintill::from_percent(30),\n\t\tPerquintill::from_percent(8),\n\t);\n\n\tlet council: Vec\u003c_\u003e = pendulum::SUDO_SIGNATORIES\n\t\t.iter()\n\t\t.map(|address| AccountId::from_ss58check(address).unwrap())\n\t\t.collect();\n\n\tpendulum_runtime::GenesisConfig {\n\t\tasset_registry: Default::default(),\n\t\tsystem: pendulum_runtime::SystemConfig {\n\t\t\tcode: pendulum_runtime::WASM_BINARY\n\t\t\t\t.expect(\"WASM binary was not build, please build it!\")\n\t\t\t\t.to_vec(),\n\t\t},\n\t\tbalances: pendulum_runtime::BalancesConfig { balances },\n\t\tparachain_info: pendulum_runtime::ParachainInfoConfig { parachain_id: id },\n\t\tparachain_staking: pendulum_runtime::ParachainStakingConfig {\n\t\t\tstakers,\n\t\t\tinflation_config,\n\t\t\tmax_candidate_stake: 400_000 * UNIT,\n\t\t\tmax_selected_candidates: 40,\n\t\t},\n\t\tsession: pendulum_runtime::SessionConfig {\n\t\t\tkeys: collators\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|account| {\n\t\t\t\t\t(\n\t\t\t\t\t\taccount.clone(),\n\t\t\t\t\t\taccount.clone(),\n\t\t\t\t\t\tget_pendulum_session_keys(Into::\u003c[u8; 32]\u003e::into(account).unchecked_into()),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.collect(),\n\t\t},\n\t\t// no need to pass anything to aura, in fact it will panic if we do. Session will take care\n\t\t// of this.\n\t\taura: Default::default(),\n\t\taura_ext: Default::default(),\n\t\tparachain_system: Default::default(),\n\t\tpolkadot_xcm: pendulum_runtime::PolkadotXcmConfig {\n\t\t\tsafe_xcm_version: Some(SAFE_XCM_VERSION),\n\t\t},\n\t\tcouncil: pendulum_runtime::CouncilConfig { members: council.clone(), ..Default::default() },\n\t\tdemocracy: Default::default(),\n\t\ttechnical_committee: pendulum_runtime::TechnicalCommitteeConfig {\n\t\t\tmembers: council,\n\t\t\t..Default::default()\n\t\t},\n\t\tvesting: pendulum_runtime::VestingConfig { vesting: vesting_schedules },\n\t}\n}\n\nfn testnet_genesis(\n\tinvulnerables: Vec\u003c(AccountId, AuraId)\u003e,\n\tendowed_accounts: Vec\u003cAccountId\u003e,\n\tid: ParaId,\n) -\u003e development_runtime::GenesisConfig {\n\tdevelopment_runtime::GenesisConfig {\n\t\tsystem: development_runtime::SystemConfig {\n\t\t\tcode: development_runtime::WASM_BINARY\n\t\t\t\t.expect(\"WASM binary was not build, please build it!\")\n\t\t\t\t.to_vec(),\n\t\t},\n\t\tbalances: development_runtime::BalancesConfig {\n\t\t\tbalances: endowed_accounts.iter().cloned().map(|k| (k, 1 \u003c\u003c 60)).collect(),\n\t\t},\n\t\tparachain_info: development_runtime::ParachainInfoConfig { parachain_id: id },\n\t\tcollator_selection: development_runtime::CollatorSelectionConfig {\n\t\t\tinvulnerables: invulnerables.iter().cloned().map(|(acc, _)| acc).collect(),\n\t\t\tcandidacy_bond: EXISTENTIAL_DEPOSIT * 16,\n\t\t\t..Default::default()\n\t\t},\n\t\tsession: development_runtime::SessionConfig {\n\t\t\tkeys: invulnerables\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|(acc, aura)| {\n\t\t\t\t\t(\n\t\t\t\t\t\tacc.clone(),                        // account id\n\t\t\t\t\t\tacc,                                // validator id\n\t\t\t\t\t\tget_development_session_keys(aura), // session keys\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.collect(),\n\t\t},\n\t\t// no need to pass anything to aura, in fact it will panic if we do. Session will take care\n\t\t// of this.\n\t\taura: Default::default(),\n\t\taura_ext: Default::default(),\n\t\tparachain_system: Default::default(),\n\t\tpolkadot_xcm: amplitude_runtime::PolkadotXcmConfig {\n\t\t\tsafe_xcm_version: Some(SAFE_XCM_VERSION),\n\t\t},\n\t}\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","marcel","Documents","pendulum","node","src","cli.rs"],"content":"use std::path::PathBuf;\n\n/// Sub-commands supported by the collator.\n#[derive(Debug, clap::Subcommand)]\npub enum Subcommand {\n\t/// Build a chain specification.\n\tBuildSpec(sc_cli::BuildSpecCmd),\n\n\t/// Validate blocks.\n\tCheckBlock(sc_cli::CheckBlockCmd),\n\n\t/// Export blocks.\n\tExportBlocks(sc_cli::ExportBlocksCmd),\n\n\t/// Export the state of a given block into a chain spec.\n\tExportState(sc_cli::ExportStateCmd),\n\n\t/// Import blocks.\n\tImportBlocks(sc_cli::ImportBlocksCmd),\n\n\t/// Revert the chain to a previous state.\n\tRevert(sc_cli::RevertCmd),\n\n\t/// Remove the whole chain.\n\tPurgeChain(cumulus_client_cli::PurgeChainCmd),\n\n\t/// Export the genesis state of the parachain.\n\tExportGenesisState(cumulus_client_cli::ExportGenesisStateCommand),\n\n\t/// Export the genesis wasm of the parachain.\n\tExportGenesisWasm(cumulus_client_cli::ExportGenesisWasmCommand),\n\n\t/// Sub-commands concerned with benchmarking.\n\t/// The pallet benchmarking moved to the `pallet` sub-command.\n\t#[command(subcommand)]\n\tBenchmark(frame_benchmarking_cli::BenchmarkCmd),\n\n\t/// Try some command against runtime state.\n\t#[cfg(feature = \"try-runtime\")]\n\tTryRuntime(try_runtime_cli::TryRuntimeCmd),\n}\n\n#[derive(Debug, clap::Parser)]\n#[command(\n\tpropagate_version = true,\n\targs_conflicts_with_subcommands = true,\n\tsubcommand_negates_reqs = true\n)]\npub struct Cli {\n\t#[command(subcommand)]\n\tpub subcommand: Option\u003cSubcommand\u003e,\n\n\t#[command(flatten)]\n\tpub run: cumulus_client_cli::RunCmd,\n\n\t/// Disable automatic hardware benchmarks.\n\t///\n\t/// By default these benchmarks are automatically ran at startup and measure\n\t/// the CPU speed, the memory bandwidth and the disk speed.\n\t///\n\t/// The results are then printed out in the logs, and also sent as part of\n\t/// telemetry, if telemetry is enabled.\n\t#[arg(long)]\n\tpub no_hardware_benchmarks: bool,\n\n\t/// Relay chain arguments\n\t#[arg(raw = true)]\n\tpub relay_chain_args: Vec\u003cString\u003e,\n}\n\n#[derive(Debug)]\npub struct RelayChainCli {\n\t/// The actual relay chain cli object.\n\tpub base: polkadot_cli::RunCmd,\n\n\t/// Optional chain id that should be passed to the relay chain.\n\tpub chain_id: Option\u003cString\u003e,\n\n\t/// The base path that should be used by the relay chain.\n\tpub base_path: Option\u003cPathBuf\u003e,\n}\n\nimpl RelayChainCli {\n\t/// Parse the relay chain CLI parameters using the para chain `Configuration`.\n\tpub fn new\u003c'a\u003e(\n\t\tpara_config: \u0026sc_service::Configuration,\n\t\trelay_chain_args: impl Iterator\u003cItem = \u0026'a String\u003e,\n\t) -\u003e Self {\n\t\tlet extension = crate::chain_spec::ParachainExtensions::try_get(\u0026*para_config.chain_spec);\n\t\tlet chain_id = extension.map(|e| e.relay_chain.clone());\n\t\tlet base_path = para_config.base_path.as_ref().map(|x| x.path().join(\"polkadot\"));\n\t\tSelf { base_path, chain_id, base: clap::Parser::parse_from(relay_chain_args) }\n\t}\n}\n","traces":[{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","Users","marcel","Documents","pendulum","node","src","command.rs"],"content":"use std::net::SocketAddr;\n\nuse codec::Encode;\nuse cumulus_client_cli::generate_genesis_block;\nuse cumulus_primitives_core::ParaId;\nuse frame_benchmarking_cli::{BenchmarkCmd, SUBSTRATE_REFERENCE_HARDWARE};\nuse log::{info, warn};\nuse runtime_common::opaque::Block;\nuse sc_chain_spec::GenericChainSpec;\nuse sc_cli::{\n\tChainSpec, CliConfiguration, DefaultConfigurationValues, ImportParams, KeystoreParams,\n\tNetworkParams, Result, RuntimeVersion, SharedParams, SubstrateCli,\n};\nuse sc_service::config::{BasePath, PrometheusConfig};\nuse sp_core::hexdisplay::HexDisplay;\nuse sp_runtime::traits::{AccountIdConversion, Block as BlockT};\n\nuse crate::{\n\tchain_spec::{self, ParachainExtensions},\n\tcli::{Cli, RelayChainCli, Subcommand},\n\tservice::{\n\t\tnew_partial, AmplitudeRuntimeExecutor, DevelopmentRuntimeExecutor, FoucocoRuntimeExecutor,\n\t\tPendulumRuntimeExecutor,\n\t},\n};\n\n#[derive(PartialEq, Eq)]\nenum ChainIdentity {\n\tAmplitude,\n\tFoucoco,\n\tPendulum,\n\tDevelopment,\n}\n\nimpl ChainIdentity {\n\tfn identify(id: \u0026str) -\u003e Option\u003cSelf\u003e {\n\t\tmatch id {\n\t\t\t\"amplitude\" =\u003e Some(ChainIdentity::Amplitude),\n\t\t\t\"foucoco\" =\u003e Some(ChainIdentity::Foucoco),\n\t\t\t\"pendulum\" =\u003e Some(ChainIdentity::Pendulum),\n\t\t\t\"\" | \"dev\" =\u003e Some(ChainIdentity::Development),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n\n\tfn from_json_file(path: \u0026str) -\u003e std::result::Result\u003cSelf, String\u003e {\n\t\tGenericChainSpec::\u003c(), ParachainExtensions\u003e::from_json_file(path.into())\n\t\t\t.map(|chain_spec| chain_spec.identify())\n\t\t\t.or_else(|_| {\n\t\t\t\tGenericChainSpec::\u003c()\u003e::from_json_file(path.into())\n\t\t\t\t\t.map(|chain_spec| chain_spec.identify())\n\t\t\t})\n\t}\n\n\tfn get_runtime_version(\u0026self) -\u003e \u0026'static RuntimeVersion {\n\t\tmatch self {\n\t\t\tChainIdentity::Amplitude =\u003e \u0026amplitude_runtime::VERSION,\n\t\t\tChainIdentity::Foucoco =\u003e \u0026foucoco_runtime::VERSION,\n\t\t\tChainIdentity::Pendulum =\u003e \u0026pendulum_runtime::VERSION,\n\t\t\tChainIdentity::Development =\u003e \u0026development_runtime::VERSION,\n\t\t}\n\t}\n\n\tfn create_chain_spec(\u0026self) -\u003e Box\u003cdyn ChainSpec\u003e {\n\t\tmatch self {\n\t\t\tChainIdentity::Amplitude =\u003e Box::new(chain_spec::amplitude_config()),\n\t\t\tChainIdentity::Foucoco =\u003e Box::new(chain_spec::foucoco_config()),\n\t\t\tChainIdentity::Pendulum =\u003e Box::new(chain_spec::pendulum_config()),\n\t\t\tChainIdentity::Development =\u003e Box::new(chain_spec::development_config()),\n\t\t}\n\t}\n\n\tfn load_chain_spec_from_json_file(\n\t\t\u0026self,\n\t\tpath: \u0026str,\n\t) -\u003e std::result::Result\u003cBox\u003cdyn ChainSpec\u003e, String\u003e {\n\t\tOk(match self {\n\t\t\tChainIdentity::Amplitude =\u003e\n\t\t\t\tBox::new(chain_spec::AmplitudeChainSpec::from_json_file(path.into())?),\n\t\t\tChainIdentity::Foucoco =\u003e\n\t\t\t\tBox::new(chain_spec::FoucocoChainSpec::from_json_file(path.into())?),\n\t\t\tChainIdentity::Pendulum =\u003e\n\t\t\t\tBox::new(chain_spec::PendulumChainSpec::from_json_file(path.into())?),\n\t\t\tChainIdentity::Development =\u003e\n\t\t\t\tBox::new(chain_spec::DevelopmentChainSpec::from_json_file(path.into())?),\n\t\t})\n\t}\n}\n\ntrait IdentifyChain {\n\tfn identify(\u0026self) -\u003e ChainIdentity;\n}\n\nimpl IdentifyChain for dyn sc_service::ChainSpec {\n\tfn identify(\u0026self) -\u003e ChainIdentity {\n\t\tChainIdentity::identify(self.id()).unwrap_or(ChainIdentity::Development)\n\t}\n}\n\nimpl\u003cT: sc_service::ChainSpec + 'static\u003e IdentifyChain for T {\n\tfn identify(\u0026self) -\u003e ChainIdentity {\n\t\t\u003cdyn sc_service::ChainSpec\u003e::identify(self)\n\t}\n}\n\nimpl SubstrateCli for Cli {\n\tfn impl_name() -\u003e String {\n\t\t\"Pendulum Collator\".into()\n\t}\n\n\tfn impl_version() -\u003e String {\n\t\tenv!(\"SUBSTRATE_CLI_IMPL_VERSION\").into()\n\t}\n\n\tfn description() -\u003e String {\n\t\tformat!(\n\t\t\t\"Pendulum Collator\\n\\nThe command-line arguments provided first will be \\\n\t\tpassed to the parachain node, while the arguments provided after -- will be passed \\\n\t\tto the relay chain node.\\n\\n\\\n\t\t{} \u003cparachain-args\u003e -- \u003crelay-chain-args\u003e\",\n\t\t\tSelf::executable_name()\n\t\t)\n\t}\n\n\tfn author() -\u003e String {\n\t\tenv!(\"CARGO_PKG_AUTHORS\").into()\n\t}\n\n\tfn support_url() -\u003e String {\n\t\t\"https://github.com/pendulum-chain/pendulum/issues/new\".into()\n\t}\n\n\tfn copyright_start_year() -\u003e i32 {\n\t\t2022\n\t}\n\n\tfn load_spec(\u0026self, id: \u0026str) -\u003e std::result::Result\u003cBox\u003cdyn sc_service::ChainSpec\u003e, String\u003e {\n\t\tOk(match ChainIdentity::identify(id) {\n\t\t\tSome(identitiy) =\u003e identitiy.create_chain_spec(),\n\t\t\tNone =\u003e ChainIdentity::from_json_file(id)?.load_chain_spec_from_json_file(id)?,\n\t\t})\n\t}\n\n\tfn native_runtime_version(spec: \u0026Box\u003cdyn ChainSpec\u003e) -\u003e \u0026'static RuntimeVersion {\n\t\tspec.identify().get_runtime_version()\n\t}\n}\n\nimpl SubstrateCli for RelayChainCli {\n\tfn impl_name() -\u003e String {\n\t\t\"Pendulum Collator\".into()\n\t}\n\n\tfn impl_version() -\u003e String {\n\t\tenv!(\"SUBSTRATE_CLI_IMPL_VERSION\").into()\n\t}\n\n\tfn description() -\u003e String {\n\t\tformat!(\n\t\t\t\"Pendulum Collator\\n\\nThe command-line arguments provided first will be \\\n\t\tpassed to the parachain node, while the arguments provided after -- will be passed \\\n\t\tto the relay chain node.\\n\\n\\\n\t\t{} \u003cparachain-args\u003e -- \u003crelay-chain-args\u003e\",\n\t\t\tSelf::executable_name()\n\t\t)\n\t}\n\n\tfn author() -\u003e String {\n\t\tenv!(\"CARGO_PKG_AUTHORS\").into()\n\t}\n\n\tfn support_url() -\u003e String {\n\t\t\"https://github.com/pendulum-chain/pendulum/issues/new\".into()\n\t}\n\n\tfn copyright_start_year() -\u003e i32 {\n\t\t2022\n\t}\n\n\tfn load_spec(\u0026self, id: \u0026str) -\u003e std::result::Result\u003cBox\u003cdyn sc_service::ChainSpec\u003e, String\u003e {\n\t\tpolkadot_cli::Cli::from_iter([RelayChainCli::executable_name()].iter()).load_spec(id)\n\t}\n\n\tfn native_runtime_version(chain_spec: \u0026Box\u003cdyn ChainSpec\u003e) -\u003e \u0026'static RuntimeVersion {\n\t\tpolkadot_cli::Cli::native_runtime_version(chain_spec)\n\t}\n}\n\nmacro_rules! construct_sync_run {\n\t(|$components:ident, $cli:ident, $cmd:ident, $config:ident| $code:expr ) =\u003e {{\n\t\tlet runner = $cli.create_runner($cmd)?;\n\n\t\tmatch runner.config().chain_spec.identify() {\n\t\t\tChainIdentity::Amplitude =\u003e runner.sync_run(|$config| {\n\t\t\t\tlet $components = new_partial::\u003c\n\t\t\t\t\tamplitude_runtime::RuntimeApi,\n\t\t\t\t\tAmplitudeRuntimeExecutor,\n\t\t\t\t\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Foucoco =\u003e runner.sync_run(|$config| {\n\t\t\t\tlet $components =\n\t\t\t\t\tnew_partial::\u003cfoucoco_runtime::RuntimeApi, FoucocoRuntimeExecutor\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Pendulum =\u003e runner.sync_run(|$config| {\n\t\t\t\tlet $components =\n\t\t\t\t\tnew_partial::\u003cpendulum_runtime::RuntimeApi, PendulumRuntimeExecutor\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Development =\u003e runner.sync_run(|$config| {\n\t\t\t\tlet $components = new_partial::\u003c\n\t\t\t\t\tdevelopment_runtime::RuntimeApi,\n\t\t\t\t\tDevelopmentRuntimeExecutor,\n\t\t\t\t\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t}\n\t}};\n}\n\nmacro_rules! construct_generic_async_run {\n\t(|$components:ident, $cli:ident, $cmd:ident, $config:ident| $code:expr ) =\u003e {{\n\t\tlet runner = $cli.create_runner($cmd)?;\n\n\t\tmatch runner.config().chain_spec.identify() {\n\t\t\tChainIdentity::Amplitude =\u003e runner.async_run(|$config| {\n\t\t\t\tlet $components = new_partial::\u003c\n\t\t\t\t\tamplitude_runtime::RuntimeApi,\n\t\t\t\t\tAmplitudeRuntimeExecutor,\n\t\t\t\t\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Foucoco =\u003e runner.async_run(|$config| {\n\t\t\t\tlet $components =\n\t\t\t\t\tnew_partial::\u003cfoucoco_runtime::RuntimeApi, FoucocoRuntimeExecutor\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Pendulum =\u003e runner.async_run(|$config| {\n\t\t\t\tlet $components =\n\t\t\t\t\tnew_partial::\u003cpendulum_runtime::RuntimeApi, PendulumRuntimeExecutor\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t\tChainIdentity::Development =\u003e runner.async_run(|$config| {\n\t\t\t\tlet $components = new_partial::\u003c\n\t\t\t\t\tdevelopment_runtime::RuntimeApi,\n\t\t\t\t\tDevelopmentRuntimeExecutor,\n\t\t\t\t\u003e(\u0026$config)?;\n\t\t\t\t$code\n\t\t\t}),\n\t\t}\n\t}};\n}\n\nmacro_rules! construct_async_run {\n\t(|$components:ident, $cli:ident, $cmd:ident, $config:ident| $( $code:tt )* ) =\u003e {{\n\t\tconstruct_generic_async_run!(|$components, $cli, $cmd, $config| {\n\t\t\tlet task_manager = $components.task_manager;\n\t\t\t\t\t{ $( $code )* }.map(|v| (v, task_manager))\n\t\t})\n\t}}\n}\n\n/// Parse command line arguments into service configuration.\npub fn run() -\u003e Result\u003c()\u003e {\n\tlet cli = Cli::from_args();\n\n\tmatch \u0026cli.subcommand {\n\t\tSome(Subcommand::BuildSpec(cmd)) =\u003e {\n\t\t\tlet runner = cli.create_runner(cmd)?;\n\t\t\trunner.sync_run(|config| cmd.run(config.chain_spec, config.network))\n\t\t},\n\t\tSome(Subcommand::CheckBlock(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, components.import_queue))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ExportBlocks(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, config.database))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ExportState(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, config.chain_spec))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ImportBlocks(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, components.import_queue))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::Revert(cmd)) =\u003e {\n\t\t\tconstruct_async_run!(|components, cli, cmd, config| {\n\t\t\t\tOk(cmd.run(components.client, components.backend, None))\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::PurgeChain(cmd)) =\u003e {\n\t\t\tlet runner = cli.create_runner(cmd)?;\n\n\t\t\trunner.sync_run(|config| {\n\t\t\t\tlet polkadot_cli = RelayChainCli::new(\n\t\t\t\t\t\u0026config,\n\t\t\t\t\t[RelayChainCli::executable_name()].iter().chain(cli.relay_chain_args.iter()),\n\t\t\t\t);\n\n\t\t\t\tlet polkadot_config = SubstrateCli::create_configuration(\n\t\t\t\t\t\u0026polkadot_cli,\n\t\t\t\t\t\u0026polkadot_cli,\n\t\t\t\t\tconfig.tokio_handle.clone(),\n\t\t\t\t)\n\t\t\t\t.map_err(|err| format!(\"Relay chain argument error: {}\", err))?;\n\n\t\t\t\tcmd.run(config, polkadot_config)\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ExportGenesisState(cmd)) =\u003e {\n\t\t\tlet runner = cli.create_runner(cmd)?;\n\t\t\trunner.sync_run(|_config| {\n\t\t\t\tlet spec = cli.load_spec(\u0026cmd.shared_params.chain.clone().unwrap_or_default())?;\n\t\t\t\tlet state_version = Cli::native_runtime_version(\u0026spec).state_version();\n\t\t\t\tcmd.run::\u003cBlock\u003e(\u0026*spec, state_version)\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::ExportGenesisWasm(cmd)) =\u003e {\n\t\t\tlet runner = cli.create_runner(cmd)?;\n\t\t\trunner.sync_run(|_config| {\n\t\t\t\tlet spec = cli.load_spec(\u0026cmd.shared_params.chain.clone().unwrap_or_default())?;\n\t\t\t\tcmd.run(\u0026*spec)\n\t\t\t})\n\t\t},\n\t\tSome(Subcommand::Benchmark(bench_cmd)) =\u003e match bench_cmd {\n\t\t\tBenchmarkCmd::Pallet(cmd) =\u003e\n\t\t\t\tif cfg!(feature = \"runtime-benchmarks\") {\n\t\t\t\t\tlet runner = cli.create_runner(cmd)?;\n\n\t\t\t\t\tmatch runner.config().chain_spec.identify() {\n\t\t\t\t\t\tChainIdentity::Amplitude =\u003e runner\n\t\t\t\t\t\t\t.sync_run(|config| cmd.run::\u003cBlock, AmplitudeRuntimeExecutor\u003e(config)),\n\t\t\t\t\t\tChainIdentity::Foucoco =\u003e runner\n\t\t\t\t\t\t\t.sync_run(|config| cmd.run::\u003cBlock, FoucocoRuntimeExecutor\u003e(config)),\n\t\t\t\t\t\tChainIdentity::Pendulum =\u003e runner\n\t\t\t\t\t\t\t.sync_run(|config| cmd.run::\u003cBlock, PendulumRuntimeExecutor\u003e(config)),\n\t\t\t\t\t\tChainIdentity::Development =\u003e runner.sync_run(|config| {\n\t\t\t\t\t\t\tcmd.run::\u003cBlock, DevelopmentRuntimeExecutor\u003e(config)\n\t\t\t\t\t\t}),\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tErr(\"Benchmarking wasn't enabled when building the node. \\\n\t\t\t\tYou can enable it with `--features runtime-benchmarks`.\"\n\t\t\t\t\t\t.into())\n\t\t\t\t},\n\t\t\tBenchmarkCmd::Block(cmd) =\u003e {\n\t\t\t\tconstruct_sync_run!(|components, cli, cmd, config| cmd.run(components.client))\n\t\t\t},\n\t\t\t#[cfg(not(feature = \"runtime-benchmarks\"))]\n\t\t\tBenchmarkCmd::Storage(_) =\u003e\n\t\t\t\treturn Err(sc_cli::Error::Input(\n\t\t\t\t\t\"Compile with --features=runtime-benchmarks \\\n\t\t\t\t\t\tto enable storage benchmarks.\"\n\t\t\t\t\t\t.into(),\n\t\t\t\t)\n\t\t\t\t.into()),\n\t\t\t#[cfg(feature = \"runtime-benchmarks\")]\n\t\t\tBenchmarkCmd::Storage(cmd) =\u003e {\n\t\t\t\tconstruct_sync_run!(|components, cli, cmd, config| {\n\t\t\t\t\tlet db = components.backend.expose_db();\n\t\t\t\t\tlet storage = components.backend.expose_storage();\n\n\t\t\t\t\tcmd.run(config, components.client.clone(), db, storage)\n\t\t\t\t})\n\t\t\t},\n\t\t\tBenchmarkCmd::Machine(cmd) =\u003e {\n\t\t\t\tlet runner = cli.create_runner(cmd)?;\n\t\t\t\trunner.sync_run(|config| cmd.run(\u0026config, SUBSTRATE_REFERENCE_HARDWARE.clone()))\n\t\t\t},\n\t\t\t// NOTE: this allows the Client to leniently implement\n\t\t\t// new benchmark commands without requiring a companion MR.\n\t\t\t#[allow(unreachable_patterns)]\n\t\t\t_ =\u003e Err(\"Benchmarking sub-command unsupported\".into()),\n\t\t},\n\t\t#[cfg(feature = \"try-runtime\")]\n\t\tSome(Subcommand::TryRuntime(cmd)) =\u003e {\n\t\t\tif cfg!(feature = \"try-runtime\") {\n\t\t\t\tlet runner = cli.create_runner(cmd)?;\n\n\t\t\t\t// grab the task manager.\n\t\t\t\tlet registry = \u0026runner.config().prometheus_config.as_ref().map(|cfg| \u0026cfg.registry);\n\t\t\t\tlet task_manager =\n\t\t\t\t\tTaskManager::new(runner.config().tokio_handle.clone(), *registry)\n\t\t\t\t\t\t.map_err(|e| format!(\"Error: {:?}\", e))?;\n\n\t\t\t\tmatch runner.config().chain_spec.identify() {\n\t\t\t\t\tChainIdentity::Amplitude =\u003e runner.async_run(|config| {\n\t\t\t\t\t\tOk((cmd.run::\u003cBlock, AmplitudeRuntimeExecutor\u003e(config), task_manager))\n\t\t\t\t\t}),\n\t\t\t\t\tChainIdentity::Foucoco =\u003e runner.async_run(|config| {\n\t\t\t\t\t\tOk((cmd.run::\u003cBlock, FoucocoRuntimeExecutor\u003e(config), task_manager))\n\t\t\t\t\t}),\n\t\t\t\t\tChainIdentity::Pendulum =\u003e runner.async_run(|config| {\n\t\t\t\t\t\tOk((cmd.run::\u003cBlock, PendulumRuntimeExecutor\u003e(config), task_manager))\n\t\t\t\t\t}),\n\t\t\t\t\tChainIdentity::Development =\u003e runner.async_run(|config| {\n\t\t\t\t\t\tOk((cmd.run::\u003cBlock, DevelopmentRuntimeExecutor\u003e(config), task_manager))\n\t\t\t\t\t}),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tErr(\"Try-runtime must be enabled by `--features try-runtime`.\".into())\n\t\t\t}\n\t\t},\n\t\tNone =\u003e {\n\t\t\tlet runner = cli.create_runner(\u0026cli.run.normalize())?;\n\t\t\tlet collator_options = cli.run.collator_options();\n\n\t\t\trunner.run_node_until_exit(|config| async move {\n\t\t\t\tlet hwbench = if !cli.no_hardware_benchmarks {\n\t\t\t\t\tconfig.database.path().map(|database_path| {\n\t\t\t\t\t\tlet _ = std::fs::create_dir_all(\u0026database_path);\n\t\t\t\t\t\tsc_sysinfo::gather_hwbench(Some(database_path))\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tNone\n\t\t\t\t};\n\n\t\t\t\tlet para_id = chain_spec::ParachainExtensions::try_get(\u0026*config.chain_spec)\n\t\t\t\t\t.map(|e| e.para_id)\n\t\t\t\t\t.ok_or_else(|| \"Could not find parachain ID in chain-spec.\")?;\n\n\t\t\t\tlet polkadot_cli = RelayChainCli::new(\n\t\t\t\t\t\u0026config,\n\t\t\t\t\t[RelayChainCli::executable_name()].iter().chain(cli.relay_chain_args.iter()),\n\t\t\t\t);\n\n\t\t\t\tlet id = ParaId::from(para_id);\n\n\t\t\t\tlet parachain_account =\n\t\t\t\t\tAccountIdConversion::\u003cpolkadot_primitives::v2::AccountId\u003e::into_account_truncating(\u0026id);\n\n\t\t\t\tlet state_version = Cli::native_runtime_version(\u0026config.chain_spec).state_version();\n\t\t\t\tlet block: Block = generate_genesis_block(\u0026*config.chain_spec, state_version)\n\t\t\t\t\t.map_err(|e| format!(\"{:?}\", e))?;\n\t\t\t\tlet genesis_state = format!(\"0x{:?}\", HexDisplay::from(\u0026block.header().encode()));\n\n\t\t\t\tlet tokio_handle = config.tokio_handle.clone();\n\t\t\t\tlet polkadot_config =\n\t\t\t\t\tSubstrateCli::create_configuration(\u0026polkadot_cli, \u0026polkadot_cli, tokio_handle)\n\t\t\t\t\t\t.map_err(|err| format!(\"Relay chain argument error: {}\", err))?;\n\n\t\t\t\tinfo!(\"Parachain id: {:?}\", id);\n\t\t\t\tinfo!(\"Parachain Account: {}\", parachain_account);\n\t\t\t\tinfo!(\"Parachain genesis state: {}\", genesis_state);\n\t\t\t\tinfo!(\"Is collating: {}\", if config.role.is_authority() { \"yes\" } else { \"no\" });\n\n\t\t\t\tif !collator_options.relay_chain_rpc_urls.is_empty() \u0026\u0026 cli.relay_chain_args.len() \u003e 0 {\n\t\t\t\t\twarn!(\"Detected relay chain node arguments together with --relay-chain-rpc-url. This command starts a minimal Polkadot node that only uses a network-related subset of all relay chain CLI options.\");\n\t\t\t\t}\n\n\t\t\t\tlet res = match config.chain_spec.identify() {\n\t\t\t\t\tChainIdentity::Amplitude =\u003e {\n\t\t\t\t\t\tsp_core::crypto::set_default_ss58_version(\n\t\t\t\t\t\t\tamplitude_runtime::SS58Prefix::get().into(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcrate::service::start_parachain_node_spacewalk_amplitude(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tpolkadot_config,\n\t\t\t\t\t\t\tcollator_options,\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\thwbench,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.await\n\t\t\t\t\t\t.map(|r| r.0)\n\t\t\t\t\t\t.map_err(Into::into)\n\t\t\t\t\t},\n\t\t\t\t\tChainIdentity::Foucoco =\u003e {\n\t\t\t\t\t\tsp_core::crypto::set_default_ss58_version(\n\t\t\t\t\t\t\tfoucoco_runtime::SS58Prefix::get().into(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcrate::service::start_parachain_node_spacewalk_foucoco(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tpolkadot_config,\n\t\t\t\t\t\t\tcollator_options,\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\thwbench,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.await\n\t\t\t\t\t\t.map(|r| r.0)\n\t\t\t\t\t\t.map_err(Into::into)\n\t\t\t\t\t},\n\t\t\t\t\tChainIdentity::Pendulum =\u003e {\n\t\t\t\t\t\tsp_core::crypto::set_default_ss58_version(\n\t\t\t\t\t\t\tpendulum_runtime::SS58Prefix::get().into(),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcrate::service::start_parachain_node_pendulum(\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tpolkadot_config,\n\t\t\t\t\t\t\tcollator_options,\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\thwbench,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.await\n\t\t\t\t\t\t.map(|r| r.0)\n\t\t\t\t\t\t.map_err(Into::into)\n\t\t\t\t\t},\n\n\t\t\t\t\tChainIdentity::Development =\u003e crate::service::start_parachain_node_development(\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tpolkadot_config,\n\t\t\t\t\t\tcollator_options,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\thwbench,\n\t\t\t\t\t)\n\t\t\t\t\t.await\n\t\t\t\t\t.map(|r| r.0)\n\t\t\t\t\t.map_err(Into::into),\n\t\t\t\t};\n\n\t\t\t\tres\n\t\t\t})\n\t\t},\n\t}\n}\n\nimpl DefaultConfigurationValues for RelayChainCli {\n\tfn p2p_listen_port() -\u003e u16 {\n\t\t30334\n\t}\n\n\tfn rpc_ws_listen_port() -\u003e u16 {\n\t\t9945\n\t}\n\n\tfn rpc_http_listen_port() -\u003e u16 {\n\t\t9934\n\t}\n\n\tfn prometheus_listen_port() -\u003e u16 {\n\t\t9616\n\t}\n}\n\nimpl CliConfiguration\u003cSelf\u003e for RelayChainCli {\n\tfn shared_params(\u0026self) -\u003e \u0026SharedParams {\n\t\tself.base.base.shared_params()\n\t}\n\n\tfn import_params(\u0026self) -\u003e Option\u003c\u0026ImportParams\u003e {\n\t\tself.base.base.import_params()\n\t}\n\n\tfn network_params(\u0026self) -\u003e Option\u003c\u0026NetworkParams\u003e {\n\t\tself.base.base.network_params()\n\t}\n\n\tfn keystore_params(\u0026self) -\u003e Option\u003c\u0026KeystoreParams\u003e {\n\t\tself.base.base.keystore_params()\n\t}\n\n\tfn base_path(\u0026self) -\u003e Result\u003cOption\u003cBasePath\u003e\u003e {\n\t\tOk(self\n\t\t\t.shared_params()\n\t\t\t.base_path()?\n\t\t\t.or_else(|| self.base_path.clone().map(Into::into)))\n\t}\n\n\tfn rpc_http(\u0026self, default_listen_port: u16) -\u003e Result\u003cOption\u003cSocketAddr\u003e\u003e {\n\t\tself.base.base.rpc_http(default_listen_port)\n\t}\n\n\tfn rpc_ipc(\u0026self) -\u003e Result\u003cOption\u003cString\u003e\u003e {\n\t\tself.base.base.rpc_ipc()\n\t}\n\n\tfn rpc_ws(\u0026self, default_listen_port: u16) -\u003e Result\u003cOption\u003cSocketAddr\u003e\u003e {\n\t\tself.base.base.rpc_ws(default_listen_port)\n\t}\n\n\tfn prometheus_config(\n\t\t\u0026self,\n\t\tdefault_listen_port: u16,\n\t\tchain_spec: \u0026Box\u003cdyn ChainSpec\u003e,\n\t) -\u003e Result\u003cOption\u003cPrometheusConfig\u003e\u003e {\n\t\tself.base.base.prometheus_config(default_listen_port, chain_spec)\n\t}\n\n\tfn init\u003cF\u003e(\n\t\t\u0026self,\n\t\t_support_url: \u0026String,\n\t\t_impl_version: \u0026String,\n\t\t_logger_hook: F,\n\t\t_config: \u0026sc_service::Configuration,\n\t) -\u003e Result\u003c()\u003e\n\twhere\n\t\tF: FnOnce(\u0026mut sc_cli::LoggerBuilder, \u0026sc_service::Configuration),\n\t{\n\t\tunreachable!(\"PolkadotCli is never initialized; qed\");\n\t}\n\n\tfn chain_id(\u0026self, is_dev: bool) -\u003e Result\u003cString\u003e {\n\t\tlet chain_id = self.base.base.chain_id(is_dev)?;\n\n\t\tOk(if chain_id.is_empty() { self.chain_id.clone().unwrap_or_default() } else { chain_id })\n\t}\n\n\tfn role(\u0026self, is_dev: bool) -\u003e Result\u003csc_service::Role\u003e {\n\t\tself.base.base.role(is_dev)\n\t}\n\n\tfn transaction_pool(\u0026self, is_dev: bool) -\u003e Result\u003csc_service::config::TransactionPoolOptions\u003e {\n\t\tself.base.base.transaction_pool(is_dev)\n\t}\n\n\tfn trie_cache_maximum_size(\u0026self) -\u003e Result\u003cOption\u003cusize\u003e\u003e {\n\t\tself.base.base.trie_cache_maximum_size()\n\t}\n\n\tfn rpc_methods(\u0026self) -\u003e Result\u003csc_service::config::RpcMethods\u003e {\n\t\tself.base.base.rpc_methods()\n\t}\n\n\tfn rpc_ws_max_connections(\u0026self) -\u003e Result\u003cOption\u003cusize\u003e\u003e {\n\t\tself.base.base.rpc_ws_max_connections()\n\t}\n\n\tfn rpc_cors(\u0026self, is_dev: bool) -\u003e Result\u003cOption\u003cVec\u003cString\u003e\u003e\u003e {\n\t\tself.base.base.rpc_cors(is_dev)\n\t}\n\n\tfn default_heap_pages(\u0026self) -\u003e Result\u003cOption\u003cu64\u003e\u003e {\n\t\tself.base.base.default_heap_pages()\n\t}\n\n\tfn force_authoring(\u0026self) -\u003e Result\u003cbool\u003e {\n\t\tself.base.base.force_authoring()\n\t}\n\n\tfn disable_grandpa(\u0026self) -\u003e Result\u003cbool\u003e {\n\t\tself.base.base.disable_grandpa()\n\t}\n\n\tfn max_runtime_instances(\u0026self) -\u003e Result\u003cOption\u003cusize\u003e\u003e {\n\t\tself.base.base.max_runtime_instances()\n\t}\n\n\tfn announce_block(\u0026self) -\u003e Result\u003cbool\u003e {\n\t\tself.base.base.announce_block()\n\t}\n\n\tfn telemetry_endpoints(\n\t\t\u0026self,\n\t\tchain_spec: \u0026Box\u003cdyn ChainSpec\u003e,\n\t) -\u003e Result\u003cOption\u003csc_telemetry::TelemetryEndpoints\u003e\u003e {\n\t\tself.base.base.telemetry_endpoints(chain_spec)\n\t}\n\n\tfn node_name(\u0026self) -\u003e Result\u003cString\u003e {\n\t\tself.base.base.node_name()\n\t}\n}\n","traces":[{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","marcel","Documents","pendulum","node","src","constants","amplitude.rs"],"content":"use runtime_common::{Balance, UNIT};\n\npub const PARACHAIN_ID: u32 = 2124;\npub const INITIAL_ISSUANCE: Balance = 200_000_000 * UNIT;\n\npub const INITIAL_ISSUANCE_PER_SIGNATORY: Balance = 200 * UNIT;\n\npub const INITIAL_COLLATOR_STAKING: Balance = 10_000 * UNIT;\npub const COLLATOR_ADDITIONAL: Balance = 10 * UNIT;\n\npub const TOKEN_DECIMALS: u32 = 12;\n\npub const INITIAL_SUDO_SIGNATORIES: [\u0026str; 5] = [\n\t\"6nJwMD3gk36fe6pMRL2UpbwAEjDdjjxdngQGShe753pyAvCT\",\n\t\"6i4xDEE1Q2Bv8tnJtgD4jse4YTAzzCwCJVUehRQ93hCqKp8f\",\n\t\"6n62KZWvmZHgeyEXTvQFmoHRMqjKfFWvQVsApkePekuNfek5\",\n\t\"6kwxQBRKMadrY9Lq3K8gZXkw1UkjacpqYhcqvX3AqmN9DofF\",\n\t\"6kKHwcpCVC18KepwvdMSME8Q7ZTNr1RoRUrFDH9AdAmhL3Pt\",\n];\n\npub const INITIAL_COLLATORS: [\u0026str; 8] = [\n\t\"6mTATq7Ug9RPk4s8aMv5H7WVZ7RvwrJ1JitbYMXWPhanzqiv\",\n\t\"6n8WiWqjEB8nCNRo5mxXc89FqhuMd2dgXNSrzuPxoZSnatnL\",\n\t\"6ic56zZmjqo746yifWzcNxxzxLe3pRo8WNitotniUQvgKnyU\",\n\t\"6gvFApEyYj4EavJP26mwbVu7YxFBYZ9gaJFB7gv5gA6vNfze\",\n\t\"6mz3ymVAsfHotEhHphVRvLLBhMZ2frnwbuvW5QZiMRwJghxE\",\n\t\"6mpD3zcHcUBkxCjTsGg2tMTfmQZdXLVYZnk4UkN2XAUTLkRe\",\n\t\"6mGcZntk59RK2JfxfdmprgDJeByVUgaffMQYkp1ZeoEKeBJA\",\n\t\"6jq7obxC7AxhWeJNzopwYidKNNe48cLrbGSgB2zs2SuRTWGA\",\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","constants","foucoco.rs"],"content":"use runtime_common::{Balance, UNIT};\n\npub const PARACHAIN_ID: u32 = 2124;\npub const INITIAL_ISSUANCE: Balance = 200_000_000 * UNIT;\n\npub const INITIAL_ISSUANCE_PER_SIGNATORY: Balance = 200 * UNIT;\n\npub const INITIAL_COLLATOR_STAKING: Balance = 10_000 * UNIT;\npub const COLLATOR_ADDITIONAL: Balance = 10 * UNIT;\n\npub const OFF_CHAIN_WORKER_ADDRESS: \u0026str = \"6m69vWMouLarYCbJGJisVaDDpfNGETkD5hsDWf2T7osW4Cn1\";\n\npub const TOKEN_DECIMALS: u32 = 12;\n\npub const INITIAL_SUDO_SIGNATORIES: [\u0026str; 5] = [\n\t\"6mSy3qQKgAez9zpqY1JSnYW7d1njMNX93P4mkkQvsmPXmehB\",\n\t\"6mrdgs7NsHwceSPQRcXCagYzZiB4hoMBGmpMPLA4rS4BGyo7\",\n\t\"6jBUR27UemaZBF2aYrEbMuN3u76aANEpA3uxLrQcWP8jNDtf\",\n\t\"6hcDDb1nV6zrqfiB7dgQ5DbzuLkPmxkvSZ5LSA9kcE3gxNs8\",\n\t\"6k4NQX2KepBkeexrWVNabnWG9GZxvQTYi4ytHHCNwPhLZMnE\",\n];\n\npub const INITIAL_COLLATORS: [\u0026str; 4] = [\n\t\"6ihktBwyFJYjE1LKdqoAWzo5VDPJJGso9D5iASZyhuN5JvGH\",\n\t\"6mbXa9Qca6B6cX51cbtfWWLhup84rMoMFCxNHjso15GBFyGh\",\n\t\"6mMdv2wmb4Cp8PAtDLF1WTh1wLPwPbETwtcjqgJLskdB8EYo\",\n\t\"6kL1dzcBJiLgMdAT1qDFD79CLupX1gCCF8RSg5Dh5qRgQeCx\",\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","constants","mod.rs"],"content":"use spacewalk_primitives::{Asset, CurrencyId};\n\npub mod amplitude;\npub mod foucoco;\npub mod pendulum;\n\n// For Mainnet USDC issued by the testnet issuer\npub const MAINNET_USDC_CURRENCY_ID: CurrencyId = CurrencyId::Stellar(Asset::AlphaNum4 {\n\tcode: *b\"USDC\",\n\tissuer: [\n\t\t59, 153, 17, 56, 14, 254, 152, 139, 160, 168, 144, 14, 177, 207, 228, 79, 54, 111, 125,\n\t\t190, 148, 107, 237, 7, 114, 64, 247, 246, 36, 223, 21, 197,\n\t],\n});\n\n// For Mainnet BRL issued by the testnet issuer\npub const MAINNET_BRL_CURRENCY_ID: CurrencyId = CurrencyId::Stellar(Asset::AlphaNum4 {\n\tcode: *b\"BRL\\0\",\n\tissuer: [\n\t\t234, 172, 104, 212, 208, 227, 123, 76, 36, 194, 83, 105, 22, 232, 48, 115, 95, 3, 45, 13,\n\t\t107, 42, 28, 143, 202, 59, 197, 162, 94, 8, 62, 58,\n\t],\n});\n\n// For Mainnet TZS issued by the testnet issuer\npub const MAINNET_TZS_CURRENCY_ID: CurrencyId = CurrencyId::Stellar(Asset::AlphaNum4 {\n\tcode: *b\"TZS\\0\",\n\tissuer: [\n\t\t52, 201, 75, 42, 75, 169, 232, 181, 123, 34, 84, 125, 203, 179, 15, 68, 60, 76, 176, 45,\n\t\t163, 130, 154, 137, 170, 27, 212, 120, 14, 68, 102, 186,\n\t],\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","constants","pendulum.rs"],"content":"use runtime_common::{Balance, UNIT};\n\npub const PARACHAIN_ID: u32 = 2094;\npub const TOTAL_INITIAL_ISSUANCE: Balance = 160_000_000 * UNIT;\n\npub const INITIAL_ISSUANCE_PER_SIGNATORY: Balance = 200 * UNIT;\n\npub const INITIAL_COLLATOR_STAKING: Balance = 5_000 * UNIT;\npub const COLLATOR_ADDITIONAL: Balance = 10 * UNIT;\n\npub const TOKEN_DECIMALS: u32 = 12;\n\npub const SUDO_SIGNATORIES: [\u0026str; 5] = [\n\t\"6bgxxegcuBCYngSkJqp7bzgVZWd7brVrABEQetFq1R5dNa7T\",\n\t\"6cm5M5JVknj4NQdWpdayqwm92wzvSzjgE5SCRS7HM1EoauLm\",\n\t\"6gkRvy75f8gngVgtbJ72WHWPf17xgFGHuE2h2vKce5cnBidw\",\n\t\"6eD6Ep2GxAsPrCLNMtPNEv2Nj9D3EzJsPzMBGz8R8JGgNXg3\",\n\t\"6fvm48ZH2NYvBasbFLm8r2t33K9tVL6y9Z14HWiaoAYr4WNi\",\n];\n\npub const MULTISIG_ID_GENESIS: \u0026str = \"6ce4KspfCTmRnDzpQ3JYFYGPDgoqph6NYnqNTe58b86tusEn\";\npub const MULTISIG_ID_TEAM: \u0026str = \"6diKWq553r9jYkuyeWLd7YLU36ovc71puFKEq4ayqChBUQAL\";\npub const MULTISIG_ID_CL_RESERVES: \u0026str = \"6fMjg9qf8r6wZNJB71k3x7Gm7QRkFkjUsJq9ZuhQucav3sBZ\";\npub const MULTISIG_ID_INCENTIVES: \u0026str = \"6dzVMr6dud6Qt5ztG9T3iscv7f5jN9N26PfGAqJq8EjHGkcd\";\npub const MULTISIG_ID_MARKETING: \u0026str = \"6dxAdKt9zGDjUeHHcsi5U1fgxT1HKcHVjwoTANRPWjHd7Q1U\";\n\npub const CL_RESERVES_ALLOCATION: Balance = 10_000_000 * UNIT;\npub const INCENTIVES_ALLOCATION: Balance = 8_000_000 * UNIT;\npub const MARKETING_ALLOCATION: Balance = 10_000_000 * UNIT;\npub const TREASURY_ALLOCATION: Balance = 26_000_000 * UNIT;\n\npub const INITIAL_COLLATORS: [\u0026str; 8] = [\n\t\"6gUmMnikYxEkk4H7RdnsLRrzNRuDrGAh8JgSiCghG39qenX9\",\n\t\"6cgKZANaeUJ42VC7iAXrTzX8NC2gdn4WmYAHRo1RBjBfVvnk\",\n\t\"6bh2t6KMJ9BKgCs1B6qcrp5BjMyv2azmgBC6ySwZ3wrTeW5s\",\n\t\"6bBH94XAkscX5Q1oswuPSenUzjb9f2iPcfhTKdu1XCK1uwVS\",\n\t\"6emSrvAgGZXGBu255njQg3pBxDyQN47T7H2XDZuS5V5epHaX\",\n\t\"6fciE2ek1AMFUaFm4nizaHEZtXBy6eRxEcoygr3SFKfddBBK\",\n\t\"6ftBtHvYrThAv1xHYDnYrm2qQLFcj2rhkaU5GqNuqvKp57v6\",\n\t\"6feqfoP5htFpSriTd9oomDa1dZDmcM4XpjKEq8dfdcADCfGt\",\n];\n\npub struct Allocation {\n\tpub address: \u0026'static str,\n\tpub amount: Balance,\n}\n\npub const ALLOCATIONS_10_24: [Allocation; 33] = [\n\tAllocation { address: \"16LZddCHy8Td5p1T7hN52k1yPgS5Kvi4FbcN1qmgpEDLrmxW\", amount: 200000 },\n\tAllocation { address: \"124pJ5gdqKDXL3VjryYZiPBTTmtia6rEAGfUbHaf8LNToqZE\", amount: 2000000 },\n\tAllocation { address: \"15SvDT9AEzWbZU96Ea6KtPgFVvH1R1DqFDmUi9pYPr1ZymLG\", amount: 280000 },\n\tAllocation { address: \"16Zm7ctGjbVsADdPP8x8M6X6KXQxdzwjncWXbhFmQgGVQ1k6\", amount: 1200000 },\n\tAllocation { address: \"1kM6D9EgjD6VZQTZoEEVdANhaQFFeVtvowzVFpgv5DbqySk\", amount: 553480 },\n\tAllocation { address: \"13QdwVMsKiN8DVvjhwUSg3zrfFAPKvd1nPP3FbtKacwZGZW3\", amount: 2960000 },\n\tAllocation { address: \"1RyThWA1SCv3EGayyC2n74Cz28Prh7cYHZih5Hc1eCk157N\", amount: 1900000 },\n\tAllocation { address: \"15uXmzkjdBh9oJzBea1cTK1jw79djMwfw6845DyCiFQJzr17\", amount: 400000 },\n\tAllocation { address: \"4sVT7n5xGBq4X4Nyr1oPmw7qyKpxFZfB3PyuSPa44uFwh2oa\", amount: 1080000 },\n\tAllocation { address: \"13wbnsaCot1JqtP7HS3ASjgs5n2X2fzGC2TswSjyEmThFkjv\", amount: 1000000 },\n\tAllocation { address: \"12xmShQ49VKcmWNoMovChvUP3ar3muvFtkcf7PvPwkAk2V31\", amount: 64000 },\n\tAllocation { address: \"14s3dQEfCB9yaexpQFN4C5ZmkvkXwEdxrv9NToSsBP7rCegG\", amount: 100000 },\n\tAllocation { address: \"5EhUWtF2ZJpHMbG9G65LUjAtBA48zCV5PCWXibZKwZvzNKQa\", amount: 160000 },\n\tAllocation { address: \"1nHjrXTmso9AuGnssYRYxJnBf8NbwFQyhrb7Svk7FcvrvH3\", amount: 276800 },\n\tAllocation { address: \"5DhWaXkGNJVg1FU15myWRcSLEpotK4wz4fjBp7qtcmnDtSJ6\", amount: 800000 },\n\tAllocation { address: \"136X6NEWZEBQscsCaocy5DT328KHpxFWwR6Z54fHPLRVuVu3\", amount: 800000 },\n\tAllocation { address: \"1254xvMjWNvYGn7vB1vcSLS4gL1VUiJL8BHu8NWsrG1jkHi8\", amount: 200000 },\n\tAllocation { address: \"5CAR4QkAD2pxc9uXT2SzLJjpKPGDfxqFVVeQKGB4ixXVL74c\", amount: 800000 },\n\tAllocation { address: \"14uUXVDrEjUSv9Ec22w6GQ3keXRxNu98RZ39z5Xz2FWHzwCC\", amount: 1840000 },\n\tAllocation { address: \"16XjrAX12Drvcz3daqjoLJmCTP3dBC8zxS286Zx9G9am66qm\", amount: 440000 },\n\tAllocation { address: \"158kU5QMgc74aQniPbBZwaezXD62GbHLv59CSqB3KnjNy8sV\", amount: 160000 },\n\tAllocation { address: \"5CaosCeDNkCMGV4CQHy2YNia5zmvV4EmVv2aTg2jzNcxejFn\", amount: 960000 },\n\tAllocation { address: \"15Dg5uQM8fuckTSfLnEC5cTyyBMbNbkwx4FJSoFshwQwqvRr\", amount: 1200000 },\n\tAllocation { address: \"15E56zSiZXmZNyaLAmhwo8icCqQWgWJpunytkideS9ZQSNLT\", amount: 1200000 },\n\tAllocation { address: \"5GVtKE3KP2pJpK8HjeDTsSMMYgciHZpP4HNj8E2bL2wHmtvW\", amount: 120000 },\n\tAllocation { address: \"12gmcL9eej9jRBFT26vZLF4b7aAe4P9aEYHGHFzJdmf5arPi\", amount: 200000 },\n\tAllocation { address: \"152ryYwv8LaNCEA5v1kr5hPQF8LLCEq1xuJmykMD2dbbDBiM\", amount: 200000 },\n\tAllocation { address: \"5EHtSzWCq4aaC2XzPRmbPEdwV4Uty7pKqukVTdeEygVpEJxf\", amount: 400000 },\n\tAllocation { address: \"153GQ6MRcZiSwRy7xEy3X8kQybdFMov9TWvQr8NDmJLzoFan\", amount: 80000 },\n\tAllocation { address: \"12KdQaJLMovA6q6j6jGbooMuCuDPz1PWtTLtT5ExCmwKbNJ6\", amount: 80000 },\n\tAllocation { address: \"5ELsgzLeCyCBBPQ5yimZ9aXiLBmvHkcTTK6iP9TdtaS3BvMp\", amount: 80000 },\n\tAllocation { address: \"5G45b78emoZ1eLmu4FCarmhhaxsRNmLZKuQmXE6tLnUGyFSC\", amount: 80000 },\n\tAllocation { address: \"156DACh3KCPcFbxQmdQeWZD7B1TywvRviSQwcE8TxHkDij4b\", amount: 160000 },\n];\n\npub const ALLOCATIONS_12_36: [Allocation; 2] = [\n\tAllocation { address: \"1xhckCAgNsFFTCeSN1VX7xMG6zrpL2dQqJDKqjt1mPmEAut\", amount: 500000 },\n\tAllocation { address: \"6gPTQUcQBM9xdmo3tfXDLuUNoZbERAdGHNhW3JeFDHuLfUBY\", amount: 500000 },\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","main.rs"],"content":"//! Pendulum/Amplitude Collator CLI\n\n#![warn(missing_docs)]\n\nmod chain_spec;\n#[macro_use]\nmod service;\nmod cli;\nmod command;\nmod constants;\nmod rpc;\n\nfn main() -\u003e sc_cli::Result\u003c()\u003e {\n\tcommand::run()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","node","src","rpc.rs"],"content":"//! A collection of node-specific RPC methods.\n//! Substrate provides the `sc-rpc` crate, which defines the core RPC layer\n//! used by Substrate nodes. This file extends those RPC definitions with\n//! capabilities that are specific to this project's runtime configuration.\n\n#![warn(missing_docs)]\n\nuse std::sync::Arc;\n\npub use sc_rpc::{DenyUnsafe, SubscriptionTaskExecutor};\nuse sc_transaction_pool_api::TransactionPool;\n\nuse bifrost_farming_rpc_api::{FarmingRpc, FarmingRpcApiServer};\n\nuse zenlink_protocol_rpc::{ZenlinkProtocol, ZenlinkProtocolApiServer};\n\nuse module_issue_rpc::{Issue, IssueApiServer};\nuse module_oracle_rpc::{Oracle, OracleApiServer};\nuse module_redeem_rpc::{Redeem, RedeemApiServer};\nuse module_replace_rpc::{Replace, ReplaceApiServer};\nuse module_vault_registry_rpc::{VaultRegistry, VaultRegistryApiServer};\nuse pallet_transaction_payment_rpc::{TransactionPayment, TransactionPaymentApiServer};\nuse substrate_frame_rpc_system::{System, SystemApiServer};\n\nuse crate::service::{AmplitudeClient, DevelopmentClient, FoucocoClient, PendulumClient};\n\n/// A type representing all RPC extensions.\npub type RpcExtension = jsonrpsee::RpcModule\u003c()\u003e;\n\n/// Full client dependencies\npub struct FullDeps\u003cC, P\u003e {\n\t/// The client instance to use.\n\tpub client: Arc\u003cC\u003e,\n\t/// Transaction pool instance.\n\tpub pool: Arc\u003cP\u003e,\n\t/// Whether to deny unsafe calls\n\tpub deny_unsafe: DenyUnsafe,\n}\n\n/// Instantiate all RPC extensions.\npub fn create_full_pendulum\u003cP\u003e(\n\tdeps: FullDeps\u003cPendulumClient, P\u003e,\n) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\nwhere\n\tP: TransactionPool + Sync + Send + 'static,\n{\n\tlet mut module = RpcExtension::new(());\n\tlet FullDeps { client, pool, deny_unsafe } = deps;\n\n\tmodule.merge(System::new(client.clone(), pool, deny_unsafe).into_rpc())?;\n\tmodule.merge(TransactionPayment::new(client.clone()).into_rpc())?;\n\tmodule.merge(ZenlinkProtocol::new(client).into_rpc())?;\n\tOk(module)\n}\n\n/// Instantiate all RPC extensions.\npub fn create_full_development\u003cP\u003e(\n\tdeps: FullDeps\u003cDevelopmentClient, P\u003e,\n) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\nwhere\n\tP: TransactionPool + Sync + Send + 'static,\n{\n\tlet mut module = RpcExtension::new(());\n\tlet FullDeps { client, pool, deny_unsafe } = deps;\n\n\tmodule.merge(System::new(client.clone(), pool, deny_unsafe).into_rpc())?;\n\tmodule.merge(TransactionPayment::new(client).into_rpc())?;\n\tOk(module)\n}\n\npub fn create_full_amplitude\u003cP\u003e(\n\tdeps: FullDeps\u003cAmplitudeClient, P\u003e,\n) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\nwhere\n\tP: TransactionPool + Sync + Send + 'static,\n{\n\tlet mut module = RpcExtension::new(());\n\tlet FullDeps { client, pool, deny_unsafe } = deps;\n\n\tmodule.merge(System::new(client.clone(), pool, deny_unsafe).into_rpc())?;\n\tmodule.merge(TransactionPayment::new(client.clone()).into_rpc())?;\n\tmodule.merge(Issue::new(client.clone()).into_rpc())?;\n\tmodule.merge(Redeem::new(client.clone()).into_rpc())?;\n\tmodule.merge(Replace::new(client.clone()).into_rpc())?;\n\tmodule.merge(VaultRegistry::new(client.clone()).into_rpc())?;\n\tmodule.merge(Oracle::new(client.clone()).into_rpc())?;\n\tmodule.merge(FarmingRpc::new(client.clone()).into_rpc())?;\n\tmodule.merge(ZenlinkProtocol::new(client).into_rpc())?;\n\n\tOk(module)\n}\n\npub fn create_full_foucoco\u003cP\u003e(\n\tdeps: FullDeps\u003cFoucocoClient, P\u003e,\n) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\nwhere\n\tP: TransactionPool + Sync + Send + 'static,\n{\n\tlet mut module = RpcExtension::new(());\n\tlet FullDeps { client, pool, deny_unsafe } = deps;\n\n\tmodule.merge(System::new(client.clone(), pool, deny_unsafe).into_rpc())?;\n\tmodule.merge(TransactionPayment::new(client.clone()).into_rpc())?;\n\tmodule.merge(Issue::new(client.clone()).into_rpc())?;\n\tmodule.merge(Redeem::new(client.clone()).into_rpc())?;\n\tmodule.merge(Replace::new(client.clone()).into_rpc())?;\n\tmodule.merge(VaultRegistry::new(client.clone()).into_rpc())?;\n\tmodule.merge(Oracle::new(client.clone()).into_rpc())?;\n\tmodule.merge(FarmingRpc::new(client.clone()).into_rpc())?;\n\tmodule.merge(ZenlinkProtocol::new(client).into_rpc())?;\n\n\tOk(module)\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":35},{"path":["/","Users","marcel","Documents","pendulum","node","src","service.rs"],"content":"//! Service and ServiceFactory implementation. Specialized wrapper over substrate service.\n\n// std\nuse std::{sync::Arc, time::Duration};\n\nuse cumulus_client_cli::CollatorOptions;\n// Local Runtime Types\nuse runtime_common::{opaque::Block, AccountId, Balance, Index as Nonce};\n\n// Cumulus Imports\nuse cumulus_client_consensus_aura::{AuraConsensus, BuildAuraConsensusParams, SlotProportion};\nuse cumulus_client_consensus_common::{\n\tParachainBlockImport as TParachainBlockImport, ParachainConsensus,\n};\nuse cumulus_client_network::BlockAnnounceValidator;\nuse cumulus_client_service::{\n\tprepare_node_config, start_collator, start_full_node, StartCollatorParams, StartFullNodeParams,\n};\nuse cumulus_primitives_core::ParaId;\nuse cumulus_relay_chain_inprocess_interface::build_inprocess_relay_chain;\nuse cumulus_relay_chain_interface::{RelayChainInterface, RelayChainResult};\nuse cumulus_relay_chain_minimal_node::build_minimal_relay_chain_node;\n\n// Substrate Imports\nuse sc_executor::NativeElseWasmExecutor;\nuse sc_network::NetworkBlock;\nuse sc_network_sync::SyncingService;\n\nuse sc_service::{Configuration, PartialComponents, TFullBackend, TFullClient, TaskManager};\nuse sc_telemetry::{Telemetry, TelemetryHandle, TelemetryWorker, TelemetryWorkerHandle};\nuse sp_api::ConstructRuntimeApi;\nuse sp_consensus_aura::{sr25519::AuthorityId, AuraApi};\nuse sp_keystore::SyncCryptoStorePtr;\nuse sp_runtime::traits::BlakeTwo256;\nuse substrate_prometheus_endpoint::Registry;\n\nuse polkadot_service::CollatorPair;\nuse sc_consensus::ImportQueue;\n\nuse crate::rpc::{\n\tcreate_full_amplitude, create_full_development, create_full_foucoco, create_full_pendulum,\n\tFullDeps, RpcExtension,\n};\n\npub use amplitude_runtime::RuntimeApi as AmplitudeRuntimeApi;\npub use development_runtime::RuntimeApi as DevelopmentRuntimeApi;\npub use foucoco_runtime::RuntimeApi as FoucocoRuntimeApi;\npub use pendulum_runtime::RuntimeApi as PendulumRuntimeApi;\n\npub type AmplitudeClient =\n\tTFullClient\u003cBlock, AmplitudeRuntimeApi, NativeElseWasmExecutor\u003cAmplitudeRuntimeExecutor\u003e\u003e;\npub type FoucocoClient =\n\tTFullClient\u003cBlock, FoucocoRuntimeApi, NativeElseWasmExecutor\u003cFoucocoRuntimeExecutor\u003e\u003e;\npub type PendulumClient =\n\tTFullClient\u003cBlock, PendulumRuntimeApi, NativeElseWasmExecutor\u003cPendulumRuntimeExecutor\u003e\u003e;\npub type DevelopmentClient =\n\tTFullClient\u003cBlock, DevelopmentRuntimeApi, NativeElseWasmExecutor\u003cDevelopmentRuntimeExecutor\u003e\u003e;\n\ntype ParachainBlockImport\u003cRuntimeApi, Executor\u003e = TParachainBlockImport\u003c\n\tBlock,\n\tArc\u003cTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e,\n\tTFullBackend\u003cBlock\u003e,\n\u003e;\n\npub trait ParachainRuntimeApiImpl:\n\tsp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e\n\t+ sp_api::Metadata\u003cBlock\u003e\n\t+ sp_session::SessionKeys\u003cBlock\u003e\n\t+ sp_api::ApiExt\u003cBlock, StateBackend = sc_client_api::StateBackendFor\u003cTFullBackend\u003cBlock\u003e, Block\u003e\u003e\n\t+ sp_offchain::OffchainWorkerApi\u003cBlock\u003e\n\t+ sp_block_builder::BlockBuilder\u003cBlock\u003e\n\t+ cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e\n\t+ pallet_transaction_payment_rpc::TransactionPaymentRuntimeApi\u003cBlock, Balance\u003e\n\t+ substrate_frame_rpc_system::AccountNonceApi\u003cBlock, AccountId, Nonce\u003e\n\t+ AuraApi\u003cBlock, AuthorityId\u003e\n{\n}\n\nimpl ParachainRuntimeApiImpl for amplitude_runtime::RuntimeApiImpl\u003cBlock, AmplitudeClient\u003e {}\nimpl ParachainRuntimeApiImpl for pendulum_runtime::RuntimeApiImpl\u003cBlock, PendulumClient\u003e {}\nimpl ParachainRuntimeApiImpl for foucoco_runtime::RuntimeApiImpl\u003cBlock, FoucocoClient\u003e {}\nimpl ParachainRuntimeApiImpl for development_runtime::RuntimeApiImpl\u003cBlock, DevelopmentClient\u003e {}\n\n/// Amplitude executor type.\npub struct AmplitudeRuntimeExecutor;\n\nimpl sc_executor::NativeExecutionDispatch for AmplitudeRuntimeExecutor {\n\ttype ExtendHostFunctions = frame_benchmarking::benchmarking::HostFunctions;\n\n\tfn dispatch(method: \u0026str, data: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n\t\tamplitude_runtime::api::dispatch(method, data)\n\t}\n\n\tfn native_version() -\u003e sc_executor::NativeVersion {\n\t\tamplitude_runtime::native_version()\n\t}\n}\n\n/// Foucoco executor type.\npub struct FoucocoRuntimeExecutor;\n\nimpl sc_executor::NativeExecutionDispatch for FoucocoRuntimeExecutor {\n\ttype ExtendHostFunctions = frame_benchmarking::benchmarking::HostFunctions;\n\n\tfn dispatch(method: \u0026str, data: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n\t\tfoucoco_runtime::api::dispatch(method, data)\n\t}\n\n\tfn native_version() -\u003e sc_executor::NativeVersion {\n\t\tfoucoco_runtime::native_version()\n\t}\n}\n\n/// Pendulum executor type.\npub struct PendulumRuntimeExecutor;\n\nimpl sc_executor::NativeExecutionDispatch for PendulumRuntimeExecutor {\n\ttype ExtendHostFunctions = frame_benchmarking::benchmarking::HostFunctions;\n\n\tfn dispatch(method: \u0026str, data: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n\t\tpendulum_runtime::api::dispatch(method, data)\n\t}\n\n\tfn native_version() -\u003e sc_executor::NativeVersion {\n\t\tpendulum_runtime::native_version()\n\t}\n}\n\n/// Development executor instance.\npub struct DevelopmentRuntimeExecutor;\n\nimpl sc_executor::NativeExecutionDispatch for DevelopmentRuntimeExecutor {\n\ttype ExtendHostFunctions = frame_benchmarking::benchmarking::HostFunctions;\n\n\tfn dispatch(method: \u0026str, data: \u0026[u8]) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n\t\tdevelopment_runtime::api::dispatch(method, data)\n\t}\n\n\tfn native_version() -\u003e sc_executor::NativeVersion {\n\t\tdevelopment_runtime::native_version()\n\t}\n}\n\n/// Starts a `ServiceBuilder` for a full service.\n///\n/// Use this macro if you don't actually need the full service, but just the builder in order to\n/// be able to perform chain operations.\npub fn new_partial\u003cRuntimeApi, Executor\u003e(\n\tconfig: \u0026Configuration,\n) -\u003e Result\u003c\n\tPartialComponents\u003c\n\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\tTFullBackend\u003cBlock\u003e,\n\t\t(),\n\t\tsc_consensus::DefaultImportQueue\u003c\n\t\t\tBlock,\n\t\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\t\u003e,\n\t\tsc_transaction_pool::FullPool\u003c\n\t\t\tBlock,\n\t\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\t\u003e,\n\t\t(\n\t\t\tParachainBlockImport\u003cRuntimeApi, Executor\u003e,\n\t\t\tOption\u003cTelemetry\u003e,\n\t\t\tOption\u003cTelemetryWorkerHandle\u003e,\n\t\t),\n\t\u003e,\n\tsc_service::Error,\n\u003e\nwhere\n\tRuntimeApi: ConstructRuntimeApi\u003cBlock, TFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e\n\t\t+ Send\n\t\t+ Sync\n\t\t+ 'static,\n\tRuntimeApi::RuntimeApi: ParachainRuntimeApiImpl,\n\tExecutor: sc_executor::NativeExecutionDispatch + 'static,\n{\n\tlet telemetry = config\n\t\t.telemetry_endpoints\n\t\t.clone()\n\t\t.filter(|x| !x.is_empty())\n\t\t.map(|endpoints| -\u003e Result\u003c_, sc_telemetry::Error\u003e {\n\t\t\tlet worker = TelemetryWorker::new(16)?;\n\t\t\tlet telemetry = worker.handle().new_telemetry(endpoints);\n\t\t\tOk((worker, telemetry))\n\t\t})\n\t\t.transpose()?;\n\n\tlet executor = NativeElseWasmExecutor::\u003cExecutor\u003e::new(\n\t\tconfig.wasm_method,\n\t\tconfig.default_heap_pages,\n\t\tconfig.max_runtime_instances,\n\t\tconfig.runtime_cache_size,\n\t);\n\n\tlet (client, backend, keystore_container, task_manager) =\n\t\tsc_service::new_full_parts::\u003cBlock, RuntimeApi, _\u003e(\n\t\t\tconfig,\n\t\t\ttelemetry.as_ref().map(|(_, telemetry)| telemetry.handle()),\n\t\t\texecutor,\n\t\t)?;\n\tlet client = Arc::new(client);\n\n\tlet telemetry_worker_handle = telemetry.as_ref().map(|(worker, _)| worker.handle());\n\n\tlet telemetry = telemetry.map(|(worker, telemetry)| {\n\t\ttask_manager.spawn_handle().spawn(\"telemetry\", None, worker.run());\n\t\ttelemetry\n\t});\n\n\tlet transaction_pool = sc_transaction_pool::BasicPool::new_full(\n\t\tconfig.transaction_pool.clone(),\n\t\tconfig.role.is_authority().into(),\n\t\tconfig.prometheus_registry(),\n\t\ttask_manager.spawn_essential_handle(),\n\t\tclient.clone(),\n\t);\n\n\tlet block_import = ParachainBlockImport::new(client.clone(), backend.clone());\n\n\tlet import_queue = build_import_queue(\n\t\tclient.clone(),\n\t\tblock_import.clone(),\n\t\tconfig,\n\t\ttelemetry.as_ref().map(|telemetry| telemetry.handle()),\n\t\t\u0026task_manager,\n\t)?;\n\n\tOk(PartialComponents {\n\t\tbackend,\n\t\tclient,\n\t\timport_queue,\n\t\tkeystore_container,\n\t\ttask_manager,\n\t\ttransaction_pool,\n\t\tselect_chain: (),\n\t\tother: (block_import, telemetry, telemetry_worker_handle),\n\t})\n}\n\nasync fn build_relay_chain_interface(\n\tpolkadot_config: Configuration,\n\tparachain_config: \u0026Configuration,\n\ttelemetry_worker_handle: Option\u003cTelemetryWorkerHandle\u003e,\n\ttask_manager: \u0026mut TaskManager,\n\tcollator_options: CollatorOptions,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e RelayChainResult\u003c(Arc\u003c(dyn RelayChainInterface + 'static)\u003e, Option\u003cCollatorPair\u003e)\u003e {\n\tif !collator_options.relay_chain_rpc_urls.is_empty() {\n\t\tbuild_minimal_relay_chain_node(\n\t\t\tpolkadot_config,\n\t\t\ttask_manager,\n\t\t\tcollator_options.relay_chain_rpc_urls,\n\t\t)\n\t\t.await\n\t} else {\n\t\tbuild_inprocess_relay_chain(\n\t\t\tpolkadot_config,\n\t\t\tparachain_config,\n\t\t\ttelemetry_worker_handle,\n\t\t\ttask_manager,\n\t\t\thwbench,\n\t\t)\n\t}\n}\n\ntype FullDepsOf\u003cRuntimeApi, Executor\u003e = FullDeps\u003c\n\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\tsc_transaction_pool::FullPool\u003c\n\t\tBlock,\n\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\u003e,\n\u003e;\n\n#[sc_tracing::logging::prefix_logs_with(\"Parachain\")]\nasync fn start_node_impl\u003cRuntimeApi, Executor\u003e(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n\tcreate_full_rpc: fn(\n\t\tdeps: FullDepsOf\u003cRuntimeApi, Executor\u003e,\n\t) -\u003e Result\u003cRpcExtension, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e,\n) -\u003e sc_service::error::Result\u003c(\n\tTaskManager,\n\tArc\u003cTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e,\n)\u003e\nwhere\n\tRuntimeApi: ConstructRuntimeApi\u003cBlock, TFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e\n\t\t+ Send\n\t\t+ Sync\n\t\t+ 'static,\n\tRuntimeApi::RuntimeApi: ParachainRuntimeApiImpl,\n\tsc_client_api::StateBackendFor\u003cTFullBackend\u003cBlock\u003e, Block\u003e: sp_api::StateBackend\u003cBlakeTwo256\u003e,\n\tExecutor: sc_executor::NativeExecutionDispatch + 'static,\n{\n\tlet parachain_config = prepare_node_config(parachain_config);\n\n\tlet params = new_partial(\u0026parachain_config)?;\n\tlet (block_import, mut telemetry, telemetry_worker_handle) = params.other;\n\n\tlet client = params.client.clone();\n\tlet backend = params.backend.clone();\n\tlet mut task_manager = params.task_manager;\n\n\tlet (relay_chain_interface, collator_key) = build_relay_chain_interface(\n\t\tpolkadot_config,\n\t\t\u0026parachain_config,\n\t\ttelemetry_worker_handle,\n\t\t\u0026mut task_manager,\n\t\tcollator_options.clone(),\n\t\thwbench.clone(),\n\t)\n\t.await\n\t.map_err(|e| sc_service::Error::Application(Box::new(e)))?;\n\n\tlet block_announce_validator = BlockAnnounceValidator::new(relay_chain_interface.clone(), id);\n\n\tlet force_authoring = parachain_config.force_authoring;\n\tlet validator = parachain_config.role.is_authority();\n\tlet prometheus_registry = parachain_config.prometheus_registry().cloned();\n\tlet transaction_pool = params.transaction_pool.clone();\n\tlet import_queue_service = params.import_queue.service();\n\n\tlet (network, system_rpc_tx, tx_handler_controller, start_network, sync_service) =\n\t\tsc_service::build_network(sc_service::BuildNetworkParams {\n\t\t\tconfig: \u0026parachain_config,\n\t\t\tclient: client.clone(),\n\t\t\ttransaction_pool: transaction_pool.clone(),\n\t\t\tspawn_handle: task_manager.spawn_handle(),\n\t\t\timport_queue: params.import_queue,\n\t\t\tblock_announce_validator_builder: Some(Box::new(|_| {\n\t\t\t\tBox::new(block_announce_validator)\n\t\t\t})),\n\t\t\twarp_sync_params: None,\n\t\t})?;\n\n\tif parachain_config.offchain_worker.enabled {\n\t\tsc_service::build_offchain_workers(\n\t\t\t\u0026parachain_config,\n\t\t\ttask_manager.spawn_handle(),\n\t\t\tclient.clone(),\n\t\t\tnetwork.clone(),\n\t\t);\n\t}\n\n\tlet rpc_builder = {\n\t\tlet client = client.clone();\n\t\tlet transaction_pool = transaction_pool.clone();\n\n\t\tBox::new(move |deny_unsafe, _| {\n\t\t\tlet deps =\n\t\t\t\tFullDeps { client: client.clone(), pool: transaction_pool.clone(), deny_unsafe };\n\n\t\t\tcreate_full_rpc(deps).map_err(Into::into)\n\t\t})\n\t};\n\n\tsc_service::spawn_tasks(sc_service::SpawnTasksParams {\n\t\trpc_builder,\n\t\tclient: client.clone(),\n\t\ttransaction_pool: transaction_pool.clone(),\n\t\ttask_manager: \u0026mut task_manager,\n\t\tconfig: parachain_config,\n\t\tkeystore: params.keystore_container.sync_keystore(),\n\t\tbackend: backend.clone(),\n\t\tnetwork: network.clone(),\n\t\tsystem_rpc_tx,\n\t\ttx_handler_controller,\n\t\tsync_service: sync_service.clone(),\n\t\ttelemetry: telemetry.as_mut(),\n\t})?;\n\n\tif let Some(hwbench) = hwbench {\n\t\tsc_sysinfo::print_hwbench(\u0026hwbench);\n\n\t\tif let Some(ref mut telemetry) = telemetry {\n\t\t\tlet telemetry_handle = telemetry.handle();\n\t\t\ttask_manager.spawn_handle().spawn(\n\t\t\t\t\"telemetry_hwbench\",\n\t\t\t\tNone,\n\t\t\t\tsc_sysinfo::initialize_hwbench_telemetry(telemetry_handle, hwbench),\n\t\t\t);\n\t\t}\n\t}\n\n\tlet announce_block = {\n\t\tlet sync_service = sync_service.clone();\n\t\tArc::new(move |hash, data| sync_service.announce_block(hash, data))\n\t};\n\n\tlet relay_chain_slot_duration = Duration::from_secs(6);\n\n\tlet overseer_handle = relay_chain_interface\n\t\t.overseer_handle()\n\t\t.map_err(|e| sc_service::Error::Application(Box::new(e)))?;\n\n\tif validator {\n\t\tlet parachain_consensus = build_consensus(\n\t\t\tclient.clone(),\n\t\t\tblock_import,\n\t\t\tprometheus_registry.as_ref(),\n\t\t\ttelemetry.as_ref().map(|t| t.handle()),\n\t\t\t\u0026task_manager,\n\t\t\trelay_chain_interface.clone(),\n\t\t\ttransaction_pool,\n\t\t\tsync_service.clone(),\n\t\t\tparams.keystore_container.sync_keystore(),\n\t\t\tforce_authoring,\n\t\t\tid,\n\t\t)?;\n\n\t\tlet spawner = task_manager.spawn_handle();\n\t\tlet params = StartCollatorParams {\n\t\t\tpara_id: id,\n\t\t\tblock_status: client.clone(),\n\t\t\tannounce_block,\n\t\t\tclient: client.clone(),\n\t\t\ttask_manager: \u0026mut task_manager,\n\t\t\trelay_chain_interface,\n\t\t\tspawner,\n\t\t\tparachain_consensus,\n\t\t\timport_queue: import_queue_service,\n\t\t\tcollator_key: collator_key.expect(\"Command line arguments do not allow this. qed\"),\n\t\t\trelay_chain_slot_duration,\n\t\t\trecovery_handle: Box::new(overseer_handle),\n\t\t};\n\n\t\tstart_collator(params).await?;\n\t} else {\n\t\tlet params = StartFullNodeParams {\n\t\t\tclient: client.clone(),\n\t\t\tannounce_block,\n\t\t\ttask_manager: \u0026mut task_manager,\n\t\t\tpara_id: id,\n\t\t\trelay_chain_interface,\n\t\t\trelay_chain_slot_duration,\n\t\t\timport_queue: import_queue_service,\n\t\t\trecovery_handle: Box::new(overseer_handle),\n\t\t};\n\n\t\tstart_full_node(params)?;\n\t}\n\n\tstart_network.start_network();\n\n\tOk((task_manager, client))\n}\n\n/// Build the import queue for the parachain runtime.\nfn build_import_queue\u003cRuntimeApi, Executor\u003e(\n\tclient: Arc\u003cTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e,\n\tblock_import: ParachainBlockImport\u003cRuntimeApi, Executor\u003e,\n\tconfig: \u0026Configuration,\n\ttelemetry: Option\u003cTelemetryHandle\u003e,\n\ttask_manager: \u0026TaskManager,\n) -\u003e Result\u003c\n\tsc_consensus::DefaultImportQueue\u003c\n\t\tBlock,\n\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\u003e,\n\tsc_service::Error,\n\u003e\nwhere\n\tRuntimeApi: ConstructRuntimeApi\u003cBlock, TFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e\n\t\t+ Send\n\t\t+ Sync\n\t\t+ 'static,\n\tRuntimeApi::RuntimeApi: ParachainRuntimeApiImpl,\n\tExecutor: sc_executor::NativeExecutionDispatch + 'static,\n{\n\tlet slot_duration = cumulus_client_consensus_aura::slot_duration(\u0026*client)?;\n\n\tcumulus_client_consensus_aura::import_queue::\u003c\n\t\tsp_consensus_aura::sr25519::AuthorityPair,\n\t\t_,\n\t\t_,\n\t\t_,\n\t\t_,\n\t\t_,\n\t\u003e(cumulus_client_consensus_aura::ImportQueueParams {\n\t\tblock_import,\n\t\tclient,\n\t\tcreate_inherent_data_providers: move |_, _| async move {\n\t\t\tlet timestamp = sp_timestamp::InherentDataProvider::from_system_time();\n\n\t\t\tlet slot =\n\t\t\t\tsp_consensus_aura::inherents::InherentDataProvider::from_timestamp_and_slot_duration(\n\t\t\t\t\t*timestamp,\n\t\t\t\t\tslot_duration,\n\t\t\t\t);\n\n\t\t\tOk((slot, timestamp))\n\t\t},\n\t\tregistry: config.prometheus_registry(),\n\t\tspawner: \u0026task_manager.spawn_essential_handle(),\n\t\ttelemetry,\n\t})\n\t.map_err(Into::into)\n}\n\nfn build_consensus\u003cRuntimeApi, Executor\u003e(\n\tclient: Arc\u003cTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e,\n\tblock_import: ParachainBlockImport\u003cRuntimeApi, Executor\u003e,\n\tprometheus_registry: Option\u003c\u0026Registry\u003e,\n\ttelemetry: Option\u003cTelemetryHandle\u003e,\n\ttask_manager: \u0026TaskManager,\n\trelay_chain_interface: Arc\u003cdyn RelayChainInterface\u003e,\n\ttransaction_pool: Arc\u003c\n\t\tsc_transaction_pool::FullPool\u003c\n\t\t\tBlock,\n\t\t\tTFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e,\n\t\t\u003e,\n\t\u003e,\n\tsync_oracle: Arc\u003cSyncingService\u003cBlock\u003e\u003e,\n\tkeystore: SyncCryptoStorePtr,\n\tforce_authoring: bool,\n\tid: ParaId,\n) -\u003e Result\u003cBox\u003cdyn ParachainConsensus\u003cBlock\u003e\u003e, sc_service::Error\u003e\nwhere\n\tRuntimeApi: ConstructRuntimeApi\u003cBlock, TFullClient\u003cBlock, RuntimeApi, NativeElseWasmExecutor\u003cExecutor\u003e\u003e\u003e\n\t\t+ Send\n\t\t+ Sync\n\t\t+ 'static,\n\tRuntimeApi::RuntimeApi: ParachainRuntimeApiImpl,\n\tsc_client_api::StateBackendFor\u003cTFullBackend\u003cBlock\u003e, Block\u003e: sp_api::StateBackend\u003cBlakeTwo256\u003e,\n\tExecutor: sc_executor::NativeExecutionDispatch + 'static,\n{\n\tlet slot_duration = cumulus_client_consensus_aura::slot_duration(\u0026*client)?;\n\n\tlet proposer_factory = sc_basic_authorship::ProposerFactory::with_proof_recording(\n\t\ttask_manager.spawn_handle(),\n\t\tclient.clone(),\n\t\ttransaction_pool,\n\t\tprometheus_registry,\n\t\ttelemetry.clone(),\n\t);\n\n\tlet params = BuildAuraConsensusParams {\n\t\tproposer_factory,\n\t\tcreate_inherent_data_providers: move |_, (relay_parent, validation_data)| {\n\t\t\tlet relay_chain_interface = relay_chain_interface.clone();\n\t\t\tasync move {\n\t\t\t\tlet parachain_inherent =\n\t\t\t\t\tcumulus_primitives_parachain_inherent::ParachainInherentData::create_at(\n\t\t\t\t\t\trelay_parent,\n\t\t\t\t\t\t\u0026relay_chain_interface,\n\t\t\t\t\t\t\u0026validation_data,\n\t\t\t\t\t\tid,\n\t\t\t\t\t)\n\t\t\t\t\t.await;\n\t\t\t\tlet timestamp = sp_timestamp::InherentDataProvider::from_system_time();\n\n\t\t\t\tlet slot =\n\t\t\t\t\t\tsp_consensus_aura::inherents::InherentDataProvider::from_timestamp_and_slot_duration(\n\t\t\t\t\t\t\t*timestamp,\n\t\t\t\t\t\t\tslot_duration,\n\t\t\t\t\t\t);\n\n\t\t\t\tlet parachain_inherent = parachain_inherent.ok_or_else(|| {\n\t\t\t\t\tBox::\u003cdyn std::error::Error + Send + Sync\u003e::from(\n\t\t\t\t\t\t\"Failed to create parachain inherent\",\n\t\t\t\t\t)\n\t\t\t\t})?;\n\t\t\t\tOk((slot, timestamp, parachain_inherent))\n\t\t\t}\n\t\t},\n\t\tblock_import,\n\t\tpara_client: client,\n\t\tbackoff_authoring_blocks: Option::\u003c()\u003e::None,\n\t\tsync_oracle,\n\t\tkeystore,\n\t\tforce_authoring,\n\t\tslot_duration,\n\t\t// We got around 500ms for proposing\n\t\tblock_proposal_slot_portion: SlotProportion::new(1f32 / 24f32),\n\t\t// And a maximum of 750ms if slots are skipped\n\t\tmax_block_proposal_slot_portion: Some(SlotProportion::new(1f32 / 16f32)),\n\t\ttelemetry,\n\t};\n\n\tOk(AuraConsensus::build::\u003csp_consensus_aura::sr25519::AuthorityPair, _, _, _, _, _, _\u003e(params))\n}\n\n/// Start a parachain node.\npub async fn start_parachain_node_pendulum(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e sc_service::error::Result\u003c(TaskManager, Arc\u003cPendulumClient\u003e)\u003e {\n\tstart_node_impl(\n\t\tparachain_config,\n\t\tpolkadot_config,\n\t\tcollator_options,\n\t\tid,\n\t\thwbench,\n\t\tcreate_full_pendulum,\n\t)\n\t.await\n}\n\n/// Start a parachain node.\npub async fn start_parachain_node_development(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e sc_service::error::Result\u003c(TaskManager, Arc\u003cDevelopmentClient\u003e)\u003e {\n\tstart_node_impl(\n\t\tparachain_config,\n\t\tpolkadot_config,\n\t\tcollator_options,\n\t\tid,\n\t\thwbench,\n\t\tcreate_full_development,\n\t)\n\t.await\n}\n\n/// Start a parachain node with the Spacewalk RPC exposed using the foucoco runtime definitions.\npub async fn start_parachain_node_spacewalk_foucoco(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e sc_service::error::Result\u003c(TaskManager, Arc\u003cFoucocoClient\u003e)\u003e {\n\tstart_node_impl(\n\t\tparachain_config,\n\t\tpolkadot_config,\n\t\tcollator_options,\n\t\tid,\n\t\thwbench,\n\t\tcreate_full_foucoco,\n\t)\n\t.await\n}\n\n/// Start a parachain node with the Spacewalk RPC exposed using the amplitude runtime definitions.\npub async fn start_parachain_node_spacewalk_amplitude(\n\tparachain_config: Configuration,\n\tpolkadot_config: Configuration,\n\tcollator_options: CollatorOptions,\n\tid: ParaId,\n\thwbench: Option\u003csc_sysinfo::HwBench\u003e,\n) -\u003e sc_service::error::Result\u003c(TaskManager, Arc\u003cAmplitudeClient\u003e)\u003e {\n\tstart_node_impl(\n\t\tparachain_config,\n\t\tpolkadot_config,\n\t\tcollator_options,\n\t\tid,\n\t\thwbench,\n\t\tcreate_full_amplitude,\n\t)\n\t.await\n}\n","traces":[{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":158},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","benchmarking.rs"],"content":"#![allow(warnings)]\nuse super::{Pallet as TokenAllowance, *};\nuse frame_benchmarking::{account, benchmarks, impl_benchmark_test_suite};\nuse frame_system::RawOrigin;\nuse sp_std::prelude::*;\n\nbenchmarks! {\n\tadd_allowed_currencies {\n\t\t// This has to come first. Ranges are inclusive on both sides so we start from 1, see\n\t\t// [here](https://tidelabs.github.io/tidechain/frame_benchmarking/v1/macro.benchmarks.html)\n\t\tlet n in 1..T::MaxAllowedCurrencies::get();\n\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\n\t\t// It does not really matter that it's the same currency as the loop of the extrinsic\n\t\t// will iterate over it the same amount of times.\n\t\tlet added_currencies = vec![native_currency_id; n as usize];\n\t}: add_allowed_currencies(RawOrigin::Root, added_currencies)\n\tverify {\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tassert_eq!(AllowedCurrencies::\u003cT\u003e::get(native_currency_id), Some(()));\n\t}\n\n\tremove_allowed_currencies {\n\t\t// This has to come first. Ranges are inclusive on both sides so we start from 1, see\n\t\t// [here](https://tidelabs.github.io/tidechain/frame_benchmarking/v1/macro.benchmarks.html)\n\t\tlet n in 1..T::MaxAllowedCurrencies::get();\n\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tAllowedCurrencies::\u003cT\u003e::insert(native_currency_id, ());\n\n\t\tlet removed_currencies = vec![native_currency_id; n as usize];\n\t}: remove_allowed_currencies(RawOrigin::Root, removed_currencies)\n\tverify {\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tassert_eq!(AllowedCurrencies::\u003cT\u003e::get(native_currency_id), None);\n\t}\n\n\tapprove {\n\t\t//allow currency\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tAllowedCurrencies::\u003cT\u003e::insert(native_currency_id, ());\n\n\t\t//initialize accounts\n\t\tlet owner: T::AccountId = account(\"Alice\", 0, 0);\n\t\tlet delegate: T::AccountId = account(\"Bob\", 0, 0);\n\n\t\t//fund account\n\t\tlet amount =  BalanceOf::\u003cT\u003e::from(1_000_000_000u32);\n\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::deposit(native_currency_id, \u0026owner, amount);\n\n\t}: approve(RawOrigin::Signed(owner), native_currency_id, delegate, amount)\n\tverify {\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tlet owner: T::AccountId = account(\"Alice\", 0, 0);\n\t\tlet delegate: T::AccountId = account(\"Bob\", 0, 0);\n\t\tlet amount =  BalanceOf::\u003cT\u003e::from(1_000_000_000u32);\n\n\t\t//check that the allowance was updated\n\t\tassert_eq!(TokenAllowance::\u003cT\u003e::allowance(native_currency_id, \u0026owner, \u0026delegate), amount);\n\t}\n\n\ttransfer_from {\n\t\t//allow currency\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tAllowedCurrencies::\u003cT\u003e::insert(native_currency_id, ());\n\n\t\t//initialize accounts\n\t\tlet owner: T::AccountId = account(\"Alice\", 0, 0);\n\t\tlet delegate: T::AccountId = account(\"Bob\", 0, 0);\n\t\tlet destination: T::AccountId = account(\"Charlie\", 0, 0);\n\n\t\t//fund accounts\n\t\tlet amount =  BalanceOf::\u003cT\u003e::from(1_000_000_000u32);\n\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::deposit(native_currency_id, \u0026owner, amount);\n\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::deposit(native_currency_id, \u0026delegate, amount);\n\n\t\t//approve\n\t\tTokenAllowance::\u003cT\u003e::do_approve_transfer(native_currency_id, \u0026owner, \u0026delegate, amount);\n\n\t}: transfer_from(RawOrigin::Signed(delegate), native_currency_id, owner, destination, amount)\n\tverify {\n\t\tlet native_currency_id = \u003cT as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tlet owner: T::AccountId = account(\"Alice\", 0, 0);\n\t\tlet delegate: T::AccountId = account(\"Bob\", 0, 0);\n\t\tlet destination: T::AccountId = account(\"Charlie\", 0, 0);\n\t\tlet amount =  BalanceOf::\u003cT\u003e::from(1_000_000_000u32);\n\n\t\t//check that the allowance was updated\n\t\tassert_eq!(TokenAllowance::\u003cT\u003e::allowance(native_currency_id, \u0026owner, \u0026delegate), BalanceOf::\u003cT\u003e::from(0u32));\n\n\t\t//check that the balance was updated\n\t\tlet destination_balance = \u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::free_balance(native_currency_id, \u0026destination);\n\t\tassert_eq!(destination_balance, amount);\n\t}\n}\n\nimpl_benchmark_test_suite!(TokenAllowance, crate::mock::ExtBuilder::build(), crate::mock::Test);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","default_weights.rs"],"content":"\n//! Autogenerated weights for orml_currencies_allowance_extension\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-07-24, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Marcels-MBP`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"foucoco\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// foucoco\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet\n// orml-currencies-allowance-extension\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// pallets/orml-currencies-allowance-extension/src/default_weights.rs\n// --template\n// .maintain/frame-weight-template.hbs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n#![allow(missing_docs)]\n\nuse frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};\nuse core::marker::PhantomData;\n\n/// Weight functions needed for orml_currencies_allowance_extension.\npub trait WeightInfo {\n\tfn add_allowed_currencies(n: u32, ) -\u003e Weight;\n\tfn remove_allowed_currencies(n: u32, ) -\u003e Weight;\n\tfn approve() -\u003e Weight;\n\tfn transfer_from() -\u003e Weight;\n}\n\n/// Weights for orml_currencies_allowance_extension using the Substrate node and recommended hardware.\npub struct SubstrateWeight\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e WeightInfo for SubstrateWeight\u003cT\u003e {\n\t/// Storage: TokenAllowance AllowedCurrencies (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// The range of component `n` is `[1, 256]`.\n\tfn add_allowed_currencies(n: u32, ) -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(10_797_953, 0)\n\t\t\t// Standard Error: 1_712\n\t\t\t.saturating_add(Weight::from_parts(1_078_644, 0).saturating_mul(n.into()))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// The range of component `n` is `[1, 256]`.\n\tfn remove_allowed_currencies(n: u32, ) -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_672_163, 0)\n\t\t\t// Standard Error: 1_724\n\t\t\t.saturating_add(Weight::from_parts(1_085_251, 0).saturating_mul(n.into()))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:1 w:0)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: TokenAllowance Approvals (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance Approvals (max_values: None, max_size: None, mode: Measured)\n\tfn approve() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `184`\n\t\t//  Estimated: `3833`\n\t\t// Minimum execution time: 15_000_000 picoseconds.\n\t\tWeight::from_parts(16_000_000, 3833)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1_u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:1 w:0)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: TokenAllowance Approvals (r:1 w:1)\n\t/// Proof Skipped: TokenAllowance Approvals (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: System Account (r:2 w:2)\n\t/// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: MaxEncodedLen)\n\tfn transfer_from() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `561`\n\t\t//  Estimated: `14248`\n\t\t// Minimum execution time: 44_000_000 picoseconds.\n\t\tWeight::from_parts(46_000_000, 14248)\n\t\t\t.saturating_add(T::DbWeight::get().reads(4_u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3_u64))\n\t}\n}\n\n// For backwards compatibility and tests\nimpl WeightInfo for () {\n\t/// Storage: TokenAllowance AllowedCurrencies (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// The range of component `n` is `[1, 256]`.\n\tfn add_allowed_currencies(n: u32, ) -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(10_797_953, 0)\n\t\t\t// Standard Error: 1_712\n\t\t\t.saturating_add(Weight::from_parts(1_078_644, 0).saturating_mul(n.into()))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// The range of component `n` is `[1, 256]`.\n\tfn remove_allowed_currencies(n: u32, ) -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_672_163, 0)\n\t\t\t// Standard Error: 1_724\n\t\t\t.saturating_add(Weight::from_parts(1_085_251, 0).saturating_mul(n.into()))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:1 w:0)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: TokenAllowance Approvals (r:0 w:1)\n\t/// Proof Skipped: TokenAllowance Approvals (max_values: None, max_size: None, mode: Measured)\n\tfn approve() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `184`\n\t\t//  Estimated: `3833`\n\t\t// Minimum execution time: 15_000_000 picoseconds.\n\t\tWeight::from_parts(16_000_000, 3833)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1_u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1_u64))\n\t}\n\t/// Storage: TokenAllowance AllowedCurrencies (r:1 w:0)\n\t/// Proof Skipped: TokenAllowance AllowedCurrencies (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: TokenAllowance Approvals (r:1 w:1)\n\t/// Proof Skipped: TokenAllowance Approvals (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: System Account (r:2 w:2)\n\t/// Proof: System Account (max_values: None, max_size: Some(128), added: 2603, mode: MaxEncodedLen)\n\tfn transfer_from() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `561`\n\t\t//  Estimated: `14248`\n\t\t// Minimum execution time: 44_000_000 picoseconds.\n\t\tWeight::from_parts(46_000_000, 14248)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(4_u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(3_u64))\n\t}\n}","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":32},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","lib.rs"],"content":"#![deny(warnings)]\n#![cfg_attr(test, feature(proc_macro_hygiene))]\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\n#[cfg(test)]\nextern crate mocktopus;\n\nuse frame_support::{dispatch::DispatchResult, ensure};\n\n#[cfg(test)]\nuse mocktopus::macros::mockable;\nuse orml_traits::MultiCurrency;\nuse sp_runtime::traits::*;\nuse sp_std::{convert::TryInto, prelude::*, vec};\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benchmarking;\n\npub mod default_weights;\n\n#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod tests;\n\npub use pallet::*;\n\npub(crate) type BalanceOf\u003cT\u003e =\n\t\u003c\u003cT as orml_currencies::Config\u003e::MultiCurrency as orml_traits::MultiCurrency\u003c\n\t\t\u003cT as frame_system::Config\u003e::AccountId,\n\t\u003e\u003e::Balance;\n\npub(crate) type CurrencyOf\u003cT\u003e =\n\t\u003c\u003cT as orml_currencies::Config\u003e::MultiCurrency as orml_traits::MultiCurrency\u003c\n\t\t\u003cT as frame_system::Config\u003e::AccountId,\n\t\u003e\u003e::CurrencyId;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse crate::default_weights::WeightInfo;\n\tuse frame_support::{pallet_prelude::*, transactional};\n\tuse frame_system::{ensure_root, ensure_signed, pallet_prelude::OriginFor};\n\n\tuse super::*;\n\n\t/// ## Configuration\n\t/// The pallet's configuration trait.\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config + orml_tokens::Config + orml_currencies::Config {\n\t\t/// The overarching event type.\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\n\t\t/// Weight information for the extrinsics in this module.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\t/// The maximum number of allowed currencies.\n\t\t#[pallet::constant]\n\t\ttype MaxAllowedCurrencies: Get\u003cu32\u003e;\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\tAllowedCurrenciesAdded {\n\t\t\tcurrencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t\t},\n\t\tAllowedCurrenciesDeleted {\n\t\t\tcurrencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t\t},\n\t\t/// (Additional) funds have been approved for transfer to a destination account.\n\t\tTransferApproved {\n\t\t\tcurrency_id: CurrencyOf\u003cT\u003e,\n\t\t\tsource: T::AccountId,\n\t\t\tdelegate: T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t},\n\t}\n\n\t#[pallet::error]\n\tpub enum Error\u003cT\u003e {\n\t\tUnapproved,\n\t\tCurrencyNotLive,\n\t\tExceedsNumberOfAllowedCurrencies,\n\t}\n\n\t/// Approved balance transfers. Balance is the amount approved for transfer.\n\t/// First key is the currency ID, second key is the owner and third key is the delegate.\n\t#[pallet::storage]\n\tpub type Approvals\u003cT: Config\u003e = StorageNMap\u003c\n\t\t_,\n\t\t(\n\t\t\tNMapKey\u003cBlake2_128Concat, CurrencyOf\u003cT\u003e\u003e,\n\t\t\tNMapKey\u003cBlake2_128Concat, T::AccountId\u003e, // owner\n\t\t\tNMapKey\u003cBlake2_128Concat, T::AccountId\u003e, // delegate\n\t\t),\n\t\tBalanceOf\u003cT\u003e,\n\t\u003e;\n\n\t/// Currencies that can be used in chain extension\n\t#[pallet::storage]\n\tpub(super) type AllowedCurrencies\u003cT: Config\u003e =\n\t\tStorageMap\u003c_, Blake2_128Concat, CurrencyOf\u003cT\u003e, ()\u003e;\n\n\t#[pallet::hooks]\n\timpl\u003cT: Config\u003e Hooks\u003cT::BlockNumber\u003e for Pallet\u003cT\u003e {}\n\n\t#[pallet::genesis_config]\n\tpub struct GenesisConfig\u003cT: Config\u003e {\n\t\tpub allowed_currencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t}\n\n\t#[cfg(feature = \"std\")]\n\timpl\u003cT: Config\u003e Default for GenesisConfig\u003cT\u003e {\n\t\tfn default() -\u003e Self {\n\t\t\tSelf { allowed_currencies: vec![] }\n\t\t}\n\t}\n\n\t#[pallet::genesis_build]\n\timpl\u003cT: Config\u003e GenesisBuild\u003cT\u003e for GenesisConfig\u003cT\u003e {\n\t\tfn build(\u0026self) {\n\t\t\tfor i in \u0026self.allowed_currencies.clone() {\n\t\t\t\tAllowedCurrencies::\u003cT\u003e::insert(i, ());\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::pallet]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet\u003cT\u003e(_);\n\n\t// The pallet's dispatchable functions.\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Added allowed currencies that possible to use chain extension\n\t\t///\n\t\t/// # Arguments\n\t\t/// * `currencies` - list of currency id allowed to use in chain extension\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::add_allowed_currencies(T::MaxAllowedCurrencies::get()))]\n\t\t#[transactional]\n\t\tpub fn add_allowed_currencies(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcurrencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\n\t\t\t// Check if the supplied amount of currencies is less than the maximum allowed\n\t\t\tlet max_allowed_currencies: usize = T::MaxAllowedCurrencies::get() as usize;\n\t\t\tensure!(\n\t\t\t\tcurrencies.len() \u003c= max_allowed_currencies,\n\t\t\t\tError::\u003cT\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t\t);\n\n\t\t\tfor i in currencies.clone() {\n\t\t\t\tAllowedCurrencies::\u003cT\u003e::insert(i, ());\n\t\t\t}\n\n\t\t\t// Check if the resulting vector of allowed currencies is less than the maximum allowed.\n\t\t\t// We check after the insertion to avoid counting duplicates.\n\t\t\tlet allowed_currencies_len: usize = AllowedCurrencies::\u003cT\u003e::iter().count();\n\t\t\tensure!(\n\t\t\t\tallowed_currencies_len \u003c= max_allowed_currencies,\n\t\t\t\tError::\u003cT\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t\t);\n\n\t\t\tSelf::deposit_event(Event::AllowedCurrenciesAdded { currencies });\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Remove allowed currencies that possible to use chain extension\n\t\t///\n\t\t/// # Arguments\n\t\t/// * `currencies` - list of currency id allowed to use in chain extension\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::remove_allowed_currencies(T::MaxAllowedCurrencies::get()))]\n\t\t#[transactional]\n\t\tpub fn remove_allowed_currencies(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcurrencies: Vec\u003cCurrencyOf\u003cT\u003e\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\n\t\t\t// Check if the supplied amount of currencies is less than the maximum allowed\n\t\t\t// Although this is not strictly necessary, it is a good sanity check and prevents callers\n\t\t\t// from using too large currency vectors.\n\t\t\tlet max_allowed_currencies: usize = T::MaxAllowedCurrencies::get() as usize;\n\t\t\tensure!(\n\t\t\t\tcurrencies.len() \u003c= max_allowed_currencies,\n\t\t\t\tError::\u003cT\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t\t);\n\n\t\t\tfor i in currencies.clone() {\n\t\t\t\tAllowedCurrencies::\u003cT\u003e::remove(i);\n\t\t\t}\n\n\t\t\tSelf::deposit_event(Event::AllowedCurrenciesDeleted { currencies });\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Approve an amount for another account to spend on owner's behalf.\n\t\t///\n\t\t/// # Arguments\n\t\t/// * `id` - the currency_id of the asset to approve\n\t\t/// * `delegate` - the spender account to approve the asset for\n\t\t/// * `amount` - the amount of the asset to approve\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::approve())]\n\t\t#[transactional]\n\t\tpub fn approve(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tid: CurrencyOf\u003cT\u003e,\n\t\t\tdelegate: T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet owner = ensure_signed(origin)?;\n\t\t\tSelf::do_approve_transfer(id, \u0026owner, \u0026delegate, amount)\n\t\t}\n\n\t\t/// Execute a pre-approved transfer from another account\n\t\t///\n\t\t/// # Arguments\n\t\t/// * `id` - the currency_id of the asset to transfer\n\t\t/// * `owner` - the owner account of the asset to transfer\n\t\t/// * `destination` - the destination account to transfer to\n\t\t/// * `amount` - the amount of the asset to transfer\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::transfer_from())]\n\t\t#[transactional]\n\t\tpub fn transfer_from(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tid: CurrencyOf\u003cT\u003e,\n\t\t\towner: T::AccountId,\n\t\t\tdestination: T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet delegate = ensure_signed(origin)?;\n\t\t\tSelf::do_transfer_approved(id, \u0026owner, \u0026delegate, \u0026destination, amount)\n\t\t}\n\t}\n}\n\n#[allow(clippy::forget_non_drop, clippy::swap_ptr_to_ref, clippy::forget_ref, clippy::forget_copy)]\n#[cfg_attr(test, mockable)]\nimpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t// Check the amount approved to be spent by an owner to a delegate\n\tpub fn is_allowed_currency(asset: CurrencyOf\u003cT\u003e) -\u003e bool {\n\t\treturn AllowedCurrencies::\u003cT\u003e::get(asset) == Some(())\n\t}\n\n\t// Check the amount approved to be spent by an owner to a delegate\n\tpub fn allowance(\n\t\tasset: CurrencyOf\u003cT\u003e,\n\t\towner: \u0026T::AccountId,\n\t\tdelegate: \u0026T::AccountId,\n\t) -\u003e BalanceOf\u003cT\u003e {\n\t\tApprovals::\u003cT\u003e::get((asset, \u0026owner, \u0026delegate)).unwrap_or_else(Zero::zero)\n\t}\n\n\t/// Creates an approval from `owner` to spend `amount` of asset `id` tokens by 'delegate'\n\t/// while reserving `T::ApprovalDeposit` from owner\n\t///\n\t/// If an approval already exists, the new amount is added to such existing approval\n\tpub fn do_approve_transfer(\n\t\tid: CurrencyOf\u003cT\u003e,\n\t\towner: \u0026T::AccountId,\n\t\tdelegate: \u0026T::AccountId,\n\t\tamount: BalanceOf\u003cT\u003e,\n\t) -\u003e DispatchResult {\n\t\tensure!(Self::is_allowed_currency(id), Error::\u003cT\u003e::CurrencyNotLive);\n\t\tApprovals::\u003cT\u003e::set((id, \u0026owner, \u0026delegate), Some(amount));\n\t\tSelf::deposit_event(Event::TransferApproved {\n\t\t\tcurrency_id: id,\n\t\t\tsource: owner.clone(),\n\t\t\tdelegate: delegate.clone(),\n\t\t\tamount,\n\t\t});\n\n\t\tOk(())\n\t}\n\n\t/// Reduces the asset `id` balance of `owner` by some `amount` and increases the balance of\n\t/// `dest` by (similar) amount, checking that 'delegate' has an existing approval from `owner`\n\t/// to spend`amount`.\n\t///\n\t/// Will fail if `amount` is greater than the approval from `owner` to 'delegate'\n\t/// Will unreserve the deposit from `owner` if the entire approved `amount` is spent by\n\t/// 'delegate'\n\tpub fn do_transfer_approved(\n\t\tid: CurrencyOf\u003cT\u003e,\n\t\towner: \u0026T::AccountId,\n\t\tdelegate: \u0026T::AccountId,\n\t\tdestination: \u0026T::AccountId,\n\t\tamount: BalanceOf\u003cT\u003e,\n\t) -\u003e DispatchResult {\n\t\tensure!(Self::is_allowed_currency(id), Error::\u003cT\u003e::CurrencyNotLive);\n\t\tApprovals::\u003cT\u003e::try_mutate_exists(\n\t\t\t(id, \u0026owner, delegate),\n\t\t\t|maybe_approved| -\u003e DispatchResult {\n\t\t\t\tlet approved = maybe_approved.take().ok_or(Error::\u003cT\u003e::Unapproved)?;\n\t\t\t\tlet remaining = approved.checked_sub(\u0026amount).ok_or(Error::\u003cT\u003e::Unapproved)?;\n\n\t\t\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::transfer(\n\t\t\t\t\tid,\n\t\t\t\t\t\u0026owner,\n\t\t\t\t\t\u0026destination,\n\t\t\t\t\tamount,\n\t\t\t\t)?;\n\n\t\t\t\t// Don't decrement allowance if it is set to the max value (which acts as infinite allowance)\n\t\t\t\tif approved == BalanceOf::\u003cT\u003e::max_value() {\n\t\t\t\t\t*maybe_approved = Some(approved);\n\t\t\t\t} else if remaining.is_zero() {\n\t\t\t\t\t*maybe_approved = None;\n\t\t\t\t} else {\n\t\t\t\t\t*maybe_approved = Some(remaining);\n\t\t\t\t}\n\t\t\t\tOk(())\n\t\t\t},\n\t\t)?;\n\t\tOk(())\n\t}\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2079},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1560},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":775},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":511},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":255},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":49,"coverable":67},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","mock.rs"],"content":"use crate::{self as token_allowance, Config};\nuse frame_support::{\n\tparameter_types,\n\ttraits::{ConstU32, Everything},\n};\nuse orml_currencies::BasicCurrencyAdapter;\nuse orml_traits::parameter_type_with_key;\nuse sp_core::H256;\nuse sp_runtime::{\n\ttesting::Header,\n\ttraits::{BlakeTwo256, IdentityLookup},\n};\ntype UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic\u003cTest\u003e;\ntype Block = frame_system::mocking::MockBlock\u003cTest\u003e;\n\n// Configure a mock runtime to test the pallet.\nframe_support::construct_runtime!(\n\tpub enum Test where\n\t\tBlock = Block,\n\t\tNodeBlock = Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Storage, Config, Event\u003cT\u003e},\n\t\tTokens: orml_tokens::{Pallet, Storage, Config\u003cT\u003e, Event\u003cT\u003e},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Event\u003cT\u003e},\n\t\tCurrencies: orml_currencies::{Pallet, Call},\n\t\tTokenAllowance: token_allowance::{Pallet, Storage, Call, Event\u003cT\u003e},\n\t}\n);\n\npub type AccountId = u64;\npub type Balance = u128;\npub type BlockNumber = u64;\npub type Index = u64;\npub type Amount = i64;\npub type CurrencyId = u64;\n\nparameter_types! {\n\tpub const BlockHashCount: u64 = 250;\n\tpub const SS58Prefix: u8 = 42;\n}\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = Everything;\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype DbWeight = ();\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Index = Index;\n\ttype BlockNumber = BlockNumber;\n\ttype Hash = H256;\n\ttype Hashing = BlakeTwo256;\n\ttype AccountId = AccountId;\n\ttype Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n\ttype Header = Header;\n\ttype RuntimeEvent = TestEvent;\n\ttype BlockHashCount = BlockHashCount;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype SS58Prefix = SS58Prefix;\n\ttype OnSetCode = ();\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\npub type TestEvent = RuntimeEvent;\n\nparameter_types! {\n\tpub const GetCollateralCurrencyId: CurrencyId = 1;\n\tpub const MaxLocks: u32 = 50;\n\tpub const GetNativeCurrencyId: CurrencyId = 1;\n}\n\nparameter_type_with_key! {\n\tpub ExistentialDeposits: |_currency_id: CurrencyId| -\u003e Balance {\n\t\t0\n\t};\n}\n\npub struct CurrencyHooks\u003cT\u003e(sp_std::marker::PhantomData\u003cT\u003e);\nimpl\u003cT: orml_tokens::Config\u003e\n\torml_traits::currency::MutationHooks\u003cT::AccountId, T::CurrencyId, T::Balance\u003e for CurrencyHooks\u003cT\u003e\n{\n\ttype OnDust = orml_tokens::BurnDust\u003cT\u003e;\n\ttype OnSlash = ();\n\ttype PreDeposit = ();\n\ttype PostDeposit = ();\n\ttype PreTransfer = ();\n\ttype PostTransfer = ();\n\ttype OnNewTokenAccount = ();\n\ttype OnKilledTokenAccount = ();\n}\n\nimpl orml_tokens::Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype Amount = Amount;\n\ttype CurrencyId = CurrencyId;\n\ttype WeightInfo = ();\n\ttype ExistentialDeposits = ExistentialDeposits;\n\ttype CurrencyHooks = CurrencyHooks\u003cSelf\u003e;\n\ttype MaxLocks = MaxLocks;\n\ttype MaxReserves = ConstU32\u003c0\u003e;\n\ttype ReserveIdentifier = ();\n\ttype DustRemovalWhitelist = Everything;\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = 1000;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Test {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cTest\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = ();\n}\n\nimpl orml_currencies::Config for Test {\n\ttype MultiCurrency = Tokens;\n\ttype NativeCurrency = BasicCurrencyAdapter\u003cTest, Balances, Amount, BlockNumber\u003e;\n\ttype GetNativeCurrencyId = GetNativeCurrencyId;\n\ttype WeightInfo = ();\n}\n\nimpl Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = token_allowance::default_weights::SubstrateWeight\u003cTest\u003e;\n\ttype MaxAllowedCurrencies = ConstU32\u003c256\u003e;\n}\n\npub struct ExtBuilder;\n\nimpl ExtBuilder {\n\tpub fn build() -\u003e sp_io::TestExternalities {\n\t\tlet storage = frame_system::GenesisConfig::default().build_storage::\u003cTest\u003e().unwrap();\n\n\t\tsp_io::TestExternalities::from(storage)\n\t}\n}\n\npub fn run_test\u003cT\u003e(test: T)\nwhere\n\tT: FnOnce(),\n{\n\tExtBuilder::build().execute_with(|| {\n\t\tSystem::set_block_number(1);\n\t\ttest();\n\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","orml-currencies-allowance-extension","src","tests.rs"],"content":"use frame_support::{assert_err, assert_ok, error::BadOrigin, traits::Get};\nuse orml_traits::MultiCurrency;\n\nuse crate::{mock::*, AllowedCurrencies, Config, CurrencyOf, Error};\n\n#[test]\nfn should_add_allowed_currencies() {\n\trun_test(|| {\n\t\tlet max_allowed_currencies: u32 = \u003cTest as Config\u003e::MaxAllowedCurrencies::get();\n\t\tlet max_allowed_currencies: u64 = max_allowed_currencies as u64;\n\t\tlet added_currencies = (0..max_allowed_currencies).collect::\u003cVec\u003cu64\u003e\u003e();\n\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(RuntimeOrigin::root(), added_currencies));\n\t\tfor i in 0..max_allowed_currencies {\n\t\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(i), Some(()));\n\t\t}\n\t})\n}\n\n#[test]\nfn should_remove_allowed_currencies() {\n\trun_test(|| {\n\t\tlet max_allowed_currencies: u32 = \u003cTest as Config\u003e::MaxAllowedCurrencies::get();\n\t\tlet max_allowed_currencies: u64 = max_allowed_currencies as u64;\n\t\tlet mut added_currencies = (0..max_allowed_currencies).collect::\u003cVec\u003cu64\u003e\u003e();\n\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tadded_currencies.clone()\n\t\t));\n\t\tfor i in 0..max_allowed_currencies {\n\t\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(i), Some(()));\n\t\t}\n\n\t\tlet existing_currency: CurrencyOf\u003cTest\u003e =\n\t\t\tadded_currencies.pop().expect(\"Should have a currency\");\n\t\tassert_ok!(TokenAllowance::remove_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tadded_currencies.clone()\n\t\t));\n\n\t\tfor i in 0..added_currencies.len() as u64 {\n\t\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(i), None);\n\t\t}\n\t\t// The existing currency should remain\n\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(existing_currency), Some(()));\n\t})\n}\n\n#[test]\nfn should_not_exceed_allowed_currencies() {\n\trun_test(|| {\n\t\tlet max_allowed_currencies: u32 = \u003cTest as Config\u003e::MaxAllowedCurrencies::get();\n\t\tlet max_allowed_currencies: u64 = max_allowed_currencies as u64;\n\t\tlet too_many_currencies = (0..max_allowed_currencies + 1).collect::\u003cVec\u003cu64\u003e\u003e();\n\n\t\t// We can't add more than the maximum allowed currencies\n\t\tassert_err!(\n\t\t\tTokenAllowance::add_allowed_currencies(\n\t\t\t\tRuntimeOrigin::root(),\n\t\t\t\ttoo_many_currencies.clone()\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t);\n\n\t\tassert_err!(\n\t\t\tTokenAllowance::remove_allowed_currencies(RuntimeOrigin::root(), too_many_currencies),\n\t\t\tError::\u003cTest\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t);\n\n\t\t// Fill the allowed currencies to the maximum\n\t\tlet added_currencies = (0..max_allowed_currencies).collect::\u003cVec\u003cu64\u003e\u003e();\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tadded_currencies.clone()\n\t\t));\n\t\tfor i in 0..max_allowed_currencies {\n\t\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(i), Some(()));\n\t\t}\n\n\t\t// Try to add a duplicate currency (should not fail because we don't store duplicates)\n\t\tlet already_added_currency = added_currencies[0];\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![already_added_currency]\n\t\t));\n\t\tassert_eq!(AllowedCurrencies::\u003cTest\u003e::get(already_added_currency), Some(()));\n\n\t\t// Try to add a new distinct currency (should fail since we reached the maximum)\n\t\tlet illegal_currency: CurrencyOf\u003cTest\u003e = max_allowed_currencies;\n\t\tassert_err!(\n\t\t\tTokenAllowance::add_allowed_currencies(RuntimeOrigin::root(), vec![illegal_currency]),\n\t\t\tError::\u003cTest\u003e::ExceedsNumberOfAllowedCurrencies\n\t\t);\n\t})\n}\n\n#[test]\nfn should_not_add_allowed_currencies_with_non_root_origin() {\n\trun_test(|| {\n\t\tlet native_currency_id = \u003cTest as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tlet added_currencies: Vec\u003cCurrencyOf\u003cTest\u003e\u003e = vec![native_currency_id];\n\t\tassert_err!(\n\t\t\tTokenAllowance::add_allowed_currencies(\n\t\t\t\tRuntimeOrigin::signed(1),\n\t\t\t\tadded_currencies.clone()\n\t\t\t),\n\t\t\tBadOrigin\n\t\t);\n\t\tassert_err!(\n\t\t\tTokenAllowance::add_allowed_currencies(RuntimeOrigin::none(), added_currencies),\n\t\t\tBadOrigin\n\t\t);\n\t})\n}\n\n#[test]\nfn should_not_remove_allowed_currencies_with_non_root_origin() {\n\trun_test(|| {\n\t\tlet native_currency_id = \u003cTest as orml_currencies::Config\u003e::GetNativeCurrencyId::get();\n\t\tlet added_currencies: Vec\u003cCurrencyOf\u003cTest\u003e\u003e = vec![native_currency_id];\n\t\tassert_err!(\n\t\t\tTokenAllowance::remove_allowed_currencies(\n\t\t\t\tRuntimeOrigin::signed(1),\n\t\t\t\tadded_currencies.clone()\n\t\t\t),\n\t\t\tBadOrigin\n\t\t);\n\t\tassert_err!(\n\t\t\tTokenAllowance::remove_allowed_currencies(RuntimeOrigin::none(), added_currencies),\n\t\t\tBadOrigin\n\t\t);\n\t})\n}\n\n#[test]\nfn should_return_allowance() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Check allowance\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), 0);\n\n\t\t// Approve the amount\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Check allowance again\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), amount);\n\t})\n}\n\n#[test]\nfn should_approve_transfer() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\t// Will not work yet\n\t\tassert_err!(\n\t\t\tTokenAllowance::approve(\n\t\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\t\tcurrency_id,\n\t\t\t\tdelegate.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::CurrencyNotLive\n\t\t);\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Should work now\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Check allowance\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), amount);\n\t})\n}\n\n#[test]\nfn should_transfer_from_for_approved_transfer() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\t// Mint some tokens\n\t\tassert_ok!(Tokens::deposit(currency_id, \u0026owner, amount));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), 0);\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Approve the amount\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Transfer all of the approved amount\n\t\tassert_ok!(TokenAllowance::transfer_from(\n\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\tcurrency_id,\n\t\t\towner.clone(),\n\t\t\tdestination.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), amount);\n\t\t// Check that the allowance is now empty since we transferred the whole amount\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), 0);\n\n\t\t// Test again but this time only using a partial amount of what was approved\n\t\tlet partial_amount = amount / 2;\n\t\tassert_ok!(Tokens::deposit(currency_id, \u0026owner, amount));\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\t\tassert_ok!(TokenAllowance::transfer_from(\n\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\tcurrency_id,\n\t\t\towner.clone(),\n\t\t\tdestination.clone(),\n\t\t\tpartial_amount\n\t\t));\n\n\t\t// Check the balances again\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), amount - partial_amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), amount + partial_amount);\n\t\t// Check that the allowance is now reduced by the partial amount\n\t\tassert_eq!(\n\t\t\tTokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate),\n\t\t\tamount - partial_amount\n\t\t);\n\t})\n}\n\n#[test]\nfn should_not_transfer_from_without_approved_transfer() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\t// Mint some tokens\n\t\tassert_ok!(Tokens::deposit(currency_id, \u0026owner, amount));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), 0);\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Try to `transfer_from` without having approved the transfer\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::Unapproved\n\t\t);\n\n\t\t// Approve the amount\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tamount\n\t\t));\n\n\t\t// Try to `transfer_from` for amount larger than what was approved\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount + 1\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::Unapproved\n\t\t);\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), 0);\n\t})\n}\n\n#[test]\nfn should_transfer_from_while_keeping_infinite_allowance() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\t// We use the max value of u128 as the amount to approve because it represents an infinite allowance\n\t\tlet allowance_amount: \u003cTest as orml_tokens::Config\u003e::Balance =\n\t\t\t\u003cTest as orml_tokens::Config\u003e::Balance::max_value();\n\n\t\t// Mint some tokens\n\t\tassert_ok!(Tokens::deposit(currency_id, \u0026owner, allowance_amount));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), allowance_amount);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), 0);\n\n\t\t// We need to add the currency first\n\t\tassert_ok!(TokenAllowance::add_allowed_currencies(\n\t\t\tRuntimeOrigin::root(),\n\t\t\tvec![currency_id]\n\t\t));\n\n\t\t// Approve infinite spending\n\t\tassert_ok!(TokenAllowance::approve(\n\t\t\tRuntimeOrigin::signed(owner.clone()),\n\t\t\tcurrency_id,\n\t\t\tdelegate.clone(),\n\t\t\tallowance_amount,\n\t\t));\n\n\t\t// Check the allowance of the delegate\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), allowance_amount);\n\n\t\t// Transfer the approved amount once\n\t\tassert_ok!(TokenAllowance::transfer_from(\n\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\tcurrency_id,\n\t\t\towner.clone(),\n\t\t\tdestination.clone(),\n\t\t\tallowance_amount\n\t\t));\n\n\t\t// Check the balances\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), allowance_amount);\n\n\t\t// Check that the allowance of the delegate is still the same since it should be infinite\n\t\tassert_eq!(TokenAllowance::allowance(currency_id, \u0026owner, \u0026delegate), allowance_amount);\n\n\t\t// Move the tokens from `destination` to the `owner` again to avoid overflow but allow for testing the same amount again\n\t\tassert_ok!(Tokens::transfer(\n\t\t\tRuntimeOrigin::signed(destination.clone()),\n\t\t\towner,\n\t\t\tcurrency_id,\n\t\t\tallowance_amount\n\t\t));\n\n\t\t// Transfer the approved amount again\n\t\tassert_ok!(TokenAllowance::transfer_from(\n\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\tcurrency_id,\n\t\t\towner.clone(),\n\t\t\tdestination.clone(),\n\t\t\tallowance_amount\n\t\t));\n\n\t\t// Check the balances again\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026owner), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026delegate), 0);\n\t\tassert_eq!(Tokens::free_balance(currency_id, \u0026destination), allowance_amount);\n\t})\n}\n\n#[test]\nfn should_not_transfer_from_for_invalid_origin() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::none(),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tBadOrigin\n\t\t);\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::root(),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tBadOrigin\n\t\t);\n\t})\n}\n\n#[test]\nfn should_not_transfer_from_for_invalid_currency() {\n\trun_test(|| {\n\t\tlet currency_id: \u003cTest as orml_tokens::Config\u003e::CurrencyId = 0;\n\t\tlet owner: \u003cTest as frame_system::Config\u003e::AccountId = 0;\n\t\tlet delegate: \u003cTest as frame_system::Config\u003e::AccountId = 1;\n\t\tlet destination: \u003cTest as frame_system::Config\u003e::AccountId = 2;\n\t\tlet amount: \u003cTest as orml_tokens::Config\u003e::Balance = 1_000_000_000u32 as Balance;\n\n\t\tassert_err!(\n\t\t\tTokenAllowance::transfer_from(\n\t\t\t\tRuntimeOrigin::signed(delegate.clone()),\n\t\t\t\tcurrency_id,\n\t\t\t\towner.clone(),\n\t\t\t\tdestination.clone(),\n\t\t\t\tamount\n\t\t\t),\n\t\t\tError::\u003cTest\u003e::CurrencyNotLive\n\t\t);\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","benchmarking.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n#![cfg(feature = \"runtime-benchmarks\")]\n\n//! Benchmarking\nuse crate::{types::RoundInfo, *};\nuse frame_benchmarking::{account, benchmarks, impl_benchmark_test_suite, Zero};\nuse frame_support::{\n\tassert_ok,\n\ttraits::{Currency, Get, OnInitialize},\n};\nuse frame_system::{Pallet as System, RawOrigin};\nuse pallet_session::Pallet as Session;\nuse sp_runtime::{\n\ttraits::{One, SaturatedConversion, StaticLookup},\n\tPerquintill,\n};\nuse sp_std::{convert::TryInto, vec::Vec};\n\nconst COLLATOR_ACCOUNT_SEED: u32 = 0;\nconst DELEGATOR_ACCOUNT_SEED: u32 = 1;\n\n/// Fills the candidate pool up to `num_candidates`.\nfn setup_collator_candidates\u003cT: Config\u003e(\n\tnum_candidates: u32,\n\tdefault_amount: Option\u003cT::CurrencyBalance\u003e,\n) -\u003e Vec\u003cT::AccountId\u003e {\n\tlet current_collator_count = TopCandidates::\u003cT\u003e::get().len().saturated_into::\u003cu32\u003e();\n\tlet collators: Vec\u003cT::AccountId\u003e = (current_collator_count..num_candidates)\n\t\t.map(|i| account(\"collator\", i.saturated_into::\u003cu32\u003e(), COLLATOR_ACCOUNT_SEED))\n\t\t.collect();\n\tlet amount: T::CurrencyBalance =\n\t\tdefault_amount.unwrap_or_else(T::MinCollatorCandidateStake::get);\n\n\tfor acc in collators.iter() {\n\t\tT::Currency::make_free_balance_be(acc, amount);\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_candidates(\n\t\t\tT::RuntimeOrigin::from(Some(acc.clone()).into()),\n\t\t\tamount,\n\t\t));\n\t\tassert_eq!(\u003cCandidatePool\u003cT\u003e\u003e::get(acc).unwrap().stake, amount);\n\t}\n\n\tTopCandidates::\u003cT\u003e::get()\n\t\t.into_bounded_vec()\n\t\t.into_inner()\n\t\t.drain(..)\n\t\t.map(|c| c.owner)\n\t\t.collect()\n}\n\nfn fill_delegators\u003cT: Config\u003e(\n\tnum_delegators: u32,\n\tcollator: T::AccountId,\n\tcollator_seed: u32,\n) -\u003e Vec\u003cT::AccountId\u003e {\n\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\tlet current_delegators = state.delegators.len().saturated_into::\u003cu32\u003e();\n\n\tlet delegators: Vec\u003cT::AccountId\u003e = (current_delegators..num_delegators)\n\t\t.map(|i| {\n\t\t\taccount(\n\t\t\t\t\"delegator\",\n\t\t\t\ti.saturated_into::\u003cu32\u003e(),\n\t\t\t\tDELEGATOR_ACCOUNT_SEED * 1000 + collator_seed,\n\t\t\t)\n\t\t})\n\t\t.collect();\n\n\tfor acc in delegators.iter() {\n\t\tT::Currency::make_free_balance_be(acc, T::MinDelegatorStake::get());\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_delegators(\n\t\t\tT::RuntimeOrigin::from(Some(acc.clone()).into()),\n\t\t\tT::Lookup::unlookup(collator.clone()),\n\t\t\tT::MinDelegatorStake::get(),\n\t\t));\n\t}\n\n\tdelegators\n}\n\n// fills unstake BTreeMap by unstaked many entries of 1\nfn fill_unstaking\u003cT: Config\u003e(\n\tcollator: \u0026T::AccountId,\n\tdelegator: Option\u003c\u0026T::AccountId\u003e,\n\tunstaked: u64,\n) where\n\tu64: Into\u003c\u003cT as frame_system::Config\u003e::BlockNumber\u003e,\n{\n\tlet who = delegator.unwrap_or(collator);\n\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(who).len(), 0);\n\twhile System::\u003cT\u003e::block_number() \u003c unstaked.into() {\n\t\tif let Some(delegator) = delegator {\n\t\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_less(\n\t\t\t\tRawOrigin::Signed(delegator.clone()).into(),\n\t\t\t\tT::Lookup::unlookup(collator.clone()),\n\t\t\t\tT::CurrencyBalance::one()\n\t\t\t));\n\t\t} else {\n\t\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::candidate_stake_less(\n\t\t\t\tRawOrigin::Signed(collator.clone()).into(),\n\t\t\t\tT::CurrencyBalance::one()\n\t\t\t));\n\t\t}\n\t\tSystem::\u003cT\u003e::set_block_number(System::\u003cT\u003e::block_number() + T::BlockNumber::one());\n\t}\n\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(who).len() as u64, unstaked);\n\tassert!(\u003cUnstaking\u003cT\u003e\u003e::get(who).len() \u003c= T::MaxUnstakeRequests::get().try_into().unwrap());\n}\n\nbenchmarks! {\n\twhere_clause { where u64: Into\u003c\u003cT as frame_system::Config\u003e::BlockNumber\u003e }\n\n\ton_initialize_no_action {\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get().current, 0u32);\n\t\tlet block = T::BlockNumber::one();\n\t}: { Pallet::\u003cT\u003e::on_initialize(block) }\n\tverify {\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get().current, 0u32);\n\t}\n\n\ton_initialize_round_update {\n\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\t\tassert_eq!(round.current, 0u32);\n\t}: { Pallet::\u003cT\u003e::on_initialize(round.length) }\n\tverify {\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get().current, 1u32);\n\t}\n\n\ton_initialize_network_rewards {\n\t\tlet issuance = T::Currency::total_issuance();\n\t\t// if we only add by one, we also initialize a new year\n\t\tlet block = T::NetworkRewardStart::get() + T::BlockNumber::one() * 2_u64.into();\n\t}: { Pallet::\u003cT\u003e::on_initialize(block) }\n\tverify {\n\t\tlet new_issuance = T::Currency::total_issuance();\n\t\tlet max_col_reward = InflationConfig::\u003cT\u003e::get().collator.reward_rate.per_block * MaxCollatorCandidateStake::\u003cT\u003e::get() * MaxSelectedCandidates::\u003cT\u003e::get().into();\n\t\tlet network_block_reward = T::NetworkRewardRate::get() * max_col_reward;\n\t\tassert!(new_issuance \u003e issuance);\n\t\tassert_eq!(new_issuance - issuance, network_block_reward)\n\t}\n\n\tforce_new_round {\n\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\t\tlet now = System::\u003cT\u003e::block_number();\n\t\tassert_eq!(round.current, 0);\n\t\tassert_eq!(Session::\u003cT\u003e::current_index(), 0);\n\t\tassert!(!\u003cForceNewRound\u003cT\u003e\u003e::get());\n\t}: _(RawOrigin::Root)\n\tverify {\n\t\tassert!(\u003cForceNewRound\u003cT\u003e\u003e::get());\n\t\tassert_eq!(Session::\u003cT\u003e::current_index(), 0);\n\n\t\t// jump to next block to trigger new round\n\t\tlet now = now + T::BlockNumber::one();\n\t\tSystem::\u003cT\u003e::set_block_number(now);\n\t\tSession::\u003cT\u003e::on_initialize(now);\n\t\tassert_eq!(Session::\u003cT\u003e::current_index(), 1);\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get(), RoundInfo {\n\t\t\tcurrent: 1,\n\t\t\tfirst: now,\n\t\t\tlength: round.length,\n\t\t});\n\t\tassert!(!\u003cForceNewRound\u003cT\u003e\u003e::get());\n\t}\n\n\tset_inflation {\n\t\tlet n in 0 .. T::MaxTopCandidates::get();\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t\tRewards::\u003cT\u003e::insert(\u0026c, T::CurrencyBalance::one());\n\t\t}\n\n\t\tlet inflation = InflationInfo::new(\n\t\t\tT::BLOCKS_PER_YEAR.saturated_into(),\n\t\t\tPerquintill::from_percent(10),\n\t\t\tPerquintill::from_percent(15),\n\t\t\tPerquintill::from_percent(40),\n\t\t\tPerquintill::from_percent(10)\n\t\t);\n\t}: _(RawOrigin::Root, inflation.collator.max_rate, inflation.collator.reward_rate.annual, inflation.delegator.max_rate, inflation.delegator.reward_rate.annual)\n\tverify {\n\t\tassert_eq!(InflationConfig::\u003cT\u003e::get(), inflation);\n\t\tcandidates.into_iter().for_each(|candidate| {\n\t\t\tassert!(!Rewards::\u003cT\u003e::get(\u0026candidate).is_zero());\n\t\t});\n\t}\n\n\tset_max_selected_candidates {\n\t\tlet n in (T::MinCollators::get()) .. T::MaxTopCandidates::get();\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet old_candidate = candidates[0].clone();\n\t}: _(RawOrigin::Root, n)\n\tverify {\n\t\tassert_eq!(\u003cMaxSelectedCandidates\u003cT\u003e\u003e::get(), n);\n\t}\n\n\tset_blocks_per_round {\n\t\tlet bpr: T::BlockNumber = T::MinBlocksPerRound::get() + T::BlockNumber::one();\n\t}: _(RawOrigin::Root, bpr)\n\tverify {\n\t\tassert_eq!(\u003cRound\u003cT\u003e\u003e::get().length, bpr);\n\t}\n\n\tforce_remove_candidate {\n\t\tlet n in (T::MinCollators::get() + 1) .. T::MaxTopCandidates::get();\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet candidate = candidates[0].clone();\n\t\tlet unlookup_candidate = T::Lookup::unlookup(candidate.clone());\n\t}: _(RawOrigin::Root, unlookup_candidate)\n\tverify {\n\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\t\tassert!(!candidates.into_iter().any(|other| other.owner == candidate));\n\t}\n\n\tjoin_candidates {\n\t\tlet n in 1 .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet min_candidate_stake = T::MinCollatorCandidateStake::get();\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\n\t\tlet new_candidate = account(\"new_collator\", u32::MAX , COLLATOR_ACCOUNT_SEED);\n\t\tT::Currency::make_free_balance_be(\u0026new_candidate, min_candidate_stake);\n\n\t\tlet origin = RawOrigin::Signed(new_candidate.clone());\n\t}: _(origin, min_candidate_stake)\n\tverify {\n\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\t\tassert!(candidates.into_iter().any(|other| other.owner == new_candidate));\n\t}\n\n\tinit_leave_candidates {\n\t\tlet n in (T::MinCollators::get() + 1) .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\n\t\tlet now = \u003cRound\u003cT\u003e\u003e::get().current;\n\t\tlet candidate = candidates[0].clone();\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin)\n\tverify {\n\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\t\tassert!(!candidates.into_iter().any(|other| other.owner == candidate));\n\t\tlet unlocking_at = now.saturating_add(T::ExitQueueDelay::get());\n\t\tassert!(\u003cCandidatePool\u003cT\u003e\u003e::get(candidate).unwrap().can_exit(unlocking_at));\n\t}\n\n\tcancel_leave_candidates {\n\t\tlet n in (T::MinCollators::get() + 1) .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\n\t\tlet candidate = candidates[0].clone();\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::init_leave_candidates(RawOrigin::Signed(candidate.clone()).into()));\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin)\n\tverify {\n\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\t\tassert!(candidates.into_iter().any(|other| other.owner == candidate));\n\t}\n\n\texecute_leave_candidates {\n\t\tlet n in (T::MinCollators::get() + 1) .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet u = T::MaxUnstakeRequests::get() as u32 - 1;\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet candidate = candidates[0].clone();\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tlet more_stake = T::MinCollatorCandidateStake::get();\n\t\tT::Currency::make_free_balance_be(\u0026candidate, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::candidate_stake_more(RawOrigin::Signed(candidate.clone()).into(), more_stake));\n\n\t\t// fill unstake BTreeMap by unstaked many entries of 1\n\t\tfill_unstaking::\u003cT\u003e(\u0026candidate, None, u as u64);\n\n\t\t// go to block in which we can exit\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::init_leave_candidates(RawOrigin::Signed(candidate.clone()).into()));\n\n\t\tfor i in 1..=T::ExitQueueDelay::get() {\n\t\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\t\t\tlet now = round.first + round.length;\n\t\t\tSystem::\u003cT\u003e::set_block_number(now);\n\t\t\tPallet::\u003cT\u003e::on_initialize(now);\n\t\t}\n\t\tlet unlookup_candidate = T::Lookup::unlookup(candidate.clone());\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin, unlookup_candidate)\n\tverify {\n\t\t// should have one more entry in Unstaking\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026candidate).len().saturated_into::\u003cu32\u003e(), u.saturating_add(1u32));\n\t}\n\n\tcandidate_stake_more {\n\t\tlet n in 1 .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\t\tlet u in 0 .. (T::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e() - 1);\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet candidate = candidates[0].clone();\n\n\t\tlet old_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tlet more_stake = T::MinCollatorCandidateStake::get();\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tT::Currency::make_free_balance_be(\u0026candidate, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::candidate_stake_more(RawOrigin::Signed(candidate.clone()).into(), more_stake));\n\n\t\t// fill unstake BTreeMap by unstaked many entries of 1\n\t\tfill_unstaking::\u003cT\u003e(\u0026candidate, None, u as u64);\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin, more_stake)\n\tverify {\n\t\tlet new_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tassert!(\u003cUnstaking\u003cT\u003e\u003e::get(candidate).is_empty());\n\t\tassert_eq!(new_stake, old_stake + more_stake + more_stake - T::CurrencyBalance::from(u as u64));\n\t}\n\n\tcandidate_stake_less {\n\t\tlet n in 1 .. T::MaxTopCandidates::get() - 1;\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet candidate = candidates[0].clone();\n\n\t\t// increase stake of candidate to later decrease it again\n\t\tlet old_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tlet more_stake = T::MinCollatorCandidateStake::get();\n\n\t\tT::Currency::make_free_balance_be(\u0026candidate, T::CurrencyBalance::from(u128::MAX));\n\t\tPallet::\u003cT\u003e::candidate_stake_more(RawOrigin::Signed(candidate.clone()).into(), more_stake).expect(\"should increase stake\");\n\n\t\tlet new_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tassert_eq!(new_stake, old_stake + more_stake);\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin, more_stake)\n\tverify {\n\t\tlet new_stake = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake;\n\t\tassert_eq!(new_stake, old_stake);\n\t}\n\n\tjoin_delegators {\n\t\tlet n in 1 .. T::MaxTopCandidates::get();\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get() - 1;\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\t\tlet delegator = account(\"new-delegator\", 0, DELEGATOR_ACCOUNT_SEED);\n\t\tlet amount = T::MinDelegatorStake::get();\n\t\tT::Currency::make_free_balance_be(\u0026delegator, amount + amount + amount + amount);\n\t\tlet unlookup_collator = T::Lookup::unlookup(collator.clone());\n\n\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin, unlookup_collator, amount)\n\tverify {\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tassert!(state.delegators.into_iter().any(|x| x.owner == delegator));\n\t}\n\n\tdelegator_stake_more {\n\t\t// we need at least 1 collators\n\t\tlet n in 1 .. T::MaxTopCandidates::get();\n\t\t// we need at least 1 delegator\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get() - 1;\n\t\tlet u in 1 .. (T::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e() - 1);\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\t\tlet amount = T::MinDelegatorStake::get();\n\n\t\t// make sure delegator collated to collator\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tlet delegator = state.delegators.into_bounded_vec()[0].owner.clone();\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, amount);\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tT::Currency::make_free_balance_be(\u0026delegator, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_more(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), T::CurrencyBalance::from(u as u64)));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, amount + T::CurrencyBalance::from(u as u64));\n\n\t\t// fill unstake BTreeMap by unstaked many entries of 1\n\t\tfill_unstaking::\u003cT\u003e(\u0026collator, Some(\u0026delegator), u as u64);\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, amount);\n\t\tlet unlookup_collator = T::Lookup::unlookup(collator.clone());\n\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin, unlookup_collator, amount)\n\tverify {\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tassert!(state.delegators.into_iter().any(|x| x.owner == delegator));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, amount + amount);\n\t\tassert!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).is_empty());\n\t}\n\n\tdelegator_stake_less {\n\t\t// we need at least 1 collators\n\t\tlet n in 1 .. T::MaxTopCandidates::get();\n\t\t// we need at least 1 delegator\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get() - 1;\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\t\tlet amount = T::CurrencyBalance::one();\n\n\t\t// make sure delegator collated to collator\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tlet delegator = state.delegators.into_bounded_vec()[0].owner.clone();\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get());\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tT::Currency::make_free_balance_be(\u0026delegator, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_more(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), amount + amount));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get() + amount + amount);\n\n\t\t// decrease stake once so we have an unstaking entry for this block\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_less(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), amount));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get() + amount);\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).len(), 1);\n\t\tlet unlookup_collator = T::Lookup::unlookup(collator.clone());\n\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin, unlookup_collator, amount)\n\tverify {\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tassert!(state.delegators.into_iter().any(|x| x.owner == delegator));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get());\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).len(), 2);\n\t}\n\n\tleave_delegators {\n\t\t// we need at least 1 collators\n\t\tlet n in 1 .. T::MaxTopCandidates::get();\n\t\t// we need at least 1 delegator\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get() - 1;\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\t\tlet amount = T::CurrencyBalance::one();\n\n\t\t// make sure delegator collated to collator\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tlet delegator = state.delegators.into_bounded_vec()[0].owner.clone();\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get());\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tT::Currency::make_free_balance_be(\u0026delegator, T::CurrencyBalance::from(u128::MAX));\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_more(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), amount + amount));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get() + amount + amount);\n\n\t\t// decrease stake once so we have an unstaking entry for this block\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::delegator_stake_less(RawOrigin::Signed(delegator.clone()).into(), T::Lookup::unlookup(collator.clone()), amount));\n\t\tassert_eq!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).unwrap().amount, T::MinDelegatorStake::get() + amount);\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).len(), 1);\n\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin)\n\tverify {\n\t\tlet state = \u003cCandidatePool\u003cT\u003e\u003e::get(\u0026collator).unwrap();\n\t\tassert!(!state.delegators.into_iter().any(|x| x.owner == delegator));\n\t\tassert!(\u003cDelegatorState\u003cT\u003e\u003e::get(\u0026delegator).is_none());\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026delegator).len(), 2);\n\t}\n\n\tunlock_unstaked {\n\t\tlet u in 1 .. (T::MaxUnstakeRequests::get() as u32 - 1);\n\n\t\tlet candidate = account(\"collator\", 0u32, COLLATOR_ACCOUNT_SEED);\n\t\tlet free_balance = T::CurrencyBalance::from(u128::MAX);\n\t\tlet stake = T::MinCollatorCandidateStake::get();\n\t\tT::Currency::make_free_balance_be(\u0026candidate, free_balance);\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_candidates(\n\t\t\tT::RuntimeOrigin::from(Some(candidate.clone()).into()),\n\t\t\tstake,\n\t\t));\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026candidate), (free_balance - T::MinCollatorCandidateStake::get()).into());\n\n\t\t// increase stake so we can unstake, because current stake is minimum\n\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::candidate_stake_more(RawOrigin::Signed(candidate.clone()).into(), stake));\n\n\t\t// fill unstake BTreeMap by unstaked many entries of 1\n\t\tfill_unstaking::\u003cT\u003e(\u0026candidate, None, u as u64);\n\t\tassert_eq!(\u003cCandidatePool\u003cT\u003e\u003e::get(\u0026candidate).unwrap().stake, stake + stake -  T::CurrencyBalance::from(u as u64));\n\n\t\t// roll to block in which first unstake can be unlocked\n\t\tSystem::\u003cT\u003e::set_block_number(T::StakeDuration::get());\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026candidate), (free_balance - stake - stake).into());\n\t\tlet unlookup_candidate = T::Lookup::unlookup(candidate.clone());\n\n\t\tlet origin = RawOrigin::Signed(candidate.clone());\n\t}: _(origin, unlookup_candidate)\n\tverify {\n\t\tassert_eq!(\u003cUnstaking\u003cT\u003e\u003e::get(\u0026candidate).len().saturated_into::\u003cu32\u003e(), u.saturating_sub(1u32));\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026candidate), (free_balance - stake - stake + T::CurrencyBalance::one()).into());\n\t}\n\n\tset_max_candidate_stake {\n\t\tlet old = \u003cMaxCollatorCandidateStake\u003cT\u003e\u003e::get();\n\t\tlet new = \u003cMaxCollatorCandidateStake\u003cT\u003e\u003e::get() + T::CurrencyBalance::from(10u128);\n\t}: _(RawOrigin::Root, new)\n\tverify {\n\t\tassert_eq!(\u003cMaxCollatorCandidateStake\u003cT\u003e\u003e::get(), new);\n\t}\n\n\tincrement_delegator_rewards {\n\t\tlet collator = setup_collator_candidates::\u003cT\u003e(1, None)[0].clone();\n\t\tlet delegator = fill_delegators::\u003cT\u003e(1, collator.clone(), COLLATOR_ACCOUNT_SEED)[0].clone();\n\n\t\t// mock high values to compensate for tiny values in unit test env\n\t\tlet stake = T::CurrencyBalance::from(1_000_000_000_000_000_000u128);\n\t\tDelegatorState::\u003cT\u003e::insert(\u0026delegator, crate::types::Delegator { owner: Some(collator.clone()), amount: stake});\n\t\tRewardCount::\u003cT\u003e::insert(\u0026collator, u32::MAX);\n\n\t\tassert!(Rewards::\u003cT\u003e::get(\u0026delegator).is_zero());\n\t\tlet origin = RawOrigin::Signed(delegator.clone());\n\t}: _(origin)\n\tverify {\n\t\tassert!(!Rewards::\u003cT\u003e::get(\u0026delegator).is_zero());\n\t}\n\n\tincrement_collator_rewards {\n\t\tlet m in 1 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet collator = setup_collator_candidates::\u003cT\u003e(1, None)[0].clone();\n\t\tlet delegators = fill_delegators::\u003cT\u003e(m, collator.clone(), COLLATOR_ACCOUNT_SEED);\n\n\t\t// mock high counter to compensate for tiny amounts in unit test env\n\t\tRewardCount::\u003cT\u003e::insert(\u0026collator, u32::MAX);\n\t\tassert!(Rewards::\u003cT\u003e::get(\u0026collator).is_zero(), \"reward {:?}\", Rewards::\u003cT\u003e::get(\u0026collator));\n\t\tlet origin = RawOrigin::Signed(collator.clone());\n\t}: _(origin)\n\tverify {\n\t\tassert!(!Rewards::\u003cT\u003e::get(\u0026collator).is_zero());\n\t}\n\n\tclaim_rewards {\n\t\tlet beneficiary = account(\"beneficiary\", 0, 0);\n\t\tlet amount = T::MinCollatorCandidateStake::get();\n\t\tT::Currency::make_free_balance_be(\u0026beneficiary, amount);\n\t\tRewards::\u003cT\u003e::insert(\u0026beneficiary, amount);\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026beneficiary), amount.into());\n\t\tlet origin = RawOrigin::Signed(beneficiary.clone());\n\t}: _(origin)\n\tverify {\n\t\tassert!(Rewards::\u003cT\u003e::get(\u0026beneficiary).is_zero());\n\t\tassert_eq!(pallet_balances::Pallet::\u003cT\u003e::usable_balance(\u0026beneficiary), (amount + amount).into());\n\t}\n\n\texecute_scheduled_reward_change {\n\t\t// we need at least 1 collators\n\t\tlet n in 0 .. T::MaxTopCandidates::get();\n\t\t// we need at least 1 delegator\n\t\tlet m in 0 .. T::MaxDelegatorsPerCollator::get();\n\n\t\tlet candidates = setup_collator_candidates::\u003cT\u003e(n, None);\n\t\tfor (i, c) in candidates.iter().enumerate() {\n\t\t\tfill_delegators::\u003cT\u003e(m, c.clone(), i.saturated_into::\u003cu32\u003e());\n\t\t}\n\t\tlet collator = candidates[0].clone();\n\n\t\tlet old = InflationConfig::\u003cT\u003e::get();\n\t\tassert_eq!(LastRewardReduction::\u003cT\u003e::get(), T::BlockNumber::zero());\n\t\tSystem::\u003cT\u003e::set_block_number(T::BLOCKS_PER_YEAR + T::BlockNumber::one());\n\t}: _(RawOrigin::Signed(collator))\n\tverify {\n\t\tlet new = InflationConfig::\u003cT\u003e::get();\n\t\tassert_eq!(LastRewardReduction::\u003cT\u003e::get(), T::BlockNumber::one());\n\t\tassert_eq!(new.collator.max_rate, old.collator.max_rate);\n\t\tassert_eq!(new.delegator.max_rate, old.delegator.max_rate);\n\t\tassert!(new.collator.reward_rate.annual \u003c old.collator.reward_rate.annual);\n\t\tassert!(new.delegator.reward_rate.annual \u003c old.delegator.reward_rate.annual);\n\t}\n\n}\n\nimpl_benchmark_test_suite!(\n\tPallet,\n\tcrate::mock::ExtBuilder::default()\n\t\t.with_balances(vec![(u64::MAX, 1000 * crate::mock::MILLI_KILT)])\n\t\t.with_collators(vec![(u64::MAX, 1000 * crate::mock::MILLI_KILT)])\n\t\t.build(),\n\tcrate::mock::Test,\n);\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":43},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","default_weights.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\n//! Autogenerated weights for parachain_staking\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2022-02-14, STEPS: {{cmd.steps}}\\, REPEAT: {{cmd.repeat}}\\, LOW RANGE: {{cmd.lowest_range_values}}\\, HIGH RANGE: {{cmd.highest_range_values}}\\\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"spiritnet-dev\"), DB CACHE: 1024\n\n// Executed Command:\n// target/release/kilt-parachain\n// benchmark\n// --chain=spiritnet-dev\n// --steps=50\n// --repeat=20\n// --pallet=parachain-staking\n// --extrinsic=*\n// --execution=wasm\n// --wasm-execution=compiled\n// --heap-pages=4096\n// --output=pallets/parachain-staking/src/default_weights.rs\n// --template=.maintain/weight-template.hbs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n#![allow(clippy::unnecessary_cast)]\n\nuse frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions needed for parachain_staking.\npub trait WeightInfo {\n\tfn on_initialize_no_action() -\u003e Weight;\n\tfn on_initialize_round_update() -\u003e Weight;\n\tfn on_initialize_network_rewards() -\u003e Weight;\n\tfn force_new_round() -\u003e Weight;\n\tfn set_inflation(n: u32, m:u32 ) -\u003e Weight;\n\tfn set_max_selected_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn set_blocks_per_round() -\u003e Weight;\n\tfn force_remove_candidate(n: u32, m: u32, ) -\u003e Weight;\n\tfn join_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn init_leave_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn cancel_leave_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn execute_leave_candidates(n: u32, m: u32, ) -\u003e Weight;\n\tfn candidate_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight;\n\tfn candidate_stake_less(n: u32, m: u32, ) -\u003e Weight;\n\tfn join_delegators(n: u32, m: u32, ) -\u003e Weight;\n\tfn delegator_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight;\n\tfn delegator_stake_less(n: u32, m: u32, ) -\u003e Weight;\n\tfn leave_delegators(n: u32, m: u32, ) -\u003e Weight;\n\tfn unlock_unstaked(u: u32, ) -\u003e Weight;\n\tfn set_max_candidate_stake() -\u003e Weight;\n\tfn increment_delegator_rewards() -\u003e Weight;\n\tfn increment_collator_rewards(_m: u32, ) -\u003e Weight;\n\tfn claim_rewards() -\u003e Weight;\n\tfn execute_scheduled_reward_change(n: u32, m: u32, ) -\u003e Weight;\n}\n\n/// Weights for parachain_staking using the Substrate node and recommended hardware.\npub struct SubstrateWeight\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e WeightInfo for SubstrateWeight\u003cT\u003e {\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\tfn on_initialize_no_action() -\u003e Weight {\n\t\tWeight::from_parts(3_103_000u64,0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\tfn on_initialize_round_update() -\u003e Weight {\n\t\tWeight::from_parts(11_496_000u64,0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: System Account (r:1 w:1)\n\tfn on_initialize_network_rewards() -\u003e Weight {\n\t\tWeight::from_parts(35_227_000u64,0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(5 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking ForceNewRound (r:0 w:1)\n\tfn force_new_round() -\u003e Weight {\n\t\tWeight::from_parts(5_101_000u64,0)\n\t\t\t.saturating_add(T::DbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:3 w:0)\n\t// Storage: ParachainStaking RewardCount (r:72 w:72)\n\t// Storage: ParachainStaking Rewards (r:2 w:2)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:1)\n\t/// The range of component `n` is `[0, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn set_inflation(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64,0)\n\t\t\t// Standard Error: 3_005_000\n\t\t\t.saturating_add(Weight::from_parts(216_364_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 6_440_000\n\t\t\t.saturating_add(Weight::from_parts(440_763_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((37 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().reads((75 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes((36 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes((75 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:59 w:0)\n\t/// The range of component `n` is `[16, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn set_max_selected_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 524_000\n\t\t\t.saturating_add(Weight::from_parts(5_444_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 883_000\n\t\t\t.saturating_add(Weight::from_parts(5_252_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(1u64.saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\tfn set_blocks_per_round() -\u003e Weight {\n\t\tWeight::from_parts(24_978_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(1 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:17 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:36 w:36)\n\t// Storage: ParachainStaking DelegatorState (r:35 w:35)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: Session Validators (r:1 w:0)\n\t// Storage: Session DisabledValidators (r:1 w:1)\n\t// Storage: System Digest (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t/// The range of component `n` is `[17, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn force_remove_candidate(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 1_056_000\n\t\t\t.saturating_add(Weight::from_parts(2_682_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_750_000\n\t\t\t.saturating_add(Weight::from_parts(22_787_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(28 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((3 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(9 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes((3 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking DelegatorState (r:1 w:0)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn join_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(31_764_000u64, 0)\n\t\t\t// Standard Error: 644_000\n\t\t\t.saturating_add(Weight::from_parts(1_293_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_343_000\n\t\t\t.saturating_add(Weight::from_parts(2_377_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(10 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(7 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:17 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn init_leave_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 987_000\n\t\t\t.saturating_add(Weight::from_parts(7_127_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_607_000\n\t\t\t.saturating_add(Weight::from_parts(6_771_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(21 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:2 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn cancel_leave_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 26_390_000\n\t\t\t.saturating_add(Weight::from_parts(13_197_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 42_978_000\n\t\t\t.saturating_add(Weight::from_parts(24_662_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: ParachainStaking Unstaking (r:36 w:36)\n\t// Storage: ParachainStaking DelegatorState (r:35 w:35)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: Session Validators (r:1 w:0)\n\t// Storage: Session DisabledValidators (r:1 w:1)\n\t// Storage: System Digest (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn execute_leave_candidates(_n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(998_775_000u64, 0)\n\t\t\t// Standard Error: 431_000\n\t\t\t.saturating_add(Weight::from_parts(20_295_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(11 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((3 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(7 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes((3 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\t/// The range of component `u` is `[0, 9]`.\n\tfn candidate_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 332_000\n\t\t\t.saturating_add(Weight::from_parts(2_506_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 693_000\n\t\t\t.saturating_add(Weight::from_parts(9_543_000u64, 0).saturating_mul(m as u64))\n\t\t\t// Standard Error: 2_698_000\n\t\t\t.saturating_add(Weight::from_parts(5_104_000u64, 0).saturating_mul(u as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(11 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((1 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(8 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes((1 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn candidate_stake_less(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 905_000\n\t\t\t.saturating_add(Weight::from_parts(2_785_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_888_000\n\t\t\t.saturating_add(Weight::from_parts(10_300_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((1 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes(6 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes((1 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:2 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking LastDelegation (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:1 w:1)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn join_delegators(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(8_951_000u64, 0)\n\t\t\t// Standard Error: 855_000\n\t\t\t.saturating_add(Weight::from_parts(1_589_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_919_000\n\t\t\t.saturating_add(Weight::from_parts(3_562_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(12 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(9 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\t/// The range of component `u` is `[1, 9]`.\n\tfn delegator_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(56_774_000u64, 0)\n\t\t\t// Standard Error: 883_000\n\t\t\t.saturating_add(Weight::from_parts(1_562_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_981_000\n\t\t\t.saturating_add(Weight::from_parts(867_000u64, 0).saturating_mul(m as u64))\n\t\t\t// Standard Error: 8_175_000\n\t\t\t.saturating_add(Weight::from_parts(5_717_000u64, 0).saturating_mul(u as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(10 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(7 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn delegator_stake_less(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(1_844_000u64, 0)\n\t\t\t// Standard Error: 138_000\n\t\t\t.saturating_add(Weight::from_parts(1_192_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 310_000\n\t\t\t.saturating_add(Weight::from_parts(2_218_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn leave_delegators(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(3_824_000u64, 0)\n\t\t\t// Standard Error: 51_000\n\t\t\t.saturating_add(Weight::from_parts(1_216_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 114_000\n\t\t\t.saturating_add(Weight::from_parts(2_150_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5 as u64))\n\t}\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t/// The range of component `u` is `[1, 9]`.\n\tfn unlock_unstaked(_u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(30_399_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(3 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:0 w:1)\n\tfn set_max_candidate_stake() -\u003e Weight {\n\t\tWeight::from_parts(13_991_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:0)\n\t// Storage: ParachainStaking RewardCount (r:2 w:1)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\tfn increment_delegator_rewards() -\u003e Weight {\n\t\tWeight::from_parts(25_796_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(6 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:0)\n\t// Storage: ParachainStaking RewardCount (r:1 w:1)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `m` is `[0, 35]`.\n\tfn increment_collator_rewards(_m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(366_611_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(75 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(72 as u64))\n\t}\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\tfn claim_rewards() -\u003e Weight {\n\t\tWeight::from_parts(29_833_000u64, 0)\n\t\t\t.saturating_add(T::DbWeight::get().reads(2 as u64))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking LastRewardReduction (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:3 w:0)\n\t// Storage: ParachainStaking RewardCount (r:72 w:72)\n\t// Storage: ParachainStaking Rewards (r:2 w:2)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:0)\n\t/// The range of component `n` is `[0, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn execute_scheduled_reward_change(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 5_730_000\n\t\t\t.saturating_add(Weight::from_parts(202_623_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 12_280_000\n\t\t\t.saturating_add(Weight::from_parts(415_436_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(T::DbWeight::get().reads((37 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().reads((75 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes((36 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(T::DbWeight::get().writes((75 as u64).saturating_mul(m as u64)))\n\t}\n}\n\n// For backwards compatibility and tests\nimpl WeightInfo for () {\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\tfn on_initialize_no_action() -\u003e Weight {\n\t\tWeight::from_parts(3_103_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\tfn on_initialize_round_update() -\u003e Weight {\n\t\tWeight::from_parts(11_496_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: System Account (r:1 w:1)\n\tfn on_initialize_network_rewards() -\u003e Weight {\n\t\tWeight::from_parts(35_227_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(5 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking ForceNewRound (r:0 w:1)\n\tfn force_new_round() -\u003e Weight {\n\t\tWeight::from_parts(5_101_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:3 w:0)\n\t// Storage: ParachainStaking RewardCount (r:72 w:72)\n\t// Storage: ParachainStaking Rewards (r:2 w:2)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:1)\n\t/// The range of component `n` is `[0, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn set_inflation(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 3_005_000\n\t\t\t.saturating_add(Weight::from_parts(216_364_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 6_440_000\n\t\t\t.saturating_add(Weight::from_parts(440_763_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((37 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((75 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((36 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((75 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:59 w:0)\n\t/// The range of component `n` is `[16, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn set_max_selected_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 524_000\n\t\t\t.saturating_add(Weight::from_parts(5_444_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 883_000\n\t\t\t.saturating_add(Weight::from_parts(5_252_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1u64.saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking Round (r:1 w:1)\n\tfn set_blocks_per_round() -\u003e Weight {\n\t\tWeight::from_parts(24_978_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(1 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:17 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:36 w:36)\n\t// Storage: ParachainStaking DelegatorState (r:35 w:35)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: Session Validators (r:1 w:0)\n\t// Storage: Session DisabledValidators (r:1 w:1)\n\t// Storage: System Digest (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t/// The range of component `n` is `[17, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn force_remove_candidate(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 1_056_000\n\t\t\t.saturating_add(Weight::from_parts(2_682_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_750_000\n\t\t\t.saturating_add(Weight::from_parts(22_787_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(28 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((3 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(9 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((3 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking DelegatorState (r:1 w:0)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn join_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(31_764_000u64, 0)\n\t\t\t// Standard Error: 644_000\n\t\t\t.saturating_add(Weight::from_parts(1_293_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_343_000\n\t\t\t.saturating_add(Weight::from_parts(2_377_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(10 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(7 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:17 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn init_leave_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 987_000\n\t\t\t.saturating_add(Weight::from_parts(7_127_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_607_000\n\t\t\t.saturating_add(Weight::from_parts(6_771_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(21 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:2 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn cancel_leave_candidates(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 26_390_000\n\t\t\t.saturating_add(Weight::from_parts(13_197_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 42_978_000\n\t\t\t.saturating_add(Weight::from_parts(24_662_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(5 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: ParachainStaking Unstaking (r:36 w:36)\n\t// Storage: ParachainStaking DelegatorState (r:35 w:35)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t// Storage: Session Validators (r:1 w:0)\n\t// Storage: Session DisabledValidators (r:1 w:1)\n\t// Storage: System Digest (r:1 w:1)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:1)\n\t/// The range of component `n` is `[17, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn execute_leave_candidates(_n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(998_775_000u64, 0)\n\t\t\t// Standard Error: 431_000\n\t\t\t.saturating_add(Weight::from_parts(20_295_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(11 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((3 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(7 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((3 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:1 w:0)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\t/// The range of component `u` is `[0, 9]`.\n\tfn candidate_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 332_000\n\t\t\t.saturating_add(Weight::from_parts(2_506_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 693_000\n\t\t\t.saturating_add(Weight::from_parts(9_543_000u64, 0).saturating_mul(m as u64))\n\t\t\t// Standard Error: 2_698_000\n\t\t\t.saturating_add(Weight::from_parts(5_104_000u64, 0).saturating_mul(u as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(11 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((1 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(8 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((1 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:36 w:36)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `n` is `[1, 74]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn candidate_stake_less(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 905_000\n\t\t\t.saturating_add(Weight::from_parts(2_785_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_888_000\n\t\t\t.saturating_add(Weight::from_parts(10_300_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((1 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(6 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((1 as u64).saturating_mul(m as u64)))\n\t}\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:2 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking LastDelegation (r:1 w:1)\n\t// Storage: ParachainStaking Round (r:1 w:0)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:1 w:1)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn join_delegators(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(8_951_000u64, 0)\n\t\t\t// Standard Error: 855_000\n\t\t\t.saturating_add(Weight::from_parts(1_589_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_919_000\n\t\t\t.saturating_add(Weight::from_parts(3_562_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(12 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(9 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\t/// The range of component `u` is `[1, 9]`.\n\tfn delegator_stake_more(n: u32, m: u32, u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(56_774_000u64, 0)\n\t\t\t// Standard Error: 883_000\n\t\t\t.saturating_add(Weight::from_parts(1_562_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 1_981_000\n\t\t\t.saturating_add(Weight::from_parts(867_000u64, 0).saturating_mul(m as u64))\n\t\t\t// Standard Error: 8_175_000\n\t\t\t.saturating_add(Weight::from_parts(5_717_000u64, 0).saturating_mul(u as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(10 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(7 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn delegator_stake_less(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(1_844_000u64, 0)\n\t\t\t// Standard Error: 138_000\n\t\t\t.saturating_add(Weight::from_parts(1_192_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 310_000\n\t\t\t.saturating_add(Weight::from_parts(2_218_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(5 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:1 w:1)\n\t// Storage: ParachainStaking RewardCount (r:2 w:0)\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: ParachainStaking TopCandidates (r:1 w:1)\n\t// Storage: ParachainStaking MaxSelectedCandidates (r:1 w:0)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:1)\n\t/// The range of component `n` is `[1, 75]`.\n\t/// The range of component `m` is `[1, 34]`.\n\tfn leave_delegators(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(3_824_000u64, 0)\n\t\t\t// Standard Error: 51_000\n\t\t\t.saturating_add(Weight::from_parts(1_216_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 114_000\n\t\t\t.saturating_add(Weight::from_parts(2_150_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads(8 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(5 as u64))\n\t}\n\t// Storage: ParachainStaking Unstaking (r:1 w:1)\n\t// Storage: Balances Locks (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\t/// The range of component `u` is `[1, 9]`.\n\tfn unlock_unstaked(_u: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(30_399_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(3 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(3 as u64))\n\t}\n\t// Storage: ParachainStaking MaxCollatorCandidateStake (r:0 w:1)\n\tfn set_max_candidate_stake() -\u003e Weight {\n\t\tWeight::from_parts(13_991_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().writes(1 as u64))\n\t}\n\t// Storage: ParachainStaking DelegatorState (r:1 w:0)\n\t// Storage: ParachainStaking RewardCount (r:2 w:1)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\tfn increment_delegator_rewards() -\u003e Weight {\n\t\tWeight::from_parts(25_796_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(6 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking CandidatePool (r:1 w:0)\n\t// Storage: ParachainStaking RewardCount (r:1 w:1)\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:0)\n\t/// The range of component `m` is `[0, 35]`.\n\tfn increment_collator_rewards(_m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(366_611_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(75 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(72 as u64))\n\t}\n\t// Storage: ParachainStaking Rewards (r:1 w:1)\n\t// Storage: System Account (r:1 w:1)\n\tfn claim_rewards() -\u003e Weight {\n\t\tWeight::from_parts(29_833_000u64, 0)\n\t\t\t.saturating_add(RocksDbWeight::get().reads(2 as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().writes(2 as u64))\n\t}\n\t// Storage: ParachainStaking LastRewardReduction (r:1 w:1)\n\t// Storage: ParachainStaking InflationConfig (r:1 w:1)\n\t// Storage: ParachainStaking CandidatePool (r:3 w:0)\n\t// Storage: ParachainStaking RewardCount (r:72 w:72)\n\t// Storage: ParachainStaking Rewards (r:2 w:2)\n\t// Storage: ParachainStaking TotalCollatorStake (r:1 w:0)\n\t// Storage: ParachainStaking CounterForCandidatePool (r:1 w:0)\n\t/// The range of component `n` is `[0, 75]`.\n\t/// The range of component `m` is `[0, 35]`.\n\tfn execute_scheduled_reward_change(n: u32, m: u32, ) -\u003e Weight {\n\t\tWeight::from_parts(0u64, 0)\n\t\t\t// Standard Error: 5_730_000\n\t\t\t.saturating_add(Weight::from_parts(202_623_000u64, 0).saturating_mul(n as u64))\n\t\t\t// Standard Error: 12_280_000\n\t\t\t.saturating_add(Weight::from_parts(415_436_000u64, 0).saturating_mul(m as u64))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((37 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().reads((75 as u64).saturating_mul(m as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((36 as u64).saturating_mul(n as u64)))\n\t\t\t.saturating_add(RocksDbWeight::get().writes((75 as u64).saturating_mul(m as u64)))\n\t}\n}\n","traces":[{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":134},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","inflation.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\n//! Helper methods for computing issuance based on inflation\nuse crate::{pallet::Config, types::BalanceOf};\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::{traits::Saturating, Perquintill, RuntimeDebug};\n\n#[cfg(feature = \"std\")]\nuse serde::{Deserialize, Serialize};\n\n#[cfg_attr(feature = \"std\", derive(Serialize, Deserialize))]\n#[derive(Eq, PartialEq, Clone, Encode, Decode, Default, RuntimeDebug, TypeInfo)]\npub struct RewardRate {\n\tpub annual: Perquintill,\n\tpub per_block: Perquintill,\n}\n\nimpl MaxEncodedLen for RewardRate {\n\tfn max_encoded_len() -\u003e usize {\n\t\t// Perquintill is at most u128\n\t\tu128::max_encoded_len().saturating_add(u128::max_encoded_len())\n\t}\n}\n\n/// Convert annual reward rate to per_block.\nfn annual_to_per_block(blocks_per_year: u64, rate: Perquintill) -\u003e Perquintill {\n\trate / blocks_per_year.max(1)\n}\n\nimpl RewardRate {\n\tpub fn new(blocks_per_year: u64, rate: Perquintill) -\u003e Self {\n\t\tRewardRate { annual: rate, per_block: annual_to_per_block(blocks_per_year, rate) }\n\t}\n}\n\n/// Staking info (staking rate and reward rate) for collators and delegators.\n#[cfg_attr(feature = \"std\", derive(Serialize, Deserialize))]\n#[derive(Eq, PartialEq, Clone, Encode, Decode, Default, RuntimeDebug, TypeInfo)]\npub struct StakingInfo {\n\t/// Maximum staking rate.\n\tpub max_rate: Perquintill,\n\t/// Reward rate annually and per_block.\n\tpub reward_rate: RewardRate,\n}\n\nimpl MaxEncodedLen for StakingInfo {\n\tfn max_encoded_len() -\u003e usize {\n\t\t// Perquintill is at most u128\n\t\tRewardRate::max_encoded_len().saturating_add(u128::max_encoded_len())\n\t}\n}\n\nimpl StakingInfo {\n\tpub fn new(\n\t\tblocks_per_year: u64,\n\t\tmax_rate: Perquintill,\n\t\tannual_reward_rate: Perquintill,\n\t) -\u003e Self {\n\t\tStakingInfo { max_rate, reward_rate: RewardRate::new(blocks_per_year, annual_reward_rate) }\n\t}\n\n\t/// Calculate newly minted rewards on coinbase, e.g.,\n\t/// reward = rewards_per_block * staking_rate.\n\t///\n\t/// NOTE: If we exceed the max staking rate, the reward will be reduced by\n\t/// max_rate / current_rate.\n\tpub fn compute_reward\u003cT: Config\u003e(\n\t\t\u0026self,\n\t\tstake: BalanceOf\u003cT\u003e,\n\t\tcurrent_staking_rate: Perquintill,\n\t\tauthors_per_round: BalanceOf\u003cT\u003e,\n\t) -\u003e BalanceOf\u003cT\u003e {\n\t\t// Perquintill automatically bounds to [0, 100]% in case staking_rate is greater\n\t\t// than self.max_rate\n\t\tlet reduction = Perquintill::from_rational(\n\t\t\tself.max_rate.deconstruct(),\n\t\t\tcurrent_staking_rate.deconstruct(),\n\t\t);\n\t\t// multiplication with perbill cannot overflow\n\t\tlet reward = (self.reward_rate.per_block * stake).saturating_mul(authors_per_round);\n\t\treduction * reward\n\t}\n}\n\n#[cfg_attr(feature = \"std\", derive(Serialize, Deserialize))]\n#[derive(Eq, PartialEq, Clone, Encode, Decode, Default, RuntimeDebug, TypeInfo, MaxEncodedLen)]\npub struct InflationInfo {\n\tpub collator: StakingInfo,\n\tpub delegator: StakingInfo,\n}\n\nimpl InflationInfo {\n\t/// Create a new inflation info from the max staking rates and annual reward\n\t/// rates for collators and delegators.\n\t///\n\t/// Example: InflationInfo::new(Perquintill_from_percent(10), ...)\n\tpub fn new(\n\t\tblocks_per_year: u64,\n\t\tcollator_max_rate_percentage: Perquintill,\n\t\tcollator_annual_reward_rate_percentage: Perquintill,\n\t\tdelegator_max_rate_percentage: Perquintill,\n\t\tdelegator_annual_reward_rate_percentage: Perquintill,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tcollator: StakingInfo::new(\n\t\t\t\tblocks_per_year,\n\t\t\t\tcollator_max_rate_percentage,\n\t\t\t\tcollator_annual_reward_rate_percentage,\n\t\t\t),\n\t\t\tdelegator: StakingInfo::new(\n\t\t\t\tblocks_per_year,\n\t\t\t\tdelegator_max_rate_percentage,\n\t\t\t\tdelegator_annual_reward_rate_percentage,\n\t\t\t),\n\t\t}\n\t}\n\n\t/// Check whether the annual reward rate is approx. the per_block reward\n\t/// rate multiplied with the number of blocks per year\n\tpub fn is_valid(\u0026self, blocks_per_year: u64) -\u003e bool {\n\t\tself.collator.reward_rate.annual \u003e=\n\t\t\tPerquintill::from_parts(\n\t\t\t\tself.collator\n\t\t\t\t\t.reward_rate\n\t\t\t\t\t.per_block\n\t\t\t\t\t.deconstruct()\n\t\t\t\t\t.saturating_mul(blocks_per_year),\n\t\t\t) \u0026\u0026 self.delegator.reward_rate.annual \u003e=\n\t\t\tPerquintill::from_parts(\n\t\t\t\tself.delegator\n\t\t\t\t\t.reward_rate\n\t\t\t\t\t.per_block\n\t\t\t\t\t.deconstruct()\n\t\t\t\t\t.saturating_mul(blocks_per_year),\n\t\t\t)\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse sp_runtime::Perbill;\n\n\tuse super::*;\n\tuse crate::mock::{almost_equal, ExtBuilder, Test, DECIMALS, MAX_COLLATOR_STAKE};\n\n\t#[test]\n\tfn perquintill() {\n\t\tassert_eq!(\n\t\t\tPerquintill::from_percent(100) * Perquintill::from_percent(50),\n\t\t\tPerquintill::from_percent(50)\n\t\t);\n\t}\n\n\t#[test]\n\tfn annual_to_block_rate() {\n\t\tlet rate = Perquintill::one();\n\t\tassert!(almost_equal(\n\t\t\trate * 10_000_000_000u128,\n\t\t\tPerquintill::from_parts(\n\t\t\t\tannual_to_per_block(\u003cTest as Config\u003e::BLOCKS_PER_YEAR, rate).deconstruct() *\n\t\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR\n\t\t\t) * 10_000_000_000u128,\n\t\t\tPerbill::from_perthousand(1)\n\t\t));\n\t}\n\n\t#[test]\n\tfn single_block_reward_collator() {\n\t\tlet inflation = InflationInfo::new(\n\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\tPerquintill::from_percent(10),\n\t\t\tPerquintill::from_percent(10),\n\t\t\tPerquintill::from_percent(40),\n\t\t\tPerquintill::from_percent(8),\n\t\t);\n\t\tlet reward = inflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\tMAX_COLLATOR_STAKE,\n\t\t\tPerquintill::from_percent(9),\n\t\t\t2,\n\t\t);\n\t\tlet expected = \u003cTest as Config\u003e::CurrencyBalance::from(15210282150733u64);\n\t\tassert!(\n\t\t\talmost_equal(reward, expected, Perbill::from_perthousand(1)),\n\t\t\t\"left {:?}, right {:?}\",\n\t\t\treward,\n\t\t\texpected\n\t\t);\n\t}\n\n\t#[test]\n\tfn simple_block_reward_check() {\n\t\tlet precision = Perbill::from_perthousand(1);\n\t\tExtBuilder::default()\n\t\t\t.with_inflation(10, 15, 40, 10, 5)\n\t\t\t.with_balances(vec![(1, 10)])\n\t\t\t.with_collators(vec![(1, 10)])\n\t\t\t.build()\n\t\t\t.execute_with(|| {\n\t\t\t\tlet inflation = InflationInfo::new(\n\t\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\t\tPerquintill::from_percent(10),\n\t\t\t\t\tPerquintill::from_percent(15),\n\t\t\t\t\tPerquintill::from_percent(40),\n\t\t\t\t\tPerquintill::from_percent(10),\n\t\t\t\t);\n\t\t\t\tlet years_u128: BalanceOf\u003cTest\u003e = \u003cTest as Config\u003e::BLOCKS_PER_YEAR as u128;\n\n\t\t\t\t// Dummy checks for correct instantiation\n\t\t\t\tassert!(inflation.is_valid(\u003cTest as Config\u003e::BLOCKS_PER_YEAR));\n\t\t\t\tassert_eq!(inflation.collator.max_rate, Perquintill::from_percent(10));\n\t\t\t\tassert_eq!(inflation.collator.reward_rate.annual, Perquintill::from_percent(15));\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.collator.reward_rate.per_block * DECIMALS * 10_000,\n\t\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS / years_u128,\n\t\t\t\t\t\tprecision\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.collator.reward_rate.per_block * 10_000 * DECIMALS,\n\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS / years_u128,\n\t\t\t\t);\n\t\t\t\tassert_eq!(inflation.delegator.max_rate, Perquintill::from_percent(40));\n\t\t\t\tassert_eq!(inflation.delegator.reward_rate.annual, Perquintill::from_percent(10));\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.delegator.reward_rate.per_block * DECIMALS * 10_000,\n\t\t\t\t\t\tPerquintill::from_percent(10) * 10_000 * DECIMALS / years_u128,\n\t\t\t\t\t\tprecision\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.delegator.reward_rate.per_block * DECIMALS * 10_000,\n\t\t\t\t\tPerquintill::from_percent(10) * 10_000 * DECIMALS / years_u128,\n\t\t\t\t);\n\n\t\t\t\t// Check collator reward computation\n\t\t\t\tlet authors_per_round = 1u128;\n\t\t\t\tlet mut current_staking_rate: Perquintill = inflation.collator.max_rate;\n\t\t\t\tassert_eq!(\n\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t),\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(5000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t5000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(15) * 5000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t5000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(15) * 5000 * DECIMALS,\n\t\t\t\t);\n\t\t\t\t// Check for max_rate which is 10%\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(10_000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t10_000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t10_000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS,\n\t\t\t\t);\n\n\t\t\t\t// Check for exceeding max_rate: 50% instead of 10%\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(50_000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t50_000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t50_000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(15) * 10_000 * DECIMALS,\n\t\t\t\t);\n\n\t\t\t\t// Check delegator reward computation\n\t\t\t\tcurrent_staking_rate = inflation.delegator.max_rate;\n\t\t\t\tassert_eq!(\n\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t),\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(5000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t5000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(10) * 5000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t5000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(10) * 5000 * DECIMALS,\n\t\t\t\t);\n\t\t\t\t// Check for max_rate which is 40%\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(40_000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t40_000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(10) * 40_000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t40_000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(10) * 40_000 * DECIMALS,\n\t\t\t\t);\n\n\t\t\t\t// Check for exceeding max_rate: 50% instead of 40%\n\t\t\t\tcurrent_staking_rate = Perquintill::from_rational(50_000u64, 100_000u64);\n\t\t\t\tassert!(\n\t\t\t\t\talmost_equal(\n\t\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t\t50_000 * DECIMALS,\n\t\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t\t) * years_u128,\n\t\t\t\t\t\tPerquintill::from_percent(8) * 50_000 * DECIMALS,\n\t\t\t\t\t\tPerbill::from_percent(1)\n\t\t\t\t\t),\n\t\t\t\t\t\"left = {:?}, right = {:?}\",\n\t\t\t\t\tinflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t\t\t50_000 * DECIMALS,\n\t\t\t\t\t\tcurrent_staking_rate,\n\t\t\t\t\t\tauthors_per_round\n\t\t\t\t\t) * years_u128,\n\t\t\t\t\tPerquintill::from_percent(8) * 50_000 * DECIMALS,\n\t\t\t\t);\n\t\t\t});\n\t}\n}\n","traces":[{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","lib.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\n//! # Parachain Staking\n//!\n//! A simple staking pallet providing means of selecting a set of collators to\n//! become block authors based on their total backed stake. The main difference\n//! between this pallet and `frame/pallet-staking` is that this pallet uses\n//! direct delegation. Delegators choose exactly who they delegate and with what\n//! stake. This is different from `frame/pallet-staking` where you approval vote\n//! and then run Phragmen. Moreover, this pallet rewards a collator and their\n//! delegators immediately when authoring a block. Rewards are calculated\n//! separately between collators and delegators.\n//!\n//! To join the set of candidates, an account must call `join_candidates` with\n//! `MinCollatorCandidateStake` \u003c= stake \u003c= `MaxCollatorCandidateStake`.\n//!\n//! To leave the set of candidates, the collator calls `leave_candidates`. If\n//! the call succeeds, the collator is removed from the pool of candidates so\n//! they cannot be selected for future collator sets, but they are not unstaking\n//! until executing the exit request by calling the extrinsic\n//! `execute_leave_candidates` at least `ExitQueueDelay` rounds later. After\n//! doing so, the collator candidate as well as their delegators are unstaked.\n//! Both parties then have to wait another `StakeDuration` more blocks to be\n//! able to unlock their stake.\n//!\n//! Candidates which requested to leave can still be in the set of authors for\n//! the next round due to the design of the session pallet which at the start of\n//! session s(i) chooses a set for the next session s(i+1). Thus, candidates\n//! have to keep collating at least until the end of the next session (= round).\n//! We extend this by delaying their execute by at least `ExitQueueDelay` many\n//! sessions.\n//!\n//! To join the set of delegators, an account must call `join_delegators` with\n//! stake \u003e= `MinDelegatorStake`. There are also runtime methods for delegating\n//! additional collators and revoking delegations.\n//!\n//!\n//! - [`Config`]\n//! - [`Call`]\n//! - [`Pallet`]\n//!\n//! ## Overview\n//!\n//! The KILT parachain staking pallet provides functions for:\n//! - Joining the set of collator candidates of which the best\n//!   `MaxSelectedCandidates` are chosen to become active collators for the next\n//!   session. That makes the set of active collators the set of block authors\n//!   by handing it over to the session and the authority pallet.\n//! - Delegating to a collator candidate by staking for them.\n//! - Increasing and reducing your stake as a collator or delegator.\n//! - Revoking your delegation entirely.\n//! - Requesting to leave the set of collator candidates.\n//! - Withdrawing your unstaked balance after waiting for a certain number of\n//!   blocks.\n//!\n//! ### Terminology\n//!\n//! - **Candidate:** A user which locks up tokens to be included into the set of\n//!   authorities which author blocks and receive rewards for doing so.\n//!\n//! - **Collator:** A candidate that was chosen to collate this round.\n//!\n//! - **Delegator:** A user which locks up tokens for collators they trust. When\n//!   their collator authors a block, the corresponding delegators also receive\n//!   rewards.\n//!\n//! - **Total Stake:** A collator’s own stake + the sum of delegated stake to\n//!   this collator.\n//!\n//! - **Total collator stake:** The sum of tokens locked for staking from all\n//!   collator candidates.\n//!\n//! - **Total delegator stake:** The sum of tokens locked for staking from all\n//!   delegators.\n//!\n//! - **To Stake:** Lock tokens for staking.\n//!\n//! - **To Unstake:** Unlock tokens from staking.\n//!\n//! - **Round (= Session):** A fixed number of blocks in which the set of\n//!   collators does not change. We set the length of a session to the length of\n//!   a staking round, thus both words are interchangeable in the context of\n//!   this pallet.\n//!\n//! - **Lock:** A freeze on a specified amount of an account's free balance\n//!   until a specified block number. Multiple locks always operate over the\n//!   same funds, so they \"overlay\" rather than \"stack\"\n//!\n//! ## Genesis config\n//!\n//! The ParachainStaking pallet depends on the [`GenesisConfig`].\n//!\n//! ## Assumptions\n//!\n//! - At the start of session s(i), the set of session ids for session s(i+1)\n//!   are chosen. These equal the set of selected candidates. Thus, we cannot\n//!   allow collators to leave at least until the start of session s(i+2).\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::unused_unit)]\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub mod benchmarking;\npub mod default_weights;\npub mod runtime_api;\n\n#[cfg(test)]\npub(crate) mod mock;\n#[cfg(test)]\npub(crate) mod tests;\n\n#[cfg(any(feature = \"try-runtime\", test))]\nmod try_state;\n\nmod inflation;\nmod set;\nmod types;\n\nuse frame_support::pallet;\n\npub use crate::{default_weights::WeightInfo, pallet::*};\n\n#[pallet]\npub mod pallet {\n\tuse super::*;\n\tpub use crate::inflation::{InflationInfo, RewardRate, StakingInfo};\n\n\tuse frame_support::{\n\t\tpallet_prelude::*,\n\t\tstorage::bounded_btree_map::BoundedBTreeMap,\n\t\ttraits::{\n\t\t\tCurrency, EstimateNextSessionRotation, Get, Imbalance, LockIdentifier,\n\t\t\tLockableCurrency, OnUnbalanced, ReservableCurrency, StorageVersion, WithdrawReasons,\n\t\t},\n\t\tBoundedVec,\n\t};\n\n\t#[cfg(feature = \"std\")]\n\tuse frame_support::assert_ok;\n\n\tuse frame_system::pallet_prelude::*;\n\tuse pallet_balances::{BalanceLock, Locks};\n\tuse pallet_session::ShouldEndSession;\n\tuse scale_info::TypeInfo;\n\tuse sp_runtime::{\n\t\ttraits::{Convert, One, SaturatedConversion, Saturating, StaticLookup, Zero},\n\t\tPermill, Perquintill,\n\t};\n\tuse sp_staking::SessionIndex;\n\tuse sp_std::prelude::*;\n\n\tuse crate::{\n\t\tset::OrderedSet,\n\t\ttypes::{\n\t\t\tBalanceOf, Candidate, CandidateOf, CandidateStatus, DelegationCounter, Delegator,\n\t\t\tNegativeImbalanceOf, RoundInfo, Stake, StakeOf, TotalStake,\n\t\t},\n\t};\n\tuse sp_std::{convert::TryInto, fmt::Debug};\n\n\t/// Kilt-specific lock for staking rewards.\n\tpub(crate) const STAKING_ID: LockIdentifier = *b\"kiltpstk\";\n\n\t/// The current storage version.\n\tconst STORAGE_VERSION: StorageVersion = StorageVersion::new(7);\n\n\t/// Pallet for parachain staking.\n\t#[pallet::pallet]\n\t#[pallet::storage_version(STORAGE_VERSION)]\n\tpub struct Pallet\u003cT\u003e(PhantomData\u003cT\u003e);\n\n\t/// Configuration trait of this pallet.\n\t#[pallet::config]\n\tpub trait Config:\n\t\tframe_system::Config + pallet_balances::Config + pallet_session::Config\n\t{\n\t\t/// Overarching event type\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\t\t// FIXME: Remove Currency and CurrencyBalance types. Problem: Need to restrict\n\t\t// pallet_balances::Config::Balance with From\u003cu64\u003e for usage with Perquintill\n\t\t// multiplication\n\t\t/// The currency type\n\t\t/// Note: Declaration of Balance taken from pallet_gilt\n\t\ttype Currency: Currency\u003cSelf::AccountId, Balance = Self::CurrencyBalance\u003e\n\t\t\t+ ReservableCurrency\u003cSelf::AccountId, Balance = Self::CurrencyBalance\u003e\n\t\t\t+ LockableCurrency\u003cSelf::AccountId, Balance = Self::CurrencyBalance\u003e\n\t\t\t+ Eq;\n\n\t\t/// Just the `Currency::Balance` type; we have this item to allow us to\n\t\t/// constrain it to `From\u003cu64\u003e`.\n\t\t/// Note: Definition taken from pallet_gilt\n\t\ttype CurrencyBalance: sp_runtime::traits::AtLeast32BitUnsigned\n\t\t\t+ parity_scale_codec::FullCodec\n\t\t\t+ Copy\n\t\t\t+ MaybeSerializeDeserialize\n\t\t\t+ sp_std::fmt::Debug\n\t\t\t+ Default\n\t\t\t+ From\u003cu64\u003e\n\t\t\t+ From\u003cu128\u003e\n\t\t\t+ Into\u003c\u003cSelf as pallet_balances::Config\u003e::Balance\u003e\n\t\t\t+ From\u003c\u003cSelf as pallet_balances::Config\u003e::Balance\u003e\n\t\t\t+ TypeInfo\n\t\t\t+ MaxEncodedLen;\n\n\t\t/// Minimum number of blocks validation rounds can last.\n\t\t#[pallet::constant]\n\t\ttype MinBlocksPerRound: Get\u003cSelf::BlockNumber\u003e;\n\n\t\t/// Default number of blocks validation rounds last, as set in the\n\t\t/// genesis configuration.\n\t\t#[pallet::constant]\n\t\ttype DefaultBlocksPerRound: Get\u003cSelf::BlockNumber\u003e;\n\t\t/// Number of blocks for which unstaked balance will still be locked\n\t\t/// before it can be unlocked by actively calling the extrinsic\n\t\t/// `unlock_unstaked`.\n\t\t#[pallet::constant]\n\t\ttype StakeDuration: Get\u003cSelf::BlockNumber\u003e;\n\t\t/// Number of rounds a collator has to stay active after submitting a\n\t\t/// request to leave the set of collator candidates.\n\t\t#[pallet::constant]\n\t\ttype ExitQueueDelay: Get\u003cu32\u003e;\n\n\t\t/// Minimum number of collators selected from the set of candidates at\n\t\t/// every validation round.\n\t\t#[pallet::constant]\n\t\ttype MinCollators: Get\u003cu32\u003e;\n\n\t\t/// Minimum number of collators which cannot leave the network if there\n\t\t/// are no others.\n\t\t#[pallet::constant]\n\t\ttype MinRequiredCollators: Get\u003cu32\u003e;\n\n\t\t/// Maximum number of delegations which can be made within the same\n\t\t/// round.\n\t\t///\n\t\t/// NOTE: To prevent re-delegation-reward attacks, we should keep this\n\t\t/// to be one.\n\t\t#[pallet::constant]\n\t\ttype MaxDelegationsPerRound: Get\u003cu32\u003e;\n\n\t\t/// Maximum number of delegators a single collator can have.\n\t\t#[pallet::constant]\n\t\ttype MaxDelegatorsPerCollator: Get\u003cu32\u003e + Debug + PartialEq;\n\n\t\t/// Maximum size of the top candidates set.\n\t\t#[pallet::constant]\n\t\ttype MaxTopCandidates: Get\u003cu32\u003e + Debug + PartialEq;\n\n\t\t/// Minimum stake required for any account to be elected as validator\n\t\t/// for a round.\n\t\t#[pallet::constant]\n\t\ttype MinCollatorStake: Get\u003cBalanceOf\u003cSelf\u003e\u003e;\n\n\t\t/// Minimum stake required for any account to be added to the set of\n\t\t/// candidates.\n\t\t#[pallet::constant]\n\t\ttype MinCollatorCandidateStake: Get\u003cBalanceOf\u003cSelf\u003e\u003e;\n\n\t\t/// Minimum stake required for any account to become a delegator.\n\t\t#[pallet::constant]\n\t\ttype MinDelegatorStake: Get\u003cBalanceOf\u003cSelf\u003e\u003e;\n\n\t\t/// The annual decay rate of the collator rewards\n\t\t#[pallet::constant]\n\t\ttype CollatorRewardRateDecay: Get\u003cPerquintill\u003e;\n\n\t\t/// Max number of concurrent active unstaking requests before\n\t\t/// unlocking.\n\t\t///\n\t\t/// NOTE: To protect against irremovability of a candidate or delegator,\n\t\t/// we only allow for MaxUnstakeRequests - 1 many manual unstake\n\t\t/// requests. The last one serves as a placeholder for the cases of\n\t\t/// calling either `kick_delegator`, force_remove_candidate` or\n\t\t/// `execute_leave_candidates`. Otherwise, a user could max out their\n\t\t/// unstake requests and prevent themselves from being kicked from the\n\t\t/// set of candidates/delegators until they unlock their funds.\n\t\t#[pallet::constant]\n\t\ttype MaxUnstakeRequests: Get\u003cu32\u003e;\n\n\t\t/// The starting block number for the network rewards. Once the current\n\t\t/// block number exceeds this start, the beneficiary will receive the\n\t\t/// configured reward in each block.\n\t\t#[pallet::constant]\n\t\ttype NetworkRewardStart: Get\u003c\u003cSelf as frame_system::Config\u003e::BlockNumber\u003e;\n\n\t\t/// The rate in percent for the network rewards which are based on the\n\t\t/// maximum number of collators and the maximum amount a collator can\n\t\t/// stake.\n\t\t#[pallet::constant]\n\t\ttype NetworkRewardRate: Get\u003cPerquintill\u003e;\n\n\t\t/// The beneficiary to receive the network rewards.\n\t\ttype NetworkRewardBeneficiary: OnUnbalanced\u003cNegativeImbalanceOf\u003cSelf\u003e\u003e;\n\n\t\t/// Weight information for extrinsics in this pallet.\n\t\ttype WeightInfo: WeightInfo;\n\n\t\tconst BLOCKS_PER_YEAR: Self::BlockNumber;\n\t}\n\n\t#[pallet::error]\n\tpub enum Error\u003cT\u003e {\n\t\t/// The account is not part of the delegators set.\n\t\tDelegatorNotFound,\n\t\t/// The account is not part of the collator candidates set.\n\t\tCandidateNotFound,\n\t\t/// The account is already part of the delegators set.\n\t\tDelegatorExists,\n\t\t/// The account is already part of the collator candidates set.\n\t\tCandidateExists,\n\t\t/// The account tried to stake more or less with amount zero.\n\t\tValStakeZero,\n\t\t/// The account has not staked enough funds to be added to the collator\n\t\t/// candidates set.\n\t\tValStakeBelowMin,\n\t\t/// The account has already staked the maximum amount of funds possible.\n\t\tValStakeAboveMax,\n\t\t/// The account has not staked enough funds to delegate a collator\n\t\t/// candidate.\n\t\tDelegationBelowMin,\n\t\t/// The collator candidate has already trigger the process to leave the\n\t\t/// set of collator candidates.\n\t\tAlreadyLeaving,\n\t\t/// The collator candidate wanted to execute the exit but has not\n\t\t/// requested to leave before by calling `init_leave_candidates`.\n\t\tNotLeaving,\n\t\t/// The collator tried to leave before waiting at least for\n\t\t/// `ExitQueueDelay` many rounds.\n\t\tCannotLeaveYet,\n\t\t/// The account has a full list of unstaking requests and needs to\n\t\t/// unlock at least one of these before being able to join (again).\n\t\t/// NOTE: Can only happen if the account was a candidate or\n\t\t/// delegator before and either got kicked or exited voluntarily.\n\t\tCannotJoinBeforeUnlocking,\n\t\t/// The account is already delegating the collator candidate.\n\t\tAlreadyDelegating,\n\t\t/// The account has not delegated any collator candidate yet, hence it\n\t\t/// is not in the set of delegators.\n\t\tNotYetDelegating,\n\t\t/// The delegator has exceeded the number of delegations per round which\n\t\t/// is equal to MaxDelegatorsPerCollator.\n\t\t///\n\t\t/// This protects against attacks in which a delegator can re-delegate\n\t\t/// from a collator who has already authored a block, to another one\n\t\t/// which has not in this round.\n\t\tDelegationsPerRoundExceeded,\n\t\t/// The collator candidate has already reached the maximum number of\n\t\t/// delegators.\n\t\t///\n\t\t/// This error is generated in case a new delegation request does not\n\t\t/// stake enough funds to replace some other existing delegation.\n\t\tTooManyDelegators,\n\t\t/// The set of collator candidates would fall below the required minimum\n\t\t/// if the collator left.\n\t\tTooFewCollatorCandidates,\n\t\t/// The collator candidate is in the process of leaving the set of\n\t\t/// candidates and cannot perform any other actions in the meantime.\n\t\tCannotStakeIfLeaving,\n\t\t/// The collator candidate is in the process of leaving the set of\n\t\t/// candidates and thus cannot be delegated to.\n\t\tCannotDelegateIfLeaving,\n\t\t/// The delegator has already delegated the maximum number of candidates\n\t\t/// allowed.\n\t\tMaxCollatorsPerDelegatorExceeded,\n\t\t/// The delegator has already previously delegated the collator\n\t\t/// candidate.\n\t\tAlreadyDelegatedCollator,\n\t\t/// The given delegation does not exist in the set of delegations.\n\t\tDelegationNotFound,\n\t\t/// The collator delegate or the delegator is trying to un-stake more\n\t\t/// funds that are currently staked.\n\t\tUnderflow,\n\t\t/// The number of selected candidates per staking round is\n\t\t/// above the maximum value allowed.\n\t\tCannotSetAboveMax,\n\t\t/// The number of selected candidates per staking round is\n\t\t/// below the minimum value allowed.\n\t\tCannotSetBelowMin,\n\t\t/// An invalid inflation configuration is trying to be set.\n\t\tInvalidSchedule,\n\t\t/// The staking reward being unlocked does not exist.\n\t\t/// Max unlocking requests reached.\n\t\tNoMoreUnstaking,\n\t\t/// The reward rate cannot be adjusted yet as an entire year has not\n\t\t/// passed.\n\t\tTooEarly,\n\t\t/// Provided staked value is zero. Should never be thrown.\n\t\tStakeNotFound,\n\t\t/// Cannot unlock when Unstaked is empty.\n\t\tUnstakingIsEmpty,\n\t\t/// Cannot claim rewards if empty.\n\t\tRewardsNotFound,\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(crate) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\t/// A new staking round has started.\n\t\t/// \\[block number, round number\\]\n\t\tNewRound(T::BlockNumber, SessionIndex),\n\t\t/// A new account has joined the set of top candidates.\n\t\t/// \\[account\\]\n\t\tEnteredTopCandidates(T::AccountId),\n\t\t/// An account was removed from the set of top candidates.\n\t\t/// \\[account\\]\n\t\tLeftTopCandidates(T::AccountId),\n\t\t/// A new account has joined the set of collator candidates.\n\t\t/// \\[account, amount staked by the new candidate\\]\n\t\tJoinedCollatorCandidates(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// A collator candidate has increased the amount of funds at stake.\n\t\t/// \\[collator's account, previous stake, new stake\\]\n\t\tCollatorStakedMore(T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// A collator candidate has decreased the amount of funds at stake.\n\t\t/// \\[collator's account, previous stake, new stake\\]\n\t\tCollatorStakedLess(T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// A collator candidate has started the process to leave the set of\n\t\t/// candidates. \\[round number, collator's account, round number when\n\t\t/// the collator will be effectively removed from the set of\n\t\t/// candidates\\]\n\t\tCollatorScheduledExit(SessionIndex, T::AccountId, SessionIndex),\n\t\t/// A collator candidate has canceled the process to leave the set of\n\t\t/// candidates and was added back to the candidate pool. \\[collator's\n\t\t/// account\\]\n\t\tCollatorCanceledExit(T::AccountId),\n\t\t/// An account has left the set of collator candidates.\n\t\t/// \\[account, amount of funds un-staked\\]\n\t\tCandidateLeft(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// An account was forcedly removed from the  set of collator\n\t\t/// candidates. \\[account, amount of funds un-staked\\]\n\t\tCollatorRemoved(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// The maximum candidate stake has been changed.\n\t\t/// \\[new max amount\\]\n\t\tMaxCandidateStakeChanged(BalanceOf\u003cT\u003e),\n\t\t/// A delegator has increased the amount of funds at stake for a\n\t\t/// collator. \\[delegator's account, collator's account, previous\n\t\t/// delegation stake, new delegation stake\\]\n\t\tDelegatorStakedMore(T::AccountId, T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// A delegator has decreased the amount of funds at stake for a\n\t\t/// collator. \\[delegator's account, collator's account, previous\n\t\t/// delegation stake, new delegation stake\\]\n\t\tDelegatorStakedLess(T::AccountId, T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// An account has left the set of delegators.\n\t\t/// \\[account, amount of funds un-staked\\]\n\t\tDelegatorLeft(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// An account has delegated a new collator candidate.\n\t\t/// \\[account, amount of funds staked, total amount of delegators' funds\n\t\t/// staked for the collator candidate\\]\n\t\tDelegation(T::AccountId, BalanceOf\u003cT\u003e, T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// A new delegation has replaced an existing one in the set of ongoing\n\t\t/// delegations for a collator candidate. \\[new delegator's account,\n\t\t/// amount of funds staked in the new delegation, replaced delegator's\n\t\t/// account, amount of funds staked in the replace delegation, collator\n\t\t/// candidate's account, new total amount of delegators' funds staked\n\t\t/// for the collator candidate\\]\n\t\tDelegationReplaced(\n\t\t\tT::AccountId,\n\t\t\tBalanceOf\u003cT\u003e,\n\t\t\tT::AccountId,\n\t\t\tBalanceOf\u003cT\u003e,\n\t\t\tT::AccountId,\n\t\t\tBalanceOf\u003cT\u003e,\n\t\t),\n\t\t/// An account has stopped delegating a collator candidate.\n\t\t/// \\[account, collator candidate's account, old amount of delegators'\n\t\t/// funds staked, new amount of delegators' funds staked\\]\n\t\tDelegatorLeftCollator(T::AccountId, T::AccountId, BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e),\n\t\t/// A collator or a delegator has received a reward.\n\t\t/// \\[account, amount of reward\\]\n\t\tRewarded(T::AccountId, BalanceOf\u003cT\u003e),\n\t\t/// Inflation configuration for future validation rounds has changed.\n\t\t/// \\[maximum collator's staking rate, maximum collator's reward rate,\n\t\t/// maximum delegator's staking rate, maximum delegator's reward rate\\]\n\t\tRoundInflationSet(Perquintill, Perquintill, Perquintill, Perquintill),\n\t\t/// The maximum number of collator candidates selected in future\n\t\t/// validation rounds has changed. \\[old value, new value\\]\n\t\tMaxSelectedCandidatesSet(u32, u32),\n\t\t/// The length in blocks for future validation rounds has changed.\n\t\t/// \\[round number, first block in the current round, old value, new\n\t\t/// value\\]\n\t\tBlocksPerRoundSet(SessionIndex, T::BlockNumber, T::BlockNumber, T::BlockNumber),\n\t}\n\n\t#[pallet::hooks]\n\timpl\u003cT: Config\u003e Hooks\u003cBlockNumberFor\u003cT\u003e\u003e for Pallet\u003cT\u003e {\n\t\tfn on_initialize(now: T::BlockNumber) -\u003e frame_support::weights::Weight {\n\t\t\tlet mut post_weight = \u003cT as Config\u003e::WeightInfo::on_initialize_no_action();\n\t\t\tlet mut round = \u003cRound\u003cT\u003e\u003e::get();\n\n\t\t\t// check for round update\n\t\t\tif round.should_update(now) {\n\t\t\t\t// mutate round\n\t\t\t\tround.update(now);\n\t\t\t\t// start next round\n\t\t\t\t\u003cRound\u003cT\u003e\u003e::put(round);\n\n\t\t\t\tSelf::deposit_event(Event::NewRound(round.first, round.current));\n\t\t\t\tpost_weight = \u003cT as Config\u003e::WeightInfo::on_initialize_round_update();\n\t\t\t}\n\t\t\t// check for network reward and mint\n\t\t\t// on success, mint each block\n\t\t\tif now \u003e T::NetworkRewardStart::get() {\n\t\t\t\tT::NetworkRewardBeneficiary::on_unbalanced(Self::issue_network_reward());\n\t\t\t\tpost_weight = post_weight\n\t\t\t\t\t.saturating_add(\u003cT as Config\u003e::WeightInfo::on_initialize_network_rewards());\n\t\t\t}\n\t\t\tpost_weight\n\t\t}\n\t}\n\n\t/// The maximum number of collator candidates selected at each round.\n\t#[pallet::storage]\n\t#[pallet::getter(fn max_selected_candidates)]\n\tpub(crate) type MaxSelectedCandidates\u003cT: Config\u003e = StorageValue\u003c_, u32, ValueQuery\u003e;\n\n\t/// Current round number and next round scheduled transition.\n\t#[pallet::storage]\n\t#[pallet::getter(fn round)]\n\tpub(crate) type Round\u003cT: Config\u003e = StorageValue\u003c_, RoundInfo\u003cT::BlockNumber\u003e, ValueQuery\u003e;\n\n\t/// Delegation information for the latest session in which a delegator\n\t/// delegated.\n\t///\n\t/// It maps from an account to the number of delegations in the last\n\t/// session in which they (re-)delegated.\n\t#[pallet::storage]\n\t#[pallet::getter(fn last_delegation)]\n\tpub(crate) type LastDelegation\u003cT: Config\u003e =\n\t\tStorageMap\u003c_, Twox64Concat, T::AccountId, DelegationCounter, ValueQuery\u003e;\n\n\t/// Delegation staking information.\n\t///\n\t/// It maps from an account to its delegation details.\n\t#[pallet::storage]\n\t#[pallet::getter(fn delegator_state)]\n\tpub(crate) type DelegatorState\u003cT: Config\u003e = StorageMap\u003c\n\t\t_,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\tDelegator\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e,\n\t\tOptionQuery,\n\t\u003e;\n\n\t/// The staking information for a candidate.\n\t///\n\t/// It maps from an account to its information.\n\t/// Moreover, it counts the number of candidates.\n\t#[pallet::storage]\n\t#[pallet::getter(fn candidate_pool)]\n\tpub(crate) type CandidatePool\u003cT: Config\u003e = CountedStorageMap\u003c\n\t\t_,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\tCandidate\u003cT::AccountId, BalanceOf\u003cT\u003e, T::MaxDelegatorsPerCollator\u003e,\n\t\tOptionQuery,\n\t\u003e;\n\n\t/// Total funds locked to back the currently selected collators.\n\t/// The sum of all collator and their delegator stakes.\n\t///\n\t/// Note: There are more funds locked by this pallet, since the backing for\n\t/// non collating candidates is not included in [TotalCollatorStake].\n\t#[pallet::storage]\n\t#[pallet::getter(fn total_collator_stake)]\n\tpub(crate) type TotalCollatorStake\u003cT: Config\u003e =\n\t\tStorageValue\u003c_, TotalStake\u003cBalanceOf\u003cT\u003e\u003e, ValueQuery\u003e;\n\n\t/// The collator candidates with the highest amount of stake.\n\t///\n\t/// Each time the stake of a collator is increased, it is checked whether\n\t/// this pushes another candidate out of the list. When the stake is\n\t/// reduced however, it is not checked if another candidate has more stake,\n\t/// since this would require iterating over the entire [CandidatePool].\n\t///\n\t/// There must always be more candidates than [MaxSelectedCandidates] so\n\t/// that a collator can drop out of the collator set by reducing their\n\t/// stake.\n\t#[pallet::storage]\n\t#[pallet::getter(fn top_candidates)]\n\tpub(crate) type TopCandidates\u003cT: Config\u003e = StorageValue\u003c\n\t\t_,\n\t\tOrderedSet\u003cStake\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e, T::MaxTopCandidates\u003e,\n\t\tValueQuery,\n\t\u003e;\n\n\t/// Inflation configuration.\n\t#[pallet::storage]\n\t#[pallet::getter(fn inflation_config)]\n\tpub(crate) type InflationConfig\u003cT: Config\u003e = StorageValue\u003c_, InflationInfo, ValueQuery\u003e;\n\n\t/// The funds waiting to be unstaked.\n\t///\n\t/// It maps from accounts to all the funds addressed to them in the future\n\t/// blocks.\n\t#[pallet::storage]\n\t#[pallet::getter(fn unstaking)]\n\tpub(crate) type Unstaking\u003cT: Config\u003e = StorageMap\u003c\n\t\t_,\n\t\tTwox64Concat,\n\t\tT::AccountId,\n\t\tBoundedBTreeMap\u003cT::BlockNumber, BalanceOf\u003cT\u003e, T::MaxUnstakeRequests\u003e,\n\t\tValueQuery,\n\t\u003e;\n\n\t/// The maximum amount a collator candidate can stake.\n\t#[pallet::storage]\n\t#[pallet::getter(fn max_candidate_stake)]\n\tpub(crate) type MaxCollatorCandidateStake\u003cT: Config\u003e =\n\t\tStorageValue\u003c_, BalanceOf\u003cT\u003e, ValueQuery\u003e;\n\n\t/// The year in which the last automatic reduction of the reward rates\n\t/// occurred.\n\t///\n\t/// It starts at zero at genesis and increments by one every BLOCKS_PER_YEAR\n\t/// many blocks.\n\t#[pallet::storage]\n\t#[pallet::getter(fn last_reward_reduction)]\n\tpub(crate) type LastRewardReduction\u003cT: Config\u003e = StorageValue\u003c_, T::BlockNumber, ValueQuery\u003e;\n\n\t/// The counter of accumulated rewards for an account.\n\t///\n\t/// For collators, it reflects the number of authored blocks since the last\n\t/// reward raise. Thus, everytime a collator authors a block, the\n\t/// counter is increased. It is reset, when the collator increments their\n\t/// rewards.\n\t///\n\t/// For delegators, it is used to determine the difference between the\n\t/// delegator and corresponding collator when incrementing the delegator's\n\t/// rewards. In this case, the counter is never incremented but reset to the\n\t/// collator one when the delegator reward increment happens.\n\t// TODO: Maybe rather use u64. Assuming 30 validators, u32 would suffice for 27 years of constant 12s blocktime.\n\t#[pallet::storage]\n\t#[pallet::getter(fn reward_count)]\n\tpub(crate) type RewardCount\u003cT: Config\u003e =\n\t\tStorageMap\u003c_, Twox64Concat, T::AccountId, u32, ValueQuery\u003e;\n\n\t/// The accumulated rewards for collator candidates and delegators.\n\t///\n\t/// It maps from accounts to their total rewards since the last payout.\n\t#[pallet::storage]\n\t#[pallet::getter(fn rewards)]\n\tpub(crate) type Rewards\u003cT: Config\u003e =\n\t\tStorageMap\u003c_, Twox64Concat, T::AccountId, BalanceOf\u003cT\u003e, ValueQuery\u003e;\n\n\tpub type GenesisStaker\u003cT\u003e = Vec\u003c(\n\t\t\u003cT as frame_system::Config\u003e::AccountId,\n\t\tOption\u003c\u003cT as frame_system::Config\u003e::AccountId\u003e,\n\t\tBalanceOf\u003cT\u003e,\n\t)\u003e;\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn new_round_forced)]\n\tpub(crate) type ForceNewRound\u003cT: Config\u003e = StorageValue\u003c_, bool, ValueQuery\u003e;\n\n\t#[pallet::genesis_config]\n\tpub struct GenesisConfig\u003cT: Config\u003e {\n\t\tpub stakers: GenesisStaker\u003cT\u003e,\n\t\tpub inflation_config: InflationInfo,\n\t\tpub max_candidate_stake: BalanceOf\u003cT\u003e,\n\t\tpub max_selected_candidates: u32,\n\t}\n\n\t#[cfg(feature = \"std\")]\n\timpl\u003cT: Config\u003e Default for GenesisConfig\u003cT\u003e {\n\t\tfn default() -\u003e Self {\n\t\t\tSelf {\n\t\t\t\tstakers: Default::default(),\n\t\t\t\tinflation_config: Default::default(),\n\t\t\t\tmax_candidate_stake: Default::default(),\n\t\t\t\tmax_selected_candidates: Default::default(),\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::genesis_build]\n\timpl\u003cT: Config\u003e GenesisBuild\u003cT\u003e for GenesisConfig\u003cT\u003e {\n\t\tfn build(\u0026self) {\n\t\t\tassert!(\n\t\t\t\tself.inflation_config.is_valid(T::BLOCKS_PER_YEAR.saturated_into()),\n\t\t\t\t\"Invalid inflation configuration\"\n\t\t\t);\n\n\t\t\tInflationConfig::\u003cT\u003e::put(self.inflation_config.clone());\n\t\t\tMaxCollatorCandidateStake::\u003cT\u003e::put(self.max_candidate_stake);\n\n\t\t\t// Setup delegate \u0026 collators\n\t\t\tfor \u0026(ref actor, ref opt_val, balance) in \u0026self.stakers {\n\t\t\t\tassert!(\n\t\t\t\t\tT::Currency::free_balance(actor) \u003e= balance,\n\t\t\t\t\t\"Account does not have enough balance to stake.\"\n\t\t\t\t);\n\t\t\t\tif let Some(delegated_val) = opt_val {\n\t\t\t\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_delegators(\n\t\t\t\t\t\tT::RuntimeOrigin::from(Some(actor.clone()).into()),\n\t\t\t\t\t\tT::Lookup::unlookup(delegated_val.clone()),\n\t\t\t\t\t\tbalance,\n\t\t\t\t\t));\n\t\t\t\t} else {\n\t\t\t\t\tassert_ok!(\u003cPallet\u003cT\u003e\u003e::join_candidates(\n\t\t\t\t\t\tT::RuntimeOrigin::from(Some(actor.clone()).into()),\n\t\t\t\t\t\tbalance\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Set total selected candidates to minimum config\n\t\t\tMaxSelectedCandidates::\u003cT\u003e::put(\n\t\t\t\tself.max_selected_candidates.max(T::MinCollators::get()),\n\t\t\t);\n\n\t\t\t\u003cPallet\u003cT\u003e\u003e::update_total_stake();\n\n\t\t\t// Start Round 0 at Block 0\n\t\t\tlet round: RoundInfo\u003cT::BlockNumber\u003e =\n\t\t\t\tRoundInfo::new(0u32, 0u32.into(), T::DefaultBlocksPerRound::get());\n\t\t\t\u003cRound\u003cT\u003e\u003e::put(round);\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Forces the start of the new round in the next block.\n\t\t///\n\t\t/// The new round will be enforced via \u003cT as\n\t\t/// ShouldEndSession\u003c_\u003e\u003e::should_end_session.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::force_new_round())]\n\t\tpub fn force_new_round(origin: OriginFor\u003cT\u003e) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\n\t\t\t// set force_new_round handle which, at the start of the next block, will\n\t\t\t// trigger `should_end_session` in `Session::on_initialize` and update the\n\t\t\t// current round\n\t\t\t\u003cForceNewRound\u003cT\u003e\u003e::put(true);\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Set the annual inflation rate to derive per-round inflation.\n\t\t///\n\t\t/// The inflation details are considered valid if the annual reward rate\n\t\t/// is approximately the per-block reward rate multiplied by the\n\t\t/// estimated* total number of blocks per year.\n\t\t///\n\t\t/// The estimated average block time is twelve seconds.\n\t\t///\n\t\t/// NOTE: Iterates over CandidatePool for each candidate over their\n\t\t/// delegators to set rewards. Needs to be improved when scaling up\n\t\t/// `MaxTopCandidates`.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t///\n\t\t/// Emits `RoundInflationSet`.\n\t\t#[pallet::call_index(1)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::set_inflation(T::MaxTopCandidates::get(), T::MaxDelegatorsPerCollator::get()))]\n\t\tpub fn set_inflation(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcollator_max_rate_percentage: Perquintill,\n\t\t\tcollator_annual_reward_rate_percentage: Perquintill,\n\t\t\tdelegator_max_rate_percentage: Perquintill,\n\t\t\tdelegator_annual_reward_rate_percentage: Perquintill,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_root(origin)?;\n\n\t\t\tlet inflation = InflationInfo::new(\n\t\t\t\tT::BLOCKS_PER_YEAR.saturated_into(),\n\t\t\t\tcollator_max_rate_percentage,\n\t\t\t\tcollator_annual_reward_rate_percentage,\n\t\t\t\tdelegator_max_rate_percentage,\n\t\t\t\tdelegator_annual_reward_rate_percentage,\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tinflation.is_valid(T::BLOCKS_PER_YEAR.saturated_into()),\n\t\t\t\tError::\u003cT\u003e::InvalidSchedule\n\t\t\t);\n\n\t\t\t// set rewards for all collators and delegators due\n\t\t\tlet mut num_delegators = 0;\n\t\t\tCandidatePool::\u003cT\u003e::iter().for_each(|(id, state)| {\n\t\t\t\tnum_delegators = num_delegators.max(Self::do_inc_collator_reward(\u0026id, state.stake));\n\t\t\t});\n\n\t\t\tSelf::deposit_event(Event::RoundInflationSet(\n\t\t\t\tinflation.collator.max_rate,\n\t\t\t\tinflation.collator.reward_rate.per_block,\n\t\t\t\tinflation.delegator.max_rate,\n\t\t\t\tinflation.delegator.reward_rate.per_block,\n\t\t\t));\n\t\t\tInflationConfig::\u003cT\u003e::put(inflation);\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::set_inflation(\n\t\t\t\tCandidatePool::\u003cT\u003e::count(),\n\t\t\t\tnum_delegators.saturated_into(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Set the maximum number of collator candidates that can be selected\n\t\t/// at the beginning of each validation round.\n\t\t///\n\t\t/// Changes are not applied until the start of the next round.\n\t\t///\n\t\t/// The new value must be higher than the minimum allowed as set in the\n\t\t/// pallet's configuration.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t///\n\t\t/// Emits `MaxSelectedCandidatesSet`.\n\t\t#[pallet::call_index(2)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::set_max_selected_candidates(\n\t\t\t*new,\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn set_max_selected_candidates(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tnew: u32,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_root(origin)?;\n\t\t\tensure!(new \u003e= T::MinCollators::get(), Error::\u003cT\u003e::CannotSetBelowMin);\n\t\t\tensure!(new \u003c= T::MaxTopCandidates::get(), Error::\u003cT\u003e::CannotSetAboveMax);\n\t\t\tlet old = MaxSelectedCandidates::\u003cT\u003e::get();\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tMaxSelectedCandidates::\u003cT\u003e::put(new);\n\n\t\t\t// Update total amount at stake for new top collators and their delegators\n\t\t\tlet start = old.min(new);\n\t\t\tlet end = old.max(new);\n\n\t\t\t// The slice [start, end] contains the added or removed collators. We sum up\n\t\t\t// their stake to adjust the total stake.\n\t\t\tlet (diff_collation, diff_delegation, num_delegators) = TopCandidates::\u003cT\u003e::get()\n\t\t\t\t.into_iter()\n\t\t\t\t.skip(start.saturated_into())\n\t\t\t\t// SAFETY: we ensured that end \u003e start further above.\n\t\t\t\t.take((end - start).saturated_into())\n\t\t\t\t.filter_map(|candidate| CandidatePool::\u003cT\u003e::get(\u0026candidate.owner))\n\t\t\t\t.map(|state| {\n\t\t\t\t\t(\n\t\t\t\t\t\tstate.stake,\n\t\t\t\t\t\t// SAFETY: the total is always more than the stake\n\t\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t\t\tstate.delegators.len().saturated_into::\u003cu32\u003e(),\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.reduce(|a, b| (a.0.saturating_add(b.0), a.1.saturating_add(b.1), a.2.max(b.2)))\n\t\t\t\t.unwrap_or((BalanceOf::\u003cT\u003e::zero(), BalanceOf::\u003cT\u003e::zero(), 0u32));\n\n\t\t\tTotalCollatorStake::\u003cT\u003e::mutate(|total| {\n\t\t\t\tif new \u003e old {\n\t\t\t\t\ttotal.collators = total.collators.saturating_add(diff_collation);\n\t\t\t\t\ttotal.delegators = total.delegators.saturating_add(diff_delegation);\n\t\t\t\t} else {\n\t\t\t\t\ttotal.collators = total.collators.saturating_sub(diff_collation);\n\t\t\t\t\ttotal.delegators = total.delegators.saturating_sub(diff_delegation);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tSelf::deposit_event(Event::MaxSelectedCandidatesSet(old, new));\n\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::set_max_selected_candidates(\n\t\t\t\t// SAFETY: we ensured that end \u003e start further above.\n\t\t\t\tend - start,\n\t\t\t\tnum_delegators,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Set the number of blocks each validation round lasts.\n\t\t///\n\t\t/// If the new value is less than the length of the current round, the\n\t\t/// system will immediately move to the next round in the next block.\n\t\t///\n\t\t/// The new value must be higher than the minimum allowed as set in the\n\t\t/// pallet's configuration.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t///\n\t\t/// Emits `BlocksPerRoundSet`.\n\t\t#[pallet::call_index(3)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::set_blocks_per_round())]\n\t\tpub fn set_blocks_per_round(origin: OriginFor\u003cT\u003e, new: T::BlockNumber) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\t\t\tensure!(new \u003e= T::MinBlocksPerRound::get(), Error::\u003cT\u003e::CannotSetBelowMin);\n\n\t\t\tlet old_round = \u003cRound\u003cT\u003e\u003e::get();\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\t\u003cRound\u003cT\u003e\u003e::put(RoundInfo { length: new, ..old_round });\n\n\t\t\tSelf::deposit_event(Event::BlocksPerRoundSet(\n\t\t\t\told_round.current,\n\t\t\t\told_round.first,\n\t\t\t\told_round.length,\n\t\t\t\tnew,\n\t\t\t));\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Set the maximal amount a collator can stake. Existing stakes are not\n\t\t/// changed.\n\t\t///\n\t\t/// The dispatch origin must be Root.\n\t\t///\n\t\t/// Emits `MaxCandidateStakeChanged`.\n\t\t#[pallet::call_index(4)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::set_max_candidate_stake())]\n\t\tpub fn set_max_candidate_stake(origin: OriginFor\u003cT\u003e, new: BalanceOf\u003cT\u003e) -\u003e DispatchResult {\n\t\t\tensure_root(origin)?;\n\t\t\tensure!(new \u003e= T::MinCollatorCandidateStake::get(), Error::\u003cT\u003e::CannotSetBelowMin);\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tMaxCollatorCandidateStake::\u003cT\u003e::put(new);\n\n\t\t\tSelf::deposit_event(Event::MaxCandidateStakeChanged(new));\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Forcedly removes a collator candidate from the TopCandidates and\n\t\t/// clears all associated storage for the candidate and their\n\t\t/// delegators.\n\t\t///\n\t\t/// Prepares unstaking of the candidates and their delegators stake\n\t\t/// which can be unlocked via `unlock_unstaked` after waiting at\n\t\t/// least `StakeDuration` many blocks. Also increments rewards for the\n\t\t/// collator and their delegators.\n\t\t///\n\t\t/// Increments rewards of candidate and their delegators.\n\t\t///\n\t\t/// Emits `CandidateRemoved`.\n\t\t#[pallet::call_index(5)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::force_remove_candidate(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn force_remove_candidate(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcollator: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_root(origin)?;\n\t\t\tlet collator = T::Lookup::lookup(collator)?;\n\t\t\tlet state = CandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tlet total_amount = state.total;\n\n\t\t\tlet mut candidates = TopCandidates::\u003cT\u003e::get();\n\t\t\tensure!(\n\t\t\t\tcandidates.len().saturated_into::\u003cu32\u003e() \u003e T::MinRequiredCollators::get(),\n\t\t\t\tError::\u003cT\u003e::TooFewCollatorCandidates\n\t\t\t);\n\n\t\t\t// *** No Fail except during remove_candidate beyond this point ***\n\n\t\t\t// remove candidate storage and increment rewards\n\t\t\tSelf::remove_candidate(\u0026collator, \u0026state)?;\n\n\t\t\tlet (num_collators, num_delegators) = if candidates\n\t\t\t\t.remove(\u0026Stake { owner: collator.clone(), amount: state.total })\n\t\t\t\t.is_some()\n\t\t\t{\n\t\t\t\t// update top candidates\n\t\t\t\tTopCandidates::\u003cT\u003e::put(candidates);\n\t\t\t\t// update total amount at stake from scratch\n\t\t\t\tSelf::update_total_stake()\n\t\t\t} else {\n\t\t\t\t(0u32, 0u32)\n\t\t\t};\n\n\t\t\tSelf::deposit_event(Event::CollatorRemoved(collator, total_amount));\n\n\t\t\tOk(Some(\u003cT as Config\u003e::WeightInfo::force_remove_candidate(\n\t\t\t\tnum_collators,\n\t\t\t\tnum_delegators,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Join the set of collator candidates.\n\t\t///\n\t\t/// In the next blocks, if the collator candidate has enough funds\n\t\t/// staked to be included in any of the top `MaxSelectedCandidates`\n\t\t/// positions, it will be included in the set of potential authors that\n\t\t/// will be selected by the stake-weighted random selection function.\n\t\t///\n\t\t/// The staked funds of the new collator candidate are added to the\n\t\t/// total stake of the system.\n\t\t///\n\t\t/// The total amount of funds staked must be within the allowed range as\n\t\t/// set in the pallet's configuration.\n\t\t///\n\t\t/// The dispatch origin must not be already part of the collator\n\t\t/// candidates nor of the delegators set.\n\t\t///\n\t\t/// Emits `JoinedCollatorCandidates`.\n\t\t#[pallet::call_index(6)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::join_candidates(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn join_candidates(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tstake: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet sender = ensure_signed(origin)?;\n\t\t\tif let Some(is_active_candidate) = Self::is_active_candidate(\u0026sender) {\n\t\t\t\tensure!(is_active_candidate, Error::\u003cT\u003e::AlreadyLeaving);\n\t\t\t\tensure!(!is_active_candidate, Error::\u003cT\u003e::CandidateExists);\n\t\t\t}\n\t\t\tensure!(!Self::is_delegator(\u0026sender), Error::\u003cT\u003e::DelegatorExists);\n\t\t\tensure!(stake \u003e= T::MinCollatorCandidateStake::get(), Error::\u003cT\u003e::ValStakeBelowMin);\n\t\t\tensure!(stake \u003c= MaxCollatorCandidateStake::\u003cT\u003e::get(), Error::\u003cT\u003e::ValStakeAboveMax);\n\t\t\tensure!(\n\t\t\t\tUnstaking::\u003cT\u003e::get(\u0026sender).len().saturated_into::\u003cu32\u003e() \u003c\n\t\t\t\t\tT::MaxUnstakeRequests::get(),\n\t\t\t\tError::\u003cT\u003e::CannotJoinBeforeUnlocking\n\t\t\t);\n\n\t\t\t// *** No Fail except during increase_lock beyond this point ***\n\n\t\t\tSelf::increase_lock(\u0026sender, stake, BalanceOf::\u003cT\u003e::zero())?;\n\n\t\t\tlet candidate = Candidate::new(sender.clone(), stake);\n\t\t\tlet n = Self::update_top_candidates(\n\t\t\t\tsender.clone(),\n\t\t\t\tBalanceOf::\u003cT\u003e::zero(),\n\t\t\t\tBalanceOf::\u003cT\u003e::zero(),\n\t\t\t\tstake,\n\t\t\t\tBalanceOf::\u003cT\u003e::zero(),\n\t\t\t);\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026sender, candidate);\n\n\t\t\tSelf::deposit_event(Event::JoinedCollatorCandidates(sender, stake));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::join_candidates(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Request to leave the set of collator candidates.\n\t\t///\n\t\t/// On success, the account is immediately removed from the candidate\n\t\t/// pool to prevent selection as a collator in future validation rounds,\n\t\t/// but unstaking of the funds is executed with a delay of\n\t\t/// `StakeDuration` blocks.\n\t\t///\n\t\t/// The exit request can be reversed by calling\n\t\t/// `cancel_leave_candidates`.\n\t\t///\n\t\t/// This operation affects the pallet's total stake amount. It is\n\t\t/// updated even though the funds of the candidate who signaled to leave\n\t\t/// are still locked for `ExitDelay` + `StakeDuration` more blocks.\n\t\t///\n\t\t/// NOTE 1: Upon starting a new session_i in `new_session`, the current\n\t\t/// top candidates are selected to be block authors for session_i+1. Any\n\t\t/// changes to the top candidates afterwards do not effect the set of\n\t\t/// authors for session_i+1.\n\t\t/// Thus, we have to make sure none of these collators can\n\t\t/// leave before session_i+1 ends by delaying their\n\t\t/// exit for `ExitDelay` many blocks.\n\t\t///\n\t\t/// NOTE 2: We do not increment rewards in this extrinsic as the\n\t\t/// candidate could still author blocks, and thus be eligible to receive\n\t\t/// rewards, until the end of the next session.\n\t\t///\n\t\t/// Emits `CollatorScheduledExit`.\n\t\t#[pallet::call_index(7)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::init_leave_candidates(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxTopCandidates::get().saturating_mul(T::MaxDelegatorsPerCollator::get())\n\t\t))]\n\t\tpub fn init_leave_candidates(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet collator = ensure_signed(origin)?;\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!state.is_leaving(), Error::\u003cT\u003e::AlreadyLeaving);\n\t\t\tlet mut candidates = TopCandidates::\u003cT\u003e::get();\n\t\t\tensure!(\n\t\t\t\tcandidates.len().saturated_into::\u003cu32\u003e() \u003e T::MinRequiredCollators::get(),\n\t\t\t\tError::\u003cT\u003e::TooFewCollatorCandidates\n\t\t\t);\n\n\t\t\tlet now = \u003cRound\u003cT\u003e\u003e::get().current;\n\t\t\tlet when = now.saturating_add(T::ExitQueueDelay::get());\n\t\t\tstate.leave_candidates(when);\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tlet (num_collators, num_delegators) = if candidates\n\t\t\t\t.remove(\u0026Stake { owner: collator.clone(), amount: state.total })\n\t\t\t\t.is_some()\n\t\t\t{\n\t\t\t\t// update top candidates\n\t\t\t\tTopCandidates::\u003cT\u003e::put(candidates);\n\t\t\t\tSelf::deposit_event(Event::LeftTopCandidates(collator.clone()));\n\t\t\t\t// update total amount at stake from scratch\n\t\t\t\tSelf::update_total_stake()\n\t\t\t} else {\n\t\t\t\t(0u32, 0u32)\n\t\t\t};\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\n\t\t\tSelf::deposit_event(Event::CollatorScheduledExit(now, collator, when));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::init_leave_candidates(\n\t\t\t\tnum_collators,\n\t\t\t\tnum_delegators,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Execute the network exit of a candidate who requested to leave at\n\t\t/// least `ExitQueueDelay` rounds ago. Prepares unstaking of the\n\t\t/// candidates and their delegators stake which can be unlocked via\n\t\t/// `unlock_unstaked` after waiting at least `StakeDuration` many\n\t\t/// blocks.\n\t\t///\n\t\t/// Requires the candidate to previously have called\n\t\t/// `init_leave_candidates`.\n\t\t///\n\t\t/// The exit request can be reversed by calling\n\t\t/// `cancel_leave_candidates`.\n\t\t///\n\t\t/// NOTE: Iterates over CandidatePool for each candidate over their\n\t\t/// delegators to set rewards. Needs to be improved when scaling up\n\t\t/// `MaxTopCandidates`.\n\t\t///\n\t\t/// Emits `CollatorLeft`.\n\t\t#[pallet::call_index(8)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::execute_leave_candidates(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t))]\n\t\tpub fn execute_leave_candidates(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcollator: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_signed(origin)?;\n\t\t\tlet collator = T::Lookup::lookup(collator)?;\n\t\t\tlet state = CandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(state.is_leaving(), Error::\u003cT\u003e::NotLeaving);\n\t\t\tensure!(state.can_exit(\u003cRound\u003cT\u003e\u003e::get().current), Error::\u003cT\u003e::CannotLeaveYet);\n\n\t\t\tlet num_delegators = state.delegators.len().saturated_into::\u003cu32\u003e();\n\t\t\tlet total_amount = state.total;\n\n\t\t\t// *** No Fail except during remove_candidate beyond this point ***\n\n\t\t\t// remove candidate storage and increment rewards\n\t\t\tSelf::remove_candidate(\u0026collator, \u0026state)?;\n\n\t\t\tSelf::deposit_event(Event::CandidateLeft(collator, total_amount));\n\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::execute_leave_candidates(\n\t\t\t\tT::MaxTopCandidates::get(),\n\t\t\t\tnum_delegators,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Revert the previously requested exit of the network of a collator\n\t\t/// candidate. On success, adds back the candidate to the TopCandidates\n\t\t/// and updates the collators.\n\t\t///\n\t\t/// Requires the candidate to previously have called\n\t\t/// `init_leave_candidates`.\n\t\t///\n\t\t/// Emits `CollatorCanceledExit`.\n\t\t#[pallet::call_index(9)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::cancel_leave_candidates(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t))]\n\t\tpub fn cancel_leave_candidates(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet candidate = ensure_signed(origin)?;\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026candidate).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(state.is_leaving(), Error::\u003cT\u003e::NotLeaving);\n\n\t\t\t// revert leaving state\n\t\t\tstate.revert_leaving();\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tlet n = Self::update_top_candidates(\n\t\t\t\tcandidate.clone(),\n\t\t\t\tstate.stake,\n\t\t\t\t// safe because total \u003e= stake\n\t\t\t\tstate.total - state.stake,\n\t\t\t\tstate.stake,\n\t\t\t\tstate.total - state.stake,\n\t\t\t);\n\n\t\t\t// update candidates for next round\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026candidate, state);\n\n\t\t\tSelf::deposit_event(Event::CollatorCanceledExit(candidate));\n\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::cancel_leave_candidates(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Stake more funds for a collator candidate.\n\t\t///\n\t\t/// If not in the set of candidates, staking enough funds allows the\n\t\t/// account to be added to it. The larger amount of funds, the higher\n\t\t/// chances to be selected as the author of the next block.\n\t\t///\n\t\t/// This operation affects the pallet's total stake amount.\n\t\t///\n\t\t/// The resulting total amount of funds staked must be within the\n\t\t/// allowed range as set in the pallet's configuration.\n\t\t///\n\t\t/// Emits `CollatorStakedMore`.\n\t\t#[pallet::call_index(10)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::candidate_stake_more(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\tT::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e()\n\t\t))]\n\t\tpub fn candidate_stake_more(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tmore: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet collator = ensure_signed(origin)?;\n\n\t\t\tensure!(!more.is_zero(), Error::\u003cT\u003e::ValStakeZero);\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!state.is_leaving(), Error::\u003cT\u003e::CannotStakeIfLeaving);\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: before_stake, total: before_total, .. } = state;\n\t\t\tstate.stake_more(more);\n\t\t\tlet after_stake = state.stake;\n\t\t\tensure!(\n\t\t\t\tstate.stake \u003c= MaxCollatorCandidateStake::\u003cT\u003e::get(),\n\t\t\t\tError::\u003cT\u003e::ValStakeAboveMax\n\t\t\t);\n\n\t\t\t// *** No Fail except during increase_lock beyond this point ***\n\n\t\t\tlet unstaking_len = Self::increase_lock(\u0026collator, state.stake, more)?;\n\n\t\t\tlet n = if state.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcollator.clone(),\n\t\t\t\t\tbefore_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\tbefore_total - before_stake,\n\t\t\t\t\tstate.stake,\n\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\n\t\t\t// increment rewards for origin + their delegators and reset reward counter\n\t\t\tSelf::do_inc_collator_reward(\u0026collator, before_stake);\n\n\t\t\tSelf::deposit_event(Event::CollatorStakedMore(collator, before_stake, after_stake));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::candidate_stake_more(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t\tunstaking_len,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Stake less funds for a collator candidate.\n\t\t///\n\t\t/// If the new amount of staked fund is not large enough, the account\n\t\t/// could be removed from the set of collator candidates and not be\n\t\t/// considered for authoring the next blocks.\n\t\t///\n\t\t/// This operation affects the pallet's total stake amount.\n\t\t///\n\t\t/// The unstaked funds are not released immediately to the account, but\n\t\t/// they will be available after `StakeDuration` blocks.\n\t\t///\n\t\t/// The resulting total amount of funds staked must be within the\n\t\t/// allowed range as set in the pallet's configuration.\n\t\t///\n\t\t/// Emits `CollatorStakedLess`.\n\t\t#[pallet::call_index(11)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::candidate_stake_less(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn candidate_stake_less(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tless: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet collator = ensure_signed(origin)?;\n\t\t\tensure!(!less.is_zero(), Error::\u003cT\u003e::ValStakeZero);\n\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!state.is_leaving(), Error::\u003cT\u003e::CannotStakeIfLeaving);\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: before_stake, total: before_total, .. } = state;\n\t\t\tlet after = state.stake_less(less).ok_or(Error::\u003cT\u003e::Underflow)?;\n\t\t\tensure!(after \u003e= T::MinCollatorCandidateStake::get(), Error::\u003cT\u003e::ValStakeBelowMin);\n\n\t\t\t// *** No Fail except during prep_unstake beyond this point ***\n\n\t\t\t// we don't unlock immediately\n\t\t\tSelf::prep_unstake(\u0026collator, less, false)?;\n\n\t\t\tlet n = if state.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcollator.clone(),\n\t\t\t\t\tbefore_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\tbefore_total - before_stake,\n\t\t\t\t\tstate.stake,\n\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\n\t\t\t// increment rewards for origin + their delegators and reset reward counter\n\t\t\tSelf::do_inc_collator_reward(\u0026collator, before_stake);\n\n\t\t\tSelf::deposit_event(Event::CollatorStakedLess(collator, before_stake, after));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::candidate_stake_less(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Join the set of delegators by delegating to a collator candidate.\n\t\t///\n\t\t/// The account that wants to delegate cannot be part of the collator\n\t\t/// candidates set as well.\n\t\t///\n\t\t/// The caller must _not_ have a delegation. If that is the case, they\n\t\t/// are required to first remove the delegation.\n\t\t///\n\t\t/// The amount staked must be larger than the minimum required to become\n\t\t/// a delegator as set in the pallet's configuration.\n\t\t///\n\t\t/// As only `MaxDelegatorsPerCollator` are allowed to delegate a given\n\t\t/// collator, the amount staked must be larger than the lowest one in\n\t\t/// the current set of delegator for the operation to be meaningful.\n\t\t///\n\t\t/// The collator's total stake as well as the pallet's total stake are\n\t\t/// increased accordingly.\n\t\t///\n\t\t/// Emits `Delegation`.\n\t\t/// Emits `DelegationReplaced` if the candidate has\n\t\t/// `MaxDelegatorsPerCollator` many delegations but this delegator\n\t\t/// staked more than one of the other delegators of this candidate.\n\t\t#[pallet::call_index(12)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::join_delegators(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn join_delegators(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcollator: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet acc = ensure_signed(origin)?;\n\t\t\tlet collator = T::Lookup::lookup(collator)?;\n\n\t\t\t// check balance\n\t\t\tensure!(\n\t\t\t\tpallet_balances::Pallet::\u003cT\u003e::free_balance(acc.clone()) \u003e= amount.into(),\n\t\t\t\tpallet_balances::Error::\u003cT\u003e::InsufficientBalance\n\t\t\t);\n\n\t\t\t// first delegation\n\t\t\tensure!(DelegatorState::\u003cT\u003e::get(\u0026acc).is_none(), Error::\u003cT\u003e::AlreadyDelegating);\n\t\t\tensure!(amount \u003e= T::MinDelegatorStake::get(), Error::\u003cT\u003e::DelegationBelowMin);\n\n\t\t\t// cannot be a collator candidate and delegator with same AccountId\n\t\t\tensure!(Self::is_active_candidate(\u0026acc).is_none(), Error::\u003cT\u003e::CandidateExists);\n\t\t\tensure!(\n\t\t\t\tUnstaking::\u003cT\u003e::get(\u0026acc).len().saturated_into::\u003cu32\u003e() \u003c\n\t\t\t\t\tT::MaxUnstakeRequests::get(),\n\t\t\t\tError::\u003cT\u003e::CannotJoinBeforeUnlocking\n\t\t\t);\n\t\t\t// cannot delegate if number of delegations in this round exceeds\n\t\t\t// MaxDelegationsPerRound\n\t\t\tlet delegation_counter = Self::get_delegation_counter(\u0026acc)?;\n\n\t\t\t// prepare update of collator state\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tlet num_delegations_pre_insertion: u32 = state.delegators.len().saturated_into();\n\n\t\t\tensure!(!state.is_leaving(), Error::\u003cT\u003e::CannotDelegateIfLeaving);\n\t\t\tlet delegation = Stake { owner: acc.clone(), amount };\n\n\t\t\t// attempt to insert delegator and check for uniqueness\n\t\t\t// NOTE: excess is handled below because we support replacing a delegator with\n\t\t\t// fewer stake\n\t\t\tlet insert_delegator = state\n\t\t\t\t.delegators\n\t\t\t\t// we handle TooManyDelegators error below in do_update_delegator\n\t\t\t\t.try_insert(delegation.clone())\n\t\t\t\t.unwrap_or(true);\n\t\t\t// should never fail but let's be safe\n\t\t\tensure!(insert_delegator, Error::\u003cT\u003e::DelegatorExists);\n\n\t\t\tlet delegator_state = Delegator { amount, owner: Some(collator.clone()) };\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: old_stake, total: old_total, .. } = state;\n\n\t\t\t// update state and potentially prepare kicking a delegator with less staked\n\t\t\t// amount (includes setting rewards for kicked delegator)\n\t\t\tlet state = if num_delegations_pre_insertion == T::MaxDelegatorsPerCollator::get() {\n\t\t\t\tSelf::do_update_delegator(delegation, state)?\n\t\t\t} else {\n\t\t\t\tstate.total = state.total.saturating_add(amount);\n\t\t\t\tstate\n\t\t\t};\n\t\t\tlet new_total = state.total;\n\n\t\t\t// *** No Fail except during increase_lock beyond this point ***\n\n\t\t\t// lock stake\n\t\t\tSelf::increase_lock(\u0026acc, amount, BalanceOf::\u003cT\u003e::zero())?;\n\n\t\t\t// update top candidates and total amount at stake\n\t\t\tlet n = if state.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcollator.clone(),\n\t\t\t\t\told_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\told_total - old_stake,\n\t\t\t\t\tstate.stake,\n\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\n\t\t\t// update states\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\t\t\tDelegatorState::\u003cT\u003e::insert(\u0026acc, delegator_state);\n\t\t\t\u003cLastDelegation\u003cT\u003e\u003e::insert(\u0026acc, delegation_counter);\n\n\t\t\t// initiate reward counter to match the current state of the candidate\n\t\t\tRewardCount::\u003cT\u003e::insert(\u0026acc, RewardCount::\u003cT\u003e::get(\u0026collator));\n\n\t\t\tSelf::deposit_event(Event::Delegation(acc, amount, collator, new_total));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::join_delegators(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Leave the set of delegators and, by implication, revoke the ongoing\n\t\t/// delegation.\n\t\t///\n\t\t/// All staked funds are not unlocked immediately, but they are added to\n\t\t/// the queue of pending unstaking, and will effectively be released\n\t\t/// after `StakeDuration` blocks from the moment the delegator leaves.\n\t\t///\n\t\t/// This operation reduces the total stake of the pallet as well as the\n\t\t/// stakes of all collators that were delegated, potentially affecting\n\t\t/// their chances to be included in the set of candidates in the next\n\t\t/// rounds.\n\t\t///\n\t\t/// Automatically increments the accumulated rewards of the origin of\n\t\t/// the current delegation.\n\t\t///\n\t\t/// Emits `DelegatorLeft`.\n\t\t#[pallet::call_index(13)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::leave_delegators(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn leave_delegators(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet acc = ensure_signed(origin)?;\n\t\t\tlet delegator = DelegatorState::\u003cT\u003e::get(\u0026acc).ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\t\t\t// should never throw\n\t\t\tlet collator = delegator.owner.ok_or(Error::\u003cT\u003e::DelegationNotFound)?;\n\t\t\tSelf::delegator_leaves_collator(acc.clone(), collator)?;\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\tDelegatorState::\u003cT\u003e::remove(\u0026acc);\n\n\t\t\tSelf::deposit_event(Event::DelegatorLeft(acc, delegator.amount));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::leave_delegators(\n\t\t\t\t1,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Increase the stake for delegating a collator candidate.\n\t\t///\n\t\t/// If not in the set of candidates, staking enough funds allows the\n\t\t/// collator candidate to be added to it.\n\t\t///\n\t\t/// Emits `DelegatorStakedMore`.\n\t\t#[pallet::call_index(14)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::delegator_stake_more(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\tT::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e())\n\t\t)]\n\t\tpub fn delegator_stake_more(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcandidate: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t\tmore: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet delegator = ensure_signed(origin)?;\n\t\t\tensure!(!more.is_zero(), Error::\u003cT\u003e::ValStakeZero);\n\n\t\t\tlet candidate = T::Lookup::lookup(candidate)?;\n\t\t\tlet mut delegation =\n\t\t\t\tDelegatorState::\u003cT\u003e::get(\u0026delegator).ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\t\t\tlet mut collator =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026candidate).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!collator.is_leaving(), Error::\u003cT\u003e::CannotDelegateIfLeaving);\n\t\t\tlet stake_after = delegation\n\t\t\t\t.inc_delegation(candidate.clone(), more)\n\t\t\t\t.map_err(|_| Error::\u003cT\u003e::DelegationNotFound)?;\n\n\t\t\t// *** No Fail except during increase_lock beyond this point ***\n\n\t\t\t// update lock\n\t\t\tlet unstaking_len = Self::increase_lock(\u0026delegator, stake_after, more)?;\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: before_stake, total: before_total, .. } = collator;\n\t\t\tcollator.inc_delegator(delegator.clone(), more);\n\t\t\tlet after = collator.total;\n\n\t\t\t// update top candidates and total amount at stake\n\t\t\tlet n = if collator.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcandidate.clone(),\n\t\t\t\t\tbefore_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\tbefore_total - before_stake,\n\t\t\t\t\tcollator.stake,\n\t\t\t\t\tcollator.total - collator.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\n\t\t\t// set rewards and reset reward counter\n\t\t\tSelf::do_inc_delegator_reward(\u0026delegator, stake_after.saturating_sub(more), \u0026candidate);\n\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026candidate, collator);\n\t\t\tDelegatorState::\u003cT\u003e::insert(\u0026delegator, delegation);\n\n\t\t\tSelf::deposit_event(Event::DelegatorStakedMore(\n\t\t\t\tdelegator,\n\t\t\t\tcandidate,\n\t\t\t\tbefore_total,\n\t\t\t\tafter,\n\t\t\t));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::delegator_stake_more(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t\tunstaking_len,\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Reduce the stake for delegating a collator candidate.\n\t\t///\n\t\t/// If the new amount of staked fund is not large enough, the collator\n\t\t/// could be removed from the set of collator candidates and not be\n\t\t/// considered for authoring the next blocks.\n\t\t///\n\t\t/// The unstaked funds are not release immediately to the account, but\n\t\t/// they will be available after `StakeDuration` blocks.\n\t\t///\n\t\t/// The remaining staked funds must still be larger than the minimum\n\t\t/// required by this pallet to maintain the status of delegator.\n\t\t///\n\t\t/// The resulting total amount of funds staked must be within the\n\t\t/// allowed range as set in the pallet's configuration.\n\t\t///\n\t\t/// Emits `DelegatorStakedLess`.\n\t\t#[pallet::call_index(15)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::delegator_stake_less(\n\t\t\tT::MaxTopCandidates::get(),\n\t\t\tT::MaxDelegatorsPerCollator::get()\n\t\t))]\n\t\tpub fn delegator_stake_less(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\tcandidate: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t\tless: BalanceOf\u003cT\u003e,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet delegator = ensure_signed(origin)?;\n\t\t\tensure!(!less.is_zero(), Error::\u003cT\u003e::ValStakeZero);\n\n\t\t\tlet candidate = T::Lookup::lookup(candidate)?;\n\t\t\tlet mut delegations =\n\t\t\t\tDelegatorState::\u003cT\u003e::get(\u0026delegator).ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\t\t\tlet mut collator =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026candidate).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\t\t\tensure!(!collator.is_leaving(), Error::\u003cT\u003e::CannotDelegateIfLeaving);\n\t\t\tlet stake_after = delegations\n\t\t\t\t.dec_delegation(candidate.clone(), less)\n\t\t\t\t.map_err(|_| Error::\u003cT\u003e::DelegationNotFound)?\n\t\t\t\t.ok_or(Error::\u003cT\u003e::Underflow)?;\n\n\t\t\tensure!(stake_after \u003e= T::MinDelegatorStake::get(), Error::\u003cT\u003e::DelegationBelowMin);\n\n\t\t\t// *** No Fail except during prep_unstake beyond this point ***\n\n\t\t\tSelf::prep_unstake(\u0026delegator, less, false)?;\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: before_stake, total: before_total, .. } = collator;\n\t\t\tcollator.dec_delegator(delegator.clone(), less);\n\t\t\tlet after = collator.total;\n\n\t\t\t// update top candidates and total amount at stake\n\t\t\tlet n = if collator.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcandidate.clone(),\n\t\t\t\t\tbefore_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\tbefore_total - before_stake,\n\t\t\t\t\tcollator.stake,\n\t\t\t\t\tcollator.total - collator.stake,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t0u32\n\t\t\t};\n\n\t\t\t// set rewards and reset reward counter\n\t\t\tSelf::do_inc_delegator_reward(\u0026delegator, stake_after.saturating_add(less), \u0026candidate);\n\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026candidate, collator);\n\t\t\tDelegatorState::\u003cT\u003e::insert(\u0026delegator, delegations);\n\n\t\t\tSelf::deposit_event(Event::DelegatorStakedLess(\n\t\t\t\tdelegator,\n\t\t\t\tcandidate,\n\t\t\t\tbefore_total,\n\t\t\t\tafter,\n\t\t\t));\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::delegator_stake_less(\n\t\t\t\tn,\n\t\t\t\tT::MaxDelegatorsPerCollator::get(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Unlock all previously staked funds that are now available for\n\t\t/// unlocking by the origin account after `StakeDuration` blocks have\n\t\t/// elapsed.\n\t\t///\n\t\t/// Weight: O(U) where U is the number of locked unstaking requests\n\t\t/// bounded by `MaxUnstakeRequests`.\n\t\t/// - Reads: [Origin Account], Unstaking, Locks\n\t\t/// - Writes: Unstaking, Locks\n\t\t/// - Kills: Unstaking \u0026 Locks if no balance is locked anymore\n\t\t/// # \u003c/weight\u003e\n\t\t#[pallet::call_index(16)]\n\t\t#[pallet::weight(\u003cT as pallet::Config\u003e::WeightInfo::unlock_unstaked(\n\t\t\tT::MaxUnstakeRequests::get().saturated_into::\u003cu32\u003e()\n\t\t))]\n\t\tpub fn unlock_unstaked(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\ttarget: \u003cT::Lookup as StaticLookup\u003e::Source,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_signed(origin)?;\n\t\t\tlet target = T::Lookup::lookup(target)?;\n\n\t\t\tlet unstaking_len = Self::do_unlock(\u0026target)?;\n\n\t\t\tOk(Some(\u003cT as pallet::Config\u003e::WeightInfo::unlock_unstaked(unstaking_len)).into())\n\t\t}\n\n\t\t/// Claim block authoring rewards for the target address.\n\t\t///\n\t\t/// Requires `Rewards` to be set beforehand, which can by triggered by\n\t\t/// any of the following options\n\t\t/// * Calling increment_{collator, delegator}_rewards (active)\n\t\t/// * Altering your stake (active)\n\t\t/// * Leaving the network as a collator (active)\n\t\t/// * Revoking a delegation as a delegator (active)\n\t\t/// * Being a delegator whose collator left the network, altered their\n\t\t///   stake or incremented rewards (passive)\n\t\t///\n\t\t/// The dispatch origin can be any signed one, e.g., anyone can claim\n\t\t/// for anyone.\n\t\t///\n\t\t/// Emits `Rewarded`.\n\t\t#[pallet::call_index(17)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::claim_rewards())]\n\t\tpub fn claim_rewards(origin: OriginFor\u003cT\u003e) -\u003e DispatchResult {\n\t\t\tlet target = ensure_signed(origin)?;\n\n\t\t\t// we could kill the storage entry but let's be safe in case the deposit fails\n\t\t\tlet rewards = Rewards::\u003cT\u003e::get(\u0026target);\n\t\t\tensure!(!rewards.is_zero(), Error::\u003cT\u003e::RewardsNotFound);\n\n\t\t\t// mint into target and reset rewards\n\t\t\tlet rewards = T::Currency::deposit_into_existing(\u0026target, rewards)?;\n\t\t\tRewards::\u003cT\u003e::remove(\u0026target);\n\n\t\t\tSelf::deposit_event(Event::Rewarded(target, rewards.peek()));\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Actively increment the rewards of a collator and their delegators.\n\t\t///\n\t\t/// The same effect is triggered by changing the stake or leaving the\n\t\t/// network.\n\t\t///\n\t\t/// The dispatch origin must be a collator.\n\t\t#[pallet::call_index(18)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::increment_collator_rewards(T::MaxDelegatorsPerCollator::get()))]\n\t\tpub fn increment_collator_rewards(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tlet collator = ensure_signed(origin)?;\n\t\t\tlet state = CandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\n\t\t\t// early exit\n\t\t\tlet reward_count = RewardCount::\u003cT\u003e::get(\u0026collator);\n\t\t\tensure!(!reward_count.is_zero(), Error::\u003cT\u003e::RewardsNotFound);\n\n\t\t\tlet num_delegators = Self::do_inc_collator_reward(\u0026collator, state.stake);\n\t\t\tOk(Some(\u003cT as Config\u003e::WeightInfo::increment_collator_rewards(\n\t\t\t\tnum_delegators.saturated_into(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\n\t\t/// Actively increment the rewards of a delegator for all their\n\t\t/// delegations.\n\t\t///\n\t\t/// The same effect is triggered by changing the stake or revoking\n\t\t/// delegations.\n\t\t///\n\t\t/// The dispatch origin must be a delegator.\n\t\t#[pallet::call_index(19)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::increment_delegator_rewards())]\n\t\tpub fn increment_delegator_rewards(origin: OriginFor\u003cT\u003e) -\u003e DispatchResult {\n\t\t\tlet delegator = ensure_signed(origin)?;\n\t\t\tlet delegation =\n\t\t\t\tDelegatorState::\u003cT\u003e::get(\u0026delegator).ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\t\t\t// should never throw\n\t\t\tlet collator = delegation.owner.ok_or(Error::\u003cT\u003e::DelegationNotFound)?;\n\n\t\t\tSelf::do_inc_delegator_reward(\u0026delegator, delegation.amount, \u0026collator);\n\t\t\tensure!(!Rewards::\u003cT\u003e::get(\u0026delegator).is_zero(), Error::\u003cT\u003e::RewardsNotFound);\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Executes the annual reduction of the reward rates for collators and\n\t\t/// delegators. Moreover, sets rewards for all collators and delegators\n\t\t/// before adjusting the inflation.\n\t\t///\n\t\t/// Emits `RoundInflationSet`.\n\t\t#[pallet::call_index(20)]\n\t\t#[pallet::weight(\u003cT as Config\u003e::WeightInfo::execute_scheduled_reward_change(T::MaxTopCandidates::get(), T::MaxDelegatorsPerCollator::get()))]\n\t\tpub fn execute_scheduled_reward_change(origin: OriginFor\u003cT\u003e) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_signed(origin)?;\n\n\t\t\tlet now = frame_system::Pallet::\u003cT\u003e::block_number();\n\t\t\tlet year = now / T::BLOCKS_PER_YEAR;\n\t\t\tlet last_update = LastRewardReduction::\u003cT\u003e::get();\n\n\t\t\tensure!(year \u003e last_update, Error::\u003cT\u003e::TooEarly);\n\n\t\t\t// Calculate new inflation based on last year\n\t\t\tlet inflation = InflationConfig::\u003cT\u003e::get();\n\n\t\t\tlet c_reward_rate =\n\t\t\t\tinflation.collator.reward_rate.annual * T::CollatorRewardRateDecay::get();\n\t\t\t// delegator reward rate should be 6% in 2nd year and 0% afterwards\n\t\t\tlet d_reward_rate = if year == T::BlockNumber::one() {\n\t\t\t\t// Amplitude: this value differs from the original\n\t\t\t\tPerquintill::from_percent(7)\n\t\t\t} else {\n\t\t\t\tPerquintill::zero()\n\t\t\t};\n\t\t\tlet new_inflation = InflationInfo::new(\n\t\t\t\tT::BLOCKS_PER_YEAR.saturated_into(),\n\t\t\t\tinflation.collator.max_rate,\n\t\t\t\tc_reward_rate,\n\t\t\t\tinflation.delegator.max_rate,\n\t\t\t\td_reward_rate,\n\t\t\t);\n\t\t\t// should never fail\n\t\t\tensure!(\n\t\t\t\tnew_inflation.is_valid(T::BLOCKS_PER_YEAR.saturated_into()),\n\t\t\t\tError::\u003cT\u003e::InvalidSchedule\n\t\t\t);\n\n\t\t\t// set rewards for all collators and delegators before updating reward rates\n\t\t\tlet mut max_num_delegators = 0;\n\t\t\tCandidatePool::\u003cT\u003e::iter().for_each(|(id, state)| {\n\t\t\t\tmax_num_delegators =\n\t\t\t\t\tmax_num_delegators.max(Self::do_inc_collator_reward(\u0026id, state.stake));\n\t\t\t});\n\n\t\t\t// update inflation config\n\t\t\tInflationConfig::\u003cT\u003e::put(new_inflation.clone());\n\t\t\tLastRewardReduction::\u003cT\u003e::put(year);\n\t\t\tSelf::deposit_event(Event::RoundInflationSet(\n\t\t\t\tnew_inflation.collator.max_rate,\n\t\t\t\tnew_inflation.collator.reward_rate.per_block,\n\t\t\t\tnew_inflation.delegator.max_rate,\n\t\t\t\tnew_inflation.delegator.reward_rate.per_block,\n\t\t\t));\n\n\t\t\tOk(Some(\u003cT as Config\u003e::WeightInfo::execute_scheduled_reward_change(\n\t\t\t\tCandidatePool::\u003cT\u003e::count(),\n\t\t\t\tmax_num_delegators.saturated_into(),\n\t\t\t))\n\t\t\t.into())\n\t\t}\n\t}\n\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t/// Check whether an account is currently delegating.\n\t\tpub fn is_delegator(acc: \u0026T::AccountId) -\u003e bool {\n\t\t\tDelegatorState::\u003cT\u003e::get(acc).is_some()\n\t\t}\n\n\t\t/// Check whether an account is currently a collator candidate and\n\t\t/// whether their state is CollatorStatus::Active.\n\t\t///\n\t\t/// Returns Some(is_active) if the account is a candidate, else None.\n\t\tpub fn is_active_candidate(acc: \u0026T::AccountId) -\u003e Option\u003cbool\u003e {\n\t\t\tif let Some(state) = CandidatePool::\u003cT\u003e::get(acc) {\n\t\t\t\tSome(state.status == CandidateStatus::Active)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t}\n\t\t}\n\n\t\t/// Update the top candidates and total amount at stake after mutating\n\t\t/// an active candidate's stake.\n\t\t///\n\t\t/// NOTE: It is assumed that the calling context checks whether the\n\t\t/// collator candidate is currently active before calling this function.\n\t\tfn update_top_candidates(\n\t\t\tcandidate: T::AccountId,\n\t\t\told_self: BalanceOf\u003cT\u003e,\n\t\t\told_delegators: BalanceOf\u003cT\u003e,\n\t\t\tnew_self: BalanceOf\u003cT\u003e,\n\t\t\tnew_delegators: BalanceOf\u003cT\u003e,\n\t\t) -\u003e u32 {\n\t\t\tlet mut top_candidates = TopCandidates::\u003cT\u003e::get();\n\t\t\tlet num_top_candidates: u32 = top_candidates.len().saturated_into();\n\t\t\tlet old_stake =\n\t\t\t\tStake { owner: candidate.clone(), amount: old_self.saturating_add(old_delegators) };\n\t\t\tlet new_stake =\n\t\t\t\tStake { owner: candidate.clone(), amount: new_self.saturating_add(new_delegators) };\n\n\t\t\t// update TopCandidates set\n\t\t\tlet maybe_top_candidate_update = if let Ok(i) = top_candidates.linear_search(\u0026old_stake)\n\t\t\t{\n\t\t\t\t// case 1: candidate is member of TopCandidates with old stake\n\t\t\t\ttop_candidates.mutate(|vec| {\n\t\t\t\t\tif let Some(stake) = vec.get_mut(i) {\n\t\t\t\t\t\tstake.amount = new_stake.amount;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tSome((Some(i), top_candidates))\n\t\t\t} else if top_candidates.try_insert_replace(new_stake.clone()).is_ok() {\n\t\t\t\t// case 2: candidate ascends into TopCandidates with new stake\n\t\t\t\t// and might replace another candidate if TopCandidates is full\n\t\t\t\tSelf::deposit_event(Event::EnteredTopCandidates(candidate));\n\t\t\t\tSome((None, top_candidates))\n\t\t\t} else {\n\t\t\t\t// case 3: candidate neither was nor will be member of TopCandidates\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\t// update storage for TotalCollatorStake and TopCandidates\n\t\t\tif let Some((maybe_old_idx, top_candidates)) = maybe_top_candidate_update {\n\t\t\t\tlet max_selected_candidates =\n\t\t\t\t\tMaxSelectedCandidates::\u003cT\u003e::get().saturated_into::\u003cusize\u003e();\n\t\t\t\tlet was_collating =\n\t\t\t\t\tmaybe_old_idx.map(|i| i \u003c max_selected_candidates).unwrap_or(false);\n\t\t\t\tlet is_collating = top_candidates\n\t\t\t\t\t.linear_search(\u0026new_stake)\n\t\t\t\t\t.map(|i| i \u003c max_selected_candidates)\n\t\t\t\t\t.unwrap_or(false);\n\n\t\t\t\t// update TopCollatorStake storage iff candidate was or will be a collator\n\t\t\t\tmatch (was_collating, is_collating) {\n\t\t\t\t\t(true, true) =\u003e {\n\t\t\t\t\t\tSelf::update_total_stake_by(\n\t\t\t\t\t\t\tnew_self,\n\t\t\t\t\t\t\tnew_delegators,\n\t\t\t\t\t\t\told_self,\n\t\t\t\t\t\t\told_delegators,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t(true, false) =\u003e {\n\t\t\t\t\t\t// candidate left the collator set because they staked less and have been\n\t\t\t\t\t\t// replaced by the next candidate in the queue at position\n\t\t\t\t\t\t// min(max_selected_candidates, top_candidates) - 1 in TopCandidates\n\t\t\t\t\t\tlet new_col_idx =\n\t\t\t\t\t\t\tmax_selected_candidates.min(top_candidates.len()).saturating_sub(1);\n\n\t\t\t\t\t\t// get displacer\n\t\t\t\t\t\tlet (add_collators, add_delegators) =\n\t\t\t\t\t\t\tSelf::get_top_candidate_stake_at(\u0026top_candidates, new_col_idx)\n\t\t\t\t\t\t\t\t// shouldn't be possible to fail, but we handle it gracefully\n\t\t\t\t\t\t\t\t.unwrap_or((new_self, new_delegators));\n\t\t\t\t\t\tSelf::update_total_stake_by(\n\t\t\t\t\t\t\tadd_collators,\n\t\t\t\t\t\t\tadd_delegators,\n\t\t\t\t\t\t\told_self,\n\t\t\t\t\t\t\told_delegators,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t(false, true) =\u003e {\n\t\t\t\t\t\t// candidate pushed out the least staked collator which is now at position\n\t\t\t\t\t\t// min(max_selected_top_candidates, top_candidates - 1) in TopCandidates\n\t\t\t\t\t\tlet old_col_idx =\n\t\t\t\t\t\t\tmax_selected_candidates.min(top_candidates.len().saturating_sub(1));\n\n\t\t\t\t\t\t// get amount to subtract from TotalCollatorStake\n\t\t\t\t\t\tlet (drop_self, drop_delegators) =\n\t\t\t\t\t\t\tSelf::get_top_candidate_stake_at(\u0026top_candidates, old_col_idx)\n\t\t\t\t\t\t\t\t// default to zero if candidate DNE, e.g. TopCandidates is not full\n\t\t\t\t\t\t\t\t.unwrap_or((BalanceOf::\u003cT\u003e::zero(), BalanceOf::\u003cT\u003e::zero()));\n\t\t\t\t\t\tSelf::update_total_stake_by(\n\t\t\t\t\t\t\tnew_self,\n\t\t\t\t\t\t\tnew_delegators,\n\t\t\t\t\t\t\tdrop_self,\n\t\t\t\t\t\t\tdrop_delegators,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e {},\n\t\t\t\t}\n\n\t\t\t\t// update TopCandidates storage\n\t\t\t\tTopCandidates::\u003cT\u003e::put(top_candidates);\n\t\t\t}\n\n\t\t\tnum_top_candidates\n\t\t}\n\n\t\t/// Retrieve the staked amounts (self, sum of delegators) of member of\n\t\t/// [TopCandidates] at the given index, if it exists.\n\t\tfn get_top_candidate_stake_at(\n\t\t\ttop_candidates: \u0026OrderedSet\u003cStakeOf\u003cT\u003e, T::MaxTopCandidates\u003e,\n\t\t\tindex: usize,\n\t\t) -\u003e Option\u003c(BalanceOf\u003cT\u003e, BalanceOf\u003cT\u003e)\u003e {\n\t\t\ttop_candidates\n\t\t\t\t.get(index)\n\t\t\t\t.and_then(|stake| CandidatePool::\u003cT\u003e::get(\u0026stake.owner))\n\t\t\t\t// SAFETY: the total is always more than the stake\n\t\t\t\t.map(|state| (state.stake, state.total - state.stake))\n\t\t}\n\n\t\t/// Mutate the [TotalCollatorStake] by both incrementing and decreasing\n\t\t/// it by the provided values.\n\t\tfn update_total_stake_by(\n\t\t\tadd_collators: BalanceOf\u003cT\u003e,\n\t\t\tadd_delegators: BalanceOf\u003cT\u003e,\n\t\t\tsub_collators: BalanceOf\u003cT\u003e,\n\t\t\tsub_delegators: BalanceOf\u003cT\u003e,\n\t\t) {\n\t\t\tTotalCollatorStake::\u003cT\u003e::mutate(|total| {\n\t\t\t\ttotal.collators =\n\t\t\t\t\ttotal.collators.saturating_sub(sub_collators).saturating_add(add_collators);\n\t\t\t\ttotal.delegators =\n\t\t\t\t\ttotal.delegators.saturating_sub(sub_delegators).saturating_add(add_delegators);\n\t\t\t});\n\t\t}\n\n\t\t/// Iterate over the top `MaxSelectedCandidates` many collators in terms\n\t\t/// of cumulated stake (self + from delegators) from the [TopCandidates]\n\t\t/// and recalculate the [TotalCollatorStake] from scratch.\n\t\t///\n\t\t/// NOTE: Should only be called in rare circumstances in which we cannot\n\t\t/// guarantee a single candidate's stake has changed, e.g. on genesis or\n\t\t/// when a collator leaves. Otherwise, please use\n\t\t/// [update_total_stake_by].\n\t\tfn update_total_stake() -\u003e (u32, u32) {\n\t\t\tlet mut num_of_delegators = 0u32;\n\t\t\tlet mut collator_stake = BalanceOf::\u003cT\u003e::zero();\n\t\t\tlet mut delegator_stake = BalanceOf::\u003cT\u003e::zero();\n\n\t\t\tlet collators = Self::selected_candidates();\n\n\t\t\t// Snapshot exposure for round for weighting reward distribution\n\t\t\tfor account in collators.iter() {\n\t\t\t\tlet state = CandidatePool::\u003cT\u003e::get(\u0026account)\n\t\t\t\t\t.expect(\"all members of TopCandidates must be candidates q.e.d\");\n\t\t\t\tnum_of_delegators =\n\t\t\t\t\tnum_of_delegators.max(state.delegators.len().saturated_into::\u003cu32\u003e());\n\n\t\t\t\t// sum up total stake and amount of collators, delegators\n\t\t\t\tlet amount_collator = state.stake;\n\t\t\t\tcollator_stake = collator_stake.saturating_add(state.stake);\n\t\t\t\t// safe to subtract because total \u003e= stake\n\t\t\t\tlet amount_delegators = state.total - amount_collator;\n\t\t\t\tdelegator_stake = delegator_stake.saturating_add(amount_delegators);\n\t\t\t}\n\n\t\t\tTotalCollatorStake::\u003cT\u003e::mutate(|total| {\n\t\t\t\ttotal.collators = collator_stake;\n\t\t\t\ttotal.delegators = delegator_stake;\n\t\t\t});\n\n\t\t\t// return number of selected candidates and the corresponding number of their\n\t\t\t// delegators for post-weight correction\n\t\t\t(collators.len().saturated_into(), num_of_delegators)\n\t\t}\n\n\t\t/// Update the collator's state by removing the delegator's stake and\n\t\t/// starting the process to unlock the delegator's staked funds as well\n\t\t/// as incrementing their accumulated rewards.\n\t\t///\n\t\t/// This operation affects the pallet's total stake.\n\t\tfn delegator_leaves_collator(\n\t\t\tdelegator: T::AccountId,\n\t\t\tcollator: T::AccountId,\n\t\t) -\u003e DispatchResult {\n\t\t\tlet mut state =\n\t\t\t\tCandidatePool::\u003cT\u003e::get(\u0026collator).ok_or(Error::\u003cT\u003e::CandidateNotFound)?;\n\n\t\t\tlet delegator_stake = state\n\t\t\t\t.delegators\n\t\t\t\t.remove(\u0026Stake {\n\t\t\t\t\towner: delegator.clone(),\n\t\t\t\t\t// amount is irrelevant for removal\n\t\t\t\t\tamount: BalanceOf::\u003cT\u003e::one(),\n\t\t\t\t})\n\t\t\t\t.map(|nom| nom.amount)\n\t\t\t\t.ok_or(Error::\u003cT\u003e::DelegatorNotFound)?;\n\n\t\t\tlet CandidateOf::\u003cT, _\u003e { stake: old_stake, total: old_total, .. } = state;\n\t\t\tstate.total = state.total.saturating_sub(delegator_stake);\n\t\t\tlet new_total = state.total;\n\n\t\t\t// set rewards\n\t\t\tSelf::do_inc_delegator_reward(\u0026delegator, delegator_stake, \u0026collator);\n\n\t\t\t// we don't unlock immediately\n\t\t\tSelf::prep_unstake(\u0026delegator, delegator_stake, false)?;\n\n\t\t\t// update top candidates and total amount at stake\n\t\t\tif state.is_active() {\n\t\t\t\tSelf::update_top_candidates(\n\t\t\t\t\tcollator.clone(),\n\t\t\t\t\told_stake,\n\t\t\t\t\t// safe because total \u003e= stake\n\t\t\t\t\told_total - old_stake,\n\t\t\t\t\tstate.stake,\n\t\t\t\t\tstate.total - state.stake,\n\t\t\t\t);\n\t\t\t}\n\t\t\tCandidatePool::\u003cT\u003e::insert(\u0026collator, state);\n\n\t\t\tSelf::deposit_event(Event::DelegatorLeftCollator(\n\t\t\t\tdelegator,\n\t\t\t\tcollator,\n\t\t\t\tdelegator_stake,\n\t\t\t\tnew_total,\n\t\t\t));\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Return the best `MaxSelectedCandidates` many candidates.\n\t\t///\n\t\t/// In case a collator from last round was replaced by a candidate with\n\t\t/// the same total stake during sorting, we revert this swap to\n\t\t/// prioritize collators over candidates.\n\t\tpub fn selected_candidates() -\u003e BoundedVec\u003cT::AccountId, T::MaxTopCandidates\u003e {\n\t\t\tlet candidates = TopCandidates::\u003cT\u003e::get();\n\n\t\t\t// Should never fail since WASM usize are 32bits and native are either 32 or 64\n\t\t\tlet top_n = MaxSelectedCandidates::\u003cT\u003e::get().saturated_into::\u003cusize\u003e();\n\n\t\t\tlog::trace!(\"{} Candidates for {} Collator seats\", candidates.len(), top_n);\n\n\t\t\t// Choose the top MaxSelectedCandidates qualified candidates\n\t\t\tlet collators = candidates\n\t\t\t\t.into_iter()\n\t\t\t\t.take(top_n)\n\t\t\t\t.filter(|x| x.amount \u003e= T::MinCollatorStake::get())\n\t\t\t\t.map(|x| x.owner)\n\t\t\t\t.collect::\u003cVec\u003cT::AccountId\u003e\u003e();\n\n\t\t\tcollators.try_into().expect(\"Did not extend Collators q.e.d.\")\n\t\t}\n\n\t\t/// Attempts to add the stake to the set of delegators of a collator\n\t\t/// which already reached its maximum size by removing an already\n\t\t/// existing delegator with less staked value. If the given staked\n\t\t/// amount is at most the minimum staked value of the original delegator\n\t\t/// set, an error is returned.\n\t\t///\n\t\t/// Sets rewards for the removed delegator.\n\t\t///\n\t\t/// Returns a tuple which contains the updated candidate state as well\n\t\t/// as the potentially replaced delegation which will be used later when\n\t\t/// updating the storage of the replaced delegator.\n\t\t///\n\t\t/// Emits `DelegationReplaced` if the stake exceeds one of the current\n\t\t/// delegations.\n\t\t#[allow(clippy::type_complexity)]\n\t\tfn do_update_delegator(\n\t\t\tstake: Stake\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e,\n\t\t\tmut state: Candidate\u003cT::AccountId, BalanceOf\u003cT\u003e, T::MaxDelegatorsPerCollator\u003e,\n\t\t) -\u003e Result\u003cCandidateOf\u003cT, T::MaxDelegatorsPerCollator\u003e, DispatchError\u003e {\n\t\t\t// attempt to replace the last element of the set\n\t\t\tlet stake_to_remove =\n\t\t\t\tstate.delegators.try_insert_replace(stake.clone()).map_err(|err_too_many| {\n\t\t\t\t\tif err_too_many {\n\t\t\t\t\t\tError::\u003cT\u003e::TooManyDelegators\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// should never occur because we previously check this case, but let's be sure\n\t\t\t\t\t\tError::\u003cT\u003e::AlreadyDelegating\n\t\t\t\t\t}\n\t\t\t\t})?;\n\n\t\t\tstate.total = state.total.saturating_add(stake.amount);\n\n\t\t\tif let Some(stake_to_remove) = stake_to_remove {\n\t\t\t\t// update total stake\n\t\t\t\tstate.total = state.total.saturating_sub(stake_to_remove.amount);\n\n\t\t\t\t// set rewards for kicked delegator\n\t\t\t\tSelf::do_inc_delegator_reward(\n\t\t\t\t\t\u0026stake_to_remove.owner,\n\t\t\t\t\tstake_to_remove.amount,\n\t\t\t\t\t\u0026state.id,\n\t\t\t\t);\n\t\t\t\t// prepare unstaking for kicked delegator\n\t\t\t\tSelf::prep_unstake(\u0026stake_to_remove.owner, stake_to_remove.amount, true)?;\n\t\t\t\t// remove Delegator state for kicked delegator\n\t\t\t\tDelegatorState::\u003cT\u003e::remove(\u0026stake_to_remove.owner);\n\n\t\t\t\tSelf::deposit_event(Event::DelegationReplaced(\n\t\t\t\t\tstake.owner,\n\t\t\t\t\tstake.amount,\n\t\t\t\t\tstake_to_remove.owner,\n\t\t\t\t\tstake_to_remove.amount,\n\t\t\t\t\tstate.id.clone(),\n\t\t\t\t\tstate.total,\n\t\t\t\t));\n\t\t\t}\n\n\t\t\tOk(state)\n\t\t}\n\n\t\t/// Either set or increase the BalanceLock of target account to\n\t\t/// amount.\n\t\t///\n\t\t/// Consumes unstaked balance which can be unlocked in the future up to\n\t\t/// amount and updates `Unstaking` storage accordingly.\n\t\tfn increase_lock(\n\t\t\twho: \u0026T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t\tmore: BalanceOf\u003cT\u003e,\n\t\t) -\u003e Result\u003cu32, DispatchError\u003e {\n\t\t\tensure!(\n\t\t\t\tpallet_balances::Pallet::\u003cT\u003e::free_balance(who) \u003e= amount.into(),\n\t\t\t\tpallet_balances::Error::\u003cT\u003e::InsufficientBalance\n\t\t\t);\n\n\t\t\tlet mut unstaking_len = 0u32;\n\n\t\t\t// *** No Fail except during Unstaking mutation beyond this point ***\n\n\t\t\t// update Unstaking by consuming up to {amount | more}\n\t\t\t\u003cUnstaking\u003cT\u003e\u003e::try_mutate(who, |unstaking| -\u003e DispatchResult {\n\t\t\t\t// reduce {amount | more} by unstaking until either {amount | more} is zero or\n\t\t\t\t// no unstaking is left\n\t\t\t\t// if more is set, we only want to reduce by more to achieve 100 - 40 + 30 = 90\n\t\t\t\t// locked\n\t\t\t\tlet mut amt_consuming_unstaking = if more.is_zero() { amount } else { more };\n\t\t\t\tunstaking_len = unstaking.len().saturated_into();\n\t\t\t\tfor (block_number, locked_balance) in unstaking.clone() {\n\t\t\t\t\tif amt_consuming_unstaking.is_zero() {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else if locked_balance \u003e amt_consuming_unstaking {\n\t\t\t\t\t\t// amount is only reducible by locked_balance - amt_consuming_unstaking\n\t\t\t\t\t\tlet delta = locked_balance.saturating_sub(amt_consuming_unstaking);\n\t\t\t\t\t\t// replace old entry with delta\n\t\t\t\t\t\tunstaking\n\t\t\t\t\t\t\t.try_insert(block_number, delta)\n\t\t\t\t\t\t\t.map_err(|_| Error::\u003cT\u003e::NoMoreUnstaking)?;\n\t\t\t\t\t\tamt_consuming_unstaking = Zero::zero();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// amount is either still reducible or reached\n\t\t\t\t\t\tamt_consuming_unstaking =\n\t\t\t\t\t\t\tamt_consuming_unstaking.saturating_sub(locked_balance);\n\t\t\t\t\t\tunstaking.remove(\u0026block_number);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOk(())\n\t\t\t})?;\n\n\t\t\t// Either set a new lock or potentially extend the existing one if amount\n\t\t\t// exceeds the currently locked amount\n\t\t\tT::Currency::extend_lock(STAKING_ID, who, amount, WithdrawReasons::all());\n\n\t\t\tOk(unstaking_len)\n\t\t}\n\n\t\t/// Set the unlocking block for the account and corresponding amount\n\t\t/// which can be unlocked via `unlock_unstaked` after waiting at\n\t\t/// least for `StakeDuration` many blocks.\n\t\t///\n\t\t/// Throws if the amount is zero (unlikely) or if active unlocking\n\t\t/// requests exceed limit. The latter defends against stake reduction\n\t\t/// spamming.\n\t\tfn prep_unstake(\n\t\t\twho: \u0026T::AccountId,\n\t\t\tamount: BalanceOf\u003cT\u003e,\n\t\t\tis_removal: bool,\n\t\t) -\u003e DispatchResult {\n\t\t\t// should never occur but let's be safe\n\t\t\tensure!(!amount.is_zero(), Error::\u003cT\u003e::StakeNotFound);\n\n\t\t\tlet now = \u003cframe_system::Pallet\u003cT\u003e\u003e::block_number();\n\t\t\tlet unlock_block = now.saturating_add(T::StakeDuration::get());\n\t\t\tlet mut unstaking = \u003cUnstaking\u003cT\u003e\u003e::get(who);\n\n\t\t\tlet allowed_unstakings = if is_removal {\n\t\t\t\t// the account was forcedly removed and we allow to fill all unstake requests\n\t\t\t\tT::MaxUnstakeRequests::get()\n\t\t\t} else {\n\t\t\t\t// we need to reserve a free slot for a forced removal of the account\n\t\t\t\tT::MaxUnstakeRequests::get().saturating_sub(1)\n\t\t\t};\n\t\t\tensure!(\n\t\t\t\tunstaking.len().saturated_into::\u003cu32\u003e() \u003c allowed_unstakings,\n\t\t\t\tError::\u003cT\u003e::NoMoreUnstaking,\n\t\t\t);\n\n\t\t\t// if existent, we have to add the current amount of same unlock_block, because\n\t\t\t// insert overwrites the current value\n\t\t\tlet amount = amount\n\t\t\t\t.saturating_add(*unstaking.get(\u0026unlock_block).unwrap_or(\u0026BalanceOf::\u003cT\u003e::zero()));\n\t\t\tunstaking\n\t\t\t\t.try_insert(unlock_block, amount)\n\t\t\t\t.map_err(|_| Error::\u003cT\u003e::NoMoreUnstaking)?;\n\t\t\t\u003cUnstaking\u003cT\u003e\u003e::insert(who, unstaking);\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Clear the CandidatePool of the candidate and remove all delegations\n\t\t/// to the candidate. Moreover, prepare unstaking for the candidate and\n\t\t/// their former delegations.\n\t\tfn remove_candidate(\n\t\t\tcollator: \u0026T::AccountId,\n\t\t\tstate: \u0026CandidateOf\u003cT, T::MaxDelegatorsPerCollator\u003e,\n\t\t) -\u003e DispatchResult {\n\t\t\t// iterate over delegators\n\t\t\tfor stake in \u0026state.delegators[..] {\n\t\t\t\t// prepare unstaking of delegator\n\t\t\t\tSelf::prep_unstake(\u0026stake.owner, stake.amount, true)?;\n\t\t\t\t// remove delegation from delegator state\n\t\t\t\tif let Some(mut delegator) = DelegatorState::\u003cT\u003e::get(\u0026stake.owner) {\n\t\t\t\t\tdelegator\n\t\t\t\t\t\t.rm_delegation(collator.clone())\n\t\t\t\t\t\t.map_err(|_| Error::\u003cT\u003e::DelegationNotFound)?;\n\t\t\t\t\tDelegatorState::\u003cT\u003e::remove(\u0026stake.owner);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// prepare unstaking of collator candidate\n\t\t\tSelf::prep_unstake(\u0026state.id, state.stake, true)?;\n\n\t\t\t// *** No Fail beyond this point ***\n\n\t\t\t// increment rewards of collator and their delegators\n\t\t\tSelf::do_inc_collator_reward(collator, state.stake);\n\n\t\t\t// disable validator for next session if they were in the set of validators\n\t\t\tpallet_session::Pallet::\u003cT\u003e::validators()\n\t\t\t\t.into_iter()\n\t\t\t\t.enumerate()\n\t\t\t\t.find_map(|(i, id)| {\n\t\t\t\t\tif \u003cT as pallet_session::Config\u003e::ValidatorIdOf::convert(collator.clone()) ==\n\t\t\t\t\t\tSome(id)\n\t\t\t\t\t{\n\t\t\t\t\t\tSome(i)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNone\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.map(u32::saturated_from::\u003cusize\u003e)\n\t\t\t\t// FIXME: Does not prevent the collator from being able to author a block in this (or potentially the next) session. See https://github.com/paritytech/substrate/issues/8004\n\t\t\t\t.map(pallet_session::Pallet::\u003cT\u003e::disable_index);\n\n\t\t\tCandidatePool::\u003cT\u003e::remove(\u0026collator);\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Withdraw all staked currency which was unstaked at least\n\t\t/// `StakeDuration` blocks ago.\n\t\tfn do_unlock(who: \u0026T::AccountId) -\u003e Result\u003cu32, DispatchError\u003e {\n\t\t\tlet now = \u003cframe_system::Pallet\u003cT\u003e\u003e::block_number();\n\t\t\tlet mut unstaking = \u003cUnstaking\u003cT\u003e\u003e::get(who);\n\t\t\tlet unstaking_len = unstaking.len().saturated_into::\u003cu32\u003e();\n\t\t\tensure!(!unstaking.is_empty(), Error::\u003cT\u003e::UnstakingIsEmpty);\n\n\t\t\tlet mut total_unlocked: BalanceOf\u003cT\u003e = Zero::zero();\n\t\t\tlet mut total_locked: BalanceOf\u003cT\u003e = Zero::zero();\n\t\t\tlet mut expired = Vec::new();\n\n\t\t\t// check potential unlocks\n\t\t\tfor (block_number, locked_balance) in unstaking.clone().into_iter() {\n\t\t\t\tif block_number \u003c= now {\n\t\t\t\t\texpired.push(block_number);\n\t\t\t\t\ttotal_unlocked = total_unlocked.saturating_add(locked_balance);\n\t\t\t\t} else {\n\t\t\t\t\ttotal_locked = total_locked.saturating_add(locked_balance);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor block_number in expired {\n\t\t\t\tunstaking.remove(\u0026block_number);\n\t\t\t}\n\n\t\t\t// iterate balance locks to retrieve amount of locked balance\n\t\t\tlet locks = Locks::\u003cT\u003e::get(who);\n\t\t\ttotal_locked = if let Some(BalanceLock { amount, .. }) =\n\t\t\t\tlocks.iter().find(|l| l.id == STAKING_ID)\n\t\t\t{\n\t\t\t\tamount.saturating_sub(total_unlocked.into()).into()\n\t\t\t} else {\n\t\t\t\t// should never fail to find the lock since we checked whether unstaking is not\n\t\t\t\t// empty but let's be safe\n\t\t\t\tZero::zero()\n\t\t\t};\n\n\t\t\tif total_locked.is_zero() {\n\t\t\t\tT::Currency::remove_lock(STAKING_ID, who);\n\t\t\t\t\u003cUnstaking\u003cT\u003e\u003e::remove(who);\n\t\t\t} else {\n\t\t\t\tT::Currency::set_lock(STAKING_ID, who, total_locked, WithdrawReasons::all());\n\t\t\t\t\u003cUnstaking\u003cT\u003e\u003e::insert(who, unstaking);\n\t\t\t}\n\n\t\t\tOk(unstaking_len)\n\t\t}\n\n\t\t/// Checks whether a delegator can still delegate in this round, e.g.,\n\t\t/// if they have not delegated MaxDelegationsPerRound many times\n\t\t/// already in this round.\n\t\tfn get_delegation_counter(\n\t\t\tdelegator: \u0026T::AccountId,\n\t\t) -\u003e Result\u003cDelegationCounter, DispatchError\u003e {\n\t\t\tlet last_delegation = \u003cLastDelegation\u003cT\u003e\u003e::get(delegator);\n\t\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\n\t\t\t// reset counter if the round advanced since last delegation\n\t\t\tlet counter =\n\t\t\t\tif last_delegation.round \u003c round.current { 0u32 } else { last_delegation.counter };\n\n\t\t\tensure!(\n\t\t\t\tcounter \u003c T::MaxDelegationsPerRound::get(),\n\t\t\t\tError::\u003cT\u003e::DelegationsPerRoundExceeded\n\t\t\t);\n\n\t\t\tOk(DelegationCounter { round: round.current, counter: counter.saturating_add(1) })\n\t\t}\n\n\t\t/// Calculates the network rewards per block with the current data and\n\t\t/// issues these rewards to the network. The imbalance will be handled\n\t\t/// in `on_initialize` by adding it to the free balance of\n\t\t/// `NetworkRewardBeneficiary`.\n\t\t///\n\t\t/// Over the course of an entire year, the network rewards equal the\n\t\t/// maximum annual collator staking rewards multiplied with the\n\t\t/// NetworkRewardRate. E.g., assuming 10% annual collator reward rate,\n\t\t/// 10% max staking rate, 200k KILT max collator stake and 30 collators:\n\t\t/// NetworkRewards = NetworkRewardRate * 10% * 10% * 200_000 KILT * 30\n\t\t///\n\t\t/// The expected rewards are the product of\n\t\t///  * the current total maximum collator rewards\n\t\t///  * and the configured NetworkRewardRate\n\t\t///\n\t\t/// `col_reward_rate_per_block * col_max_stake * max_num_of_collators *\n\t\t/// NetworkRewardRate`\n\t\tfn issue_network_reward() -\u003e NegativeImbalanceOf\u003cT\u003e {\n\t\t\t// Multiplication with Perquintill cannot overflow\n\t\t\tlet max_col_rewards = InflationConfig::\u003cT\u003e::get().collator.reward_rate.per_block *\n\t\t\t\tMaxCollatorCandidateStake::\u003cT\u003e::get() *\n\t\t\t\tMaxSelectedCandidates::\u003cT\u003e::get().into();\n\t\t\tlet network_reward = T::NetworkRewardRate::get() * max_col_rewards;\n\n\t\t\tT::Currency::issue(network_reward)\n\t\t}\n\n\t\t/// Calculates the collator staking rewards for authoring `multiplier`\n\t\t/// many blocks based on the given stake.\n\t\t///\n\t\t/// Depends on the current total issuance and staking reward\n\t\t/// configuration for collators.\n\t\tfn calc_block_rewards_collator(\n\t\t\tstake: BalanceOf\u003cT\u003e,\n\t\t\tmultiplier: BalanceOf\u003cT\u003e,\n\t\t) -\u003e BalanceOf\u003cT\u003e {\n\t\t\tlet total_issuance = T::Currency::total_issuance();\n\t\t\tlet TotalStake { collators: total_collators, .. } = \u003cTotalCollatorStake\u003cT\u003e\u003e::get();\n\t\t\tlet staking_rate = Perquintill::from_rational(total_collators, total_issuance);\n\n\t\t\tInflationConfig::\u003cT\u003e::get().collator.compute_reward::\u003cT\u003e(\n\t\t\t\tstake,\n\t\t\t\tstaking_rate,\n\t\t\t\tmultiplier,\n\t\t\t)\n\t\t}\n\n\t\t/// Calculates the delegator staking rewards for `multiplier` many\n\t\t/// blocks based on the given stake.\n\t\t///\n\t\t/// Depends on the current total issuance and staking reward\n\t\t/// configuration for delegators.\n\t\tfn calc_block_rewards_delegator(\n\t\t\tstake: BalanceOf\u003cT\u003e,\n\t\t\tmultiplier: BalanceOf\u003cT\u003e,\n\t\t) -\u003e BalanceOf\u003cT\u003e {\n\t\t\tlet total_issuance = T::Currency::total_issuance();\n\t\t\tlet TotalStake { delegators: total_delegators, .. } = \u003cTotalCollatorStake\u003cT\u003e\u003e::get();\n\t\t\tlet staking_rate = Perquintill::from_rational(total_delegators, total_issuance);\n\n\t\t\tInflationConfig::\u003cT\u003e::get().delegator.compute_reward::\u003cT\u003e(\n\t\t\t\tstake,\n\t\t\t\tstaking_rate,\n\t\t\t\tmultiplier,\n\t\t\t)\n\t\t}\n\n\t\t/// Calculates the staking rewards for a given account address.\n\t\t///\n\t\t/// At least used in Runtime API.\n\t\tpub fn get_unclaimed_staking_rewards(acc: \u0026T::AccountId) -\u003e BalanceOf\u003cT\u003e {\n\t\t\tlet mut reward_count = RewardCount::\u003cT\u003e::get(acc);\n\t\t\tlet rewards = Rewards::\u003cT\u003e::get(acc);\n\n\t\t\t// delegators and collators need to be handled differently\n\t\t\tif let Some(delegator_state) = DelegatorState::\u003cT\u003e::get(acc) {\n\t\t\t\t// delegator reward counts do not automatically increment in order to be\n\t\t\t\t// scalable, see [increment_delegator_rewards] for details\n\t\t\t\t// therefore, we need to query the counter of the collator\n\t\t\t\t// (`delegator_stare.owner`)\n\t\t\t\treward_count = reward_count.saturating_add(\n\t\t\t\t\tdelegator_state.owner.map(RewardCount::\u003cT\u003e::get).unwrap_or(0u32),\n\t\t\t\t);\n\t\t\t\tlet stake = delegator_state.amount;\n\t\t\t\t// rewards += stake * (self_count + collator_count) * delegator_reward_rate\n\t\t\t\trewards\n\t\t\t\t\t.saturating_add(Self::calc_block_rewards_delegator(stake, reward_count.into()))\n\t\t\t} else if Self::is_active_candidate(acc).is_some() {\n\t\t\t\tlet stake = CandidatePool::\u003cT\u003e::get(acc)\n\t\t\t\t\t.map(|state| state.stake)\n\t\t\t\t\t.unwrap_or_else(BalanceOf::\u003cT\u003e::zero);\n\t\t\t\t// rewards += stake * self_count * collator_reward_rate\n\t\t\t\trewards\n\t\t\t\t\t.saturating_add(Self::calc_block_rewards_collator(stake, reward_count.into()))\n\t\t\t} else {\n\t\t\t\tBalanceOf::\u003cT\u003e::zero()\n\t\t\t}\n\t\t}\n\n\t\t/// Increment the accumulated rewards of a collator by consuming their\n\t\t/// current rewards counter.\n\t\t///\n\t\t/// Moreover, automatically increments all associated delegators since\n\t\t/// their reward increment is dependend on the collator reward counter.\n\t\t///\n\t\t/// Resets all reward counters of the collator and their delegators to\n\t\t/// zero.\n\t\tfn do_inc_collator_reward(collator: \u0026T::AccountId, stake: BalanceOf\u003cT\u003e) -\u003e usize {\n\t\t\t// get reward counters\n\t\t\tlet col_reward_count = RewardCount::\u003cT\u003e::get(collator);\n\n\t\t\t// set reward data for collator\n\t\t\tRewards::\u003cT\u003e::mutate(collator, |reward| {\n\t\t\t\t*reward = reward.saturating_add(Self::calc_block_rewards_collator(\n\t\t\t\t\tstake,\n\t\t\t\t\tcol_reward_count.into(),\n\t\t\t\t));\n\t\t\t});\n\n\t\t\t// set reward data for delegators\n\t\t\tlet num_delegators = if let Some(state) = CandidatePool::\u003cT\u003e::get(collator.clone()) {\n\t\t\t\tlet num_delegators = state.delegators.len();\n\t\t\t\tfor Stake { owner, amount } in state.delegators {\n\t\t\t\t\tSelf::do_inc_delegator_reward(\u0026owner, amount, collator);\n\t\t\t\t\t// Reset delegator counter since collator counter will be reset\n\t\t\t\t\tRewardCount::\u003cT\u003e::insert(owner, 0);\n\t\t\t\t}\n\t\t\t\tnum_delegators\n\t\t\t} else {\n\t\t\t\t0usize\n\t\t\t};\n\n\t\t\t// Reset collator reward count\n\t\t\tRewardCount::\u003cT\u003e::insert(collator, 0);\n\n\t\t\tnum_delegators\n\t\t}\n\n\t\t/// Increment the accumulated rewards of a delegator by consuming their\n\t\t/// current rewards counter. The counter will be reset to the collator\n\t\t/// counter.\n\t\tfn do_inc_delegator_reward(\n\t\t\tacc: \u0026T::AccountId,\n\t\t\tstake: BalanceOf\u003cT\u003e,\n\t\t\tcol: \u0026T::AccountId,\n\t\t) -\u003e Weight {\n\t\t\t// get reward counters\n\t\t\tlet del_reward_count = RewardCount::\u003cT\u003e::get(acc);\n\t\t\tlet col_reward_count = RewardCount::\u003cT\u003e::get(col);\n\t\t\tlet diff = col_reward_count.saturating_sub(del_reward_count);\n\n\t\t\t// only update if collator has higher reward count\n\t\t\tif diff \u003e 0 {\n\t\t\t\tRewards::\u003cT\u003e::mutate(acc, |reward| {\n\t\t\t\t\t*reward = reward\n\t\t\t\t\t\t.saturating_add(Self::calc_block_rewards_delegator(stake, diff.into()));\n\t\t\t\t});\n\t\t\t\t// align with collator counter such that incrementing would\n\t\t\t\t// lead to 0 rewards until the collator counter increases\n\t\t\t\tRewardCount::\u003cT\u003e::insert(acc, col_reward_count);\n\n\t\t\t\t// 4 reads from reward calc\n\t\t\t\tT::DbWeight::get().reads_writes(6, 2)\n\t\t\t} else {\n\t\t\t\tT::DbWeight::get().reads(2)\n\t\t\t}\n\t\t}\n\n\t\t/// Calculates the current staking and reward rates for collators and\n\t\t/// delegators.\n\t\t///\n\t\t/// At least used in Runtime API.\n\t\tpub fn get_staking_rates() -\u003e runtime_api::StakingRates {\n\t\t\tlet total_issuance = T::Currency::total_issuance();\n\t\t\tlet total_stake = TotalCollatorStake::\u003cT\u003e::get();\n\t\t\tlet inflation_config = InflationConfig::\u003cT\u003e::get();\n\t\t\tlet collator_staking_rate =\n\t\t\t\tPerquintill::from_rational(total_stake.collators, total_issuance);\n\t\t\tlet delegator_staking_rate =\n\t\t\t\tPerquintill::from_rational(total_stake.delegators, total_issuance);\n\t\t\tlet collator_reward_rate = Perquintill::from_rational(\n\t\t\t\tinflation_config.collator.max_rate.deconstruct(),\n\t\t\t\tcollator_staking_rate.deconstruct(),\n\t\t\t) * inflation_config.collator.reward_rate.annual;\n\t\t\tlet delegator_reward_rate = Perquintill::from_rational(\n\t\t\t\tinflation_config.delegator.max_rate.deconstruct(),\n\t\t\t\tdelegator_staking_rate.deconstruct(),\n\t\t\t) * inflation_config.delegator.reward_rate.annual;\n\n\t\t\truntime_api::StakingRates {\n\t\t\t\tcollator_staking_rate,\n\t\t\t\tcollator_reward_rate,\n\t\t\t\tdelegator_staking_rate,\n\t\t\t\tdelegator_reward_rate,\n\t\t\t}\n\t\t}\n\t}\n\n\timpl\u003cT\u003e pallet_authorship::EventHandler\u003cT::AccountId, T::BlockNumber\u003e for Pallet\u003cT\u003e\n\twhere\n\t\tT: Config + pallet_authorship::Config + pallet_session::Config,\n\t{\n\t\t/// Increments the reward counter of the block author by the current\n\t\t/// number of collators in the session.\n\t\tfn note_author(author: T::AccountId) {\n\t\t\t// should always include state except if the collator has been forcedly removed\n\t\t\t// via `force_remove_candidate` in the current or previous round\n\t\t\tif CandidatePool::\u003cT\u003e::get(\u0026author).is_some() {\n\t\t\t\t// necessary to compensate for a potentially fluctuating number of collators\n\t\t\t\tlet authors = pallet_session::Pallet::\u003cT\u003e::validators();\n\t\t\t\tRewardCount::\u003cT\u003e::mutate(\u0026author, |count| {\n\t\t\t\t\t*count = count.saturating_add(authors.len().saturated_into::\u003cu32\u003e());\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tframe_system::Pallet::\u003cT\u003e::register_extra_weight_unchecked(\n\t\t\t\tT::DbWeight::get().reads_writes(2, 1),\n\t\t\t\tDispatchClass::Mandatory,\n\t\t\t);\n\t\t}\n\t}\n\n\timpl\u003cT: Config\u003e pallet_session::SessionManager\u003cT::AccountId\u003e for Pallet\u003cT\u003e {\n\t\t/// 1. A new session starts.\n\t\t/// 2. In hook new_session: Read the current top n candidates from the\n\t\t///    TopCandidates and assign this set to author blocks for the next\n\t\t///    session.\n\t\t/// 3. AuRa queries the authorities from the session pallet for\n\t\t///    this session and picks authors on round-robin-basis from list of\n\t\t///    authorities.\n\t\tfn new_session(new_index: SessionIndex) -\u003e Option\u003cVec\u003cT::AccountId\u003e\u003e {\n\t\t\tlog::debug!(\n\t\t\t\t\"assembling new collators for new session {} at #{:?}\",\n\t\t\t\tnew_index,\n\t\t\t\t\u003cframe_system::Pallet\u003cT\u003e\u003e::block_number(),\n\t\t\t);\n\n\t\t\tframe_system::Pallet::\u003cT\u003e::register_extra_weight_unchecked(\n\t\t\t\tT::DbWeight::get().reads(2),\n\t\t\t\tDispatchClass::Mandatory,\n\t\t\t);\n\n\t\t\tlet collators = Pallet::\u003cT\u003e::selected_candidates().to_vec();\n\t\t\tif collators.is_empty() {\n\t\t\t\t// we never want to pass an empty set of collators. This would brick the chain.\n\t\t\t\tlog::error!(\"💥 keeping old session because of empty collator set!\");\n\t\t\t\tNone\n\t\t\t} else {\n\t\t\t\tSome(collators)\n\t\t\t}\n\t\t}\n\n\t\tfn end_session(_end_index: SessionIndex) {\n\t\t\t// we too are not caring.\n\t\t}\n\n\t\tfn start_session(_start_index: SessionIndex) {\n\t\t\t// we too are not caring.\n\t\t}\n\t}\n\n\timpl\u003cT: Config\u003e ShouldEndSession\u003cT::BlockNumber\u003e for Pallet\u003cT\u003e {\n\t\tfn should_end_session(now: T::BlockNumber) -\u003e bool {\n\t\t\tframe_system::Pallet::\u003cT\u003e::register_extra_weight_unchecked(\n\t\t\t\tT::DbWeight::get().reads(2),\n\t\t\t\tDispatchClass::Mandatory,\n\t\t\t);\n\n\t\t\tlet mut round = \u003cRound\u003cT\u003e\u003e::get();\n\t\t\t// always update when a new round should start\n\t\t\tif round.should_update(now) {\n\t\t\t\ttrue\n\t\t\t} else if \u003cForceNewRound\u003cT\u003e\u003e::get() {\n\t\t\t\tframe_system::Pallet::\u003cT\u003e::register_extra_weight_unchecked(\n\t\t\t\t\tT::DbWeight::get().writes(2),\n\t\t\t\t\tDispatchClass::Mandatory,\n\t\t\t\t);\n\t\t\t\t// check for forced new round\n\t\t\t\t\u003cForceNewRound\u003cT\u003e\u003e::put(false);\n\t\t\t\tround.update(now);\n\t\t\t\t\u003cRound\u003cT\u003e\u003e::put(round);\n\t\t\t\tSelf::deposit_event(Event::NewRound(round.first, round.current));\n\t\t\t\ttrue\n\t\t\t} else {\n\t\t\t\tfalse\n\t\t\t}\n\t\t}\n\t}\n\n\timpl\u003cT: Config\u003e EstimateNextSessionRotation\u003cT::BlockNumber\u003e for Pallet\u003cT\u003e {\n\t\tfn average_session_length() -\u003e T::BlockNumber {\n\t\t\t\u003cRound\u003cT\u003e\u003e::get().length\n\t\t}\n\n\t\tfn estimate_current_session_progress(now: T::BlockNumber) -\u003e (Option\u003cPermill\u003e, Weight) {\n\t\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\t\t\tlet passed_blocks = now.saturating_sub(round.first);\n\n\t\t\t(\n\t\t\t\tSome(Permill::from_rational(passed_blocks, round.length)),\n\t\t\t\t// One read for the round info, blocknumber is read free\n\t\t\t\tT::DbWeight::get().reads(1),\n\t\t\t)\n\t\t}\n\n\t\tfn estimate_next_session_rotation(\n\t\t\t_now: T::BlockNumber,\n\t\t) -\u003e (Option\u003cT::BlockNumber\u003e, Weight) {\n\t\t\tlet round = \u003cRound\u003cT\u003e\u003e::get();\n\n\t\t\t(\n\t\t\t\tSome(round.first + round.length),\n\t\t\t\t// One read for the round info, blocknumber is read free\n\t\t\t\tT::DbWeight::get().reads(1),\n\t\t\t)\n\t\t}\n\t}\n}\n","traces":[{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":806,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":844,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":859,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":871,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":915,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":961,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":965,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":966,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1028,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1032,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1042,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1048,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1050,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1096,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1097,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1098,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1553,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1659,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1662,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1718,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1721,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1726,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1746,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1749,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1766,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1775,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1807,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1840,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1846,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1858,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1874,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1875,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1877,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1886,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1887,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1890,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1891,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1906,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1908,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1914,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1917,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1919,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1922,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1926,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1930,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1931,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1933,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1935,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1941,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1944,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1945,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1948,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1949,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1951,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1953,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1954,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1955,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1956,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1959,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1963,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1966,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1977,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1979,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1992,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1993,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2008,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2009,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2011,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2017,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2018,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2028,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2029,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2047,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2048,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2050,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2055,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2057,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2058,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2060,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2061,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2065,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2068,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2071,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2073,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2074,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2076,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2077,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2078,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2081,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2083,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2084,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2087,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2089,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2097,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2098,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2511,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2620,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2662,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2670,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2671,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2674,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2680,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2691,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":2703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":804},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","mock.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n//! Test utilities\n\n#![allow(clippy::from_over_into)]\n\nuse super::*;\nuse crate::{self as stake, types::NegativeImbalanceOf};\nuse frame_support::{\n\tassert_ok, construct_runtime, parameter_types,\n\ttraits::{Currency, GenesisBuild, OnFinalize, OnInitialize, OnUnbalanced},\n};\nuse pallet_authorship::EventHandler;\nuse sp_consensus_aura::sr25519::AuthorityId;\nuse sp_core::H256;\nuse sp_runtime::{\n\timpl_opaque_keys,\n\ttesting::{Header, UintAuthorityId},\n\ttraits::{BlakeTwo256, ConvertInto, IdentityLookup, OpaqueKeys},\n\tPerbill, Perquintill,\n};\nuse sp_std::fmt::Debug;\n\npub(crate) type UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic\u003cTest\u003e;\npub(crate) type Block = frame_system::mocking::MockBlock\u003cTest\u003e;\npub(crate) type Balance = u128;\npub(crate) type AccountId = u64;\npub(crate) type BlockNumber = u64;\n\npub(crate) const MILLI_KILT: Balance = 10u128.pow(12);\npub(crate) const MAX_COLLATOR_STAKE: Balance = 200_000 * 1000 * MILLI_KILT;\npub(crate) const BLOCKS_PER_ROUND: BlockNumber = 5;\npub(crate) const DECIMALS: Balance = 1000 * MILLI_KILT;\npub(crate) const TREASURY_ACC: AccountId = u64::MAX;\n\n// Configure a mock runtime to test the pallet.\nconstruct_runtime!(\n\tpub enum Test where\n\t\tBlock = Block,\n\t\tNodeBlock = Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e},\n\t\tAura: pallet_aura::{Pallet, Storage},\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e},\n\t\tStakePallet: stake::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e},\n\t\tAuthorship: pallet_authorship::{Pallet, Storage},\n\t}\n);\n\nparameter_types! {\n\tpub const BlockHashCount: u64 = 250;\n\tpub const MaximumBlockLength: u32 = 2 * 1024;\n\tpub const AvailableBlockRatio: Perbill = Perbill::one();\n\tpub const SS58Prefix: u8 = 42;\n}\n\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\ttype DbWeight = ();\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Index = u64;\n\ttype BlockNumber = BlockNumber;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Hash = H256;\n\ttype Hashing = BlakeTwo256;\n\ttype AccountId = AccountId;\n\ttype Lookup = IdentityLookup\u003cSelf::AccountId\u003e;\n\ttype Header = Header;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BlockHashCount = BlockHashCount;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype SS58Prefix = SS58Prefix;\n\ttype OnSetCode = ();\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = 1;\n}\n\nimpl pallet_balances::Config for Test {\n\ttype MaxLocks = ();\n\ttype MaxReserves = ();\n\ttype ReserveIdentifier = [u8; 8];\n\ttype Balance = Balance;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n}\n\nimpl pallet_aura::Config for Test {\n\ttype AuthorityId = AuthorityId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxCollatorCandidates;\n}\n\nimpl pallet_authorship::Config for Test {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = Pallet\u003cTest\u003e;\n}\n\nparameter_types! {\n\tpub const MinBlocksPerRound: BlockNumber = 3;\n\tpub const StakeDuration: u32 = 2;\n\tpub const ExitQueueDelay: u32 = 2;\n\tpub const DefaultBlocksPerRound: BlockNumber = BLOCKS_PER_ROUND;\n\tpub const MinCollators: u32 = 2;\n\tpub const MaxDelegationsPerRound: u32 = 2;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxDelegatorsPerCollator: u32 = 4;\n\tpub const MinCollatorStake: Balance = 10;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxCollatorCandidates: u32 = 10;\n\tpub const MinDelegatorStake: Balance = 5;\n\tpub const MaxUnstakeRequests: u32 = 6;\n\tpub const NetworkRewardRate: Perquintill = Perquintill::from_percent(10);\n\tpub const NetworkRewardStart: BlockNumber = 5 * 5 * 60 * 24 * 36525 / 100;\n\tpub const CollatorRewardRateDecay: Perquintill = Perquintill::from_percent(98);\n}\n\npub struct ToBeneficiary();\nimpl OnUnbalanced\u003cNegativeImbalanceOf\u003cTest\u003e\u003e for ToBeneficiary {\n\tfn on_nonzero_unbalanced(amount: NegativeImbalanceOf\u003cTest\u003e) {\n\t\t// Must resolve into existing but better to be safe.\n\t\t\u003cTest as Config\u003e::Currency::resolve_creating(\u0026TREASURY_ACC, amount);\n\t}\n}\n\nimpl Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyBalance = \u003cSelf as pallet_balances::Config\u003e::Balance;\n\ttype MinBlocksPerRound = MinBlocksPerRound;\n\ttype DefaultBlocksPerRound = DefaultBlocksPerRound;\n\ttype StakeDuration = StakeDuration;\n\ttype ExitQueueDelay = ExitQueueDelay;\n\ttype MinCollators = MinCollators;\n\ttype MinRequiredCollators = MinCollators;\n\ttype MaxDelegationsPerRound = MaxDelegationsPerRound;\n\ttype MaxDelegatorsPerCollator = MaxDelegatorsPerCollator;\n\ttype MinCollatorStake = MinCollatorStake;\n\ttype MinCollatorCandidateStake = MinCollatorStake;\n\ttype MaxTopCandidates = MaxCollatorCandidates;\n\ttype MinDelegatorStake = MinDelegatorStake;\n\ttype MaxUnstakeRequests = MaxUnstakeRequests;\n\ttype NetworkRewardRate = NetworkRewardRate;\n\ttype NetworkRewardStart = NetworkRewardStart;\n\ttype NetworkRewardBeneficiary = ToBeneficiary;\n\ttype CollatorRewardRateDecay = CollatorRewardRateDecay;\n\ttype WeightInfo = ();\n\tconst BLOCKS_PER_YEAR: Self::BlockNumber = 5 * 60 * 24 * 36525 / 100;\n}\n\nimpl_opaque_keys! {\n\tpub struct MockSessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\nparameter_types! {\n\tpub const DisabledValidatorsThreshold: Perbill = Perbill::from_percent(17);\n}\n\nimpl pallet_session::Config for Test {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = AccountId;\n\ttype ValidatorIdOf = ConvertInto;\n\ttype ShouldEndSession = StakePallet;\n\ttype NextSessionRotation = StakePallet;\n\ttype SessionManager = StakePallet;\n\ttype SessionHandler = \u003cMockSessionKeys as OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = MockSessionKeys;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = 1;\n}\n\nimpl pallet_timestamp::Config for Test {\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n}\n\npub(crate) struct ExtBuilder {\n\t// endowed accounts with balances\n\tbalances: Vec\u003c(AccountId, Balance)\u003e,\n\t// [collator, amount]\n\tcollators: Vec\u003c(AccountId, Balance)\u003e,\n\t// [delegator, collator, delegation_amount]\n\tdelegators: Vec\u003c(AccountId, AccountId, Balance)\u003e,\n\t// inflation config\n\tinflation_config: InflationInfo,\n\t// blocks per round\n\tblocks_per_round: BlockNumber,\n}\n\nimpl Default for ExtBuilder {\n\tfn default() -\u003e ExtBuilder {\n\t\tExtBuilder {\n\t\t\tbalances: vec![],\n\t\t\tdelegators: vec![],\n\t\t\tcollators: vec![],\n\t\t\tblocks_per_round: BLOCKS_PER_ROUND,\n\t\t\tinflation_config: InflationInfo::new(\n\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\tPerquintill::from_percent(10),\n\t\t\t\tPerquintill::from_percent(15),\n\t\t\t\tPerquintill::from_percent(40),\n\t\t\t\tPerquintill::from_percent(10),\n\t\t\t),\n\t\t}\n\t}\n}\n\nimpl ExtBuilder {\n\t#[must_use]\n\tpub(crate) fn with_balances(mut self, balances: Vec\u003c(AccountId, Balance)\u003e) -\u003e Self {\n\t\tself.balances = balances;\n\t\tself\n\t}\n\n\t#[must_use]\n\tpub(crate) fn with_collators(mut self, collators: Vec\u003c(AccountId, Balance)\u003e) -\u003e Self {\n\t\tself.collators = collators;\n\t\tself\n\t}\n\n\t#[must_use]\n\tpub(crate) fn with_delegators(\n\t\tmut self,\n\t\tdelegators: Vec\u003c(AccountId, AccountId, Balance)\u003e,\n\t) -\u003e Self {\n\t\tself.delegators = delegators;\n\t\tself\n\t}\n\n\t#[must_use]\n\tpub(crate) fn with_inflation(\n\t\tmut self,\n\t\tcol_max: u64,\n\t\tcol_rewards: u64,\n\t\td_max: u64,\n\t\td_rewards: u64,\n\t\tblocks_per_round: BlockNumber,\n\t) -\u003e Self {\n\t\tself.inflation_config = InflationInfo::new(\n\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\tPerquintill::from_percent(col_max),\n\t\t\tPerquintill::from_percent(col_rewards),\n\t\t\tPerquintill::from_percent(d_max),\n\t\t\tPerquintill::from_percent(d_rewards),\n\t\t);\n\t\tself.blocks_per_round = blocks_per_round;\n\n\t\tself\n\t}\n\n\t#[must_use]\n\tpub(crate) fn set_blocks_per_round(mut self, blocks_per_round: BlockNumber) -\u003e Self {\n\t\tself.blocks_per_round = blocks_per_round;\n\t\tself\n\t}\n\n\tpub(crate) fn build(self) -\u003e sp_io::TestExternalities {\n\t\tlet mut t = frame_system::GenesisConfig::default()\n\t\t\t.build_storage::\u003cTest\u003e()\n\t\t\t.expect(\"Frame system builds valid default genesis config\");\n\n\t\tpallet_balances::GenesisConfig::\u003cTest\u003e { balances: self.balances.clone() }\n\t\t\t.assimilate_storage(\u0026mut t)\n\t\t\t.expect(\"Pallet balances storage can be assimilated\");\n\n\t\tlet mut stakers: Vec\u003c(AccountId, Option\u003cAccountId\u003e, Balance)\u003e = Vec::new();\n\t\tfor collator in self.collators.clone() {\n\t\t\tstakers.push((collator.0, None, collator.1));\n\t\t}\n\t\tfor delegator in self.delegators.clone() {\n\t\t\tstakers.push((delegator.0, Some(delegator.1), delegator.2));\n\t\t}\n\t\tstake::GenesisConfig::\u003cTest\u003e {\n\t\t\tstakers,\n\t\t\tinflation_config: self.inflation_config.clone(),\n\t\t\tmax_candidate_stake: 160_000_000 * DECIMALS,\n\t\t\tmax_selected_candidates: 2,\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.expect(\"Parachain Staking's storage can be assimilated\");\n\n\t\t// stashes are the AccountId\n\t\tlet session_keys: Vec\u003c_\u003e = self\n\t\t\t.collators\n\t\t\t.iter()\n\t\t\t.map(|(k, _)| (*k, *k, MockSessionKeys { aura: UintAuthorityId(*k).to_public_key() }))\n\t\t\t.collect();\n\n\t\t// NOTE: this will initialize the aura authorities\n\t\t// through OneSessionHandler::on_genesis_session\n\t\tpallet_session::GenesisConfig::\u003cTest\u003e { keys: session_keys }\n\t\t\t.assimilate_storage(\u0026mut t)\n\t\t\t.expect(\"Session Pallet's storage can be assimilated\");\n\n\t\tlet mut ext = sp_io::TestExternalities::new(t);\n\n\t\tif self.blocks_per_round != BLOCKS_PER_ROUND {\n\t\t\text.execute_with(|| {\n\t\t\t\tStakePallet::set_blocks_per_round(RuntimeOrigin::root(), self.blocks_per_round)\n\t\t\t\t\t.expect(\"Ran into issues when setting blocks_per_round\");\n\t\t\t});\n\t\t}\n\n\t\text.execute_with(|| System::set_block_number(1));\n\t\text\n\t}\n\tpub fn build_and_execute_with_sanity_tests(self, test: impl FnOnce()) {\n\t\tself.build().execute_with(|| {\n\t\t\ttest();\n\t\t\tcrate::try_state::do_try_state::\u003cTest\u003e()\n\t\t\t\t.expect(\"Sanity test for parachain staking failed.\");\n\t\t})\n\t}\n}\n\n/// Compare whether the difference of both sides is at most `precision * left`.\npub(crate) fn almost_equal(left: Balance, right: Balance, precision: Perbill) -\u003e bool {\n\tlet err = precision * left;\n\tleft.max(right) - left.min(right) \u003c= err\n}\n\n/// Incrementelly traverses from the current block to the provided one and\n/// potentially sets block authors.\n///\n/// If for a block `i` the corresponding index of the authors input is set, this\n/// account is regarded to be the block author and thus gets noted.\n///\n/// NOTE: At most, this updates the RewardCount of the block author but does not\n/// increment rewards or claim them. Please use `roll_to_claim_rewards` in that\n/// case.\npub(crate) fn roll_to(n: BlockNumber, authors: Vec\u003cOption\u003cAccountId\u003e\u003e) {\n\twhile System::block_number() \u003c n {\n\t\tif let Some(Some(author)) = authors.get((System::block_number()) as usize) {\n\t\t\tStakePallet::note_author(*author);\n\t\t}\n\t\t\u003cAllPalletsWithSystem as OnFinalize\u003cu64\u003e\u003e::on_finalize(System::block_number());\n\t\tSystem::set_block_number(System::block_number() + 1);\n\t\t\u003cAllPalletsWithSystem as OnInitialize\u003cu64\u003e\u003e::on_initialize(System::block_number());\n\t}\n}\n\n#[allow(unused_must_use)]\n/// Incrementelly traverses from the current block to the provided one and\n/// potentially sets block authors.\n///\n/// If existent, rewards of the block author and their delegators are\n/// incremented and claimed.\n///\n/// If for a block `i` the corresponding index of the authors input is set, this\n/// account is regarded to be the block author and thus gets noted.\npub(crate) fn roll_to_claim_rewards(n: BlockNumber, authors: Vec\u003cOption\u003cAccountId\u003e\u003e) {\n\twhile System::block_number() \u003c n {\n\t\tif let Some(Some(author)) = authors.get((System::block_number()) as usize) {\n\t\t\tStakePallet::note_author(*author);\n\t\t\t// author must convert RewardCount to Rewards before claiming\n\t\t\tassert_ok!(StakePallet::increment_collator_rewards(RuntimeOrigin::signed(*author)));\n\n\t\t\t// author claims rewards\n\t\t\tassert_ok!(StakePallet::claim_rewards(RuntimeOrigin::signed(*author)));\n\n\t\t\t// claim rewards for delegators\n\t\t\tlet col_state =\n\t\t\t\tStakePallet::candidate_pool(author).expect(\"Block author must be candidate\");\n\t\t\tfor delegation in col_state.delegators {\n\t\t\t\t// NOTE: cannot use assert_ok! as we sometimes expect zero rewards for\n\t\t\t\t// delegators such that the claiming would throw\n\t\t\t\tStakePallet::claim_rewards(RuntimeOrigin::signed(delegation.owner));\n\t\t\t}\n\t\t}\n\t\t\u003cAllPalletsWithSystem as OnFinalize\u003cu64\u003e\u003e::on_finalize(System::block_number());\n\t\tSystem::set_block_number(System::block_number() + 1);\n\t\t\u003cAllPalletsWithSystem as OnInitialize\u003cu64\u003e\u003e::on_initialize(System::block_number());\n\t}\n}\n\npub(crate) fn last_event() -\u003e RuntimeEvent {\n\tSystem::events().pop().expect(\"Event expected\").event\n}\n\npub(crate) fn events() -\u003e Vec\u003cpallet::Event\u003cTest\u003e\u003e {\n\tSystem::events()\n\t\t.into_iter()\n\t\t.map(|r| r.event)\n\t\t.filter_map(|e| if let RuntimeEvent::StakePallet(inner) = e { Some(inner) } else { None })\n\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","runtime_api.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse frame_support::dispatch::fmt::Debug;\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::Perquintill;\n\n#[derive(Decode, Encode, TypeInfo, MaxEncodedLen, PartialEq, Eq, Debug)]\npub struct StakingRates {\n\tpub collator_staking_rate: Perquintill,\n\tpub collator_reward_rate: Perquintill,\n\tpub delegator_staking_rate: Perquintill,\n\tpub delegator_reward_rate: Perquintill,\n}\n\nsp_api::decl_runtime_apis! {\n\tpub trait ParachainStakingApi\u003cAccountId, Balance\u003e\n\twhere\n\t\tAccountId:  Eq + PartialEq + Debug + Encode + Decode + Clone,\n\t\tBalance: Encode + Decode + MaxEncodedLen + Copy + Clone + Debug + Eq + PartialEq\n\t{\n\t\tfn get_unclaimed_staking_rewards(account: \u0026AccountId) -\u003e Balance;\n\t\tfn get_staking_rates() -\u003e StakingRates;\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","set.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2023 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\nuse frame_support::{traits::Get, BoundedVec, DefaultNoBound, RuntimeDebug};\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::{traits::Zero, SaturatedConversion};\nuse sp_std::{\n\tcmp::Ordering,\n\tconvert::TryInto,\n\tops::{Index, Range, RangeFull},\n};\n\n#[cfg(feature = \"std\")]\nuse sp_std::prelude::*;\n\n/// An ordered set backed by `BoundedVec`.\n#[derive(\n\tPartialEq, Eq, Encode, Decode, DefaultNoBound, Clone, TypeInfo, MaxEncodedLen, RuntimeDebug,\n)]\n#[scale_info(skip_type_params(S))]\n#[codec(mel_bound(T: MaxEncodedLen))]\npub struct OrderedSet\u003cT, S: Get\u003cu32\u003e\u003e(BoundedVec\u003cT, S\u003e);\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e OrderedSet\u003cT, S\u003e {\n\t/// Create a new empty set.\n\tpub fn new() -\u003e Self {\n\t\tSelf(BoundedVec::default())\n\t}\n\n\tpub fn iter(\u0026self) -\u003e sp_std::slice::Iter\u003c'_, T\u003e {\n\t\tself.0.iter()\n\t}\n\n\t/// Creates an ordered set from a `BoundedVec`.\n\t///\n\t/// The vector will be sorted reversily (from greatest to lowest) and\n\t/// deduped first.\n\tpub fn from(bv: BoundedVec\u003cT, S\u003e) -\u003e Self {\n\t\tlet mut v = bv.into_inner();\n\t\tv.sort_by(|a, b| b.cmp(a));\n\t\tv.dedup();\n\t\tSelf::from_sorted_set(v.try_into().map_err(|_| ()).expect(\"No values were added\"))\n\t}\n\n\t/// Create a set from a `BoundedVec`.\n\t///\n\t/// Assumes that `v` is sorted reversely (from greatest to lowest) and only\n\t/// contains unique elements.\n\tpub fn from_sorted_set(bv: BoundedVec\u003cT, S\u003e) -\u003e Self {\n\t\tSelf(bv)\n\t}\n\n\t/// Mutate the set without restrictions. After the set was mutated it will\n\t/// be resorted and deduplicated.\n\tpub fn mutate\u003cF: FnOnce(\u0026mut BoundedVec\u003cT, S\u003e)\u003e(\u0026mut self, function: F) {\n\t\tfunction(\u0026mut self.0);\n\t\t(self.0[..]).sort_by(|a, b| b.cmp(a));\n\n\t\t// TODO: add dedup to BoundedVec\n\t\tlet mut i: usize = 0;\n\t\tlet mut next = i.saturating_add(1);\n\t\twhile next \u003c self.len() {\n\t\t\tif self[i] == self[next] {\n\t\t\t\tself.0.remove(next);\n\t\t\t} else {\n\t\t\t\ti = next;\n\t\t\t\tnext = next.saturating_add(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Inserts an element, if no equal item exist in the set.\n\t///\n\t/// Returns an error if insertion would exceed the bounded vec's max size.\n\t/// The error contains the index where the element would be inserted, if\n\t/// enough space would be left.\n\t///\n\t/// Returns true if the item is unique in the set, otherwise returns false.\n\tpub fn try_insert(\u0026mut self, value: T) -\u003e Result\u003cbool, usize\u003e {\n\t\tmatch self.linear_search(\u0026value) {\n\t\t\tOk(_) =\u003e Ok(false),\n\t\t\tErr(loc) =\u003e {\n\t\t\t\tself.0.try_insert(loc, value).map_err(|_| loc)?;\n\t\t\t\tOk(true)\n\t\t\t},\n\t\t}\n\t}\n\n\t/// Inserts an element, if no equal item exist in the set. If the set is\n\t/// full, but an element with a lower rank is in the set, the element with\n\t/// the lowest rank will be removed and the new element will be added.\n\t///\n\t/// Returns\n\t/// * Ok(Some(old_element)) if the new element was added and an old element\n\t///   had to be removed.\n\t/// * Ok(None) if the element was added without removing an element.\n\t/// * Err(true) if the set is full and the new element has a lower rank than\n\t///   the lowest element in the set.\n\t/// * Err(false) if the element is already in the set.\n\tpub fn try_insert_replace(\u0026mut self, value: T) -\u003e Result\u003cOption\u003cT\u003e, bool\u003e {\n\t\t// the highest allowed index\n\t\tlet highest_index: usize = S::get().saturating_sub(1).saturated_into();\n\t\tif S::get().is_zero() {\n\t\t\treturn Err(true)\n\t\t}\n\t\tmatch self.try_insert(value.clone()) {\n\t\t\tErr(loc) if loc \u003c= highest_index =\u003e {\n\t\t\t\t// always replace the last element\n\t\t\t\tlet last_idx = self.len().saturating_sub(1);\n\t\t\t\t// accessing by index wont panic since we checked the index, inserting the item\n\t\t\t\t// at the end of the list to ensure last-in-least-priority-rule for collators.\n\t\t\t\t// sorting algorithm must be stable!\n\t\t\t\tlet old = sp_std::mem::replace(\u0026mut self.0[last_idx], value);\n\t\t\t\tself.sort_greatest_to_lowest();\n\t\t\t\tOk(Some(old))\n\t\t\t},\n\t\t\tErr(_) =\u003e Err(true),\n\t\t\tOk(false) =\u003e Err(false),\n\t\t\tOk(_) =\u003e Ok(None),\n\t\t}\n\t}\n\n\t/// Inserts a new element or updates the value of an existing one.\n\t///\n\t/// Returns an error if the maximum size of the bounded vec would be\n\t/// exceeded upon insertion.\n\t///\n\t/// Returns the old value if existing or None if the value did not exist\n\t/// before.\n\tpub fn try_upsert(\u0026mut self, value: T) -\u003e Result\u003cOption\u003cT\u003e, ()\u003e {\n\t\tmatch self.linear_search(\u0026value) {\n\t\t\tOk(i) =\u003e {\n\t\t\t\tlet old = sp_std::mem::replace(\u0026mut self.0[i], value);\n\t\t\t\tself.sort_greatest_to_lowest();\n\t\t\t\tOk(Some(old))\n\t\t\t},\n\t\t\tErr(i) =\u003e {\n\t\t\t\t// Delegator\n\t\t\t\tself.0.try_insert(i, value).map_err(|_| ())?;\n\t\t\t\tOk(None)\n\t\t\t},\n\t\t}\n\t}\n\n\t/// Removes an element.\n\t///\n\t/// Returns true if removal happened.\n\tpub fn remove(\u0026mut self, value: \u0026T) -\u003e Option\u003cT\u003e {\n\t\tmatch self.linear_search(value) {\n\t\t\tOk(loc) =\u003e Some(self.0.remove(loc)),\n\t\t\tErr(_) =\u003e None,\n\t\t}\n\t}\n\n\t/// Return whether the set contains `value`.\n\tpub fn contains(\u0026self, value: \u0026T) -\u003e bool {\n\t\tself.linear_search(value).is_ok()\n\t}\n\n\t/// Iteratively searches this (from greatest to lowest) ordered set for a\n\t/// given element.\n\t///\n\t/// 1. If the value is found, then Result::Ok is returned, containing the\n\t/// index of the matching element.\n\t/// 2. If the value is not found, then Result::Err is returned, containing\n\t/// the index where a matching element could be inserted while maintaining\n\t/// sorted order.\n\tpub fn linear_search(\u0026self, value: \u0026T) -\u003e Result\u003cusize, usize\u003e {\n\t\tlet size = self.0.len();\n\t\tlet mut loc: usize = size;\n\t\t// keep running until we find a smaller item\n\t\tself.0\n\t\t\t.iter()\n\t\t\t.enumerate()\n\t\t\t.find_map(|(i, v)| {\n\t\t\t\tmatch (v.cmp(value), loc == size) {\n\t\t\t\t\t// prevent to have same items\n\t\t\t\t\t(Ordering::Equal, _) =\u003e Some(Ok(i)),\n\t\t\t\t\t// eventually, we want to return this index but we need to keep checking for Ordering::Equal in case\n\t\t\t\t\t// value is still in the set\n\t\t\t\t\t(Ordering::Less, true) =\u003e {\n\t\t\t\t\t\t// insert after current element\n\t\t\t\t\t\tloc = i;\n\t\t\t\t\t\tNone\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t})\n\t\t\t.unwrap_or(Err(loc))\n\t}\n\n\t/// Clear the set.\n\tpub fn clear(\u0026mut self) {\n\t\tself.0 = BoundedVec::default();\n\t}\n\n\t/// Return the length of the set.\n\tpub fn len(\u0026self) -\u003e usize {\n\t\tself.0.len()\n\t}\n\n\t/// Return whether the set is empty.\n\tpub fn is_empty(\u0026self) -\u003e bool {\n\t\tself.0.is_empty()\n\t}\n\n\t/// Convert the set to a bounded vector.\n\tpub fn into_bounded_vec(self) -\u003e BoundedVec\u003cT, S\u003e {\n\t\tself.0\n\t}\n\n\t/// Returns a reference to an element or None if out of bounds.\n\tpub fn get(\u0026self, index: usize) -\u003e Option\u003c\u0026T\u003e {\n\t\tself.0.get(index)\n\t}\n\n\t/// Sorts from greatest to lowest.\n\tpub fn sort_greatest_to_lowest(\u0026mut self) {\n\t\t(self.0[..]).sort_by(|a, b| b.cmp(a));\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e From\u003cBoundedVec\u003cT, S\u003e\u003e for OrderedSet\u003cT, S\u003e {\n\tfn from(bv: BoundedVec\u003cT, S\u003e) -\u003e Self {\n\t\tSelf::from(bv)\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e Index\u003cusize\u003e for OrderedSet\u003cT, S\u003e {\n\ttype Output = T;\n\n\tfn index(\u0026self, index: usize) -\u003e \u0026Self::Output {\n\t\t\u0026self.0[index]\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e Index\u003cRange\u003cusize\u003e\u003e for OrderedSet\u003cT, S\u003e {\n\ttype Output = [T];\n\n\tfn index(\u0026self, range: Range\u003cusize\u003e) -\u003e \u0026Self::Output {\n\t\t\u0026self.0[range]\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e Index\u003cRangeFull\u003e for OrderedSet\u003cT, S\u003e {\n\ttype Output = [T];\n\n\tfn index(\u0026self, range: RangeFull) -\u003e \u0026Self::Output {\n\t\t\u0026self.0[range]\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e IntoIterator for OrderedSet\u003cT, S\u003e {\n\ttype Item = T;\n\ttype IntoIter = sp_std::vec::IntoIter\u003cSelf::Item\u003e;\n\n\tfn into_iter(self) -\u003e Self::IntoIter {\n\t\tself.0.into_iter()\n\t}\n}\n\nimpl\u003cT: Ord + Clone, S: Get\u003cu32\u003e\u003e From\u003cOrderedSet\u003cT, S\u003e\u003e for BoundedVec\u003cT, S\u003e {\n\tfn from(s: OrderedSet\u003cT, S\u003e) -\u003e Self {\n\t\ts.0\n\t}\n}\n\n#[cfg(test)]\nmod tests {\n\tuse crate::{mock::Test, types::StakeOf};\n\tuse frame_support::parameter_types;\n\tuse sp_runtime::RuntimeDebug;\n\n\tuse super::*;\n\n\tparameter_types! {\n\t\t#[derive(Eq, PartialEq, RuntimeDebug)]\n\t\tpub const Zero: u32 = 0;\n\t\t#[derive(Eq, PartialEq, RuntimeDebug)]\n\t\tpub const One: u32 = 1;\n\t\t#[derive(Eq, PartialEq, RuntimeDebug)]\n\t\tpub const Eight: u32 = 8;\n\t\t#[derive(Clone, Eq, PartialEq, RuntimeDebug)]\n\t\tpub const Five: u32 = 5;\n\t}\n\n\t#[test]\n\tfn from() {\n\t\tlet v: BoundedVec\u003ci32, Eight\u003e = vec![4, 2, 3, 4, 3, 1].try_into().unwrap();\n\t\tlet set: OrderedSet\u003ci32, Eight\u003e = v.into();\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 2, 3, 4].try_into().unwrap()));\n\t}\n\n\t#[test]\n\tfn insert() {\n\t\tlet mut set: OrderedSet\u003ci32, Eight\u003e = OrderedSet::new();\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![].try_into().unwrap()));\n\n\t\tassert_eq!(set.try_insert(1), Ok(true));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1].try_into().unwrap()));\n\n\t\tassert_eq!(set.try_insert(5), Ok(true));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 5].try_into().unwrap()));\n\n\t\tassert_eq!(set.try_insert(3), Ok(true));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 3, 5].try_into().unwrap()));\n\n\t\tassert_eq!(set.try_insert(3), Ok(false));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 3, 5].try_into().unwrap()));\n\t}\n\n\t#[test]\n\tfn remove() {\n\t\tlet mut set: OrderedSet\u003ci32, Eight\u003e =\n\t\t\tOrderedSet::from(vec![1, 2, 3, 4].try_into().unwrap());\n\n\t\tassert_eq!(set.remove(\u00265), None);\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![1, 2, 3, 4].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00261), Some(1));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![2, 3, 4].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00263), Some(3));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![2, 4].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00263), None);\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![2, 4].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00264), Some(4));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![2].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00262), Some(2));\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![].try_into().unwrap()));\n\n\t\tassert_eq!(set.remove(\u00262), None);\n\t\tassert_eq!(set, OrderedSet::\u003ci32, Eight\u003e::from(vec![].try_into().unwrap()));\n\t}\n\n\t#[test]\n\tfn contains() {\n\t\tlet set: OrderedSet\u003ci32, Eight\u003e = OrderedSet::from(vec![1, 2, 3, 4].try_into().unwrap());\n\t\tassert!(!set.contains(\u00265));\n\t\tassert!(set.contains(\u00261));\n\t\tassert!(set.contains(\u00263));\n\t}\n\n\t#[test]\n\tfn clear() {\n\t\tlet mut set: OrderedSet\u003ci32, Eight\u003e =\n\t\t\tOrderedSet::from(vec![1, 2, 3, 4].try_into().unwrap());\n\t\tset.clear();\n\t\tassert_eq!(set, OrderedSet::new());\n\t}\n\n\t#[test]\n\tfn try_insert_replace_integer() {\n\t\tlet mut set: OrderedSet\u003ci32, Zero\u003e = OrderedSet::from(vec![].try_into().unwrap());\n\t\tassert_eq!(set.try_insert_replace(10), Err(true));\n\n\t\tlet mut set: OrderedSet\u003ci32, One\u003e = OrderedSet::from(vec![].try_into().unwrap());\n\t\tassert_eq!(set.try_insert_replace(10), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(9), Err(true));\n\t\tassert_eq!(set.try_insert_replace(11), Ok(Some(10)));\n\n\t\tlet mut set: OrderedSet\u003ci32, Five\u003e = OrderedSet::from(vec![].try_into().unwrap());\n\t\tassert_eq!(set.try_insert_replace(10), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(7), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(9), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(8), Ok(None));\n\n\t\tassert_eq!(set.clone().into_bounded_vec().into_inner(), vec![10, 9, 8, 7]);\n\t\tassert_eq!(set.try_insert_replace(5), Ok(None));\n\t\tassert!(set.try_insert(11).is_err());\n\n\t\tassert_eq!(set.try_insert_replace(6), Ok(Some(5)));\n\t\tassert_eq!(set.clone().into_bounded_vec().into_inner(), vec![10, 9, 8, 7, 6]);\n\n\t\tassert_eq!(set.try_insert_replace(6), Err(false));\n\t\tassert_eq!(set.try_insert_replace(5), Err(true));\n\n\t\tassert_eq!(set.try_insert_replace(10), Err(false));\n\t\tassert_eq!(set.try_insert_replace(11), Ok(Some(6)));\n\t\tassert_eq!(set.into_bounded_vec().into_inner(), vec![11, 10, 9, 8, 7]);\n\t}\n\n\t#[test]\n\tfn try_insert_replace_stake() {\n\t\tlet mut set: OrderedSet\u003cStakeOf\u003cTest\u003e, Eight\u003e = OrderedSet::from(\n\t\t\tvec![\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 8, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t]\n\t\t\t.try_into()\n\t\t\t.unwrap(),\n\t\t);\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 1, amount: 0 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 7, amount: 100 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 7, amount: 50 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 8, amount: 50 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 2, amount: 100 }), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 2, amount: 90 }), Err(false));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 10, amount: 65 }), Ok(None));\n\t\tassert_eq!(set.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 11, amount: 60 }), Err(true));\n\t\tassert_eq!(\n\t\t\tset.try_insert_replace(StakeOf::\u003cTest\u003e { owner: 11, amount: 100 }),\n\t\t\tOk(Some(StakeOf::\u003cTest\u003e { owner: 9, amount: 60 }))\n\t\t);\n\t}\n\n\t#[test]\n\tfn exceeding_max_size_should_fail() {\n\t\tlet mut set: OrderedSet\u003ci32, Five\u003e =\n\t\t\tOrderedSet::from(vec![1, 2, 3, 4, 5].try_into().unwrap());\n\t\tlet inserted = set.try_insert(6);\n\n\t\tassert!(inserted.is_err());\n\t}\n\n\t#[test]\n\tfn linear_search() {\n\t\tlet set: OrderedSet\u003cStakeOf\u003cTest\u003e, Eight\u003e = OrderedSet::from(\n\t\t\tvec![\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 8, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t]\n\t\t\t.try_into()\n\t\t\t.unwrap(),\n\t\t);\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 1, amount: 0 }), Ok(0));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 7, amount: 100 }), Ok(3));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 7, amount: 50 }), Ok(3));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 8, amount: 50 }), Ok(4));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 100 }), Err(1));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 90 }), Err(2));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 65 }), Err(5));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 60 }), Err(6));\n\t\tassert_eq!(set.linear_search(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 59 }), Err(6));\n\t}\n\n\t#[test]\n\tfn upsert_set() {\n\t\tlet mut set: OrderedSet\u003cStakeOf\u003cTest\u003e, Eight\u003e = OrderedSet::from(\n\t\t\tvec![\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t]\n\t\t\t.try_into()\n\t\t\t.unwrap(),\n\t\t);\n\t\tassert_eq!(set.try_insert(StakeOf::\u003cTest\u003e { owner: 2, amount: 75 }), Ok(true));\n\t\tassert_eq!(\n\t\t\tset,\n\t\t\tOrderedSet::from(\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 75 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t\t]\n\t\t\t\t.try_into()\n\t\t\t\t.unwrap()\n\t\t\t)\n\t\t);\n\t\tassert_eq!(\n\t\t\tset.try_upsert(StakeOf::\u003cTest\u003e { owner: 2, amount: 90 }),\n\t\t\tOk(Some(StakeOf::\u003cTest\u003e { owner: 2, amount: 75 }))\n\t\t);\n\t\tassert_eq!(\n\t\t\tset,\n\t\t\tOrderedSet::from(\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 90 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t\t]\n\t\t\t\t.try_into()\n\t\t\t\t.unwrap()\n\t\t\t)\n\t\t);\n\t\tassert_eq!(\n\t\t\tset.try_upsert(StakeOf::\u003cTest\u003e { owner: 2, amount: 60 }),\n\t\t\tOk(Some(StakeOf::\u003cTest\u003e { owner: 2, amount: 90 }))\n\t\t);\n\t\tassert_eq!(\n\t\t\tset,\n\t\t\tOrderedSet::from(\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 90 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 80 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 70 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 60 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 9, amount: 60 },\n\t\t\t\t]\n\t\t\t\t.try_into()\n\t\t\t\t.unwrap()\n\t\t\t)\n\t\t);\n\t}\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":91},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","tests.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\n//! Unit testing\n\nuse std::{convert::TryInto, iter};\n\nuse frame_support::{\n\tassert_noop, assert_ok, storage::bounded_btree_map::BoundedBTreeMap,\n\ttraits::EstimateNextSessionRotation, BoundedVec,\n};\nuse pallet_authorship::EventHandler;\nuse pallet_balances::{BalanceLock, Error as BalancesError, Reasons};\nuse pallet_session::{SessionManager, ShouldEndSession};\nuse sp_runtime::{traits::Zero, Perbill, Permill, Perquintill, SaturatedConversion};\n\nuse crate::{\n\tmock::{\n\t\talmost_equal, events, last_event, roll_to, roll_to_claim_rewards, AccountId, Balance,\n\t\tBalances, BlockNumber, ExtBuilder, RuntimeEvent as MetaEvent, RuntimeOrigin as Origin,\n\t\tSession, StakePallet, System, Test, BLOCKS_PER_ROUND, DECIMALS, TREASURY_ACC,\n\t},\n\truntime_api::StakingRates,\n\tset::OrderedSet,\n\ttypes::{\n\t\tBalanceOf, Candidate, CandidateStatus, DelegationCounter, Delegator, RoundInfo, Stake,\n\t\tStakeOf, TotalStake,\n\t},\n\tCandidatePool, Config, Error, Event, InflationInfo, RewardRate, StakingInfo, STAKING_ID,\n};\n\n#[test]\nfn should_select_collators_genesis_session() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 20),\n\t\t\t(2, 20),\n\t\t\t(3, 20),\n\t\t\t(4, 20),\n\t\t\t(5, 20),\n\t\t\t(6, 20),\n\t\t\t(7, 20),\n\t\t\t(8, 20),\n\t\t\t(9, 20),\n\t\t\t(10, 20),\n\t\t\t(11, 20),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::new_session(0)\n\t\t\t\t\t.expect(\"first session must return new collators\")\n\t\t\t\t\t.len(),\n\t\t\t\t2\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::new_session(1)\n\t\t\t\t\t.expect(\"second session must return new collators\")\n\t\t\t\t\t.len(),\n\t\t\t\t2\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn genesis() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 300),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 9),\n\t\t\t(9, 4),\n\t\t])\n\t\t.with_collators(vec![(1, 500), (2, 200)])\n\t\t.with_delegators(vec![(3, 1, 100), (4, 1, 100), (5, 2, 100), (6, 2, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert!(System::events().is_empty());\n\n\t\t\t// Collators\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 700, delegators: 400 }\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 700 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 400 }\n\t\t\t\t]\n\t\t\t\t.try_into(),\n\t\t\t\tOk(StakePallet::top_candidates().into_bounded_vec())\n\t\t\t);\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\n\t\t\t// 1\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), 500);\n\t\t\tassert_eq!(Balances::free_balance(\u00261), 1000);\n\t\t\tassert!(StakePallet::is_active_candidate(\u00261).is_some());\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(\u00261),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 1,\n\t\t\t\t\tstake: 500,\n\t\t\t\t\tdelegators: OrderedSet::from_sorted_set(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 100 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 700,\n\t\t\t\t\tstatus: CandidateStatus::Active,\n\t\t\t\t})\n\t\t\t);\n\t\t\t// 2\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u00262), 300);\n\t\t\tassert!(StakePallet::is_active_candidate(\u00262).is_some());\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(\u00262),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 2,\n\t\t\t\t\tstake: 200,\n\t\t\t\t\tdelegators: OrderedSet::from_sorted_set(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 400,\n\t\t\t\t\tstatus: CandidateStatus::Active,\n\t\t\t\t})\n\t\t\t);\n\t\t\t// Delegators\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 700, delegators: 400 }\n\t\t\t);\n\t\t\tfor x in 3..7 {\n\t\t\t\tassert!(StakePallet::is_delegator(\u0026x));\n\t\t\t\tassert_eq!(Balances::usable_balance(\u0026x), 0);\n\t\t\t\tassert_eq!(Balances::free_balance(\u0026x), 100);\n\t\t\t}\n\t\t\t// Uninvolved\n\t\t\tfor x in 7..10 {\n\t\t\t\tassert!(!StakePallet::is_delegator(\u0026x));\n\t\t\t}\n\t\t\tassert_eq!(Balances::free_balance(\u00267), 100);\n\t\t\tassert_eq!(Balances::usable_balance(\u00267), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u00268), 9);\n\t\t\tassert_eq!(Balances::usable_balance(\u00268), 9);\n\t\t\tassert_eq!(Balances::free_balance(\u00269), 4);\n\t\t\tassert_eq!(Balances::usable_balance(\u00269), 4);\n\n\t\t\t// Safety first checks\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::max_selected_candidates(),\n\t\t\t\t\u003cTest as Config\u003e::MinCollators::get()\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::round(),\n\t\t\t\tRoundInfo::new(0u32, 0u32.into(), \u003cTest as Config\u003e::DefaultBlocksPerRound::get())\n\t\t\t);\n\t\t});\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(6, 1, 10), (7, 1, 10), (8, 2, 10), (9, 2, 10), (10, 1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert!(System::events().is_empty());\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 5);\n\n\t\t\t// Collators\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 40, delegators: 50 }\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tOk(StakePallet::top_candidates().into_bounded_vec()),\n\t\t\t\tvec![\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 50 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 40 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 20 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 20 },\n\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 10 }\n\t\t\t\t]\n\t\t\t\t.try_into()\n\t\t\t);\n\t\t\tfor x in 1..5 {\n\t\t\t\tassert!(StakePallet::is_active_candidate(\u0026x).is_some());\n\t\t\t\tassert_eq!(Balances::free_balance(\u0026x), 100);\n\t\t\t\tassert_eq!(Balances::usable_balance(\u0026x), 80);\n\t\t\t}\n\t\t\tassert!(StakePallet::is_active_candidate(\u00265).is_some());\n\t\t\tassert_eq!(Balances::free_balance(\u00265), 100);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), 90);\n\t\t\t// Delegators\n\t\t\tfor x in 6..11 {\n\t\t\t\tassert!(StakePallet::is_delegator(\u0026x));\n\t\t\t\tassert_eq!(Balances::free_balance(\u0026x), 100);\n\t\t\t\tassert_eq!(Balances::usable_balance(\u0026x), 90);\n\t\t\t}\n\n\t\t\t// Safety first checks\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::max_selected_candidates(),\n\t\t\t\t\u003cTest as Config\u003e::MinCollators::get()\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::round(),\n\t\t\t\tRoundInfo::new(0, 0, \u003cTest as Config\u003e::DefaultBlocksPerRound::get())\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn join_collator_candidates() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 300),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 9),\n\t\t\t(9, 4),\n\t\t\t(10, 161_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 500), (2, 200)])\n\t\t.with_delegators(vec![(3, 1, 100), (4, 1, 100), (5, 2, 100), (6, 2, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 700, delegators: 400 }\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(1), 11u128,),\n\t\t\t\tError::\u003cTest\u003e::CandidateExists\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(1), 1, 11u128,),\n\t\t\t\tError::\u003cTest\u003e::CandidateExists\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(3), 11u128,),\n\t\t\t\tError::\u003cTest\u003e::DelegatorExists\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(7), 9u128,),\n\t\t\t\tError::\u003cTest\u003e::ValStakeBelowMin\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(8), 10u128,),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\t\t\tassert!(System::events().is_empty());\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(7), 10u128,));\n\t\t\tassert_eq!(\n\t\t\t\tlast_event(),\n\t\t\t\tMetaEvent::StakePallet(Event::JoinedCollatorCandidates(7, 10u128))\n\t\t\t);\n\n\t\t\t// MaxCollatorCandidateStake\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(10), 161_000_000 * DECIMALS),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_candidates(\n\t\t\t\tOrigin::signed(10),\n\t\t\t\tStakePallet::max_candidate_stake()\n\t\t\t));\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 4);\n\n\t\t\tassert_eq!(\n\t\t\t\tlast_event(),\n\t\t\t\tMetaEvent::StakePallet(Event::JoinedCollatorCandidates(\n\t\t\t\t\t10,\n\t\t\t\t\tStakePallet::max_candidate_stake(),\n\t\t\t\t))\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn collator_exit_executes_after_delay() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 300),\n\t\t\t(3, 110),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 9),\n\t\t\t(9, 4),\n\t\t\t(10, 10),\n\t\t])\n\t\t.with_collators(vec![(1, 500), (2, 200), (7, 100)])\n\t\t.with_delegators(vec![(3, 1, 100), (4, 1, 100), (5, 2, 100), (6, 2, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 3);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 700, delegators: 400 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 800, delegators: 400 }\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 7]);\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(3)),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\n\t\t\troll_to(11, vec![]);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\t// Still three, candidate didn't leave yet\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 3);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(10), 2, 10),\n\t\t\t\tError::\u003cTest\u003e::CannotDelegateIfLeaving\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 7]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(2, 2, 4)));\n\t\t\tlet info = StakePallet::candidate_pool(\u00262).unwrap();\n\t\t\tassert_eq!(info.status, CandidateStatus::Leaving(4));\n\n\t\t\troll_to(21, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(2), 2));\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\n\t\t\t// we must exclude leaving collators from rewards while\n\t\t\t// holding them retroactively accountable for previous faults\n\t\t\t// (within the last T::StakeDuration blocks)\n\t\t\troll_to(25, vec![]);\n\t\t\tlet expected = vec![\n\t\t\t\tEvent::MaxSelectedCandidatesSet(2, 5),\n\t\t\t\tEvent::NewRound(5, 1),\n\t\t\t\tEvent::NewRound(10, 2),\n\t\t\t\tEvent::LeftTopCandidates(2),\n\t\t\t\tEvent::CollatorScheduledExit(2, 2, 4),\n\t\t\t\tEvent::NewRound(15, 3),\n\t\t\t\tEvent::NewRound(20, 4),\n\t\t\t\tEvent::CandidateLeft(2, 400),\n\t\t\t\tEvent::NewRound(25, 5),\n\t\t\t];\n\t\t\tassert_eq!(events(), expected);\n\t\t});\n}\n\n#[test]\nfn collator_selection_chooses_top_candidates() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 1000),\n\t\t\t(3, 1000),\n\t\t\t(4, 1000),\n\t\t\t(5, 1000),\n\t\t\t(6, 1000),\n\t\t\t(7, 33),\n\t\t\t(8, 33),\n\t\t\t(9, 33),\n\t\t])\n\t\t.with_collators(vec![(1, 100), (2, 90), (3, 80), (4, 70), (5, 60), (6, 50)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 190, delegators: 0 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 400, delegators: 0 }\n\t\t\t);\n\t\t\troll_to(8, vec![]);\n\t\t\t// should choose top MaxSelectedCandidates (5), in order\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\t\t\tlet expected = vec![Event::MaxSelectedCandidatesSet(2, 5), Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), expected);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(6)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5],);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(1, 6, 3)));\n\n\t\t\troll_to(15, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(6), 6));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\n\t\t\troll_to(21, vec![]);\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(6), 69u128));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tlast_event(),\n\t\t\t\tMetaEvent::StakePallet(Event::JoinedCollatorCandidates(6, 69u128))\n\t\t\t);\n\n\t\t\troll_to(27, vec![]);\n\t\t\t// should choose top MaxSelectedCandidates (5), in order\n\t\t\tlet expected = vec![\n\t\t\t\tEvent::MaxSelectedCandidatesSet(2, 5),\n\t\t\t\tEvent::NewRound(5, 1),\n\t\t\t\tEvent::LeftTopCandidates(6),\n\t\t\t\tEvent::CollatorScheduledExit(1, 6, 3),\n\t\t\t\t// TotalCollatorStake is updated once candidate 6 left in `execute_delayed_collator_exits`\n\t\t\t\tEvent::NewRound(10, 2),\n\t\t\t\tEvent::NewRound(15, 3),\n\t\t\t\tEvent::CandidateLeft(6, 50),\n\t\t\t\tEvent::NewRound(20, 4),\n\t\t\t\t// 5 had staked 60 which was exceeded by 69 of 6\n\t\t\t\tEvent::EnteredTopCandidates(6),\n\t\t\t\tEvent::JoinedCollatorCandidates(6, 69),\n\t\t\t\tEvent::NewRound(25, 5),\n\t\t\t];\n\t\t\tassert_eq!(events(), expected);\n\t\t});\n}\n\n#[test]\nfn exit_queue_with_events() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 1000),\n\t\t\t(3, 1000),\n\t\t\t(4, 1000),\n\t\t\t(5, 1000),\n\t\t\t(6, 1000),\n\t\t\t(7, 33),\n\t\t\t(8, 33),\n\t\t\t(9, 33),\n\t\t])\n\t\t.with_collators(vec![(1, 100), (2, 90), (3, 80), (4, 70), (5, 60), (6, 50)])\n\t\t.with_inflation(100, 15, 40, 10, BLOCKS_PER_ROUND)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 6);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\n\t\t\troll_to(8, vec![]);\n\t\t\t// should choose top MaxSelectedCandidates (5), in order\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\t\t\tlet mut expected = vec![Event::MaxSelectedCandidatesSet(2, 5), Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), expected);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(6)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(1, 6, 3)));\n\n\t\t\troll_to(11, vec![]);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(5)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(2, 5, 4)));\n\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 6, \"No collators have left yet.\");\n\t\t\troll_to(16, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(6), 6));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(4)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(3, 4, 5)));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(4)),\n\t\t\t\tError::\u003cTest\u003e::AlreadyLeaving\n\t\t\t);\n\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 5, \"Collator #5 left.\");\n\t\t\troll_to(20, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(5), 5));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3]);\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 4, \"Two out of six collators left.\");\n\n\t\t\troll_to(26, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(4), 4));\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 3, \"Three out of six collators left.\");\n\n\t\t\troll_to(30, vec![]);\n\t\t\tlet mut new_events = vec![\n\t\t\t\tEvent::LeftTopCandidates(6),\n\t\t\t\tEvent::CollatorScheduledExit(1, 6, 3),\n\t\t\t\tEvent::NewRound(10, 2),\n\t\t\t\tEvent::LeftTopCandidates(5),\n\t\t\t\tEvent::CollatorScheduledExit(2, 5, 4),\n\t\t\t\tEvent::NewRound(15, 3),\n\t\t\t\tEvent::CandidateLeft(6, 50),\n\t\t\t\tEvent::LeftTopCandidates(4),\n\t\t\t\tEvent::CollatorScheduledExit(3, 4, 5),\n\t\t\t\tEvent::NewRound(20, 4),\n\t\t\t\tEvent::CandidateLeft(5, 60),\n\t\t\t\tEvent::NewRound(25, 5),\n\t\t\t\tEvent::CandidateLeft(4, 70),\n\t\t\t\tEvent::NewRound(30, 6),\n\t\t\t];\n\t\t\texpected.append(\u0026mut new_events);\n\t\t\tassert_eq!(events(), expected);\n\t\t});\n}\n\n#[test]\nfn execute_leave_candidates_with_delay() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 1000),\n\t\t\t(3, 1000),\n\t\t\t(4, 1000),\n\t\t\t(5, 1000),\n\t\t\t(6, 1000),\n\t\t\t(7, 1000),\n\t\t\t(8, 1000),\n\t\t\t(9, 1000),\n\t\t\t(10, 1000),\n\t\t\t(11, 1000),\n\t\t\t(12, 1000),\n\t\t\t(13, 1000),\n\t\t\t(14, 1000),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 30),\n\t\t\t(4, 40),\n\t\t\t(5, 50),\n\t\t\t(6, 60),\n\t\t\t(7, 70),\n\t\t\t(8, 80),\n\t\t\t(9, 90),\n\t\t\t(10, 100),\n\t\t])\n\t\t.with_delegators(vec![(11, 1, 110), (12, 1, 120), (13, 2, 130), (14, 2, 140)])\n\t\t.with_inflation(100, 15, 40, 10, BLOCKS_PER_ROUND)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 10);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 30, delegators: 500 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 300, delegators: 500 }\n\t\t\t);\n\n\t\t\troll_to(5, vec![]);\n\t\t\t// should choose top MaxSelectedCandidates (5), in order\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 1, 10, 9, 8]);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(10)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(9)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(7)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(6)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(5)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(8)));\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![4, 3]);\n\t\t\tfor owner in vec![1, 2, 5, 6, 7, 8, 9, 10].iter() {\n\t\t\t\tassert!(StakePallet::candidate_pool(owner)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.can_exit(1 + \u003cTest as Config\u003e::ExitQueueDelay::get()));\n\t\t\t}\n\t\t\tlet total_stake = TotalStake { collators: 70, delegators: 0 };\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(1),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 1,\n\t\t\t\t\tstake: 10,\n\t\t\t\t\tdelegators: OrderedSet::from(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 11, amount: 110 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 12, amount: 120 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 240,\n\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t})\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 2,\n\t\t\t\t\tstake: 20,\n\t\t\t\t\tdelegators: OrderedSet::from(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 13, amount: 130 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 14, amount: 140 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 290,\n\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t})\n\t\t\t);\n\t\t\tfor collator in 5u64..=10u64 {\n\t\t\t\tassert_eq!(\n\t\t\t\t\tStakePallet::candidate_pool(collator),\n\t\t\t\t\tSome(Candidate::\u003c\n\t\t\t\t\t\tAccountId,\n\t\t\t\t\t\tBalance,\n\t\t\t\t\t\t\u003cTest as Config\u003e::MaxDelegatorsPerCollator,\n\t\t\t\t\t\u003e {\n\t\t\t\t\t\tid: collator,\n\t\t\t\t\t\tstake: collator as u128 * 10u128,\n\t\t\t\t\t\tdelegators: OrderedSet::from(BoundedVec::default()),\n\t\t\t\t\t\ttotal: collator as u128 * 10u128,\n\t\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tassert!(StakePallet::is_active_candidate(\u0026collator).is_some());\n\t\t\t\tassert!(StakePallet::unstaking(collator).is_empty());\n\t\t\t}\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(11),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(1), amount: 110 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(12),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(1), amount: 120 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(13),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(2), amount: 130 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(14),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(2), amount: 140 })\n\t\t\t);\n\t\t\tfor delegator in 11u64..=14u64 {\n\t\t\t\tassert!(StakePallet::is_delegator(\u0026delegator));\n\t\t\t\tassert!(StakePallet::unstaking(delegator).is_empty());\n\t\t\t}\n\n\t\t\t// exits cannot be executed yet but in the next round\n\t\t\troll_to(10, vec![]);\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![4, 3]);\n\t\t\tfor owner in vec![1, 2, 5, 6, 7, 8, 9, 10].iter() {\n\t\t\t\tassert!(StakePallet::candidate_pool(owner)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.can_exit(1 + \u003cTest as Config\u003e::ExitQueueDelay::get()));\n\t\t\t\tassert_noop!(\n\t\t\t\t\tStakePallet::execute_leave_candidates(Origin::signed(*owner), *owner),\n\t\t\t\t\tError::\u003cTest\u003e::CannotLeaveYet\n\t\t\t\t);\n\t\t\t}\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(1),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 1,\n\t\t\t\t\tstake: 10,\n\t\t\t\t\tdelegators: OrderedSet::from(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 11, amount: 110 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 12, amount: 120 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 240,\n\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t})\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2),\n\t\t\t\tSome(Candidate::\u003cAccountId, Balance, \u003cTest as Config\u003e::MaxDelegatorsPerCollator\u003e {\n\t\t\t\t\tid: 2,\n\t\t\t\t\tstake: 20,\n\t\t\t\t\tdelegators: OrderedSet::from(\n\t\t\t\t\t\tvec![\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 13, amount: 130 },\n\t\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 14, amount: 140 }\n\t\t\t\t\t\t]\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t\t),\n\t\t\t\t\ttotal: 290,\n\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t})\n\t\t\t);\n\t\t\tfor collator in 5u64..=10u64 {\n\t\t\t\tassert_eq!(\n\t\t\t\t\tStakePallet::candidate_pool(collator),\n\t\t\t\t\tSome(Candidate::\u003c\n\t\t\t\t\t\tAccountId,\n\t\t\t\t\t\tBalance,\n\t\t\t\t\t\t\u003cTest as Config\u003e::MaxDelegatorsPerCollator,\n\t\t\t\t\t\u003e {\n\t\t\t\t\t\tid: collator,\n\t\t\t\t\t\tstake: collator as u128 * 10u128,\n\t\t\t\t\t\tdelegators: OrderedSet::from(BoundedVec::default()),\n\t\t\t\t\t\ttotal: collator as u128 * 10u128,\n\t\t\t\t\t\tstatus: CandidateStatus::Leaving(3)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tassert!(StakePallet::is_active_candidate(\u0026collator).is_some());\n\t\t\t\tassert!(StakePallet::unstaking(collator).is_empty());\n\t\t\t}\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(11),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(1), amount: 110 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(12),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(1), amount: 120 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(13),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(2), amount: 130 })\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::delegator_state(14),\n\t\t\t\tSome(Delegator::\u003cAccountId, Balance\u003e { owner: Some(2), amount: 140 })\n\t\t\t);\n\t\t\tfor delegator in 11u64..=14u64 {\n\t\t\t\tassert!(StakePallet::is_delegator(\u0026delegator));\n\t\t\t\tassert!(StakePallet::unstaking(delegator).is_empty());\n\t\t\t}\n\n\t\t\t// first five exits are executed\n\t\t\troll_to(15, vec![]);\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![4, 3]);\n\t\t\tfor collator in vec![1u64, 2u64, 5u64, 6u64, 7u64].iter() {\n\t\t\t\tassert_ok!(StakePallet::execute_leave_candidates(\n\t\t\t\t\tOrigin::signed(*collator),\n\t\t\t\t\t*collator\n\t\t\t\t));\n\t\t\t\tassert!(StakePallet::candidate_pool(\u0026collator).is_none());\n\t\t\t\tassert!(StakePallet::is_active_candidate(collator).is_none());\n\t\t\t\tassert_eq!(StakePallet::unstaking(collator).len(), 1);\n\t\t\t}\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 5, \"Five collators left.\");\n\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), total_stake);\n\t\t\tfor delegator in 11u64..=14u64 {\n\t\t\t\tassert!(!StakePallet::is_delegator(\u0026delegator));\n\t\t\t\tassert_eq!(StakePallet::unstaking(delegator).len(), 1);\n\t\t\t}\n\n\t\t\t// last 3 exits are executed\n\t\t\troll_to(20, vec![]);\n\t\t\tfor collator in 8u64..=10u64 {\n\t\t\t\tassert_ok!(StakePallet::execute_leave_candidates(\n\t\t\t\t\tOrigin::signed(collator),\n\t\t\t\t\tcollator\n\t\t\t\t));\n\t\t\t\tassert!(StakePallet::candidate_pool(\u0026collator).is_none());\n\t\t\t\tassert!(StakePallet::is_active_candidate(\u0026collator).is_none());\n\t\t\t\tassert_eq!(StakePallet::unstaking(collator).len(), 1);\n\t\t\t}\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2, \"3 collators left.\");\n\t\t});\n}\n\n// FIXME: Re-enable or potentially remove entirely\n#[test]\nfn multiple_delegations() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t\t(11, 100),\n\t\t\t(12, 100),\n\t\t\t// new\n\t\t\t(13, 100),\n\t\t\t(14, 100),\n\t\t\t(15, 100),\n\t\t\t(16, 100),\n\t\t\t(17, 100),\n\t\t\t(18, 100),\n\t\t\t(99, 1),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(6, 1, 10), (7, 1, 10), (8, 2, 10), (9, 2, 10), (10, 1, 10)])\n\t\t.set_blocks_per_round(5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\troll_to(\n\t\t\t\t8,\n\t\t\t\tvec![Some(1), Some(2), Some(3), Some(4), Some(5), Some(1), Some(2), Some(3)],\n\t\t\t);\n\t\t\t// chooses top MaxSelectedCandidates (5), in order\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 3, 4, 5]);\n\t\t\tlet mut expected = vec![Event::MaxSelectedCandidatesSet(2, 5), Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), expected);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(13), 2, 2),\n\t\t\t\tError::\u003cTest\u003e::DelegationBelowMin,\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(13), 2, 10));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(14), 4, 10));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(15), 3, 10));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 4, 3, 5]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(6), 5, 10),\n\t\t\t\tError::\u003cTest\u003e::AlreadyDelegating,\n\t\t\t);\n\n\t\t\troll_to(\n\t\t\t\t16,\n\t\t\t\tvec![Some(1), Some(2), Some(3), Some(4), Some(5), Some(1), Some(2), Some(3)],\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2, 4, 3, 5]);\n\t\t\tlet mut new = vec![\n\t\t\t\tEvent::Delegation(13, 10, 2, 50),\n\t\t\t\tEvent::Delegation(14, 10, 4, 30),\n\t\t\t\tEvent::Delegation(15, 10, 3, 30),\n\t\t\t\tEvent::NewRound(10, 2),\n\t\t\t\tEvent::NewRound(15, 3),\n\t\t\t];\n\t\t\texpected.append(\u0026mut new);\n\t\t\tassert_eq!(events(), expected);\n\n\t\t\troll_to(21, vec![Some(1), Some(2), Some(3), Some(4), Some(5)]);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(16), 2, 80));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(99), 3, 11),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(17), 2, 10),\n\t\t\t\tError::\u003cTest\u003e::TooManyDelegators\n\t\t\t);\n\t\t\t// kick 13 by staking 1 more (11 \u003e 10)\n\t\t\tassert!(StakePallet::unstaking(13).is_empty());\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(17), 2, 11));\n\t\t\tassert!(StakePallet::delegator_state(13).is_none());\n\t\t\tassert_eq!(StakePallet::unstaking(13).get(\u002623), Some(\u002610u128));\n\t\t\t// kick 9 by staking 1 more (11 \u003e 10)\n\t\t\tassert!(StakePallet::unstaking(9).is_empty());\n\t\t\tassert!(StakePallet::rewards(9).is_zero());\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(11), 2, 11));\n\t\t\t// 11 should be initiated with the same reward counter as their collator 2\n\t\t\tassert_eq!(StakePallet::reward_count(2), StakePallet::reward_count(11));\n\n\t\t\tassert!(StakePallet::delegator_state(9).is_none());\n\t\t\tassert_eq!(StakePallet::unstaking(9).get(\u002623), Some(\u002610u128));\n\t\t\tassert!(!StakePallet::candidate_pool(2)\n\t\t\t\t.unwrap()\n\t\t\t\t.delegators\n\t\t\t\t.contains(\u0026StakeOf::\u003cTest\u003e { owner: 9, amount: 10 }));\n\n\t\t\troll_to(26, vec![Some(1), Some(2), Some(3), Some(4), Some(5)]);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 1, 4, 3, 5]);\n\t\t\tlet mut new2 = vec![\n\t\t\t\tEvent::NewRound(20, 4),\n\t\t\t\tEvent::Delegation(16, 80, 2, 130),\n\t\t\t\tEvent::DelegationReplaced(17, 11, 13, 10, 2, 131),\n\t\t\t\tEvent::Delegation(17, 11, 2, 131),\n\t\t\t\tEvent::DelegationReplaced(11, 11, 9, 10, 2, 132),\n\t\t\t\tEvent::Delegation(11, 11, 2, 132),\n\t\t\t\tEvent::NewRound(25, 5),\n\t\t\t];\n\t\t\texpected.append(\u0026mut new2);\n\t\t\tassert_eq!(events(), expected);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 4, 3, 5]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorScheduledExit(5, 2, 7)));\n\n\t\t\troll_to(31, vec![Some(1), Some(2), Some(3), Some(4), Some(5)]);\n\t\t\tlet mut new3 = vec![\n\t\t\t\tEvent::LeftTopCandidates(2),\n\t\t\t\tEvent::CollatorScheduledExit(5, 2, 7),\n\t\t\t\tEvent::NewRound(30, 6),\n\t\t\t];\n\t\t\texpected.append(\u0026mut new3);\n\t\t\tassert_eq!(events(), expected);\n\n\t\t\t// test join_delegator errors\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(18), 1, 10));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(12), 1, 10),\n\t\t\t\tError::\u003cTest\u003e::TooManyDelegators\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(12), 1, 11));\n\n\t\t\t// verify that delegations are removed after collator leaves, not before\n\t\t\tassert!(StakePallet::candidate_pool(2)\n\t\t\t\t.unwrap()\n\t\t\t\t.delegators\n\t\t\t\t.contains(\u0026StakeOf::\u003cTest\u003e { owner: 8, amount: 10 }));\n\t\t\tassert!(StakePallet::candidate_pool(2)\n\t\t\t\t.unwrap()\n\t\t\t\t.delegators\n\t\t\t\t.contains(\u0026StakeOf::\u003cTest\u003e { owner: 17, amount: 11 }));\n\t\t\tassert_eq!(StakePallet::delegator_state(8).unwrap().amount, 10);\n\t\t\tassert_eq!(StakePallet::delegator_state(17).unwrap().amount, 11);\n\t\t\tassert_eq!(Balances::usable_balance(\u00268), 90);\n\t\t\tassert_eq!(Balances::usable_balance(\u002617), 89);\n\t\t\tassert_eq!(Balances::free_balance(\u00268), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u002617), 100);\n\n\t\t\troll_to(35, vec![Some(1), Some(2), Some(3), Some(4)]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(2), 2));\n\t\t\tlet mut unbonding_8: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(\n\t\t\t\tunbonding_8.try_insert(35u64 + \u003cTest as Config\u003e::StakeDuration::get() as u64, 10)\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::unstaking(8), unbonding_8);\n\t\t\tlet mut unbonding_17: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(\n\t\t\t\tunbonding_17.try_insert(35u64 + \u003cTest as Config\u003e::StakeDuration::get() as u64, 11)\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::unstaking(17), unbonding_17);\n\n\t\t\troll_to(37, vec![Some(1), Some(2)]);\n\t\t\tassert!(StakePallet::delegator_state(8).is_none());\n\t\t\tassert!(StakePallet::delegator_state(17).is_none());\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(8), 8));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(17), 17));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::unlock_unstaked(Origin::signed(12), 12),\n\t\t\t\tError::\u003cTest\u003e::UnstakingIsEmpty\n\t\t\t);\n\t\t\tassert_eq!(Balances::usable_balance(\u002617), 100);\n\t\t\tassert_eq!(Balances::usable_balance(\u00268), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u002617), 100);\n\t\t\tassert_eq!(Balances::free_balance(\u00268), 100);\n\t\t});\n}\n\n#[test]\nfn should_update_total_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t\t(11, 161_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(7, 1, 10), (8, 2, 10), (9, 2, 10)])\n\t\t.set_blocks_per_round(5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet mut old_stake = StakePallet::total_collator_stake();\n\t\t\tassert_eq!(old_stake, TotalStake { collators: 40, delegators: 30 });\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 50));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: old_stake.collators + 50, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 50));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: old_stake.collators - 50, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(7), 1, 50));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(7), 1, 0),\n\t\t\t\tError::\u003cTest\u003e::ValStakeZero\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(7), 1, 0),\n\t\t\t\tError::\u003cTest\u003e::ValStakeZero\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators + 50, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(7), 1, 50));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators - 50, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(11), 1, 200));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators + 200, ..old_stake }\n\t\t\t);\n\n\t\t\told_stake = StakePallet::total_collator_stake();\n\t\t\tassert_eq!(StakePallet::delegator_state(11).unwrap().amount, 200);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(11)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators - 200, ..old_stake }\n\t\t\t);\n\n\t\t\tlet old_stake = StakePallet::total_collator_stake();\n\t\t\tassert_eq!(StakePallet::delegator_state(8).unwrap().amount, 10);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(8)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { delegators: old_stake.delegators - 10, ..old_stake }\n\t\t\t);\n\n\t\t\t// should immediately affect total stake because collator can't be chosen in\n\t\t\t// active set from now on, thus delegated stake is reduced\n\t\t\tlet old_stake = StakePallet::total_collator_stake();\n\t\t\tassert_eq!(StakePallet::candidate_pool(2).unwrap().total, 30);\n\t\t\tassert_eq!(StakePallet::candidate_pool(2).unwrap().stake, 20);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 1]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().stake,\n\t\t\t\tStakePallet::candidate_pool(3).unwrap().stake\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\tlet old_stake = TotalStake {\n\t\t\t\tdelegators: old_stake.delegators - 10,\n\t\t\t\t// total active collator stake is unchanged because number of selected candidates is 2 and 2's\n\t\t\t\t// replacement has the same self stake as 2\n\t\t\t\tcollators: old_stake.collators,\n\t\t\t};\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 3]);\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), old_stake);\n\n\t\t\t// shouldn't change total stake when 2 leaves\n\t\t\troll_to(10, vec![]);\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), old_stake);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::total_collator_stake(), old_stake);\n\t\t})\n}\n\n#[test]\nfn collators_bond() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t\t(11, 161_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(6, 1, 10), (7, 1, 10), (8, 2, 10), (9, 2, 10), (10, 1, 10)])\n\t\t.set_blocks_per_round(5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(6), 50),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(6), 50),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 50));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 40),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\tassert!(StakePallet::candidate_pool(1)\n\t\t\t\t.unwrap()\n\t\t\t\t.can_exit(\u003cTest as Config\u003e::ExitQueueDelay::get()));\n\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 30),\n\t\t\t\tError::\u003cTest\u003e::CannotStakeIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(1), 10),\n\t\t\t\tError::\u003cTest\u003e::CannotStakeIfLeaving\n\t\t\t);\n\n\t\t\troll_to(30, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(1), 1));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 40),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(2), 80));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(2), 90));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(3), 10));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(2), 11),\n\t\t\t\tError::\u003cTest\u003e::Underflow\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(2), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeBelowMin\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(3), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeBelowMin\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(4), 11),\n\t\t\t\tError::\u003cTest\u003e::ValStakeBelowMin\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(4), 10));\n\n\t\t\t// MaxCollatorCandidateStake\n\t\t\tassert_ok!(StakePallet::join_candidates(\n\t\t\t\tOrigin::signed(11),\n\t\t\t\tStakePallet::max_candidate_stake()\n\t\t\t));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(11), 1u128),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax,\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn delegators_bond() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 100),\n\t\t\t(2, 100),\n\t\t\t(3, 100),\n\t\t\t(4, 100),\n\t\t\t(5, 100),\n\t\t\t(6, 100),\n\t\t\t(7, 100),\n\t\t\t(8, 100),\n\t\t\t(9, 100),\n\t\t\t(10, 100),\n\t\t])\n\t\t.with_collators(vec![(1, 20), (2, 20), (3, 20), (4, 20), (5, 10)])\n\t\t.with_delegators(vec![(6, 1, 10), (7, 1, 10), (8, 2, 10), (9, 2, 10)])\n\t\t.set_blocks_per_round(5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(6), 2, 50),\n\t\t\t\tError::\u003cTest\u003e::AlreadyDelegating\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(1), 2, 50),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(1), 2, 50),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(6), 2, 50),\n\t\t\t\tError::\u003cTest\u003e::DelegationNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(7), 6, 50),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(7), 6, 50),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(6), 1, 11),\n\t\t\t\tError::\u003cTest\u003e::Underflow\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(6), 1, 8),\n\t\t\t\tError::\u003cTest\u003e::DelegationBelowMin\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(6), 1, 10));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(6), 2, 5),\n\t\t\t\tError::\u003cTest\u003e::DelegationNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(6), 1, 81),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(10), 1, 4),\n\t\t\t\tError::\u003cTest\u003e::DelegationBelowMin\n\t\t\t);\n\n\t\t\troll_to(9, vec![]);\n\t\t\tassert_eq!(Balances::usable_balance(\u00266), 80);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\tassert!(StakePallet::candidate_pool(1)\n\t\t\t\t.unwrap()\n\t\t\t\t.can_exit(1 + \u003cTest as Config\u003e::ExitQueueDelay::get()));\n\n\t\t\troll_to(31, vec![]);\n\t\t\tassert!(StakePallet::is_delegator(\u00266));\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(1), 1));\n\t\t\tassert!(!StakePallet::is_delegator(\u00266));\n\t\t\tassert_eq!(Balances::usable_balance(\u00266), 80);\n\t\t\tassert_eq!(Balances::free_balance(\u00266), 100);\n\t\t});\n}\n\n#[test]\nfn should_leave_delegators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.with_delegators(vec![(2, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert!(StakePallet::delegator_state(2).is_none());\n\t\t\tassert!(!StakePallet::candidate_pool(1)\n\t\t\t\t.unwrap()\n\t\t\t\t.delegators\n\t\t\t\t.contains(\u0026StakeOf::\u003cTest\u003e { owner: 2, amount: 100 }));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::leave_delegators(Origin::signed(2)),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::leave_delegators(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn round_transitions() {\n\tlet col_max = 10;\n\tlet col_rewards = 15;\n\tlet d_max = 40;\n\tlet d_rewards = 10;\n\tlet inflation = InflationInfo::new(\n\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\tPerquintill::from_percent(col_max),\n\t\tPerquintill::from_percent(col_rewards),\n\t\tPerquintill::from_percent(d_max),\n\t\tPerquintill::from_percent(d_rewards),\n\t);\n\n\t// round_immediately_jumps_if_current_duration_exceeds_new_blocks_per_round\n\t// change from 5 bpr to 3 in block 5 -\u003e 8 should be new round\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 20)])\n\t\t.with_delegators(vec![(2, 1, 10), (3, 1, 10)])\n\t\t.with_inflation(col_max, col_rewards, d_max, d_rewards, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\t\t\troll_to(5, vec![]);\n\t\t\tlet init = vec![Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), init);\n\t\t\tassert_ok!(StakePallet::set_blocks_per_round(Origin::root(), 3));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::set_blocks_per_round(Origin::root(), 1),\n\t\t\t\tError::\u003cTest\u003e::CannotSetBelowMin\n\t\t\t);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::BlocksPerRoundSet(1, 5, 5, 3)));\n\n\t\t\t// inflation config should be untouched after per_block update\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\n\t\t\t// last round startet at 5 but we are already at 9, so we expect 9 to be the new\n\t\t\t// round\n\t\t\troll_to(8, vec![]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::NewRound(8, 2)));\n\t\t});\n\n\t// if duration of current round is less than new bpr, round waits until new bpr\n\t// passes\n\t// change from 5 bpr to 3 in block 6 -\u003e 8 should be new round\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 20)])\n\t\t.with_delegators(vec![(2, 1, 10), (3, 1, 10)])\n\t\t.with_inflation(col_max, col_rewards, d_max, d_rewards, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\t\t\t// Default round every 5 blocks, but MinBlocksPerRound is 3 and we set it to min\n\t\t\t// 3 blocks\n\t\t\troll_to(6, vec![]);\n\t\t\t// chooses top MaxSelectedCandidates (5), in order\n\t\t\tlet init = vec![Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), init);\n\t\t\tassert_ok!(StakePallet::set_blocks_per_round(Origin::root(), 3));\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::BlocksPerRoundSet(1, 5, 5, 3)));\n\n\t\t\t// inflation config should be untouched after per_block update\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\n\t\t\t// there should not be a new event\n\t\t\troll_to(7, vec![]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::BlocksPerRoundSet(1, 5, 5, 3)));\n\n\t\t\troll_to(8, vec![]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::NewRound(8, 2)));\n\t\t});\n\n\t// round_immediately_jumps_if_current_duration_exceeds_new_blocks_per_round\n\t// change from 5 bpr (blocks_per_round) to 3 in block 7 -\u003e 8 should be new round\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 20)])\n\t\t.with_delegators(vec![(2, 1, 10), (3, 1, 10)])\n\t\t.with_inflation(col_max, col_rewards, d_max, d_rewards, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// Default round every 5 blocks, but MinBlocksPerRound is 3 and we set it to min\n\t\t\t// 3 blocks\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\t\t\troll_to(7, vec![]);\n\t\t\t// chooses top MaxSelectedCandidates (5), in order\n\t\t\tlet init = vec![Event::NewRound(5, 1)];\n\t\t\tassert_eq!(events(), init);\n\t\t\tassert_ok!(StakePallet::set_blocks_per_round(Origin::root(), 3));\n\n\t\t\t// inflation config should be untouched after per_block update\n\t\t\tassert_eq!(inflation, StakePallet::inflation_config());\n\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::inflation_config(),\n\t\t\t\tInflationInfo::new(\n\t\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\t\tPerquintill::from_percent(col_max),\n\t\t\t\t\tPerquintill::from_percent(col_rewards),\n\t\t\t\t\tPerquintill::from_percent(d_max),\n\t\t\t\t\tPerquintill::from_percent(d_rewards)\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::BlocksPerRoundSet(1, 5, 5, 3)));\n\t\t\troll_to(8, vec![]);\n\n\t\t\t// last round startet at 5, so we expect 8 to be the new round\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::NewRound(8, 2)));\n\t\t});\n}\n\n#[test]\nfn coinbase_rewards_few_blocks_detailed_check() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 40_000_000 * DECIMALS),\n\t\t\t(2, 40_000_000 * DECIMALS),\n\t\t\t(3, 40_000_000 * DECIMALS),\n\t\t\t(4, 20_000_000 * DECIMALS),\n\t\t\t(5, 20_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 8_000_000 * DECIMALS), (2, 8_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![\n\t\t\t(3, 1, 32_000_000 * DECIMALS),\n\t\t\t(4, 1, 16_000_000 * DECIMALS),\n\t\t\t(5, 2, 16_000_000 * DECIMALS),\n\t\t])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet inflation = StakePallet::inflation_config();\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\t\t\tassert_eq!(total_issuance, 160_000_000 * DECIMALS);\n\n\t\t\t// compute rewards\n\t\t\tlet c_staking_rate = Perquintill::from_rational(16_000_000 * DECIMALS, total_issuance);\n\t\t\tlet c_rewards: BalanceOf\u003cTest\u003e = inflation.collator.compute_reward::\u003cTest\u003e(\n\t\t\t\t16_000_000 * DECIMALS,\n\t\t\t\tc_staking_rate,\n\t\t\t\t1u128,\n\t\t\t);\n\t\t\tlet d_staking_rate = Perquintill::from_rational(64_000_000 * DECIMALS, total_issuance);\n\t\t\tlet d_rewards: BalanceOf\u003cTest\u003e = inflation.delegator.compute_reward::\u003cTest\u003e(\n\t\t\t\t64_000_000 * DECIMALS,\n\t\t\t\td_staking_rate,\n\t\t\t\t2u128,\n\t\t\t);\n\n\t\t\t// set 1 to be author for blocks 1-3, then 2 for blocks 4-5\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\tvec![None, Some(1u64), Some(1u64), Some(1u64), Some(2u64), Some(2u64)];\n\t\t\t// let d_rewards: Balance = 3 * 2469135802453333 / 2;\n\t\t\tlet user_1 = Balances::usable_balance(\u00261);\n\t\t\tlet user_2 = Balances::usable_balance(\u00262);\n\t\t\tlet user_3 = Balances::usable_balance(\u00263);\n\t\t\tlet user_4 = Balances::usable_balance(\u00264);\n\t\t\tlet user_5 = Balances::usable_balance(\u00265);\n\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5);\n\n\t\t\t// 1 is block author for 1st block\n\t\t\troll_to_claim_rewards(2, authors.clone());\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards / 2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 4);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5);\n\n\t\t\t// 1 is block author for 2nd block\n\t\t\troll_to_claim_rewards(3, authors.clone());\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + 2 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5);\n\n\t\t\t// 1 is block author for 3rd block\n\t\t\troll_to_claim_rewards(4, authors.clone());\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + 3 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards / 2 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 4 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5);\n\n\t\t\t// 2 is block author for 4th block\n\t\t\troll_to_claim_rewards(5, authors.clone());\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + 3 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2 + c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards / 2 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 4 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5 + d_rewards / 4);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(5)));\n\n\t\t\t// 2 is block author for 5th block\n\t\t\troll_to_claim_rewards(6, authors);\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), user_1 + 3 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), user_2 + 2 * c_rewards);\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), user_3 + d_rewards / 2 * 3);\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), user_4 + d_rewards / 4 * 3);\n\t\t\t// should not receive rewards due to revoked delegation\n\t\t\tassert_eq!(Balances::usable_balance(\u00265), user_5 + d_rewards / 4);\n\t\t});\n}\n\n#[test]\nfn delegator_should_not_receive_rewards_after_revoking() {\n\t// test edge case of 1 delegator\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10_000_000 * DECIMALS), (2, 10_000_000 * DECIMALS)])\n\t\t.with_collators(vec![(1, 10_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, 10_000_000 * DECIMALS)])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e = (1u64..100u64).map(|_| Some(1u64)).collect();\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), Balance::zero());\n\t\t\troll_to_claim_rewards(100, authors);\n\t\t\tassert!(Balances::usable_balance(\u00261) \u003e Balance::zero());\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), 10_000_000 * DECIMALS);\n\t\t});\n\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 10_000_000 * DECIMALS),\n\t\t\t(2, 10_000_000 * DECIMALS),\n\t\t\t(3, 10_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 10_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, 10_000_000 * DECIMALS), (3, 1, 10_000_000 * DECIMALS)])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(3)));\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e = (1u64..100u64).map(|_| Some(1u64)).collect();\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), Balance::zero());\n\t\t\troll_to_claim_rewards(100, authors);\n\t\t\tassert!(Balances::usable_balance(\u00261) \u003e Balance::zero());\n\t\t\tassert!(Balances::usable_balance(\u00262) \u003e Balance::zero());\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(3), 3));\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), 10_000_000 * DECIMALS);\n\t\t});\n}\n#[test]\nfn coinbase_rewards_many_blocks_simple_check() {\n\tlet num_of_years: Perquintill = Perquintill::from_perthousand(2);\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 40_000_000 * DECIMALS),\n\t\t\t(2, 40_000_000 * DECIMALS),\n\t\t\t(3, 40_000_000 * DECIMALS),\n\t\t\t(4, 20_000_000 * DECIMALS),\n\t\t\t(5, 20_000_000 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 8_000_000 * DECIMALS), (2, 8_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![\n\t\t\t(3, 1, 32_000_000 * DECIMALS),\n\t\t\t(4, 1, 16_000_000 * DECIMALS),\n\t\t\t(5, 2, 16_000_000 * DECIMALS),\n\t\t])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet inflation = StakePallet::inflation_config();\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\t\t\tassert_eq!(total_issuance, 160_000_000 * DECIMALS);\n\t\t\tlet end_block: BlockNumber = num_of_years * Test::BLOCKS_PER_YEAR as BlockNumber;\n\t\t\t// set round robin authoring\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\t(0u64..=end_block).map(|i| Some(i % 2 + 1)).collect();\n\t\t\troll_to_claim_rewards(end_block, authors);\n\n\t\t\tlet rewards_1 = Balances::free_balance(\u00261).saturating_sub(40_000_000 * DECIMALS);\n\t\t\tlet rewards_2 = Balances::free_balance(\u00262).saturating_sub(40_000_000 * DECIMALS);\n\t\t\tlet rewards_3 = Balances::free_balance(\u00263).saturating_sub(40_000_000 * DECIMALS);\n\t\t\tlet rewards_4 = Balances::free_balance(\u00264).saturating_sub(20_000_000 * DECIMALS);\n\t\t\tlet rewards_5 = Balances::free_balance(\u00265).saturating_sub(20_000_000 * DECIMALS);\n\t\t\tlet expected_collator_rewards =\n\t\t\t\tnum_of_years * inflation.collator.reward_rate.annual * 16_000_000 * DECIMALS;\n\t\t\tlet expected_delegator_rewards =\n\t\t\t\tnum_of_years * inflation.delegator.reward_rate.annual * 64_000_000 * DECIMALS;\n\n\t\t\t// 1200000000000000000000\n\t\t\t// 2399074074058720000\n\n\t\t\t// collator rewards should be about the same\n\t\t\tassert!(almost_equal(rewards_1, rewards_2, Perbill::from_perthousand(1)));\n\t\t\tassert!(\n\t\t\t\talmost_equal(\n\t\t\t\t\trewards_1,\n\t\t\t\t\tnum_of_years * inflation.collator.reward_rate.annual * 8_000_000 * DECIMALS,\n\t\t\t\t\tPerbill::from_perthousand(1)\n\t\t\t\t),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\trewards_1,\n\t\t\t\tinflation.collator.reward_rate.annual * 8_000_000 * DECIMALS,\n\t\t\t);\n\n\t\t\t// delegator rewards should be about the same\n\t\t\tassert!(\n\t\t\t\talmost_equal(rewards_3, rewards_4 + rewards_5, Perbill::from_perthousand(1)),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\trewards_3,\n\t\t\t\trewards_4 + rewards_5\n\t\t\t);\n\t\t\tassert!(almost_equal(\n\t\t\t\trewards_3,\n\t\t\t\tnum_of_years * inflation.delegator.reward_rate.annual * 32_000_000 * DECIMALS,\n\t\t\t\tPerbill::from_perthousand(1)\n\t\t\t));\n\n\t\t\t// check rewards in total\n\t\t\tassert!(\n\t\t\t\talmost_equal(\n\t\t\t\t\trewards_1 + rewards_2,\n\t\t\t\t\texpected_collator_rewards,\n\t\t\t\t\tPerbill::from_perthousand(1),\n\t\t\t\t),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\trewards_1 + rewards_2,\n\t\t\t\texpected_collator_rewards,\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\talmost_equal(\n\t\t\t\t\trewards_3 + rewards_4 + rewards_5,\n\t\t\t\t\texpected_delegator_rewards,\n\t\t\t\t\tPerbill::from_perthousand(1),\n\t\t\t\t),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\trewards_3 + rewards_4 + rewards_5,\n\t\t\t\texpected_delegator_rewards,\n\t\t\t);\n\n\t\t\t// old issuance + rewards should equal new issuance\n\t\t\tassert!(\n\t\t\t\talmost_equal(\n\t\t\t\t\ttotal_issuance + expected_collator_rewards + expected_delegator_rewards,\n\t\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance(),\n\t\t\t\t\tPerbill::from_perthousand(1),\n\t\t\t\t),\n\t\t\t\t\"left {:?}, right {:?}\",\n\t\t\t\ttotal_issuance + expected_collator_rewards + expected_delegator_rewards,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance(),\n\t\t\t);\n\t\t});\n}\n\n// Could only occur if we increase MinDelegatorStakeOf::\u003cTest\u003evia runtime\n// upgrade and don't migrate delegators which fall below minimum\n#[test]\nfn should_not_reward_delegators_below_min_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10 * DECIMALS), (2, 10 * DECIMALS), (3, 10 * DECIMALS), (4, 5)])\n\t\t.with_collators(vec![(1, 10 * DECIMALS), (2, 10 * DECIMALS)])\n\t\t.with_delegators(vec![(3, 2, 10 * DECIMALS)])\n\t\t.with_inflation(10, 15, 40, 15, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// impossible but lets assume it happened\n\t\t\tlet mut state =\n\t\t\t\tStakePallet::candidate_pool(\u00261).expect(\"CollatorState cannot be missing\");\n\t\t\tlet delegator_stake_below_min = \u003cTest as Config\u003e::MinDelegatorStake::get() - 1;\n\t\t\tstate.stake += delegator_stake_below_min;\n\t\t\tstate.total += delegator_stake_below_min;\n\t\t\tlet impossible_bond =\n\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4u64, amount: delegator_stake_below_min };\n\t\t\tassert_eq!(state.delegators.try_insert(impossible_bond), Ok(true));\n\t\t\t\u003ccrate::CandidatePool\u003cTest\u003e\u003e::insert(\u00261u64, state);\n\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\tvec![Some(1u64), Some(1u64), Some(1u64), Some(1u64)];\n\t\t\tassert_eq!(Balances::usable_balance(\u00261), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), 5);\n\n\t\t\t// should only reward 1\n\t\t\troll_to_claim_rewards(4, authors);\n\t\t\tassert!(Balances::usable_balance(\u00261) \u003e Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00264), 5);\n\t\t\tassert_eq!(Balances::usable_balance(\u00262), Balance::zero());\n\t\t\tassert_eq!(Balances::usable_balance(\u00263), Balance::zero());\n\t\t});\n}\n\n#[test]\n#[should_panic]\nfn should_deny_low_delegator_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10 * DECIMALS), (2, 10 * DECIMALS), (3, 10 * DECIMALS), (4, 1)])\n\t\t.with_collators(vec![(1, 10 * DECIMALS), (2, 10 * DECIMALS)])\n\t\t.with_delegators(vec![(4, 2, 1)])\n\t\t.build()\n\t\t.execute_with(|| {});\n}\n\n#[test]\n#[should_panic]\nfn should_deny_low_collator_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10 * DECIMALS), (2, 5)])\n\t\t.with_collators(vec![(1, 10 * DECIMALS), (2, 5)])\n\t\t.build()\n\t\t.execute_with(|| {});\n}\n\n#[test]\n#[should_panic]\nfn should_deny_duplicate_collators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10 * DECIMALS)])\n\t\t.with_collators(vec![(1, 10 * DECIMALS), (1, 10 * DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {});\n}\n\n#[test]\nfn reach_max_top_candidates() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 11),\n\t\t\t(2, 20),\n\t\t\t(3, 11),\n\t\t\t(4, 11),\n\t\t\t(5, 11),\n\t\t\t(6, 11),\n\t\t\t(7, 11),\n\t\t\t(8, 11),\n\t\t\t(9, 11),\n\t\t\t(10, 11),\n\t\t\t(11, 11),\n\t\t\t(12, 12),\n\t\t\t(13, 13),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().len().saturated_into::\u003cu32\u003e(),\n\t\t\t\t\u003cTest as Config\u003e::MaxTopCandidates::get()\n\t\t\t);\n\t\t\t// should not be possible to join candidate pool, even with more stake\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(11), 11));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\tvec![2, 11, 1, 3, 4, 5, 6, 7, 8, 9]\n\t\t\t);\n\t\t\t// last come, last one in the list\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(12), 11));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\tvec![2, 11, 12, 1, 3, 4, 5, 6, 7, 8]\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(3), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(4), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(5), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(6), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(7), 1));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(8), 1));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\tvec![2, 11, 12, 1, 3, 4, 5, 6, 7, 8]\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn should_estimate_current_session_progress() {\n\tExtBuilder::default()\n\t\t.set_blocks_per_round(100)\n\t\t.with_balances(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t\t(11, 10),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(10).0.unwrap(),\n\t\t\t\tPermill::from_percent(10)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(20).0.unwrap(),\n\t\t\t\tPermill::from_percent(20)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(30).0.unwrap(),\n\t\t\t\tPermill::from_percent(30)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(60).0.unwrap(),\n\t\t\t\tPermill::from_percent(60)\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::estimate_current_session_progress(100).0.unwrap(),\n\t\t\t\tPermill::from_percent(100)\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn should_estimate_next_session_rotation() {\n\tExtBuilder::default()\n\t\t.set_blocks_per_round(100)\n\t\t.with_balances(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t\t(11, 10),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(10).0.unwrap(), 100);\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(20).0.unwrap(), 100);\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(30).0.unwrap(), 100);\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(60).0.unwrap(), 100);\n\t\t\tassert_eq!(StakePallet::estimate_next_session_rotation(100).0.unwrap(), 100);\n\t\t});\n}\n\n#[test]\nfn should_end_session_when_appropriate() {\n\tExtBuilder::default()\n\t\t.set_blocks_per_round(100)\n\t\t.with_balances(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t\t(11, 10),\n\t\t])\n\t\t.with_collators(vec![\n\t\t\t(1, 10),\n\t\t\t(2, 20),\n\t\t\t(3, 10),\n\t\t\t(4, 10),\n\t\t\t(5, 10),\n\t\t\t(6, 10),\n\t\t\t(7, 10),\n\t\t\t(8, 10),\n\t\t\t(9, 10),\n\t\t\t(10, 10),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert!(!StakePallet::should_end_session(10));\n\t\t\tassert!(!StakePallet::should_end_session(20));\n\t\t\tassert!(!StakePallet::should_end_session(30));\n\t\t\tassert!(!StakePallet::should_end_session(60));\n\t\t\tassert!(StakePallet::should_end_session(100));\n\t\t});\n}\n\n#[test]\nfn set_max_selected_candidates_safe_guards() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::set_max_selected_candidates(\n\t\t\t\t\tOrigin::root(),\n\t\t\t\t\t\u003cTest as Config\u003e::MinCollators::get() - 1\n\t\t\t\t),\n\t\t\t\tError::\u003cTest\u003e::CannotSetBelowMin\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::set_max_selected_candidates(\n\t\t\t\t\tOrigin::root(),\n\t\t\t\t\t\u003cTest as Config\u003e::MaxTopCandidates::get() + 1\n\t\t\t\t),\n\t\t\t\tError::\u003cTest\u003e::CannotSetAboveMax\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(\n\t\t\t\tOrigin::root(),\n\t\t\t\t\u003cTest as Config\u003e::MinCollators::get() + 1\n\t\t\t));\n\t\t});\n}\n\n#[test]\nfn set_max_selected_candidates_total_stake() {\n\tlet balances: Vec\u003c(AccountId, Balance)\u003e = (1..19).map(|x| (x, 100)).collect();\n\tExtBuilder::default()\n\t\t.with_balances(balances)\n\t\t.with_collators(vec![\n\t\t\t(1, 11),\n\t\t\t(2, 12),\n\t\t\t(3, 13),\n\t\t\t(4, 14),\n\t\t\t(5, 15),\n\t\t\t(6, 16),\n\t\t\t(7, 17),\n\t\t\t(8, 18),\n\t\t])\n\t\t.with_delegators(vec![\n\t\t\t(11, 1, 21),\n\t\t\t(12, 2, 22),\n\t\t\t(13, 3, 23),\n\t\t\t(14, 4, 24),\n\t\t\t(15, 5, 25),\n\t\t\t(16, 6, 26),\n\t\t\t(17, 7, 27),\n\t\t\t(18, 8, 28),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 35, delegators: 55 }\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 3));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 51, delegators: 81 }\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 80, delegators: 130 }\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 116, delegators: 196 }\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 2));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 35, delegators: 55 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_inflation() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet mut invalid_inflation = InflationInfo {\n\t\t\t\tcollator: StakingInfo {\n\t\t\t\t\tmax_rate: Perquintill::one(),\n\t\t\t\t\treward_rate: RewardRate {\n\t\t\t\t\t\tannual: Perquintill::from_percent(99),\n\t\t\t\t\t\tper_block: Perquintill::from_percent(1),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdelegator: StakingInfo {\n\t\t\t\t\tmax_rate: Perquintill::one(),\n\t\t\t\t\treward_rate: RewardRate {\n\t\t\t\t\t\tannual: Perquintill::from_percent(99),\n\t\t\t\t\t\tper_block: Perquintill::from_percent(1),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t\tassert!(!invalid_inflation.is_valid(\u003cTest as Config\u003e::BLOCKS_PER_YEAR));\n\t\t\tinvalid_inflation.collator.reward_rate.per_block = Perquintill::zero();\n\t\t\tassert!(!invalid_inflation.is_valid(\u003cTest as Config\u003e::BLOCKS_PER_YEAR));\n\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\tPerquintill::from_percent(0),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t));\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(0),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t));\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(0),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t));\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(100),\n\t\t\t\tPerquintill::from_percent(0),\n\t\t\t));\n\t\t});\n}\n\n#[test]\nfn unlock_unstaked() {\n\t// same_unstaked_as_restaked\n\t// block 1: stake \u0026 unstake for 100\n\t// block 2: stake \u0026 unstake for 100\n\t// should remove first entry in unstaking BoundedBTreeMap when staking in block\n\t// 2 should still have 100 locked until unlocking\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10), (2, 100)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.with_delegators(vec![(2, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(3, 100));\n\t\t\tlet lock = BalanceLock { id: STAKING_ID, amount: 100, reasons: Reasons::All };\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// join delegators and revoke again --\u003e consume unstaking at block 3\n\t\t\troll_to(2, vec![]);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tunstaking.remove(\u00263);\n\t\t\tassert_ok!(unstaking.try_insert(4, 100));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// should reduce unlocking but not unlock anything\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(4, vec![]);\n\t\t\tunstaking.remove(\u00264);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![]);\n\t\t});\n\n\t// less_unstaked_than_restaked\n\t// block 1: stake \u0026 unstake for 10\n\t// block 2: stake \u0026 unstake for 100\n\t// should remove first entry in unstaking BoundedBTreeMap when staking in block\n\t// 2 should still have 90 locked until unlocking in block 4\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10), (2, 100)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.with_delegators(vec![(2, 1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(3, 10));\n\t\t\tlet mut lock = BalanceLock { id: STAKING_ID, amount: 10, reasons: Reasons::All };\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// join delegators and revoke again\n\t\t\troll_to(2, vec![]);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tunstaking.remove(\u00263);\n\t\t\tassert_ok!(unstaking.try_insert(4, 100));\n\t\t\tlock.amount = 100;\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// unlock unstaked, remove lock, empty unlocking\n\t\t\troll_to(4, vec![]);\n\t\t\tunstaking.remove(\u00264);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock]);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![]);\n\t\t});\n\n\t// more_unstaked_than_restaked\n\t// block 1: stake \u0026 unstake for 100\n\t// block 2: stake \u0026 unstake for 10\n\t// should reduce first entry from amount 100 to 90 in unstaking BoundedBTreeMap\n\t// when staking in block 2\n\t// should have 100 locked until unlocking in block 3, then 10\n\t// should have 10 locked until further unlocking in block 4\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10), (2, 100)])\n\t\t.with_collators(vec![(1, 10)])\n\t\t.with_delegators(vec![(2, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(3, 100));\n\t\t\tlet mut lock = BalanceLock { id: STAKING_ID, amount: 100, reasons: Reasons::All };\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// join delegators and revoke again\n\t\t\troll_to(2, vec![]);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert_ok!(unstaking.try_insert(3, 90));\n\t\t\tassert_ok!(unstaking.try_insert(4, 10));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// should reduce unlocking but not unlock anything\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\t// should be able to unlock 90 of 100 from unstaking\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tunstaking.remove(\u00263);\n\t\t\tlock.amount = 10;\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock]);\n\t\t\t// should be able to unlock 10 of remaining 10\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tunstaking.remove(\u00264);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(2), vec![]);\n\t\t});\n\n\t// test_stake_less\n\t// block 1: stake \u0026 unstake for 100\n\t// block 2: stake \u0026 unstake for 10\n\t// should reduce first entry from amount 100 to 90 in unstaking BoundedBTreeMap\n\t// when staking in block 2\n\t// should have 100 locked until unlocking in block 3, then 10\n\t// should have 10 locked until further unlocking in block 4\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200)])\n\t\t.with_collators(vec![(1, 200)])\n\t\t.with_delegators(vec![(2, 1, 200)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// should be able to decrease more often than MaxUnstakeRequests because it's\n\t\t\t// the same block and thus unstaking is increased at block 3 instead of having\n\t\t\t// multiple entries for the same block\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10),);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10),);\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(3, 60));\n\t\t\tlet mut lock = BalanceLock { id: STAKING_ID, amount: 200, reasons: Reasons::All };\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(2, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10),);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10),);\n\t\t\tassert_ok!(unstaking.try_insert(4, 10));\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\t// shouldn't be able to unlock anything\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10),);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10),);\n\t\t\tassert_ok!(unstaking.try_insert(5, 10));\n\t\t\tassert_ok!(unstaking.try_insert(5, 10));\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\t// should unlock 60\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tlock.amount = 140;\n\t\t\tunstaking.remove(\u00263);\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\t// reach MaxUnstakeRequests\n\t\t\troll_to(4, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\troll_to(5, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\troll_to(6, vec![]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 10));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 10));\n\t\t\tassert_ok!(unstaking.try_insert(6, 10));\n\t\t\tassert_ok!(unstaking.try_insert(7, 10));\n\t\t\tassert_ok!(unstaking.try_insert(8, 10));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\n\t\t\troll_to(7, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(1), 10),\n\t\t\t\tError::\u003cTest\u003e::NoMoreUnstaking\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(2), 1, 10),\n\t\t\t\tError::\u003cTest\u003e::NoMoreUnstaking\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(1), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(2), 2));\n\t\t\tunstaking.remove(\u00264);\n\t\t\tunstaking.remove(\u00265);\n\t\t\tunstaking.remove(\u00266);\n\t\t\tunstaking.remove(\u00267);\n\t\t\tlock.amount = 100;\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock.clone()]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 40));\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(2), 1, 40));\n\t\t\tassert_ok!(unstaking.try_insert(9, 40));\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 30));\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(2), 1, 30));\n\t\t\tunstaking.remove(\u00268);\n\t\t\tassert_ok!(unstaking.try_insert(9, 20));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(2), unstaking);\n\t\t\tassert_eq!(Balances::locks(1), vec![lock.clone()]);\n\t\t\tassert_eq!(Balances::locks(2), vec![lock]);\n\t\t});\n}\n\n#[test]\nfn kick_candidate_with_full_unstaking() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200), (3, 300)])\n\t\t.with_collators(vec![(1, 200), (2, 200), (3, 200)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet max_unstake_reqs: usize =\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests::get().saturating_sub(1).saturated_into();\n\t\t\t// Fill unstake requests\n\t\t\tfor block in 1u64..1u64.saturating_add(max_unstake_reqs as u64) {\n\t\t\t\tSystem::set_block_number(block);\n\t\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(3), 1));\n\t\t\t}\n\t\t\tassert_eq!(StakePallet::unstaking(3).into_inner().len(), max_unstake_reqs);\n\n\t\t\t// Additional unstake should fail\n\t\t\tSystem::set_block_number(100);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(3), 1),\n\t\t\t\tError::\u003cTest\u003e::NoMoreUnstaking\n\t\t\t);\n\n\t\t\t// Fill last unstake request by removing candidate and unstaking all stake\n\t\t\tassert_ok!(StakePallet::force_remove_candidate(Origin::root(), 3));\n\n\t\t\t// Cannot join with full unstaking\n\t\t\tassert_eq!(StakePallet::unstaking(3).into_inner().len(), max_unstake_reqs + 1);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_candidates(Origin::signed(3), 100),\n\t\t\t\tError::\u003cTest\u003e::CannotJoinBeforeUnlocking\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(3), 3));\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(3), 100));\n\t\t});\n}\n#[test]\nfn kick_delegator_with_full_unstaking() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200), (3, 200), (4, 200), (5, 420), (6, 200)])\n\t\t.with_collators(vec![(1, 200)])\n\t\t.with_delegators(vec![(2, 1, 200), (3, 1, 200), (4, 1, 200), (5, 1, 200)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet max_unstake_reqs: usize =\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests::get().saturating_sub(1).saturated_into();\n\t\t\t// Fill unstake requests\n\t\t\tfor block in 1u64..1u64.saturating_add(max_unstake_reqs as u64) {\n\t\t\t\tSystem::set_block_number(block);\n\t\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(5), 1, 1));\n\t\t\t}\n\t\t\tassert_eq!(StakePallet::unstaking(5).into_inner().len(), max_unstake_reqs);\n\n\t\t\t// Additional unstake should fail\n\t\t\tSystem::set_block_number(100);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(5), 1, 1),\n\t\t\t\tError::\u003cTest\u003e::NoMoreUnstaking\n\t\t\t);\n\n\t\t\t// Fill last unstake request by replacing delegator\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 1, 200));\n\t\t\tassert_eq!(StakePallet::unstaking(5).into_inner().len(), max_unstake_reqs + 1);\n\t\t\tassert!(!StakePallet::is_delegator(\u00265));\n\n\t\t\t// Cannot join with full unstaking\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(5), 1, 100),\n\t\t\t\tError::\u003cTest\u003e::CannotJoinBeforeUnlocking\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(5), 5));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(5), 1, 220));\n\t\t});\n}\n\n#[test]\nfn candidate_leaves() {\n\tlet balances: Vec\u003c(AccountId, Balance)\u003e = (1u64..=15u64).map(|id| (id, 100)).collect();\n\tExtBuilder::default()\n\t\t.with_balances(balances)\n\t\t.with_collators(vec![(1, 100), (2, 100)])\n\t\t.with_delegators(vec![(12, 1, 100), (13, 1, 10)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\tvec![1, 2]\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(11)),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::TooFewCollatorCandidates\n\t\t\t);\n\t\t\t// add five more collator to max fill TopCandidates\n\t\t\tfor candidate in 3u64..11u64 {\n\t\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(candidate), 100));\n\t\t\t}\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\t(1u64..11u64).collect::\u003cVec\u003cu64\u003e\u003e()\n\t\t\t);\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 10);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\t(2u64..11u64).collect::\u003cVec\u003cu64\u003e\u003e()\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(15), 1, 10),\n\t\t\t\tError::\u003cTest\u003e::CannotDelegateIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_more(Origin::signed(12), 1, 1),\n\t\t\t\tError::\u003cTest\u003e::CannotDelegateIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::delegator_stake_less(Origin::signed(12), 1, 1),\n\t\t\t\tError::\u003cTest\u003e::CannotDelegateIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::CannotStakeIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::CannotStakeIfLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::init_leave_candidates(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::AlreadyLeaving\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::candidate_pool(1).unwrap().status, CandidateStatus::Leaving(2));\n\t\t\tassert!(StakePallet::candidate_pool(1).unwrap().can_exit(2));\n\t\t\tassert!(!StakePallet::candidate_pool(1).unwrap().can_exit(1));\n\t\t\tassert!(StakePallet::candidate_pool(1).unwrap().can_exit(3));\n\n\t\t\t// next rounds starts, cannot leave yet\n\t\t\troll_to(5, vec![]);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::execute_leave_candidates(Origin::signed(2), 2),\n\t\t\t\tError::\u003cTest\u003e::NotLeaving\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::execute_leave_candidates(Origin::signed(2), 1),\n\t\t\t\tError::\u003cTest\u003e::CannotLeaveYet\n\t\t\t);\n\t\t\t// add 11 as candidate to reach max size for TopCandidates and then try leave\n\t\t\t// again as 1 which should not be possible\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(11), 100));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\t(2u64..12u64).collect::\u003cVec\u003cu64\u003e\u003e()\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(11)));\n\t\t\t// join back\n\t\t\tassert_ok!(StakePallet::cancel_leave_candidates(Origin::signed(1)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates().into_iter().map(|s| s.owner).collect::\u003cVec\u003cu64\u003e\u003e(),\n\t\t\t\t(1u64..11u64).collect::\u003cVec\u003cu64\u003e\u003e()\n\t\t\t);\n\n\t\t\tlet stake: Vec\u003cStake\u003cAccountId, Balance\u003e\u003e = (1u64..11u64)\n\t\t\t\t.zip(iter::once(210).chain(iter::repeat(100)))\n\t\t\t\t.map(|(id, amount)| StakeOf::\u003cTest\u003e { owner: id, amount })\n\t\t\t\t.collect();\n\t\t\tassert_eq!(StakePallet::top_candidates(), OrderedSet::from(stake.try_into().unwrap()));\n\t\t\tlet state = StakePallet::candidate_pool(1).unwrap();\n\t\t\tassert_eq!(state.status, CandidateStatus::Active);\n\t\t\tassert_eq!(state.delegators.len(), 2);\n\t\t\tassert_eq!(state.total, 210);\n\t\t\tassert_eq!(\n\t\t\t\tstate.total,\n\t\t\t\tStakePallet::top_candidates()\n\t\t\t\t\t.into_bounded_vec()\n\t\t\t\t\t.iter()\n\t\t\t\t\t.find(|other| other.owner == 1)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.amount\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\n\t\t\troll_to(15, vec![]);\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(13), 1));\n\t\t\tlet mut unstaking: BoundedBTreeMap\u003c\n\t\t\t\tBlockNumber,\n\t\t\t\tBalanceOf\u003cTest\u003e,\n\t\t\t\t\u003cTest as Config\u003e::MaxUnstakeRequests,\n\t\t\t\u003e = BoundedBTreeMap::new();\n\t\t\tassert_ok!(unstaking.try_insert(17, 100));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(12), unstaking);\n\n\t\t\t// cannot unlock yet\n\t\t\troll_to(16, vec![]);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(4), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(4), 12));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(12), unstaking);\n\n\t\t\t// can unlock now\n\t\t\troll_to(17, vec![]);\n\t\t\tunstaking.remove(\u002617);\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(4), 1));\n\t\t\tassert_ok!(StakePallet::unlock_unstaked(Origin::signed(4), 12));\n\t\t\tassert_eq!(StakePallet::unstaking(1), unstaking);\n\t\t\tassert_eq!(StakePallet::unstaking(12), unstaking);\n\t\t});\n}\n\n#[test]\nfn adjust_reward_rates() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 10_000_000 * DECIMALS), (2, 90_000_000 * DECIMALS)])\n\t\t.with_collators(vec![(1, 10_000_000 * DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, 40_000_000 * DECIMALS)])\n\t\t.with_inflation(10, 10, 40, 8, 5)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet inflation_0 = StakePallet::inflation_config();\n\t\t\tlet num_of_years = 3 * \u003cTest as Config\u003e::BLOCKS_PER_YEAR;\n\t\t\t// 1 authors every block\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\t(0u64..=num_of_years).map(|_| Some(1u64)).collect();\n\n\t\t\t// reward once in first year\n\t\t\troll_to_claim_rewards(2, authors.clone());\n\t\t\tlet c_rewards_0 = Balances::free_balance(\u00261).saturating_sub(10_000_000 * DECIMALS);\n\t\t\tlet d_rewards_0 = Balances::free_balance(\u00262).saturating_sub(90_000_000 * DECIMALS);\n\t\t\tassert!(!c_rewards_0.is_zero());\n\t\t\tassert!(!d_rewards_0.is_zero());\n\n\t\t\t// finish first year\n\t\t\tSystem::set_block_number(\u003cTest as Config\u003e::BLOCKS_PER_YEAR);\n\t\t\troll_to_claim_rewards(\u003cTest as Config\u003e::BLOCKS_PER_YEAR + 1, vec![]);\n\t\t\t// reward reduction should not happen automatically anymore\n\t\t\tassert_eq!(StakePallet::last_reward_reduction(), 0u64);\n\t\t\tassert_ok!(StakePallet::execute_scheduled_reward_change(Origin::signed(1)));\n\t\t\tassert_eq!(StakePallet::last_reward_reduction(), 1u64);\n\t\t\tlet inflation_1 = InflationInfo::new(\n\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\tinflation_0.collator.max_rate,\n\t\t\t\tPerquintill::from_parts(98000000000000000),\n\t\t\t\tinflation_0.delegator.max_rate,\n\t\t\t\tPerquintill::from_percent(7),\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::inflation_config(), inflation_1);\n\t\t\t// reward once in 2nd year\n\t\t\troll_to_claim_rewards(\u003cTest as Config\u003e::BLOCKS_PER_YEAR + 2, authors.clone());\n\t\t\tlet c_rewards_1 = Balances::free_balance(\u00261)\n\t\t\t\t.saturating_sub(10_000_000 * DECIMALS)\n\t\t\t\t.saturating_sub(c_rewards_0);\n\t\t\tlet d_rewards_1 = Balances::free_balance(\u00262)\n\t\t\t\t.saturating_sub(90_000_000 * DECIMALS)\n\t\t\t\t.saturating_sub(d_rewards_0);\n\t\t\tassert!(c_rewards_0 \u003e c_rewards_1, \"left {:?}, right {:?}\", c_rewards_0, c_rewards_1);\n\t\t\tassert!(d_rewards_0 \u003e d_rewards_1);\n\n\t\t\t// finish 2nd year\n\t\t\tSystem::set_block_number(2 * \u003cTest as Config\u003e::BLOCKS_PER_YEAR);\n\t\t\troll_to_claim_rewards(2 * \u003cTest as Config\u003e::BLOCKS_PER_YEAR + 1, vec![]);\n\t\t\t// reward reduction should not happen automatically anymore\n\t\t\tassert_eq!(StakePallet::last_reward_reduction(), 1u64);\n\t\t\tassert_ok!(StakePallet::execute_scheduled_reward_change(Origin::signed(1)));\n\t\t\tassert_eq!(StakePallet::last_reward_reduction(), 2u64);\n\t\t\tlet inflation_2 = InflationInfo::new(\n\t\t\t\t\u003cTest as Config\u003e::BLOCKS_PER_YEAR,\n\t\t\t\tinflation_0.collator.max_rate,\n\t\t\t\tPerquintill::from_parts(96040000000000000),\n\t\t\t\tinflation_0.delegator.max_rate,\n\t\t\t\tPerquintill::zero(),\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::inflation_config(), inflation_2);\n\t\t\t// reward once in 3rd year\n\t\t\troll_to_claim_rewards(2 * \u003cTest as Config\u003e::BLOCKS_PER_YEAR + 2, authors);\n\t\t\tlet c_rewards_2 = Balances::free_balance(\u00261)\n\t\t\t\t.saturating_sub(10_000_000 * DECIMALS)\n\t\t\t\t.saturating_sub(c_rewards_0)\n\t\t\t\t.saturating_sub(c_rewards_1);\n\t\t\tlet d_rewards_2 = Balances::free_balance(\u00262)\n\t\t\t\t.saturating_sub(90_000_000 * DECIMALS)\n\t\t\t\t.saturating_sub(d_rewards_0)\n\t\t\t\t.saturating_sub(d_rewards_1);\n\t\t\tassert!(c_rewards_1 \u003e c_rewards_2);\n\t\t\tassert!(d_rewards_2.is_zero());\n\t\t});\n}\n\n#[test]\nfn increase_max_candidate_stake() {\n\tlet max_stake = 160_000_000 * DECIMALS;\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200_000_000 * DECIMALS)])\n\t\t.with_collators(vec![(1, max_stake)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::max_candidate_stake(), max_stake);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_candidate_stake(Origin::root(), max_stake + 1));\n\t\t\tassert_eq!(\n\t\t\t\tlast_event(),\n\t\t\t\tMetaEvent::StakePallet(Event::MaxCandidateStakeChanged(max_stake + 1))\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::max_candidate_stake(), max_stake + 1);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 1));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn decrease_max_candidate_stake() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100)])\n\t\t.with_collators(vec![(1, 100), (2, 90), (3, 40)])\n\t\t.with_delegators(vec![(4, 2, 10), (5, 3, 20)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 60 }\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tassert_ok!(StakePallet::set_max_candidate_stake(Origin::root(), 50));\n\t\t\tassert_eq!(StakePallet::max_candidate_stake(), 50);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::MaxCandidateStakeChanged(50)));\n\n\t\t\t// check collator states, nothing changed\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 2, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 60 }\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 0),\n\t\t\t\tError::\u003cTest\u003e::ValStakeZero\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_less(Origin::signed(1), 0),\n\t\t\t\tError::\u003cTest\u003e::ValStakeZero\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::candidate_stake_more(Origin::signed(1), 1),\n\t\t\t\tError::\u003cTest\u003e::ValStakeAboveMax\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 50));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::set_max_candidate_stake(Origin::root(), 9),\n\t\t\t\tError::\u003cTest\u003e::CannotSetBelowMin\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn exceed_delegations_per_round() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.with_delegators(vec![(2, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// leave and re-join to set counter to 2 (= MaxDelegationsPerRound)\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\t// reached max delegations in this round\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(2), 1, 100),\n\t\t\t\tError::\u003cTest\u003e::DelegationsPerRoundExceeded\n\t\t\t);\n\n\t\t\t// roll to next round to clear DelegationCounter\n\t\t\troll_to(5, vec![]);\n\t\t\tassert_eq!(StakePallet::last_delegation(2), DelegationCounter { round: 0, counter: 2 });\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\t// counter should be reset because the round changed\n\t\t\tassert_eq!(StakePallet::last_delegation(2), DelegationCounter { round: 1, counter: 1 });\n\t\t\t// leave and re-join to set counter to 2 (= MaxDelegationsPerRound))\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(2), 1, 100),\n\t\t\t\tError::\u003cTest\u003e::AlreadyDelegating\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(2)));\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(2), 1, 100),\n\t\t\t\tError::\u003cTest\u003e::DelegationsPerRoundExceeded\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::last_delegation(2), DelegationCounter { round: 1, counter: 2 });\n\t\t});\n}\n\n#[test]\nfn force_remove_candidate() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 100), (2, 100), (3, 100)])\n\t\t.with_delegators(vec![(4, 1, 50), (5, 1, 50)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 3);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 2, 50));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\tassert!(StakePallet::unstaking(1).get(\u00263).is_none());\n\t\t\tassert!(StakePallet::unstaking(2).get(\u00263).is_none());\n\t\t\tassert!(StakePallet::unstaking(3).get(\u00263).is_none());\n\n\t\t\t// force remove 1\n\t\t\tassert!(Session::disabled_validators().is_empty());\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::force_remove_candidate(Origin::root(), 1));\n\t\t\t// collator stake does not change since 3, who took 1's place, has staked the\n\t\t\t// same amount\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 50 }\n\t\t\t);\n\t\t\tassert_eq!(Session::disabled_validators(), vec![0]);\n\t\t\tassert_eq!(last_event(), MetaEvent::StakePallet(Event::CollatorRemoved(1, 200)));\n\t\t\tassert!(\n\t\t\t\t!StakePallet::top_candidates().contains(\u0026StakeOf::\u003cTest\u003e { owner: 1, amount: 100 })\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 3]);\n\t\t\tassert_eq!(CandidatePool::\u003cTest\u003e::count(), 2);\n\t\t\tassert!(StakePallet::candidate_pool(1).is_none());\n\t\t\tassert!(StakePallet::delegator_state(4).is_none());\n\t\t\tassert!(StakePallet::delegator_state(5).is_none());\n\t\t\tassert_eq!(StakePallet::unstaking(1).get(\u00263), Some(\u0026100));\n\t\t\tassert_eq!(StakePallet::unstaking(4).get(\u00263), Some(\u002650));\n\t\t\tassert_eq!(StakePallet::unstaking(5).get(\u00263), Some(\u002650));\n\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::force_remove_candidate(Origin::root(), 2),\n\t\t\t\tError::\u003cTest\u003e::TooFewCollatorCandidates\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::force_remove_candidate(Origin::root(), 4),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\n\t\t\t// session 1: expect 1 to still be in validator set but as disabled\n\t\t\troll_to(5, vec![]);\n\t\t\tassert_eq!(Session::current_index(), 1);\n\t\t\tassert_eq!(Session::validators(), vec![1, 2]);\n\t\t\tassert_eq!(Session::disabled_validators(), vec![0]);\n\n\t\t\t// session 2: expect validator set to have changed\n\t\t\troll_to(10, vec![]);\n\t\t\tassert_eq!(Session::validators(), vec![2, 3]);\n\t\t\tassert!(Session::disabled_validators().is_empty());\n\t\t});\n}\n\n#[test]\nfn prioritize_collators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200), (3, 200), (4, 200), (5, 200), (6, 200), (7, 200)])\n\t\t.with_collators(vec![(2, 100), (3, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![2, 3]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 3]);\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(1), 100));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![2, 3, 1]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 3]);\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(2)));\n\t\t\tassert_eq!(StakePallet::top_candidates().len(), 2);\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![3, 1]);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(3), 10));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 3]);\n\n\t\t\t// add 6\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(6), 100));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![1, 6]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.chain(vec![StakeOf::\u003cTest\u003e { owner: 3, amount: 90 }])\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// add 4\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(4), 100));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![1, 6, 4]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.chain(vec![StakeOf::\u003cTest\u003e { owner: 3, amount: 90 }])\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// add 5\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(5), 100));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![1, 6, 4, 5]\n\t\t\t\t\t\t.into_iter()\n\t\t\t\t\t\t.map(|id| StakeOf::\u003cTest\u003e { owner: id, amount: 100 })\n\t\t\t\t\t\t.chain(vec![StakeOf::\u003cTest\u003e { owner: 3, amount: 90 }])\n\t\t\t\t\t\t.collect::\u003cVec\u003cStakeOf\u003cTest\u003e\u003e\u003e()\n\t\t\t\t\t\t.try_into()\n\t\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// 3 stake_more\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(3), 20));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![3, 1]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// 1 stake_less\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), 1));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![3, 6]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 99 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// 7 delegates to 4\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(7), 5, 20));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![5, 3]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 120 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 99 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// 7 decreases delegation\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(7), 5, 10));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![5, 3]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 99 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(7)));\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![3, 5]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::top_candidates(),\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 3, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 1, amount: 99 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn prioritize_delegators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 1000),\n\t\t\t(2, 1000),\n\t\t\t(3, 1000),\n\t\t\t(4, 1000),\n\t\t\t(5, 1000),\n\t\t\t(6, 1000),\n\t\t\t(7, 1000),\n\t\t\t(8, 1000),\n\t\t\t(9, 1000),\n\t\t])\n\t\t.with_collators(vec![(1, 100), (2, 100), (3, 100)])\n\t\t.with_delegators(vec![(4, 2, 100), (7, 2, 100), (6, 2, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![2, 1]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(5), 2, 110));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// delegate_less\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(5), 2, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// delegate_more\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(6), 2, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(7), 2, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(2).unwrap().delegators,\n\t\t\t\tOrderedSet::from_sorted_set(\n\t\t\t\t\tvec![\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 6, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 7, amount: 110 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 5, amount: 100 },\n\t\t\t\t\t\tStakeOf::\u003cTest\u003e { owner: 4, amount: 100 },\n\t\t\t\t\t]\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.unwrap()\n\t\t\t\t)\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn authorities_per_round() {\n\tlet stake = 100 * DECIMALS;\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, stake),\n\t\t\t(2, stake),\n\t\t\t(3, stake),\n\t\t\t(4, stake),\n\t\t\t(5, stake),\n\t\t\t(6, stake),\n\t\t\t(7, stake),\n\t\t\t(8, stake),\n\t\t\t(9, stake),\n\t\t\t(10, stake),\n\t\t\t(11, 100 * stake),\n\t\t])\n\t\t.with_collators(vec![(1, stake), (2, stake), (3, stake), (4, stake)])\n\t\t.build_and_execute_with_sanity_tests(|| {\n\t\t\tassert_eq!(StakePallet::selected_candidates().into_inner(), vec![1, 2]);\n\t\t\t// reward 1 once per round\n\t\t\tlet authors: Vec\u003cOption\u003cAccountId\u003e\u003e =\n\t\t\t\t(0u64..=100).map(|i| if i % 5 == 2 { Some(1u64) } else { None }).collect();\n\t\t\tlet inflation = StakePallet::inflation_config();\n\n\t\t\t// roll to last block of round 0\n\t\t\troll_to_claim_rewards(4, authors.clone());\n\t\t\tlet reward_0 = inflation.collator.reward_rate.per_block * stake * 2;\n\t\t\tassert_eq!(Balances::free_balance(1), stake + reward_0);\n\t\t\t// increase max selected candidates which will become effective in round 2\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(Origin::root(), 10));\n\n\t\t\t// roll to last block of round 1\n\t\t\t// should still multiply with 2 because the Authority set was chosen at start of\n\t\t\t// round 1\n\t\t\troll_to_claim_rewards(9, authors.clone());\n\t\t\tlet reward_1 = inflation.collator.reward_rate.per_block * stake * 2;\n\t\t\tassert_eq!(Balances::free_balance(1), stake + reward_0 + reward_1);\n\n\t\t\t// roll to last block of round 2\n\t\t\t// should multiply with 4 because there are only 4 candidates\n\t\t\troll_to_claim_rewards(14, authors.clone());\n\n\t\t\tlet reward_2 = inflation.collator.reward_rate.per_block * stake * 4;\n\t\t\tassert_eq!(Balances::free_balance(1), stake + reward_0 + reward_1 + reward_2);\n\n\t\t\t// roll to last block of round 3\n\t\t\t// should multiply with 4 because there are only 4 candidates\n\t\t\troll_to_claim_rewards(19, authors);\n\t\t\tlet reward_3 = inflation.collator.reward_rate.per_block * stake * 4;\n\t\t\tassert_eq!(\n\t\t\t\tBalances::free_balance(1),\n\t\t\t\tstake + reward_0 + reward_1 + reward_2 + reward_3\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn force_new_round() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 100), (2, 100), (3, 100), (4, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet mut round = RoundInfo { current: 0, first: 0, length: 5 };\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::validators(), vec![1, 2]);\n\t\t\tassert_eq!(Session::current_index(), 0);\n\t\t\t// 3 should be validator in round 2\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(5), 3, 100));\n\n\t\t\t// init force new round from 0 to 1, updating the authorities\n\t\t\tassert_ok!(StakePallet::force_new_round(Origin::root()));\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::current_index(), 0);\n\t\t\tassert!(StakePallet::new_round_forced());\n\n\t\t\t// force new round should become active by starting next block\n\t\t\troll_to(2, vec![]);\n\t\t\tround = RoundInfo { current: 1, first: 2, length: 5 };\n\t\t\tassert_eq!(Session::current_index(), 1);\n\t\t\tassert_eq!(Session::validators(), vec![1, 2]);\n\t\t\tassert!(!StakePallet::new_round_forced());\n\n\t\t\t// roll to next block in same round 1\n\t\t\troll_to(3, vec![]);\n\t\t\tassert_eq!(Session::current_index(), 1);\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\t// assert_eq!(Session::validators(), vec![3, 1]);\n\t\t\tassert!(!StakePallet::new_round_forced());\n\t\t\t// 4 should become validator in session 3 if we do not force a new round\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 4, 100));\n\n\t\t\t// end session 2 naturally\n\t\t\troll_to(7, vec![]);\n\t\t\tround = RoundInfo { current: 2, first: 7, length: 5 };\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::current_index(), 2);\n\t\t\tassert!(!StakePallet::new_round_forced());\n\t\t\tassert_eq!(Session::validators(), vec![3, 1]);\n\n\t\t\t// force new round 3\n\t\t\tassert_ok!(StakePallet::force_new_round(Origin::root()));\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::current_index(), 2);\n\t\t\t// validator set should not change until next round\n\t\t\tassert_eq!(Session::validators(), vec![3, 1]);\n\t\t\tassert!(StakePallet::new_round_forced());\n\n\t\t\t// force new round should become active by starting next block\n\t\t\troll_to(8, vec![]);\n\t\t\tround = RoundInfo { current: 3, first: 8, length: 5 };\n\t\t\tassert_eq!(Session::current_index(), 3);\n\t\t\tassert_eq!(StakePallet::round(), round);\n\t\t\tassert_eq!(Session::validators(), vec![3, 4]);\n\t\t\tassert!(!StakePallet::new_round_forced());\n\t\t});\n}\n\n#[test]\nfn replace_lowest_delegator() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100), (5, 100), (6, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.with_delegators(vec![(2, 1, 51), (3, 1, 51), (4, 1, 51), (5, 1, 50)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(1).unwrap().delegators.len() as u32,\n\t\t\t\t\u003cTest as Config\u003e::MaxDelegatorsPerCollator::get()\n\t\t\t);\n\n\t\t\t// 6 replaces 5\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 1, 51));\n\t\t\tassert!(StakePallet::delegator_state(5).is_none());\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::candidate_pool(1)\n\t\t\t\t\t.unwrap()\n\t\t\t\t\t.delegators\n\t\t\t\t\t.into_bounded_vec()\n\t\t\t\t\t.into_inner(),\n\t\t\t\tvec![\n\t\t\t\t\tStake { owner: 2, amount: 51 },\n\t\t\t\t\tStake { owner: 3, amount: 51 },\n\t\t\t\t\tStake { owner: 4, amount: 51 },\n\t\t\t\t\tStake { owner: 6, amount: 51 }\n\t\t\t\t]\n\t\t\t);\n\n\t\t\t// 5 attempts to replace 6 with more balance than available\n\t\t\tframe_support::assert_noop!(\n\t\t\t\tStakePallet::join_delegators(Origin::signed(5), 1, 101),\n\t\t\t\tBalancesError::\u003cTest\u003e::InsufficientBalance\n\t\t\t);\n\t\t\tassert!(StakePallet::delegator_state(6).is_some());\n\t\t})\n}\n\n#[test]\nfn network_reward_multiple_blocks() {\n\tlet max_stake: Balance = 160_000_000 * DECIMALS;\n\tlet collators: Vec\u003c(AccountId, Balance)\u003e =\n\t\t(1u64..=\u003cTest as Config\u003e::MinCollators::get().saturating_add(1).into())\n\t\t\t.map(|acc_id| (acc_id, max_stake))\n\t\t\t.collect();\n\n\tExtBuilder::default()\n\t\t.with_balances(collators.clone())\n\t\t.with_collators(collators)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(max_stake, StakePallet::max_candidate_stake());\n\t\t\tlet total_collator_stake =\n\t\t\t\tmax_stake.saturating_mul(\u003cTest as Config\u003e::MinCollators::get().into());\n\t\t\tassert_eq!(total_collator_stake, StakePallet::total_collator_stake().collators);\n\t\t\tassert!(Balances::free_balance(\u0026TREASURY_ACC).is_zero());\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\n\t\t\t// total issuance should not increase when not noting authors because we haven't\n\t\t\t// reached NetworkRewardStart yet\n\t\t\troll_to(10, vec![None]);\n\t\t\tassert!(Balances::free_balance(\u0026TREASURY_ACC).is_zero());\n\t\t\tassert_eq!(total_issuance, \u003cTest as Config\u003e::Currency::total_issuance());\n\n\t\t\t// set current block to one block before NetworkRewardStart\n\t\t\tlet network_reward_start = \u003cTest as Config\u003e::NetworkRewardStart::get();\n\t\t\tSystem::set_block_number(network_reward_start.saturating_sub(1));\n\n\t\t\t// network rewards should only appear 1 block after start\n\t\t\troll_to(network_reward_start, vec![None]);\n\t\t\tassert!(Balances::free_balance(\u0026TREASURY_ACC).is_zero());\n\t\t\tassert_eq!(total_issuance, \u003cTest as Config\u003e::Currency::total_issuance());\n\n\t\t\t// should mint to treasury now\n\t\t\troll_to(network_reward_start + 1, vec![None]);\n\t\t\tlet network_reward = Balances::free_balance(\u0026TREASURY_ACC);\n\t\t\tassert!(!network_reward.is_zero());\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + network_reward,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\t\t\tlet inflation_config = StakePallet::inflation_config();\n\t\t\tlet col_rewards =\n\t\t\t\tinflation_config.collator.reward_rate.per_block * total_collator_stake;\n\t\t\tassert_eq!(network_reward, \u003cTest as Config\u003e::NetworkRewardRate::get() * col_rewards);\n\n\t\t\t// should mint exactly the same amount\n\t\t\troll_to(network_reward_start + 2, vec![None]);\n\t\t\tassert_eq!(2 * network_reward, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + 2 * network_reward,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\n\t\t\t// should mint exactly the same amount in each block\n\t\t\troll_to(network_reward_start + 100, vec![None]);\n\t\t\tassert_eq!(100 * network_reward, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + 100 * network_reward,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\n\t\t\t// should mint the same amount even if a collator exits because reward is only\n\t\t\t// based on MaxCollatorCandidateStake and MaxSelectedCandidates\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\t\t\troll_to(network_reward_start + 101, vec![None]);\n\t\t\tassert_eq!(101 * network_reward, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + 101 * network_reward,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn network_reward_increase_max_candidate_stake() {\n\tlet max_stake: Balance = 160_000_000 * DECIMALS;\n\tlet collators: Vec\u003c(AccountId, Balance)\u003e = (1u64..=\u003cTest as Config\u003e::MinCollators::get()\n\t\t.into())\n\t\t.map(|acc_id| (acc_id, max_stake))\n\t\t.collect();\n\n\tExtBuilder::default()\n\t\t.with_balances(collators.clone())\n\t\t.with_collators(collators)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet network_reward_start = \u003cTest as Config\u003e::NetworkRewardStart::get();\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\t\t\tSystem::set_block_number(network_reward_start);\n\n\t\t\t// should mint to treasury now\n\t\t\troll_to(network_reward_start + 1, vec![None]);\n\t\t\tlet reward_before = Balances::free_balance(\u0026TREASURY_ACC);\n\t\t\tassert!(!reward_before.is_zero());\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + reward_before,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\n\t\t\t// double max stake\n\t\t\tlet max_stake_doubled = 320_000_000 * DECIMALS;\n\t\t\tlet reward_after = 2 * reward_before;\n\t\t\tassert_ok!(StakePallet::set_max_candidate_stake(Origin::root(), max_stake_doubled));\n\t\t\troll_to(network_reward_start + 2, vec![None]);\n\t\t\tassert_eq!(reward_before + reward_after, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\treward_before + reward_after + total_issuance,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn network_reward_increase_max_collator_count() {\n\tlet max_stake: Balance = 160_000_000 * DECIMALS;\n\tlet collators: Vec\u003c(AccountId, Balance)\u003e = (1u64..=\u003cTest as Config\u003e::MinCollators::get()\n\t\t.into())\n\t\t.map(|acc_id| (acc_id, max_stake))\n\t\t.collect();\n\n\tExtBuilder::default()\n\t\t.with_balances(collators.clone())\n\t\t.with_collators(collators)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet network_reward_start = \u003cTest as Config\u003e::NetworkRewardStart::get();\n\t\t\tlet total_issuance = \u003cTest as Config\u003e::Currency::total_issuance();\n\t\t\tSystem::set_block_number(network_reward_start);\n\n\t\t\t// should mint to treasury now\n\t\t\troll_to(network_reward_start + 1, vec![None]);\n\t\t\tlet reward_before = Balances::free_balance(\u0026TREASURY_ACC);\n\t\t\tassert!(!reward_before.is_zero());\n\t\t\tassert_eq!(\n\t\t\t\ttotal_issuance + reward_before,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\n\t\t\t// tripple number of max collators\n\t\t\tlet reward_after = 3 * reward_before;\n\t\t\tassert_ok!(StakePallet::set_max_selected_candidates(\n\t\t\t\tOrigin::root(),\n\t\t\t\t\u003cTest as Config\u003e::MinCollators::get() * 3\n\t\t\t));\n\t\t\troll_to(network_reward_start + 2, vec![None]);\n\t\t\tassert_eq!(reward_before + reward_after, Balances::free_balance(\u0026TREASURY_ACC));\n\t\t\tassert_eq!(\n\t\t\t\treward_before + reward_after + total_issuance,\n\t\t\t\t\u003cTest as Config\u003e::Currency::total_issuance()\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_total_stake_collators_stay() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 200), (2, 200), (3, 200), (4, 200)])\n\t\t.with_collators(vec![(1, 100), (2, 50)])\n\t\t.with_delegators(vec![(3, 1, 100), (4, 2, 50)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 150, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 160, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(2), 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 155, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(3), 1, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 155, delegators: 160 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(4), 2, 5));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 155, delegators: 155 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_total_stake_displace_collators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 200),\n\t\t\t(2, 200),\n\t\t\t(3, 200),\n\t\t\t(4, 200),\n\t\t\t(5, 200),\n\t\t\t(6, 200),\n\t\t\t(7, 200),\n\t\t\t(8, 200),\n\t\t\t(1337, 200),\n\t\t])\n\t\t.with_collators(vec![(1, 10), (2, 20), (3, 30), (4, 40)])\n\t\t.with_delegators(vec![(5, 1, 50), (6, 2, 50), (7, 3, 55), (8, 4, 55)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\n\t\t\t// 4 is pushed out by staking less\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(4), 30));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 50, delegators: 105 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(8), 4, 45));\n\n\t\t\t// 3 is pushed out by delegator staking less\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(7), 3, 45));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 30, delegators: 100 }\n\t\t\t);\n\n\t\t\t// 1 is pushed out by new candidate\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(1337), 100));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 120, delegators: 50 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_total_stake_new_collators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100), (3, 100), (4, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.with_delegators(vec![(4, 1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 100, delegators: 100 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_candidates(Origin::signed(2), 100));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 100 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(3), 2, 50));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 150 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(4)));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 200, delegators: 50 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn update_total_stake_no_collator_changes() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 200),\n\t\t\t(2, 200),\n\t\t\t(3, 200),\n\t\t\t(4, 200),\n\t\t\t(5, 200),\n\t\t\t(6, 200),\n\t\t\t(7, 200),\n\t\t\t(8, 200),\n\t\t\t(1337, 200),\n\t\t])\n\t\t.with_collators(vec![(1, 10), (2, 20), (3, 30), (4, 40)])\n\t\t.with_delegators(vec![(5, 1, 50), (6, 2, 50), (7, 3, 55), (8, 4, 55)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(5), 1, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(2), 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(6), 2, 10));\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::total_collator_stake(),\n\t\t\t\tTotalStake { collators: 70, delegators: 110 }\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn rewards_candidate_stake_more() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 2 * DECIMALS), (2, DECIMALS), (3, DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// stake more to trigger reward incrementing\n\t\t\tassert_ok!(StakePallet::candidate_stake_more(Origin::signed(1), DECIMALS));\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_candidate_stake_less() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 2 * DECIMALS), (2, DECIMALS), (3, DECIMALS)])\n\t\t.with_collators(vec![(1, 2 * DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero());\n\t\t\t});\n\n\t\t\t// stake less to trigger reward incrementing\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), DECIMALS));\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_candidate_leave_network() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 2 * DECIMALS),\n\t\t\t(2, DECIMALS),\n\t\t\t(3, DECIMALS),\n\t\t\t(4, DECIMALS),\n\t\t\t(5, DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 2 * DECIMALS), (4, DECIMALS), (5, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// init does not increment rewards\n\t\t\tassert_ok!(StakePallet::init_leave_candidates(Origin::signed(1)));\n\n\t\t\t// advance two rounds to enable leaving\n\t\t\troll_to(\n\t\t\t\t10,\n\t\t\t\tvec![\n\t\t\t\t\t// we're already in block 1, so cant note_author for block 1\n\t\t\t\t\tNone,\n\t\t\t\t\tSome(1),\n\t\t\t\t\tSome(2),\n\t\t\t\t\tSome(1),\n\t\t\t\t\tSome(2),\n\t\t\t\t\tSome(1),\n\t\t\t\t\tSome(2),\n\t\t\t\t\tSome(1),\n\t\t\t\t\tSome(2),\n\t\t\t\t],\n\t\t\t);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 4 * 2);\n\n\t\t\t// count for delegators should not be incremented\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\n\t\t\t// rewards should not be incremented\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero());\n\t\t\t});\n\n\t\t\t// execute leave intent to trigger reward incrementing\n\t\t\tassert_ok!(StakePallet::execute_leave_candidates(Origin::signed(1), 1));\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_force_remove_candidate() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, DECIMALS),\n\t\t\t(2, DECIMALS),\n\t\t\t(3, DECIMALS),\n\t\t\t(4, DECIMALS),\n\t\t\t(5, DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, DECIMALS), (4, DECIMALS), (5, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// init does not increment rewards\n\t\t\tStakePallet::note_author(1);\n\t\t\tStakePallet::note_author(2);\n\n\t\t\t// removing triggers reward increment for collator 1 and delegators 4, 5\n\t\t\tassert_ok!(StakePallet::force_remove_candidate(Origin::root(), 1));\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t\t(4..=5).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn reward_count_join_delegators() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, 100), (2, 100)])\n\t\t.with_collators(vec![(1, 100)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(2), 1, 100));\n\t\t\t// delegator should have same counter as collator upon joining\n\t\t\tassert_eq!(StakePallet::reward_count(2), 1);\n\t\t});\n}\n\n#[test]\nfn rewards_delegator_stake_more() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, DECIMALS), (2, DECIMALS), (3, 2 * DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// stake more to trigger reward incrementing just for 3\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(3), 1, DECIMALS));\n\t\t\t// 1 should still have counter 1 but no rewards\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::rewards(1).is_zero());\n\t\t\t// 2 should still have neither rewards nor counter\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::rewards(2).is_zero());\n\t\t\t// 3 should have rewards and the same counter as 1\n\t\t\tassert_eq!(StakePallet::reward_count(3), 1);\n\t\t\tassert!(!StakePallet::rewards(3).is_zero());\n\t\t});\n}\n\n#[test]\nfn rewards_delegator_stake_less() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, DECIMALS), (2, DECIMALS), (3, 2 * DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, 2 * DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// stake less to trigger reward incrementing just for 3\n\t\t\tassert_ok!(StakePallet::delegator_stake_less(Origin::signed(3), 1, DECIMALS));\n\t\t\t// 1 should still have counter 1 but no rewards\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::rewards(1).is_zero());\n\t\t\t// 2 should still have neither rewards nor counter\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::rewards(2).is_zero());\n\t\t\t// 3 should have rewards and the same counter as 1\n\t\t\tassert_eq!(StakePallet::reward_count(3), 1);\n\t\t\tassert!(!StakePallet::rewards(3).is_zero());\n\t\t});\n}\n\n#[test]\nfn rewards_delegator_replaced() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, 2 * DECIMALS),\n\t\t\t(2, 2 * DECIMALS),\n\t\t\t(3, 2 * DECIMALS),\n\t\t\t(4, 2 * DECIMALS),\n\t\t\t(5, 2 * DECIMALS),\n\t\t\t(6, 2 * DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, 2 * DECIMALS)])\n\t\t.with_delegators(vec![\n\t\t\t(2, 1, 2 * DECIMALS),\n\t\t\t(3, 1, 2 * DECIMALS),\n\t\t\t(4, 1, 2 * DECIMALS),\n\t\t\t(5, 1, DECIMALS),\n\t\t])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\n\t\t\t// 6 kicks 5\n\t\t\tassert_ok!(StakePallet::join_delegators(Origin::signed(6), 1, 2 * DECIMALS));\n\t\t\t// 5 should have rewards and counter updated\n\t\t\tassert!(!StakePallet::rewards(5).is_zero());\n\t\t\tassert_eq!(StakePallet::reward_count(5), 1);\n\t\t\t// 6 should not have rewards but same counter as former collator\n\t\t\tassert!(StakePallet::rewards(6).is_zero());\n\t\t\tassert_eq!(StakePallet::reward_count(6), 1);\n\t\t});\n}\n\n#[test]\nfn rewards_delegator_leaves() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, DECIMALS), (2, DECIMALS), (3, DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note collator once to set their counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// only 3 should have non-zero rewards and their counter reset\n\t\t\tassert_ok!(StakePallet::leave_delegators(Origin::signed(3)));\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::rewards(1).is_zero());\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::rewards(2).is_zero());\n\t\t\tassert!(!StakePallet::rewards(3).is_zero());\n\t\t\tassert_eq!(StakePallet::reward_count(3), 1);\n\t\t});\n}\n\n#[test]\nfn rewards_set_inflation() {\n\tlet hundred = Perquintill::from_percent(100);\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, DECIMALS),\n\t\t\t(2, DECIMALS),\n\t\t\t(3, DECIMALS),\n\t\t\t(4, DECIMALS),\n\t\t\t(5, DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, DECIMALS), (2, DECIMALS)])\n\t\t.with_delegators(vec![(3, 1, DECIMALS), (4, 1, DECIMALS), (5, 2, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// note collators\n\t\t\tStakePallet::note_author(1);\n\t\t\tStakePallet::note_author(1);\n\t\t\tStakePallet::note_author(2);\n\n\t\t\t// set inflation to trigger reward setting\n\t\t\tassert_ok!(StakePallet::set_inflation(\n\t\t\t\tOrigin::root(),\n\t\t\t\thundred,\n\t\t\t\thundred,\n\t\t\t\thundred,\n\t\t\t\thundred\n\t\t\t));\n\t\t\t// rewards should be set and counter reset\n\t\t\t(1..=5).for_each(|id| {\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_yearly_inflation_adjustment() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![\n\t\t\t(1, DECIMALS),\n\t\t\t(2, DECIMALS),\n\t\t\t(3, DECIMALS),\n\t\t\t(4, DECIMALS),\n\t\t\t(5, DECIMALS),\n\t\t])\n\t\t.with_collators(vec![(1, DECIMALS), (2, DECIMALS)])\n\t\t.with_delegators(vec![(3, 1, DECIMALS), (4, 1, DECIMALS), (5, 2, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// init counter and go to next year\n\t\t\tStakePallet::note_author(1);\n\t\t\tStakePallet::note_author(2);\n\t\t\tSystem::set_block_number(\u003cTest as Config\u003e::BLOCKS_PER_YEAR - 1);\n\t\t\troll_to_claim_rewards(\u003cTest as Config\u003e::BLOCKS_PER_YEAR + 1, vec![]);\n\n\t\t\t// rewards should not be triggered before executing pending adjustment\n\t\t\t(1..=5).for_each(|id| {\n\t\t\t\tassert!(StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\n\t\t\t// execute to trigger reward increment\n\t\t\tassert_ok!(StakePallet::execute_scheduled_reward_change(Origin::signed(1)));\n\t\t\t(1..=5).for_each(|id| {\n\t\t\t\tassert!(StakePallet::reward_count(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t\tassert!(!StakePallet::rewards(id).is_zero(), \"acc_id {:?}\", id);\n\t\t\t});\n\t\t});\n}\n\n#[test]\nfn rewards_incrementing_and_claiming() {\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, DECIMALS), (2, DECIMALS), (3, DECIMALS)])\n\t\t.with_collators(vec![(1, DECIMALS)])\n\t\t.with_delegators(vec![(2, 1, DECIMALS), (3, 1, DECIMALS)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\t// claiming or incrementing should not be possible with zero counter\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::increment_collator_rewards(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::RewardsNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::increment_delegator_rewards(Origin::signed(2)),\n\t\t\t\tError::\u003cTest\u003e::RewardsNotFound\n\t\t\t);\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert_noop!(\n\t\t\t\t\tStakePallet::claim_rewards(Origin::signed(id)),\n\t\t\t\t\tError::\u003cTest\u003e::RewardsNotFound,\n\t\t\t\t);\n\t\t\t});\n\n\t\t\t// note once to set counter to 1\n\t\t\tStakePallet::note_author(1);\n\t\t\tassert_eq!(StakePallet::reward_count(1), 1);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\n\t\t\t// claiming should not be possible before incrementing rewards\n\t\t\t(1..=3).for_each(|id| {\n\t\t\t\tassert_noop!(\n\t\t\t\t\tStakePallet::claim_rewards(Origin::signed(id)),\n\t\t\t\t\tError::\u003cTest\u003e::RewardsNotFound\n\t\t\t\t);\n\t\t\t});\n\n\t\t\t// increment rewards for 2 and match counter to collator\n\t\t\tassert_ok!(StakePallet::increment_delegator_rewards(Origin::signed(2)));\n\t\t\tassert_eq!(StakePallet::reward_count(2), 1);\n\t\t\tlet rewards_2 = StakePallet::rewards(2);\n\t\t\tassert!(!rewards_2.is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\tassert!(StakePallet::rewards(3).is_zero());\n\n\t\t\t// should set rewards for delegator 3 as well\n\t\t\tassert_ok!(StakePallet::increment_collator_rewards(Origin::signed(1)));\n\t\t\tassert!(StakePallet::reward_count(1).is_zero());\n\t\t\tassert!(!StakePallet::rewards(1).is_zero());\n\t\t\t// counter of delegators should be reset to 0 (= cols counter)\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::reward_count(3).is_zero());\n\t\t\t// rewards of 2 should not be changed\n\t\t\tassert_eq!(StakePallet::rewards(2), rewards_2);\n\t\t\t// 3 should have rewards now (passively)\n\t\t\tassert!(!StakePallet::rewards(3).is_zero());\n\n\t\t\t// claim for 1 to move rewards into balance\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(1)));\n\t\t\tassert!(StakePallet::reward_count(1).is_zero());\n\t\t\tassert!(StakePallet::rewards(1).is_zero());\n\t\t\t// delegator situation should be unchanged\n\t\t\tassert!(Balances::free_balance(\u00261) \u003e DECIMALS);\n\t\t\tassert_eq!(Balances::free_balance(\u00262), DECIMALS);\n\t\t\tassert_eq!(Balances::free_balance(\u00263), DECIMALS);\n\n\t\t\t// claim for 2 to move rewards into balance\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(2)));\n\t\t\tassert!(Balances::free_balance(\u00262) \u003e DECIMALS);\n\t\t\tassert!(StakePallet::reward_count(2).is_zero());\n\t\t\tassert!(StakePallet::rewards(2).is_zero());\n\t\t\tassert_eq!(Balances::free_balance(\u00263), DECIMALS);\n\n\t\t\t// should not be able to claim for incorrect role\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::increment_collator_rewards(Origin::signed(2)),\n\t\t\t\tError::\u003cTest\u003e::CandidateNotFound\n\t\t\t);\n\t\t\tassert_noop!(\n\t\t\t\tStakePallet::increment_delegator_rewards(Origin::signed(1)),\n\t\t\t\tError::\u003cTest\u003e::DelegatorNotFound\n\t\t\t);\n\t\t});\n}\n\n#[test]\nfn api_get_unclaimed_staking_rewards() {\n\tlet stake = 100_000 * DECIMALS;\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, stake), (2, stake), (3, 100 * stake)])\n\t\t.with_collators(vec![(1, stake), (3, 2 * stake)])\n\t\t.with_delegators(vec![(2, 1, stake)])\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet inflation_config = StakePallet::inflation_config();\n\n\t\t\t// Increment rewards of 1 and 2\n\t\t\troll_to(2, vec![None, Some(1)]);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::get_unclaimed_staking_rewards(\u00261),\n\t\t\t\t// Multiplying with 2 because there are two authors\n\t\t\t\tinflation_config.collator.reward_rate.per_block * stake * 2\n\t\t\t);\n\t\t\tassert_eq!(\n\t\t\t\tStakePallet::get_unclaimed_staking_rewards(\u00262),\n\t\t\t\tinflation_config.delegator.reward_rate.per_block * stake * 2\n\t\t\t);\n\t\t\tassert!(StakePallet::get_unclaimed_staking_rewards(\u00263).is_zero());\n\n\t\t\t// Should only increment rewards of 3\n\t\t\troll_to(3, vec![None, None, Some(3)]);\n\t\t\tlet rewards_1 = StakePallet::get_unclaimed_staking_rewards(\u00261);\n\t\t\tlet rewards_2 = StakePallet::get_unclaimed_staking_rewards(\u00262);\n\t\t\tlet rewards_3 = StakePallet::get_unclaimed_staking_rewards(\u00263);\n\t\t\tassert_eq!(2 * rewards_1, rewards_3,);\n\t\t\tassert_eq!(rewards_2, inflation_config.delegator.reward_rate.per_block * stake * 2);\n\n\t\t\t// API and actual claiming should match\n\t\t\tassert_ok!(StakePallet::increment_collator_rewards(Origin::signed(1)));\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(1)));\n\t\t\tassert_eq!(rewards_1, Balances::usable_balance(\u00261));\n\t\t\tassert_ok!(StakePallet::increment_delegator_rewards(Origin::signed(2)));\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(2)));\n\t\t\tassert_eq!(rewards_2, Balances::usable_balance(\u00262));\n\t\t\tassert_ok!(StakePallet::increment_collator_rewards(Origin::signed(3)));\n\t\t\tassert_ok!(StakePallet::claim_rewards(Origin::signed(3)));\n\t\t\tassert_eq!(rewards_3 + 98 * stake, Balances::usable_balance(\u00263));\n\t\t});\n}\n\n#[test]\nfn api_get_staking_rates() {\n\tlet stake = 100_000 * DECIMALS;\n\tExtBuilder::default()\n\t\t.with_balances(vec![(1, stake), (2, stake), (3, 2 * stake)])\n\t\t.with_collators(vec![(1, stake), (2, stake)])\n\t\t.with_delegators(vec![(3, 1, stake)])\n\t\t.with_inflation(25, 10, 25, 8, \u003cTest as Config\u003e::BLOCKS_PER_YEAR)\n\t\t.build()\n\t\t.execute_with(|| {\n\t\t\tlet mut rates = StakingRates {\n\t\t\t\tcollator_staking_rate: Perquintill::from_percent(50),\n\t\t\t\tcollator_reward_rate: Perquintill::from_percent(5),\n\t\t\t\tdelegator_staking_rate: Perquintill::from_percent(25),\n\t\t\t\tdelegator_reward_rate: Perquintill::from_percent(8),\n\t\t\t};\n\t\t\t// collators exceed max staking rate\n\t\t\tassert_eq!(rates, StakePallet::get_staking_rates());\n\n\t\t\t// candidates stake less to not exceed max staking rate\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(1), stake / 2));\n\t\t\tassert_ok!(StakePallet::candidate_stake_less(Origin::signed(2), stake / 2));\n\t\t\t// delegator stakes more to exceed\n\t\t\tassert_ok!(StakePallet::delegator_stake_more(Origin::signed(3), 1, stake));\n\t\t\trates.collator_staking_rate = Perquintill::from_percent(25);\n\t\t\trates.collator_reward_rate = Perquintill::from_percent(10);\n\t\t\trates.delegator_staking_rate = Perquintill::from_percent(50);\n\t\t\trates.delegator_reward_rate = Perquintill::from_percent(4);\n\t\t\tassert_eq!(rates, StakePallet::get_staking_rates());\n\t\t});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","try_state.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2023 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\nuse frame_support::{ensure, traits::Get};\nuse scale_info::prelude::format;\nuse sp_runtime::{\n\ttraits::{CheckedAdd, Zero},\n\tSaturatedConversion, Saturating,\n};\n\nuse crate::{\n\tset::OrderedSet,\n\ttypes::{BalanceOf, Candidate, Stake},\n\tCandidatePool, Config, DelegatorState, LastDelegation, MaxCollatorCandidateStake,\n\tMaxSelectedCandidates, Pallet, Round, TopCandidates, TotalCollatorStake,\n};\n\npub fn log_and_return_error_message(error_message: String) -\u003e \u0026'static str {\n\tlog::error!(\"{}\", error_message);\n\t\"Sanity test error\"\n}\n\npub(crate) fn do_try_state\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\tvalidate_candiate_pool::\u003cT\u003e()?;\n\tvalidate_delegators::\u003cT\u003e()?;\n\tvalidate_top_candidates::\u003cT\u003e()?;\n\tvalidate_stake::\u003cT\u003e()\n}\n\nfn validate_candiate_pool\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\t// check if enough collators are set.\n\tensure!(\n\t\tCandidatePool::\u003cT\u003e::count() \u003e= T::MinCollators::get(),\n\t\tlog_and_return_error_message(format!(\n\t\t\t\"Insufficient collators. Collators count: {:?}. Min required collators: {:?}\",\n\t\t\tCandidatePool::\u003cT\u003e::count(),\n\t\t\tT::MinCollators::get()\n\t\t))\n\t);\n\n\tCandidatePool::\u003cT\u003e::iter_values().try_for_each(\n\t\t|candidate: Candidate\u003cT::AccountId, BalanceOf\u003cT\u003e, _\u003e| -\u003e Result\u003c(), \u0026'static str\u003e {\n\t\t\tlet sum_delegations: BalanceOf\u003cT\u003e = candidate\n\t\t\t\t.delegators\n\t\t\t\t.iter()\n\t\t\t\t.fold(Zero::zero(), |acc, stake| acc.saturating_add(stake.amount));\n\n\t\t\t// total stake should be the sum of delegators stake + colator stake.\n\t\t\tlet stake_total = sum_delegations.checked_add(\u0026candidate.stake);\n\t\t\tensure!(\n\t\t\t\tstake_total == Some(candidate.total),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Total stake of collator {:?} does not match. Saved stake: {:?}. Calculated stake: {:?}\",\n\t\t\t\t\tcandidate.id, candidate.stake, stake_total\n\t\t\t\t))\n\t\t\t);\n\n\t\t\t// Min required stake should be set\n\t\t\tensure!(\n\t\t\t\tcandidate.stake \u003e= T::MinCollatorCandidateStake::get(),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Stake of collator {:?} insufficient. Required stake: {:?}. Owned Stake: {:?} \",\n\t\t\t\t\tcandidate.id,\n\t\t\t\t\tT::MinCollatorCandidateStake::get(),\n\t\t\t\t\tcandidate.stake\n\t\t\t\t))\n\t\t\t);\n\n\t\t\tvalidate_delegators_from_collator::\u003cT\u003e(candidate.delegators)?;\n\n\t\t\t// check min and max stake for each candidate\n\t\t\tensure!(\n\t\t\t\tcandidate.stake \u003c= MaxCollatorCandidateStake::\u003cT\u003e::get(),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Candidate {:?} exceeded stake. Allowed stake: {:?}. Owned Stake: {:?}\",\n\t\t\t\t\tcandidate.id,\n\t\t\t\t\tMaxCollatorCandidateStake::\u003cT\u003e::get(),\n\t\t\t\t\tcandidate.stake\n\t\t\t\t))\n\t\t\t);\n\n\t\t\tOk(())\n\t\t},\n\t)\n}\n\nfn validate_top_candidates\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\tlet top_candidates = TopCandidates::\u003cT\u003e::get();\n\n\t// check if enough top candidates are set.\n\tensure!(\n\t\ttop_candidates.len() \u003e= T::MinRequiredCollators::get().saturated_into(),\n\t\tlog_and_return_error_message(format!(\n\t\t\t\"Not enough candidates are set. Candidate count: {:?}. Required: {:?}\",\n\t\t\ttop_candidates.len(),\n\t\t\tT::MinRequiredCollators::get()\n\t\t))\n\t);\n\n\ttop_candidates.iter().try_for_each(|stake| -\u003e Result\u003c(), \u0026'static str\u003e {\n\t\t// top candidates should be part of the candidate pool.\n\t\tensure!(\n\t\t\tCandidatePool::\u003cT\u003e::contains_key(\u0026stake.owner),\n\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\"Unknown candidate {:?} in top candidates.\",\n\t\t\t\tstake.owner\n\t\t\t))\n\t\t);\n\n\t\t// an account can not be candidate and delegator.\n\t\tensure!(\n\t\t\tDelegatorState::\u003cT\u003e::get(\u0026stake.owner).is_none(),\n\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\"Account {:?} is delegator and candidate.\",\n\t\t\t\tstake.owner\n\t\t\t))\n\t\t);\n\n\t\t// a top candidate should be active.\n\t\tensure!(\n\t\t\tPallet::\u003cT\u003e::is_active_candidate(\u0026stake.owner).unwrap(),\n\t\t\tlog_and_return_error_message(format!(\"Top candidate {:?} is inactive\", stake.owner))\n\t\t);\n\n\t\tOk(())\n\t})\n}\n\nfn validate_delegators_from_collator\u003cT: Config\u003e(\n\tdelegators: OrderedSet\u003cStake\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e, T::MaxDelegatorsPerCollator\u003e,\n) -\u003e Result\u003c(), \u0026'static str\u003e {\n\tdelegators\n\t\t.iter()\n\t\t.try_for_each(|delegator_stake| -\u003e Result\u003c(), \u0026'static str\u003e {\n\t\t\tlet last_delegation = LastDelegation::\u003cT\u003e::get(\u0026delegator_stake.owner);\n\t\t\tlet round = Round::\u003cT\u003e::get();\n\t\t\tlet counter = if last_delegation.round \u003c round.current {\n\t\t\t\t0u32\n\t\t\t} else {\n\t\t\t\tlast_delegation.counter\n\t\t\t};\n\n\t\t\t// each delegator should not exceed the [MaxDelegationsPerRound]\n\t\t\tensure!(\n\t\t\t\tcounter \u003c= T::MaxDelegationsPerRound::get(),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Delegator {:?} exceeded delegations per round. Allowed delegations {:?}. Confirmed delegations {:?}\",\n\t\t\t\t\tdelegator_stake.owner, T::MaxDelegationsPerRound::get(), counter\n\t\t\t\t))\n\t\t\t);\n\n\t\t\t// each delegator should have the min required stake\n\t\t\tensure!(\n\t\t\t\tdelegator_stake.amount \u003e= T::MinDelegatorStake::get(),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Delegator {:?} insufficient stake. Required stake: {:?}. Owned stake: {:?}\",\n\t\t\t\t\tdelegator_stake.owner,\n\t\t\t\t\tT::MinDelegatorStake::get(),\n\t\t\t\t\tdelegator_stake.amount\n\t\t\t\t))\n\t\t\t);\n\n\t\t\tensure!(\n\t\t\t\tDelegatorState::\u003cT\u003e::get(\u0026delegator_stake.owner).is_some(),\n\t\t\t\tlog_and_return_error_message(format!(\"Unknown delegator {:?}\", delegator_stake.owner))\n\t\t\t);\n\n\t\t\tOk(())\n\t\t})\n}\n\nfn validate_stake\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\t// the total fund has to be the sum over the first [MaxSelectedCandidates] of\n\t// [TopCandidates].\n\tlet top_candidates = TopCandidates::\u003cT\u003e::get();\n\tlet top_n = MaxSelectedCandidates::\u003cT\u003e::get().saturated_into::\u003cusize\u003e();\n\n\tlet total_stake = TotalCollatorStake::\u003cT\u003e::get();\n\n\tlet collator_delegator_stake = top_candidates\n\t\t.iter()\n\t\t.take(top_n)\n\t\t.fold(Zero::zero(), |acc: BalanceOf\u003cT\u003e, details| acc.saturating_add(details.amount));\n\n\tlet collator_stake = top_candidates\n\t\t.iter()\n\t\t.take(top_n)\n\t\t.filter_map(|stake| CandidatePool::\u003cT\u003e::get(\u0026stake.owner))\n\t\t.fold(Zero::zero(), |acc: BalanceOf\u003cT\u003e, candidate| acc.saturating_add(candidate.stake));\n\n\tlet delegator_state = collator_delegator_stake.saturating_sub(collator_stake);\n\n\tensure!(\n\t\ttotal_stake.collators == collator_stake,\n\t\tlog_and_return_error_message(format!(\n\t\t\t\"Corrupted total collator stake. Saved total stake: {:?}. Calculated stake: {:?}\",\n\t\t\ttotal_stake.collators, collator_stake\n\t\t))\n\t);\n\n\tensure!(\n\t\ttotal_stake.delegators == delegator_state,\n\t\tlog_and_return_error_message(format!(\n\t\t\t\"Corrupted total delegator stake. Saved total stake: {:?}. Calculated stake: {:?}\",\n\t\t\ttotal_stake.delegators, delegator_state\n\t\t))\n\t);\n\n\tOk(())\n}\n\nfn validate_delegators\u003cT: Config\u003e() -\u003e Result\u003c(), \u0026'static str\u003e {\n\tDelegatorState::\u003cT\u003e::iter_values().try_for_each(\n\t\t|delegator_details| -\u003e Result\u003c(), \u0026'static str\u003e {\n\t\t\tlet Some(owner) = \u0026delegator_details.owner else {\n\t\t\treturn Err(\"owner not found\");\n\t\t};\n\n\t\t\tensure!(\n\t\t\t\tCandidatePool::\u003cT\u003e::contains_key(owner),\n\t\t\t\tlog_and_return_error_message(format!(\n\t\t\t\t\t\"Collator {:?} not found\",\n\t\t\t\t\tdelegator_details.owner\n\t\t\t\t))\n\t\t\t);\n\t\t\tOk(())\n\t\t},\n\t)\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":120},{"path":["/","Users","marcel","Documents","pendulum","pallets","parachain-staking","src","types.rs"],"content":"// KILT Blockchain – https://botlabs.org\n// Copyright (C) 2019-2022 BOTLabs GmbH\n\n// The KILT Blockchain is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// The KILT Blockchain is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n\n// If you feel like getting in touch with us, you can do so at info@botlabs.org\n\nuse frame_support::traits::{Currency, Get};\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::{\n\ttraits::{AtLeast32BitUnsigned, CheckedSub, Saturating, Zero},\n\tRuntimeDebug,\n};\nuse sp_staking::SessionIndex;\nuse sp_std::{\n\tcmp::Ordering,\n\tfmt::Debug,\n\tops::{Add, Sub},\n};\n\nuse crate::{set::OrderedSet, Config};\n\n/// A struct represented an amount of staked funds.\n///\n/// The stake has a destination account (to which the stake is directed) and an\n/// amount of funds staked.\n#[derive(Default, Clone, Encode, Decode, RuntimeDebug, PartialEq, Eq, TypeInfo, MaxEncodedLen)]\n#[codec(mel_bound(AccountId: MaxEncodedLen, Balance: MaxEncodedLen))]\npub struct Stake\u003cAccountId, Balance\u003e\nwhere\n\tAccountId: Eq + Ord,\n\tBalance: Eq + Ord,\n{\n\t/// The account that is backed by the stake.\n\tpub owner: AccountId,\n\n\t/// The amount of backing the `owner` received.\n\tpub amount: Balance,\n}\n\nimpl\u003cA, B\u003e From\u003cA\u003e for Stake\u003cA, B\u003e\nwhere\n\tA: Eq + Ord,\n\tB: Default + Eq + Ord,\n{\n\tfn from(owner: A) -\u003e Self {\n\t\tStake { owner, amount: B::default() }\n\t}\n}\n\nimpl\u003cAccountId: Ord, Balance: PartialEq + Ord\u003e PartialOrd for Stake\u003cAccountId, Balance\u003e {\n\tfn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n\t\tSome(self.cmp(other))\n\t}\n}\n\n// We order by stake and only return an equal order, if both account ids match.\n// This prevents the same account ids to be in the same OrderedSet. Otherwise,\n// it is ordered from greatest to lowest stake (primary) and from first joined\n// to last joined (primary).\nimpl\u003cAccountId: Ord, Balance: PartialEq + Ord\u003e Ord for Stake\u003cAccountId, Balance\u003e {\n\tfn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n\t\tmatch (self.owner.cmp(\u0026other.owner), self.amount.cmp(\u0026other.amount)) {\n\t\t\t// enforce unique account ids\n\t\t\t(Ordering::Equal, _) =\u003e Ordering::Equal,\n\t\t\t// prioritize existing members if stakes match\n\t\t\t(_, Ordering::Equal) =\u003e Ordering::Greater,\n\t\t\t// order by stake\n\t\t\t(_, ord) =\u003e ord,\n\t\t}\n\t}\n}\n\n/// The activity status of the collator.\n#[derive(Copy, Clone, PartialEq, Eq, Encode, Decode, RuntimeDebug, TypeInfo, MaxEncodedLen)]\npub enum CandidateStatus {\n\t/// Committed to be online and producing valid blocks (not equivocating)\n\tActive,\n\t/// Staked until the inner round\n\tLeaving(SessionIndex),\n}\n\nimpl Default for CandidateStatus {\n\tfn default() -\u003e CandidateStatus {\n\t\tCandidateStatus::Active\n\t}\n}\n\n#[derive(Encode, Decode, Clone, RuntimeDebug, PartialEq, Eq, TypeInfo, MaxEncodedLen)]\n#[scale_info(skip_type_params(MaxDelegatorsPerCandidate))]\n#[codec(mel_bound(AccountId: MaxEncodedLen, Balance: MaxEncodedLen))]\n/// Global collator state with commission fee, staked funds, and delegations\npub struct Candidate\u003cAccountId, Balance, MaxDelegatorsPerCandidate\u003e\nwhere\n\tAccountId: Eq + Ord + Debug,\n\tBalance: Eq + Ord + Debug,\n\tMaxDelegatorsPerCandidate: Get\u003cu32\u003e + Debug + PartialEq,\n{\n\t/// Account id of the candidate.\n\tpub id: AccountId,\n\n\t/// The stake that the candidate put down.\n\tpub stake: Balance,\n\n\t/// The delegators that back the candidate.\n\tpub delegators: OrderedSet\u003cStake\u003cAccountId, Balance\u003e, MaxDelegatorsPerCandidate\u003e,\n\n\t/// The total backing a collator has.\n\t///\n\t/// Should equal the sum of all delegators stake adding collators stake\n\tpub total: Balance,\n\n\t/// The current status of the candidate. Indicates whether a candidate is\n\t/// active or leaving the candidate pool\n\tpub status: CandidateStatus,\n}\n\nimpl\u003cA, B, S\u003e Candidate\u003cA, B, S\u003e\nwhere\n\tA: Ord + Clone + Debug,\n\tB: AtLeast32BitUnsigned + Ord + Copy + Saturating + Debug + Zero,\n\tS: Get\u003cu32\u003e + Debug + PartialEq,\n{\n\tpub fn new(id: A, stake: B) -\u003e Self {\n\t\tlet total = stake;\n\t\tCandidate {\n\t\t\tid,\n\t\t\tstake,\n\t\t\tdelegators: OrderedSet::new(),\n\t\t\ttotal,\n\t\t\tstatus: CandidateStatus::default(), // default active\n\t\t}\n\t}\n\n\tpub fn is_active(\u0026self) -\u003e bool {\n\t\tself.status == CandidateStatus::Active\n\t}\n\n\tpub fn is_leaving(\u0026self) -\u003e bool {\n\t\tmatches!(self.status, CandidateStatus::Leaving(_))\n\t}\n\n\tpub fn can_exit(\u0026self, when: u32) -\u003e bool {\n\t\tmatches!(self.status, CandidateStatus::Leaving(at) if at \u003c= when )\n\t}\n\n\tpub fn revert_leaving(\u0026mut self) {\n\t\tself.status = CandidateStatus::Active;\n\t}\n\n\tpub fn stake_more(\u0026mut self, more: B) {\n\t\tself.stake = self.stake.saturating_add(more);\n\t\tself.total = self.total.saturating_add(more);\n\t}\n\n\t// Returns None if underflow or less == self.stake (in which case collator\n\t// should leave).\n\tpub fn stake_less(\u0026mut self, less: B) -\u003e Option\u003cB\u003e {\n\t\tif self.stake \u003e less {\n\t\t\tself.stake = self.stake.saturating_sub(less);\n\t\t\tself.total = self.total.saturating_sub(less);\n\t\t\tSome(self.stake)\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn inc_delegator(\u0026mut self, delegator: A, more: B) {\n\t\tif let Ok(i) = self\n\t\t\t.delegators\n\t\t\t.linear_search(\u0026Stake::\u003cA, B\u003e { owner: delegator, amount: B::zero() })\n\t\t{\n\t\t\tself.delegators.mutate(|vec| vec[i].amount = vec[i].amount.saturating_add(more));\n\t\t\tself.total = self.total.saturating_add(more);\n\t\t\tself.delegators.sort_greatest_to_lowest()\n\t\t}\n\t}\n\n\tpub fn dec_delegator(\u0026mut self, delegator: A, less: B) {\n\t\tif let Ok(i) = self\n\t\t\t.delegators\n\t\t\t.linear_search(\u0026Stake::\u003cA, B\u003e { owner: delegator, amount: B::zero() })\n\t\t{\n\t\t\tself.delegators.mutate(|vec| vec[i].amount = vec[i].amount.saturating_sub(less));\n\t\t\tself.total = self.total.saturating_sub(less);\n\t\t\tself.delegators.sort_greatest_to_lowest()\n\t\t}\n\t}\n\n\tpub fn leave_candidates(\u0026mut self, round: SessionIndex) {\n\t\tself.status = CandidateStatus::Leaving(round);\n\t}\n}\n\npub type Delegator\u003cAccountId, Balance\u003e = Stake\u003cOption\u003cAccountId\u003e, Balance\u003e;\nimpl\u003cAccountId, Balance\u003e Delegator\u003cAccountId, Balance\u003e\nwhere\n\tAccountId: Eq + Ord + Clone + Debug,\n\tBalance: Copy\n\t\t+ Add\u003cOutput = Balance\u003e\n\t\t+ Saturating\n\t\t+ PartialOrd\n\t\t+ Eq\n\t\t+ Ord\n\t\t+ Debug\n\t\t+ Zero\n\t\t+ Default\n\t\t+ CheckedSub,\n{\n\t/// Adds a new delegation.\n\t///\n\t/// If already delegating to someone, this call will fail.\n\tpub fn add_delegation(\u0026mut self, stake: Stake\u003cAccountId, Balance\u003e) -\u003e Result\u003c(), ()\u003e {\n\t\tif self.owner.is_none() \u0026\u0026 self.amount.is_zero() {\n\t\t\tself.owner = Some(stake.owner);\n\t\t\tself.amount = stake.amount;\n\t\t\tOk(())\n\t\t} else {\n\t\t\tErr(())\n\t\t}\n\t}\n\n\t/// Returns Ok if the delegation for the\n\t/// collator exists and `Err` otherwise.\n\tpub fn rm_delegation(\u0026mut self, collator: AccountId) -\u003e Result\u003c(), ()\u003e {\n\t\tif self.owner == Some(collator) {\n\t\t\tself.amount = Balance::zero();\n\t\t\tself.owner = None;\n\t\t\tOk(())\n\t\t} else {\n\t\t\tErr(())\n\t\t}\n\t}\n\n\t/// Returns Ok(delegated_amount) if successful, `Err` if delegation was\n\t/// not found.\n\tpub fn inc_delegation(\u0026mut self, collator: AccountId, more: Balance) -\u003e Result\u003cBalance, ()\u003e {\n\t\tif self.owner == Some(collator) {\n\t\t\tself.amount = self.amount.saturating_add(more);\n\t\t\tOk(self.amount)\n\t\t} else {\n\t\t\tErr(())\n\t\t}\n\t}\n\n\t/// Returns Ok(Some(delegated_amount)) if successful, `Err` if delegation\n\t/// was not found and Ok(None) if delegated stake would underflow.\n\tpub fn dec_delegation(\n\t\t\u0026mut self,\n\t\tcollator: AccountId,\n\t\tless: Balance,\n\t) -\u003e Result\u003cOption\u003cBalance\u003e, ()\u003e {\n\t\tif self.owner == Some(collator) {\n\t\t\tOk(self.amount.checked_sub(\u0026less).map(|new| {\n\t\t\t\tself.amount = new;\n\t\t\t\tself.amount\n\t\t\t}))\n\t\t} else {\n\t\t\tErr(())\n\t\t}\n\t}\n}\n\n/// The current round index and transition information.\n#[derive(Copy, Clone, PartialEq, Eq, Encode, Decode, RuntimeDebug, TypeInfo, MaxEncodedLen)]\npub struct RoundInfo\u003cBlockNumber\u003e {\n\t/// Current round index.\n\tpub current: SessionIndex,\n\t/// The first block of the current round.\n\tpub first: BlockNumber,\n\t/// The length of the current round in blocks.\n\tpub length: BlockNumber,\n}\n\nimpl\u003cB\u003e RoundInfo\u003cB\u003e\nwhere\n\tB: Copy + Saturating + From\u003cu32\u003e + PartialOrd,\n{\n\tpub fn new(current: SessionIndex, first: B, length: B) -\u003e RoundInfo\u003cB\u003e {\n\t\tRoundInfo { current, first, length }\n\t}\n\n\t/// Checks if the round should be updated.\n\t///\n\t/// The round should update if `self.length` or more blocks where produced\n\t/// after `self.first`.\n\tpub fn should_update(\u0026self, now: B) -\u003e bool {\n\t\tlet l = now.saturating_sub(self.first);\n\t\tl \u003e= self.length\n\t}\n\n\t/// Starts a new round.\n\tpub fn update(\u0026mut self, now: B) {\n\t\tself.current = self.current.saturating_add(1u32);\n\t\tself.first = now;\n\t}\n}\n\nimpl\u003cB\u003e Default for RoundInfo\u003cB\u003e\nwhere\n\tB: Copy + Saturating + Add\u003cOutput = B\u003e + Sub\u003cOutput = B\u003e + From\u003cu32\u003e + PartialOrd,\n{\n\tfn default() -\u003e RoundInfo\u003cB\u003e {\n\t\tRoundInfo::new(0u32, 0u32.into(), 20.into())\n\t}\n}\n\n/// The total stake of the pallet.\n///\n/// The stake includes both collators' and delegators' staked funds.\n#[derive(Default, Clone, Encode, Decode, RuntimeDebug, PartialEq, Eq, TypeInfo, MaxEncodedLen)]\npub struct TotalStake\u003cBalance: Default\u003e {\n\tpub collators: Balance,\n\tpub delegators: Balance,\n}\n\n/// The number of delegations a delegator has done within the last session in\n/// which they delegated.\n#[derive(Default, Clone, Encode, Decode, Eq, MaxEncodedLen, PartialEq, RuntimeDebug, TypeInfo)]\npub struct DelegationCounter {\n\t/// The index of the last delegation.\n\tpub round: SessionIndex,\n\t/// The number of delegations made within round.\n\tpub counter: u32,\n}\n\npub type AccountIdOf\u003cT\u003e = \u003cT as frame_system::Config\u003e::AccountId;\npub type BalanceOf\u003cT\u003e = \u003c\u003cT as Config\u003e::Currency as Currency\u003cAccountIdOf\u003cT\u003e\u003e\u003e::Balance;\npub type CandidateOf\u003cT, S\u003e = Candidate\u003cAccountIdOf\u003cT\u003e, BalanceOf\u003cT\u003e, S\u003e;\npub type StakeOf\u003cT\u003e = Stake\u003cAccountIdOf\u003cT\u003e, BalanceOf\u003cT\u003e\u003e;\npub type NegativeImbalanceOf\u003cT\u003e =\n\t\u003c\u003cT as Config\u003e::Currency as Currency\u003cAccountIdOf\u003cT\u003e\u003e\u003e::NegativeImbalance;\n","traces":[{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":76},{"path":["/","Users","marcel","Documents","pendulum","pallets","vesting-manager","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub use pallet::*;\n\nuse frame_support::traits::VestingSchedule;\nuse sp_runtime::traits::StaticLookup;\n\ntype AccountIdLookupOf\u003cT\u003e = \u003c\u003cT as frame_system::Config\u003e::Lookup as StaticLookup\u003e::Source;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::pallet]\n\tpub struct Pallet\u003cT\u003e(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config {\n\t\ttype RuntimeEvent: From\u003cEvent\u003cSelf\u003e\u003e + IsType\u003c\u003cSelf as frame_system::Config\u003e::RuntimeEvent\u003e;\n\t\ttype VestingSchedule: VestingSchedule\u003cSelf::AccountId\u003e;\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event\u003cT: Config\u003e {\n\t\tVestingScheduleRemoved { who: T::AccountId, schedule_index: u32 },\n\t}\n\n\t#[pallet::call]\n\timpl\u003cT: Config\u003e Pallet\u003cT\u003e {\n\t\t#[pallet::call_index(0)]\n\t\t#[pallet::weight(10_000_000)]\n\t\tpub fn remove_vesting_schedule(\n\t\t\torigin: OriginFor\u003cT\u003e,\n\t\t\twho: AccountIdLookupOf\u003cT\u003e,\n\t\t\tschedule_index: u32,\n\t\t) -\u003e DispatchResultWithPostInfo {\n\t\t\tensure_root(origin)?;\n\t\t\tlet who = T::Lookup::lookup(who)?;\n\t\t\tT::VestingSchedule::remove_vesting_schedule(\u0026who, schedule_index)?;\n\n\t\t\tSelf::deposit_event(Event::VestingScheduleRemoved { who, schedule_index });\n\n\t\t\t// waive the fee\n\t\t\tOk(Pays::No.into())\n\t\t}\n\t}\n}\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","build.rs"],"content":"use substrate_wasm_builder::WasmBuilder;\n\nfn main() {\n\tWasmBuilder::new()\n\t\t.with_current_project()\n\t\t.export_heap_base()\n\t\t.import_memory()\n\t\t.build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nmod weights;\npub mod xcm_config;\npub mod zenlink;\n\nuse crate::zenlink::*;\nuse bifrost_farming as farming;\nuse bifrost_farming_rpc_runtime_api as farming_rpc_runtime_api;\nuse xcm::v3::MultiLocation;\nuse zenlink_protocol::{AssetBalance, MultiAssetsHandler, PairInfo};\n\npub use parachain_staking::InflationInfo;\n\nuse codec::Encode;\n\nuse smallvec::smallvec;\nuse sp_api::impl_runtime_apis;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata, H256};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{\n\t\tAccountIdConversion, AccountIdLookup, BlakeTwo256, Block as BlockT, Convert, ConvertInto,\n\t},\n\ttransaction_validity::{TransactionSource, TransactionValidity},\n\tApplyExtrinsicResult, DispatchError, FixedPointNumber, SaturatedConversion,\n};\n\nconst CONTRACTS_DEBUG_OUTPUT: bool = true;\n\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\nuse frame_support::{\n\tconstruct_runtime,\n\tdispatch::DispatchClass,\n\tparameter_types,\n\ttraits::{\n\t\tConstBool, ConstU32, Contains, Currency as FrameCurrency, EitherOfDiverse,\n\t\tEqualPrivilegeOnly, Imbalance, OnUnbalanced, WithdrawReasons,\n\t},\n\tweights::{\n\t\tconstants::WEIGHT_REF_TIME_PER_SECOND, ConstantMultiplier, Weight, WeightToFeeCoefficient,\n\t\tWeightToFeeCoefficients, WeightToFeePolynomial,\n\t},\n\tPalletId,\n};\nuse frame_system::{\n\tlimits::{BlockLength, BlockWeights},\n\tEnsureRoot, EnsureSigned,\n};\npub use sp_runtime::{MultiAddress, Perbill, Permill, Perquintill};\n\nuse runtime_common::{\n\tasset_registry, opaque, AccountId, Amount, AuraId, Balance, BlockNumber, Hash, Index, PoolId,\n\tReserveIdentifier, Signature, EXISTENTIAL_DEPOSIT, MILLIUNIT, NANOUNIT, UNIT,\n};\n\nuse cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;\n\nuse dia_oracle::DiaOracle;\n\nuse xcm_config::{XcmConfig, XcmOriginToTransactDispatchOrigin};\n\nuse orml_currencies::BasicCurrencyAdapter;\nuse orml_traits::{currency::MutationHooks, parameter_type_with_key};\n\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\n\npub use dia_oracle::dia::AssetId;\npub use issue::{Event as IssueEvent, IssueRequest};\npub use module_oracle_rpc_runtime_api::BalanceWrapper;\npub use nomination::Event as NominationEvent;\nuse oracle::{\n\tdia,\n\tdia::{DiaOracleAdapter, NativeCurrencyKey, XCMCurrencyConversion},\n};\npub use redeem::{Event as RedeemEvent, RedeemRequest};\npub use replace::{Event as ReplaceEvent, ReplaceRequest};\npub use security::StatusCode;\npub use spacewalk_primitives::CurrencyId;\npub use stellar_relay::traits::{FieldLength, Organization, Validator};\n// Polkadot imports\nuse polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};\n\nuse spacewalk_primitives::{\n\tself as primitives, CurrencyId::XCM, Moment, SignedFixedPoint, SignedInner, UnsignedFixedPoint,\n\tUnsignedInner,\n};\n\nuse weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};\n\n// XCM Imports\nuse xcm_executor::XcmExecutor;\n\npub type VaultId = primitives::VaultId\u003cAccountId, CurrencyId\u003e;\n\n/// The address format for describing accounts.\npub type Address = MultiAddress\u003cAccountId, ()\u003e;\n\n/// Block header type as expected by this runtime.\npub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\n/// Block type as expected by this runtime.\npub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock\u003cBlock\u003e;\n\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId\u003cBlock\u003e;\n\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender\u003cRuntime\u003e,\n\tframe_system::CheckSpecVersion\u003cRuntime\u003e,\n\tframe_system::CheckTxVersion\u003cRuntime\u003e,\n\tframe_system::CheckGenesis\u003cRuntime\u003e,\n\tframe_system::CheckEra\u003cRuntime\u003e,\n\tframe_system::CheckNonce\u003cRuntime\u003e,\n\tframe_system::CheckWeight\u003cRuntime\u003e,\n\tpallet_transaction_payment::ChargeTransactionPayment\u003cRuntime\u003e,\n);\n\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tgeneric::UncheckedExtrinsic\u003cAddress, RuntimeCall, Signature, SignedExtra\u003e;\n\npub type SignedPayload = generic::SignedPayload\u003cRuntimeCall, SignedExtra\u003e;\n\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic\u003cAccountId, RuntimeCall, SignedExtra\u003e;\n\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive\u003c\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext\u003cRuntime\u003e,\n\tRuntime,\n\tAllPalletsWithSystem,\n\u003e;\n\npub struct AmplitudeDiaOracleKeyConverter;\n\nimpl NativeCurrencyKey for AmplitudeDiaOracleKeyConverter {\n\tfn native_symbol() -\u003e Vec\u003cu8\u003e {\n\t\tb\"AMPE\".to_vec()\n\t}\n\n\tfn native_chain() -\u003e Vec\u003cu8\u003e {\n\t\tb\"Amplitude\".to_vec()\n\t}\n}\n\nimpl XCMCurrencyConversion for AmplitudeDiaOracleKeyConverter {\n\tfn convert_to_dia_currency_id(token_symbol: u8) -\u003e Option\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e)\u003e {\n\t\tmatch token_symbol {\n\t\t\t0 =\u003e Some((b\"Kusama\".to_vec(), b\"KSM\".to_vec())),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n\n\tfn convert_from_dia_currency_id(blockchain: Vec\u003cu8\u003e, symbol: Vec\u003cu8\u003e) -\u003e Option\u003cu8\u003e {\n\t\tmatch (blockchain.as_slice(), symbol.as_slice()) {\n\t\t\t(b\"Kusama\", b\"KSM\") =\u003e Some(0),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\ntype DataProviderImpl = DiaOracleAdapter\u003c\n\tDiaOracleModule,\n\tUnsignedFixedPoint,\n\tMoment,\n\tdia::DiaOracleKeyConvertor\u003cAmplitudeDiaOracleKeyConverter\u003e,\n\tConvertPrice,\n\tConvertMoment,\n\u003e;\n\npub struct ConvertPrice;\n\nimpl Convert\u003cu128, Option\u003cUnsignedFixedPoint\u003e\u003e for ConvertPrice {\n\tfn convert(price: u128) -\u003e Option\u003cUnsignedFixedPoint\u003e {\n\t\tSome(UnsignedFixedPoint::from_inner(price))\n\t}\n}\n\npub struct ConvertMoment;\n\nimpl Convert\u003cu64, Option\u003cMoment\u003e\u003e for ConvertMoment {\n\tfn convert(moment: u64) -\u003e Option\u003cMoment\u003e {\n\t\t// The provided moment is in seconds, but we need milliseconds\n\t\tSome(moment.saturating_mul(1000))\n\t}\n}\n\n/// Handles converting a weight scalar to a fee value, based on the scale and granularity of the\n/// node's balance type.\n///\n/// This should typically create a mapping between the following ranges:\n///   - `[0, MAXIMUM_BLOCK_WEIGHT]`\n///   - `[Balance::min, Balance::max]`\n///\n/// Yet, it can be used for any other sort of change to weight-fee. Some examples being:\n///   - Setting it to `0` will essentially disable the weight fee.\n///   - Setting it to `1` will cause the literal `#[weight = x]` values to be charged.\npub struct WeightToFee;\n\nimpl WeightToFeePolynomial for WeightToFee {\n\ttype Balance = Balance;\n\tfn polynomial() -\u003e WeightToFeeCoefficients\u003cSelf::Balance\u003e {\n\t\tlet p = MILLIUNIT;\n\t\tlet q = 10 * Balance::from(ExtrinsicBaseWeight::get().ref_time());\n\t\tsmallvec![WeightToFeeCoefficient {\n\t\t\tdegree: 1,\n\t\t\tnegative: false,\n\t\t\tcoeff_frac: Perbill::from_rational(p % q, q),\n\t\t\tcoeff_integer: p / q,\n\t\t}]\n\t}\n}\n\nimpl_opaque_keys! {\n\tpub struct SessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\n#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"amplitude\"),\n\timpl_name: create_runtime_str!(\"amplitude\"),\n\tauthoring_version: 1,\n\tspec_version: 10,\n\timpl_version: 0,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 10,\n\tstate_version: 1,\n};\n\n/// This determines the average expected block time that we are targeting.\n/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.\n/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked\n/// up by `pallet_aura` to implement `fn slot_duration()`.\n///\n/// Change this to adjust the block time.\npub const MILLISECS_PER_BLOCK: u64 = 12000;\n\n// NOTE: Currently it is not possible to change the slot duration after the chain has started.\n//       Attempting to do so will brick block production.\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\npub const BLOCKS_PER_YEAR: BlockNumber = DAYS * 36525 / 100;\n\n/// We assume that ~5% of the block weight is consumed by `on_initialize` handlers. This is\n/// used to limit the maximal weight of a single extrinsic.\nconst AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(5);\n\n/// We allow `Normal` extrinsics to fill up the block up to 75%, the rest can be used by\n/// `Operational` extrinsics.\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\n/// We allow for 0.5 of a second of compute with a 12 second average block time.\nconst MAXIMUM_BLOCK_WEIGHT: Weight =\n\tWeight::from_parts(WEIGHT_REF_TIME_PER_SECOND.saturating_div(2), 0)\n\t\t.set_proof_size(cumulus_primitives_core::relay_chain::MAX_POV_SIZE as u64);\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -\u003e NativeVersion {\n\tNativeVersion { runtime_version: VERSION, can_author_with: Default::default() }\n}\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\n\t// This part is copied from Substrate's `bin/node/runtime/src/lib.rs`.\n\t//  The `RuntimeBlockLength` and `RuntimeBlockWeights` exist here because the\n\t// `DeletionWeightLimit` and `DeletionQueueDepth` depend on those to parameterize\n\t// the lazy contract deletion.\n\tpub RuntimeBlockLength: BlockLength =\n\t\tBlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub RuntimeBlockWeights: BlockWeights = BlockWeights::builder()\n\t\t.base_block(BlockExecutionWeight::get())\n\t\t.for_class(DispatchClass::all(), |weights| {\n\t\t\tweights.base_extrinsic = ExtrinsicBaseWeight::get();\n\t\t})\n\t\t.for_class(DispatchClass::Normal, |weights| {\n\t\t\tweights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);\n\t\t})\n\t\t.for_class(DispatchClass::Operational, |weights| {\n\t\t\tweights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);\n\t\t\t// Operational transactions have some extra reserved space, so that they\n\t\t\t// are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.\n\t\t\tweights.reserved = Some(\n\t\t\t\tMAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT\n\t\t\t);\n\t\t})\n\t\t.avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)\n\t\t.build_or_panic();\n\tpub const SS58Prefix: u16 = 57;\n}\n\npub struct BaseFilter;\n\nimpl Contains\u003cRuntimeCall\u003e for BaseFilter {\n\tfn contains(call: \u0026RuntimeCall) -\u003e bool {\n\t\tmatch call {\n\t\t\t// These modules are all allowed to be called by transactions:\n\t\t\tRuntimeCall::Bounties(_) |\n\t\t\tRuntimeCall::ChildBounties(_) |\n\t\t\tRuntimeCall::Treasury(_) |\n\t\t\tRuntimeCall::Tokens(_) |\n\t\t\tRuntimeCall::Currencies(_) |\n\t\t\tRuntimeCall::ParachainStaking(_) |\n\t\t\tRuntimeCall::Democracy(_) |\n\t\t\tRuntimeCall::Council(_) |\n\t\t\tRuntimeCall::TechnicalCommittee(_) |\n\t\t\tRuntimeCall::System(_) |\n\t\t\tRuntimeCall::Scheduler(_) |\n\t\t\tRuntimeCall::Preimage(_) |\n\t\t\tRuntimeCall::Timestamp(_) |\n\t\t\tRuntimeCall::Balances(_) |\n\t\t\tRuntimeCall::Session(_) |\n\t\t\tRuntimeCall::ParachainSystem(_) |\n\t\t\tRuntimeCall::XcmpQueue(_) |\n\t\t\tRuntimeCall::PolkadotXcm(_) |\n\t\t\tRuntimeCall::DmpQueue(_) |\n\t\t\tRuntimeCall::Utility(_) |\n\t\t\tRuntimeCall::Vesting(_) |\n\t\t\tRuntimeCall::XTokens(_) |\n\t\t\tRuntimeCall::Multisig(_) |\n\t\t\tRuntimeCall::Identity(_) |\n\t\t\tRuntimeCall::Contracts(_) |\n\t\t\tRuntimeCall::ZenlinkProtocol(_) |\n\t\t\tRuntimeCall::VestingManager(_) |\n\t\t\tRuntimeCall::DiaOracleModule(_) |\n\t\t\tRuntimeCall::Fee(_) |\n\t\t\tRuntimeCall::Issue(_) |\n\t\t\tRuntimeCall::Nomination(_) |\n\t\t\tRuntimeCall::Oracle(_) |\n\t\t\tRuntimeCall::Redeem(_) |\n\t\t\tRuntimeCall::Replace(_) |\n\t\t\tRuntimeCall::Security(_) |\n\t\t\tRuntimeCall::StellarRelay(_) |\n\t\t\tRuntimeCall::VaultRegistry(_) |\n\t\t\tRuntimeCall::VaultRewards(_) |\n\t\t\tRuntimeCall::Farming(_) |\n\t\t\tRuntimeCall::AssetRegistry(_) =\u003e true,\n\t\t\t// All pallets are allowed, but exhaustive match is defensive\n\t\t\t// in the case of adding new pallets.\n\t\t}\n\t}\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype RuntimeCall = RuntimeCall;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup\u003cAccountId, ()\u003e;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\t/// The ubiquitous origin type.\n\ttype RuntimeOrigin = RuntimeOrigin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// Runtime version.\n\ttype Version = Version;\n\t/// Converts a module to an index of this module in the runtime.\n\ttype PalletInfo = PalletInfo;\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = BaseFilter;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// Block \u0026 extrinsics weights: base values and limits.\n\ttype BlockWeights = RuntimeBlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = RuntimeBlockLength;\n\t/// This is used as an identifier of the chain. 57 is the prefix for Amplitude\n\ttype SS58Prefix = SS58Prefix;\n\t/// The action to take on a Runtime Upgrade\n\ttype OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode\u003cSelf\u003e;\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = pallet_timestamp::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const UncleGenerations: u32 = 2;\n}\n\nimpl pallet_authorship::Config for Runtime {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = ParachainStaking;\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = EXISTENTIAL_DEPOSIT;\n\tpub const MaxLocks: u32 = 50;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = Treasury;\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 100 * NANOUNIT;\n\tpub const OperationalFeeMultiplier: u8 = 5;\n}\n\ntype NegativeImbalance = \u003cBalances as FrameCurrency\u003cAccountId\u003e\u003e::NegativeImbalance;\n\npub struct DealWithFees;\n\nimpl OnUnbalanced\u003cNegativeImbalance\u003e for DealWithFees {\n\tfn on_unbalanceds\u003cB\u003e(mut fees_then_tips: impl Iterator\u003cItem = NegativeImbalance\u003e) {\n\t\tif let Some(mut fees) = fees_then_tips.next() {\n\t\t\tif let Some(tips) = fees_then_tips.next() {\n\t\t\t\ttips.merge_into(\u0026mut fees);\n\t\t\t}\n\t\t\t// for fees and tips, 100% to treasury\n\t\t\tTreasury::on_unbalanced(fees);\n\t\t}\n\t}\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter\u003cBalances, DealWithFees\u003e;\n\ttype WeightToFee = WeightToFee;\n\ttype LengthToFee = ConstantMultiplier\u003cBalance, TransactionByteFee\u003e;\n\ttype FeeMultiplierUpdate = SlowAdjustingFeeUpdate\u003cSelf\u003e;\n\ttype OperationalFeeMultiplier = OperationalFeeMultiplier;\n}\n\nparameter_types! {\n\tpub const ReservedXcmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n\tpub const ReservedDmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n}\n\nimpl cumulus_pallet_parachain_system::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSystemEvent = ();\n\ttype SelfParaId = parachain_info::Pallet\u003cRuntime\u003e;\n\ttype DmpMessageHandler = DmpQueue;\n\ttype ReservedDmpWeight = ReservedDmpWeight;\n\ttype OutboundXcmpMessageSource = XcmpQueue;\n\ttype XcmpMessageHandler = XcmpQueue;\n\ttype ReservedXcmpWeight = ReservedXcmpWeight;\n\ttype CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;\n}\n\nimpl parachain_info::Config for Runtime {}\n\nimpl cumulus_pallet_aura_ext::Config for Runtime {}\n\nimpl cumulus_pallet_xcmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ChannelInfo = ParachainSystem;\n\ttype VersionWrapper = ();\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype PriceForSiblingDelivery = ();\n\ttype WeightInfo = cumulus_pallet_xcmp_queue::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl cumulus_pallet_dmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const Offset: u32 = 0;\n\tpub const MaxAuthorities: u32 = 200;\n}\n\nimpl pallet_session::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\ttype ValidatorIdOf = ConvertInto;\n\ttype ShouldEndSession = ParachainStaking;\n\ttype NextSessionRotation = ParachainStaking;\n\ttype SessionManager = ParachainStaking;\n\ttype SessionHandler = \u003cSessionKeys as sp_runtime::traits::OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = SessionKeys;\n\ttype WeightInfo = pallet_session::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nparameter_types! {\n\tpub const LaunchPeriod: BlockNumber = 5 * DAYS;\n\tpub const VotingPeriod: BlockNumber = 5 * DAYS;\n\tpub const FastTrackVotingPeriod: BlockNumber = 3 * HOURS;\n\tpub const MinimumDeposit: Balance = UNIT;\n\tpub const EnactmentPeriod: BlockNumber = 2 * DAYS;\n\tpub const CooloffPeriod: BlockNumber = 7 * DAYS;\n\tpub const MaxProposals: u32 = 100;\n}\n\nimpl pallet_democracy::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype EnactmentPeriod = EnactmentPeriod;\n\ttype LaunchPeriod = LaunchPeriod;\n\ttype VotingPeriod = VotingPeriod;\n\ttype VoteLockingPeriod = EnactmentPeriod;\n\t// Same as EnactmentPeriod\n\ttype MinimumDeposit = MinimumDeposit;\n\t/// A straight majority of the council can decide what their next motion is.\n\ttype ExternalOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A super-majority can have the next scheduled referendum be a straight majority-carries vote.\n\ttype ExternalMajorityOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A unanimous council can have the next scheduled referendum be a straight default-carries\n\t/// (NTB) vote.\n\ttype ExternalDefaultOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 1\u003e;\n\t/// Two thirds of the technical committee can have an ExternalMajority/ExternalDefault vote\n\t/// be tabled immediately and with a shorter voting/enactment period.\n\ttype FastTrackOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 2, 3\u003e;\n\ttype InstantOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e;\n\ttype InstantAllowed = frame_support::traits::ConstBool\u003ctrue\u003e;\n\ttype FastTrackVotingPeriod = FastTrackVotingPeriod;\n\t// To cancel a proposal which has been passed, 2/3 of the council must agree to it.\n\ttype CancellationOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 2, 3\u003e;\n\t// To cancel a proposal before it has been passed, the technical committee must be unanimous or\n\t// Root must agree.\n\ttype CancelProposalOrigin = EitherOfDiverse\u003c\n\t\tEnsureRoot\u003cAccountId\u003e,\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e,\n\t\u003e;\n\ttype BlacklistOrigin = EnsureRoot\u003cAccountId\u003e;\n\t// Any single technical committee member may veto a coming council proposal, however they can\n\t// only do it once and it lasts only for the cool-off period.\n\ttype VetoOrigin = pallet_collective::EnsureMember\u003cAccountId, TechnicalCollective\u003e;\n\ttype CooloffPeriod = CooloffPeriod;\n\ttype Slash = ();\n\ttype Scheduler = Scheduler;\n\ttype PalletsOrigin = OriginCaller;\n\ttype MaxVotes = ConstU32\u003c100\u003e;\n\ttype WeightInfo = pallet_democracy::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxProposals = MaxProposals;\n\ttype Preimages = Preimage;\n\ttype MaxDeposits = ConstU32\u003c100\u003e;\n\ttype MaxBlacklisted = ConstU32\u003c100\u003e;\n\ttype SubmitOrigin = EnsureSigned\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const CouncilMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const CouncilMaxProposals: u32 = 100;\n\tpub const CouncilMaxMembers: u32 = 100;\n}\n\ntype CouncilCollective = pallet_collective::Instance1;\n\nimpl pallet_collective::Config\u003cCouncilCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = CouncilMotionDuration;\n\ttype MaxProposals = CouncilMaxProposals;\n\ttype MaxMembers = CouncilMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const TechnicalMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const TechnicalMaxProposals: u32 = 100;\n\tpub const TechnicalMaxMembers: u32 = 100;\n}\n\ntype TechnicalCollective = pallet_collective::Instance2;\n\nimpl pallet_collective::Config\u003cTechnicalCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = TechnicalMotionDuration;\n\ttype MaxProposals = TechnicalMaxProposals;\n\ttype MaxMembers = TechnicalMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub MaximumSchedulerWeight: Weight = Perbill::from_percent(80) *\n\t\tRuntimeBlockWeights::get().max_block;\n}\n\nimpl pallet_scheduler::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype PalletsOrigin = OriginCaller;\n\ttype RuntimeCall = RuntimeCall;\n\ttype MaximumWeight = MaximumSchedulerWeight;\n\ttype ScheduleOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype MaxScheduledPerBlock = ConstU32\u003c50\u003e;\n\ttype WeightInfo = pallet_scheduler::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype OriginPrivilegeCmp = EqualPrivilegeOnly;\n\ttype Preimages = Preimage;\n}\n\nparameter_types! {\n\tpub const PreimageMaxSize: u32 = 4096 * 1024;\n\tpub const PreimageBaseDeposit: Balance = 1 * UNIT;\n\t// One cent: $10,000 / MB\n\tpub const PreimageByteDeposit: Balance = 10 * MILLIUNIT;\n}\n\nimpl pallet_preimage::Config for Runtime {\n\ttype WeightInfo = pallet_preimage::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype ManagerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype BaseDeposit = PreimageBaseDeposit;\n\ttype ByteDeposit = PreimageByteDeposit;\n}\n\nparameter_types! {\n\tpub const ProposalBond: Permill = Permill::from_percent(5);\n\tpub const ProposalBondMinimum: Balance = 10 * UNIT;\n\tpub const SpendPeriod: BlockNumber = 7 * DAYS;\n\tpub const Burn: Permill = Permill::from_percent(0);\n\tpub const TreasuryPalletId: PalletId = PalletId(*b\"py/trsry\");\n\tpub const MaxApprovals: u32 = 100;\n}\n\ntype TreasuryApproveOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 3, 5\u003e,\n\u003e;\n\ntype TreasuryRejectOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_treasury::Config for Runtime {\n\ttype PalletId = TreasuryPalletId;\n\ttype Currency = Balances;\n\ttype ApproveOrigin = TreasuryApproveOrigin;\n\ttype RejectOrigin = TreasuryRejectOrigin;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSlash = Treasury;\n\ttype ProposalBond = ProposalBond;\n\ttype ProposalBondMinimum = ProposalBondMinimum;\n\ttype ProposalBondMaximum = ();\n\ttype SpendPeriod = SpendPeriod;\n\ttype Burn = Burn;\n\ttype BurnDestination = ();\n\ttype SpendFunds = Bounties;\n\ttype WeightInfo = pallet_treasury::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxApprovals = MaxApprovals;\n\ttype SpendOrigin = frame_support::traits::NeverEnsureOrigin\u003cu128\u003e;\n}\n\nparameter_types! {\n\tpub const BountyCuratorDeposit: Permill = Permill::from_percent(50);\n\tpub const BountyValueMinimum: Balance = 5 * UNIT;\n\tpub const BountyDepositBase: Balance = 1 * UNIT;\n\tpub const CuratorDepositMultiplier: Permill = Permill::from_percent(50);\n\tpub const CuratorDepositMin: Balance = 1 * UNIT;\n\tpub const CuratorDepositMax: Balance = 100 * UNIT;\n\tpub const DataDepositPerByte: Balance = 30 * MILLIUNIT;\n\tpub const BountyDepositPayoutDelay: BlockNumber = 4 * DAYS;\n\tpub const BountyUpdatePeriod: BlockNumber = 20 * DAYS;\n\tpub const MaximumReasonLength: u32 = 5000;\n}\n\nimpl pallet_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BountyDepositBase = BountyDepositBase;\n\ttype BountyDepositPayoutDelay = BountyDepositPayoutDelay;\n\ttype BountyUpdatePeriod = BountyUpdatePeriod;\n\ttype CuratorDepositMultiplier = CuratorDepositMultiplier;\n\ttype CuratorDepositMin = CuratorDepositMin;\n\ttype CuratorDepositMax = CuratorDepositMax;\n\ttype BountyValueMinimum = BountyValueMinimum;\n\ttype DataDepositPerByte = DataDepositPerByte;\n\ttype MaximumReasonLength = MaximumReasonLength;\n\ttype WeightInfo = pallet_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype ChildBountyManager = ChildBounties;\n}\n\nparameter_types! {\n\tpub const ChildBountyValueMinimum: Balance = 1 * UNIT;\n}\n\nimpl pallet_child_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MaxActiveChildBountyCount = ConstU32\u003c10\u003e;\n\ttype ChildBountyValueMinimum = ChildBountyValueMinimum;\n\ttype WeightInfo = pallet_child_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_type_with_key! {\n\tpub ExistentialDeposits: |_currency_id: CurrencyId| -\u003e Balance {\n\t\tNANOUNIT\n\t};\n}\n\npub fn get_all_module_accounts() -\u003e Vec\u003cAccountId\u003e {\n\tvec![Treasury::account_id()]\n}\n\npub struct DustRemovalWhitelist;\n\nimpl Contains\u003cAccountId\u003e for DustRemovalWhitelist {\n\tfn contains(a: \u0026AccountId) -\u003e bool {\n\t\tget_all_module_accounts().contains(a)\n\t}\n}\n\npub struct CurrencyHooks\u003cT\u003e(PhantomData\u003cT\u003e);\n\nimpl\u003cT: orml_tokens::Config\u003e MutationHooks\u003cT::AccountId, T::CurrencyId, T::Balance\u003e\n\tfor CurrencyHooks\u003cT\u003e\n{\n\ttype OnDust = orml_tokens::BurnDust\u003cT\u003e;\n\ttype OnSlash = ();\n\ttype PreDeposit = ();\n\ttype PostDeposit = ();\n\ttype PreTransfer = ();\n\ttype PostTransfer = ();\n\ttype OnNewTokenAccount = ();\n\ttype OnKilledTokenAccount = ();\n}\n\nimpl orml_tokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype Amount = Amount;\n\ttype CurrencyId = CurrencyId;\n\ttype WeightInfo = ();\n\ttype ExistentialDeposits = ExistentialDeposits;\n\ttype CurrencyHooks = CurrencyHooks\u003cRuntime\u003e;\n\ttype MaxLocks = ConstU32\u003c50\u003e;\n\ttype DustRemovalWhitelist = DustRemovalWhitelist;\n\ttype MaxReserves = ConstU32\u003c0\u003e;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const NativeCurrencyId: CurrencyId = CurrencyId::Native;\n}\n\nimpl orml_currencies::Config for Runtime {\n\ttype MultiCurrency = Tokens;\n\ttype NativeCurrency = BasicCurrencyAdapter\u003cRuntime, Balances, Amount, BlockNumber\u003e;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype WeightInfo = ();\n}\n\nimpl orml_asset_registry::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CustomMetadata = asset_registry::CustomMetadata;\n\ttype AssetId = CurrencyId;\n\ttype AuthorityOrigin = asset_registry::AssetAuthority;\n\ttype AssetProcessor = asset_registry::CustomAssetProcessor;\n\ttype Balance = Balance;\n\ttype WeightInfo = weights::orml_asset_registry::WeightInfo\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinBlocksPerRound: BlockNumber = HOURS;\n\tpub const DefaultBlocksPerRound: BlockNumber = 2 * HOURS;\n\tpub const StakeDuration: BlockNumber = 7 * DAYS;\n\tpub const ExitQueueDelay: u32 = 2;\n\tpub const MinCollators: u32 = 8;\n\tpub const MinRequiredCollators: u32 = 4;\n\tpub const MaxDelegationsPerRound: u32 = 1;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxDelegatorsPerCollator: u32 = 40;\n\tpub const MinCollatorStake: Balance = 5_000 * UNIT;\n\tpub const MinDelegatorStake: Balance = 10 * UNIT;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxTopCandidates: u32 = 40;\n\tpub const MaxUnstakeRequests: u32 = 10;\n\tpub const NetworkRewardStart: BlockNumber = BlockNumber::MAX;\n\tpub const NetworkRewardRate: Perquintill = Perquintill::from_percent(0);\n\tpub const CollatorRewardRateDecay: Perquintill = Perquintill::from_parts(936_879_853_200_000_000u64);\n}\n\nimpl parachain_staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyBalance = Balance;\n\n\ttype MinBlocksPerRound = MinBlocksPerRound;\n\ttype DefaultBlocksPerRound = DefaultBlocksPerRound;\n\ttype StakeDuration = StakeDuration;\n\ttype ExitQueueDelay = ExitQueueDelay;\n\ttype MinCollators = MinCollators;\n\ttype MinRequiredCollators = MinRequiredCollators;\n\ttype MaxDelegationsPerRound = MaxDelegationsPerRound;\n\ttype MaxDelegatorsPerCollator = MaxDelegatorsPerCollator;\n\ttype MinCollatorStake = MinCollatorStake;\n\ttype MinCollatorCandidateStake = MinCollatorStake;\n\ttype MaxTopCandidates = MaxTopCandidates;\n\ttype MinDelegatorStake = MinDelegatorStake;\n\ttype MaxUnstakeRequests = MaxUnstakeRequests;\n\ttype NetworkRewardRate = NetworkRewardRate;\n\ttype NetworkRewardStart = NetworkRewardStart;\n\ttype NetworkRewardBeneficiary = Treasury;\n\ttype CollatorRewardRateDecay = CollatorRewardRateDecay;\n\ttype WeightInfo = parachain_staking::default_weights::SubstrateWeight\u003cRuntime\u003e;\n\n\tconst BLOCKS_PER_YEAR: BlockNumber = BLOCKS_PER_YEAR;\n}\n\nparameter_types! {\n\tpub const DepositBase: Balance = 300 * MILLIUNIT;\n\tpub const DepositFactor: Balance = 50 * MILLIUNIT;\n}\n\nimpl pallet_multisig::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Currency = Balances;\n\ttype DepositBase = DepositBase;\n\ttype DepositFactor = DepositFactor;\n\ttype MaxSignatories = ConstU32\u003c20\u003e;\n\ttype WeightInfo = pallet_multisig::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_utility::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype PalletsOrigin = OriginCaller;\n\ttype WeightInfo = pallet_utility::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinVestedTransfer: Balance = 0;\n\tpub UnvestedFundsAllowedWithdrawReasons: WithdrawReasons =\n\t\tWithdrawReasons::except(WithdrawReasons::TRANSFER | WithdrawReasons::RESERVE);\n}\n\nimpl pallet_vesting::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BlockNumberToBalance = ConvertInto;\n\ttype MinVestedTransfer = MinVestedTransfer;\n\ttype UnvestedFundsAllowedWithdrawReasons = UnvestedFundsAllowedWithdrawReasons;\n\ttype WeightInfo = pallet_vesting::weights::SubstrateWeight\u003cRuntime\u003e;\n\tconst MAX_VESTING_SCHEDULES: u32 = 10;\n}\n\nimpl vesting_manager::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype VestingSchedule = Vesting;\n}\n\nconst fn deposit(items: u32, bytes: u32) -\u003e Balance {\n\t(items as Balance * UNIT + (bytes as Balance) * (5 * MILLIUNIT / 100)) / 10\n}\n\nparameter_types! {\n\tpub const DepositPerItem: Balance = deposit(1, 0);\n\tpub const DepositPerByte: Balance = deposit(0, 1);\n\tpub const DeletionQueueDepth: u32 = 128;\n\tpub DeletionWeightLimit: Weight = RuntimeBlockWeights::get()\n\t\t.per_class\n\t\t.get(DispatchClass::Normal)\n\t\t.max_total\n\t\t.unwrap_or(RuntimeBlockWeights::get().max_block);\n\tpub Schedule: pallet_contracts::Schedule\u003cRuntime\u003e = Default::default();\n}\n\nimpl pallet_contracts::Config for Runtime {\n\ttype Time = Timestamp;\n\ttype Randomness = RandomnessCollectiveFlip;\n\ttype Currency = Balances;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype CallFilter = frame_support::traits::Nothing;\n\ttype DepositPerItem = DepositPerItem;\n\ttype DepositPerByte = DepositPerByte;\n\ttype CallStack = [pallet_contracts::Frame\u003cSelf\u003e; 5];\n\ttype WeightPrice = pallet_transaction_payment::Pallet\u003cSelf\u003e;\n\ttype WeightInfo = pallet_contracts::weights::SubstrateWeight\u003cSelf\u003e;\n\ttype ChainExtension = ();\n\ttype DeletionQueueDepth = DeletionQueueDepth;\n\ttype DeletionWeightLimit = DeletionWeightLimit;\n\ttype Schedule = Schedule;\n\ttype AddressGenerator = pallet_contracts::DefaultAddressGenerator;\n\ttype MaxCodeLen = ConstU32\u003c{ 123 * 1024 }\u003e;\n\ttype MaxStorageKeyLen = ConstU32\u003c128\u003e;\n\ttype UnsafeUnstableInterface = ConstBool\u003ctrue\u003e;\n\ttype MaxDebugBufferLen = ConstU32\u003c{ 2 * 1024 * 1024 }\u003e;\n}\n\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {}\n\nparameter_types! {\n\tpub const BasicDeposit: Balance = 10 * UNIT;       // 258 bytes on-chain\n\tpub const FieldDeposit: Balance = 25 * MILLIUNIT;  // 66 bytes on-chain\n\tpub const SubAccountDeposit: Balance = 2 * UNIT;   // 53 bytes on-chain\n\tpub const MaxSubAccounts: u32 = 100;\n\tpub const MaxAdditionalFields: u32 = 100;\n\tpub const MaxRegistrars: u32 = 20;\n}\n\ntype EnsureRootOrHalfCouncil = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_identity::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BasicDeposit = BasicDeposit;\n\ttype FieldDeposit = FieldDeposit;\n\ttype SubAccountDeposit = SubAccountDeposit;\n\ttype MaxSubAccounts = MaxSubAccounts;\n\ttype MaxAdditionalFields = MaxAdditionalFields;\n\ttype MaxRegistrars = MaxRegistrars;\n\ttype Slashed = Treasury;\n\ttype ForceOrigin = EnsureRootOrHalfCouncil;\n\ttype RegistrarOrigin = EnsureRootOrHalfCouncil;\n\ttype WeightInfo = pallet_identity::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl dia_oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype AuthorityId = dia_oracle::crypto::DiaAuthId;\n\ttype WeightInfo = dia_oracle::weights::DiaWeightInfo\u003cRuntime\u003e;\n}\n\nimpl frame_system::offchain::SigningTypes for Runtime {\n\ttype Public = \u003cSignature as sp_runtime::traits::Verify\u003e::Signer;\n\ttype Signature = Signature;\n}\n\nimpl\u003cC\u003e frame_system::offchain::SendTransactionTypes\u003cC\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cC\u003e,\n{\n\ttype OverarchingCall = RuntimeCall;\n\ttype Extrinsic = UncheckedExtrinsic;\n}\n\nimpl\u003cLocalCall\u003e frame_system::offchain::CreateSignedTransaction\u003cLocalCall\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cLocalCall\u003e,\n{\n\tfn create_transaction\u003cC: frame_system::offchain::AppCrypto\u003cSelf::Public, Self::Signature\u003e\u003e(\n\t\tcall: RuntimeCall,\n\t\tpublic: \u003cSignature as sp_runtime::traits::Verify\u003e::Signer,\n\t\taccount: AccountId,\n\t\tindex: Index,\n\t) -\u003e Option\u003c(\n\t\tRuntimeCall,\n\t\t\u003cUncheckedExtrinsic as sp_runtime::traits::Extrinsic\u003e::SignaturePayload,\n\t)\u003e {\n\t\tlet period = BlockHashCount::get() as u64;\n\t\tlet current_block = System::block_number().saturated_into::\u003cu64\u003e().saturating_sub(1);\n\t\tlet tip = 0;\n\t\tlet extra: SignedExtra = (\n\t\t\tframe_system::CheckNonZeroSender::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckSpecVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckTxVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckGenesis::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckEra::\u003cRuntime\u003e::from(generic::Era::mortal(period, current_block)),\n\t\t\tframe_system::CheckNonce::\u003cRuntime\u003e::from(index),\n\t\t\tframe_system::CheckWeight::\u003cRuntime\u003e::new(),\n\t\t\tpallet_transaction_payment::ChargeTransactionPayment::\u003cRuntime\u003e::from(tip),\n\t\t);\n\n\t\tlet raw_payload = SignedPayload::new(call, extra).ok()?;\n\t\tlet signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;\n\t\tlet address = account;\n\t\tlet (call, extra, _) = raw_payload.deconstruct();\n\t\tSome((call, (sp_runtime::MultiAddress::Id(address), signature.into(), extra)))\n\t}\n}\n\npub struct CurrencyConvert;\n\nimpl currency::CurrencyConversion\u003ccurrency::Amount\u003cRuntime\u003e, CurrencyId\u003e for CurrencyConvert {\n\tfn convert(\n\t\tamount: \u0026currency::Amount\u003cRuntime\u003e,\n\t\tto: CurrencyId,\n\t) -\u003e Result\u003ccurrency::Amount\u003cRuntime\u003e, DispatchError\u003e {\n\t\tOracle::convert(amount, to)\n\t}\n}\nparameter_types! {\n\tpub const RelayChainCurrencyId: CurrencyId = XCM(0); // 0 is the index of the relay chain in our XCM mapping\n}\nimpl currency::Config for Runtime {\n\ttype UnsignedFixedPoint = UnsignedFixedPoint;\n\ttype SignedInner = SignedInner;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype Balance = Balance;\n\ttype GetRelayChainCurrencyId = RelayChainCurrencyId;\n\ttype AssetConversion = primitives::AssetConversion;\n\ttype BalanceConversion = primitives::BalanceConversion;\n\ttype CurrencyConversion = CurrencyConvert;\n\ttype AmountCompatibility = primitives::StellarCompatibility;\n}\n\nimpl security::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = security::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype SignedInner = SignedInner;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype CurrencyId = CurrencyId;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub struct DataFeederBenchmark\u003cK, V, A\u003e(PhantomData\u003c(K, V, A)\u003e);\n\n#[cfg(feature = \"runtime-benchmarks\")]\nimpl\u003cK, V, A\u003e orml_traits::DataFeeder\u003cK, V, A\u003e for DataFeederBenchmark\u003cK, V, A\u003e {\n\tfn feed_value(_who: A, _key: K, _value: V) -\u003e sp_runtime::DispatchResult {\n\t\tOk(())\n\t}\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nimpl\u003cK, V, A\u003e orml_traits::DataProvider\u003cK, V\u003e for DataFeederBenchmark\u003cK, V, A\u003e {\n\tfn get(_key: \u0026K) -\u003e Option\u003cV\u003e {\n\t\tNone\n\t}\n}\n\nimpl oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = oracle::SubstrateWeight\u003cRuntime\u003e;\n\ttype DataProvider = DataProviderImpl;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype DataFeedProvider = DataFeederBenchmark\u003c\n\t\toracle::OracleKey,\n\t\toracle::TimestampedValue\u003cUnsignedFixedPoint, Moment\u003e,\n\t\tSelf::AccountId,\n\t\u003e;\n}\n\nparameter_types! {\n\tpub const OrganizationLimit: u32 = 255;\n\tpub const ValidatorLimit: u32 = 255;\n\tpub const IsPublicNetwork: bool = true;\n}\n\nimpl stellar_relay::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OrganizationId = u128;\n\ttype OrganizationLimit = OrganizationLimit;\n\ttype ValidatorLimit = ValidatorLimit;\n\ttype IsPublicNetwork = IsPublicNetwork;\n\ttype WeightInfo = stellar_relay::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl reward::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype RewardId = VaultId;\n\ttype CurrencyId = CurrencyId;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n}\nparameter_types! {\n\tpub const FeePalletId: PalletId = PalletId(*b\"mod/fees\");\n\tpub const VaultRegistryPalletId: PalletId = PalletId(*b\"mod/vreg\");\n\tpub const MaxExpectedValue: UnsignedFixedPoint = UnsignedFixedPoint::from_inner(\u003cUnsignedFixedPoint as FixedPointNumber\u003e::DIV);\n\tpub FeeAccount: AccountId = FeePalletId::get().into_account_truncating();\n}\nimpl fee::Config for Runtime {\n\ttype FeePalletId = FeePalletId;\n\ttype WeightInfo = fee::SubstrateWeight\u003cRuntime\u003e;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype SignedInner = SignedInner;\n\ttype UnsignedFixedPoint = UnsignedFixedPoint;\n\ttype UnsignedInner = UnsignedInner;\n\ttype VaultRewards = VaultRewards;\n\ttype VaultStaking = VaultStaking;\n\ttype OnSweep = currency::SweepFunds\u003cRuntime, FeeAccount\u003e;\n\ttype MaxExpectedValue = MaxExpectedValue;\n}\n\nimpl vault_registry::Config for Runtime {\n\ttype PalletId = VaultRegistryPalletId;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype WeightInfo = vault_registry::SubstrateWeight\u003cRuntime\u003e;\n\ttype GetGriefingCollateralCurrencyId = NativeCurrencyId;\n}\n\nimpl redeem::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = redeem::SubstrateWeight\u003cRuntime\u003e;\n}\n\npub struct BlockNumberToBalance;\n\nimpl sp_runtime::traits::Convert\u003cBlockNumber, Balance\u003e for BlockNumberToBalance {\n\tfn convert(a: BlockNumber) -\u003e Balance {\n\t\ta.into()\n\t}\n}\n\nimpl issue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BlockNumberToBalance = BlockNumberToBalance;\n\ttype WeightInfo = issue::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl nomination::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = nomination::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl replace::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = replace::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const FarmingKeeperPalletId: PalletId = PalletId(*b\"am/fmkpr\");\n\tpub const FarmingRewardIssuerPalletId: PalletId = PalletId(*b\"am/fmrir\");\n\tpub AmplitudeTreasuryAccount: AccountId = TreasuryPalletId::get().into_account_truncating();\n}\n\nimpl farming::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CurrencyId = CurrencyId;\n\ttype MultiCurrency = Currencies;\n\ttype ControlOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype WeightInfo = farming::weights::BifrostWeight\u003cRuntime\u003e;\n\ttype TreasuryAccount = AmplitudeTreasuryAccount;\n\ttype Keeper = FarmingKeeperPalletId;\n\ttype RewardIssuer = FarmingRewardIssuerPalletId;\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\t// System support stuff.\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 0,\n\t\tParachainSystem: cumulus_pallet_parachain_system::{\n\t\t\tPallet, Call, Config, Storage, Inherent, Event\u003cT\u003e, ValidateUnsigned,\n\t\t} = 1,\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent} = 2,\n\t\tParachainInfo: parachain_info::{Pallet, Storage, Config} = 3,\n\n\t\t// Monetary stuff.\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 10,\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event\u003cT\u003e} = 11,\n\n\t\t// Governance\n\t\tDemocracy: pallet_democracy::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 13,\n\t\tCouncil: pallet_collective::\u003cInstance1\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e, Event\u003cT\u003e} = 14,\n\t\tTechnicalCommittee: pallet_collective::\u003cInstance2\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e,  Event\u003cT\u003e} = 15,\n\t\tScheduler: pallet_scheduler::{Pallet, Call, Storage, Event\u003cT\u003e} = 16,\n\t\tPreimage: pallet_preimage::{Pallet, Call, Storage, Event\u003cT\u003e} = 17,\n\t\tMultisig: pallet_multisig::{Pallet, Call, Storage, Event\u003cT\u003e} = 18,\n\t\tTreasury: pallet_treasury::{Pallet, Call, Storage, Event\u003cT\u003e} = 19,\n\t\tBounties: pallet_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 20,\n\t\tChildBounties: pallet_child_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 21,\n\n\t\t// Consensus support.\n\t\t// The following order MUST NOT be changed: Aura -\u003e Session -\u003e Staking -\u003e Authorship -\u003e AuraExt\n\t\t// Dependencies: AuraExt on Aura, Authorship and Session on ParachainStaking\n\t\tAura: pallet_aura::{Pallet, Storage, Config\u003cT\u003e} = 33,\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e} = 32,\n\t\tParachainStaking: parachain_staking::{Pallet, Call, Storage, Event\u003cT\u003e, Config\u003cT\u003e} = 35,\n\t\tAuthorship: pallet_authorship::{Pallet, Storage} = 30,\n\t\tAuraExt: cumulus_pallet_aura_ext::{Pallet, Storage, Config} = 34,\n\n\t\t// XCM helpers.\n\t\tXcmpQueue: cumulus_pallet_xcmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 40,\n\t\tPolkadotXcm: pallet_xcm::{Pallet, Call, Event\u003cT\u003e, Origin, Config} = 41,\n\t\tCumulusXcm: cumulus_pallet_xcm::{Pallet, Event\u003cT\u003e, Origin} = 42,\n\t\tDmpQueue: cumulus_pallet_dmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 43,\n\n\t\t// Amendments\n\t\tVesting: pallet_vesting::{Pallet, Call, Storage, Event\u003cT\u003e} = 50,\n\t\tUtility: pallet_utility::{Pallet, Call, Event} = 51,\n\t\tCurrencies: orml_currencies::{Pallet, Call, Storage} = 52,\n\t\tTokens: orml_tokens::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 53,\n\t\tXTokens: orml_xtokens::{Pallet, Storage, Call, Event\u003cT\u003e} = 54,\n\t\tIdentity: pallet_identity::{Pallet, Storage, Call, Event\u003cT\u003e} = 55,\n\t\tContracts: pallet_contracts::{Pallet, Storage, Call, Event\u003cT\u003e} = 56,\n\t\tRandomnessCollectiveFlip: pallet_insecure_randomness_collective_flip::{Pallet, Storage} = 57,\n\t\tDiaOracleModule: dia_oracle::{Pallet, Storage, Call, Config\u003cT\u003e, Event\u003cT\u003e} = 58,\n\n\t\tZenlinkProtocol: zenlink_protocol::{Pallet, Call, Storage, Event\u003cT\u003e}  = 59,\n\n\t\t// Spacewalk pallets\n\t\tCurrency: currency::{Pallet} = 60,\n\t\tFee: fee::{Pallet, Call, Config\u003cT\u003e, Storage} = 61,\n\t\tIssue: issue::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 62,\n\t\tNomination: nomination::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 63,\n\t\tOracle: oracle::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 64,\n\t\tRedeem: redeem::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 65,\n\t\tReplace: replace::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 66,\n\t\tSecurity: security::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 67,\n\t\tStellarRelay: stellar_relay::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 68,\n\t\tVaultRegistry: vault_registry::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e, ValidateUnsigned} = 69,\n\t\tVaultRewards: reward::{Pallet, Call, Storage, Event\u003cT\u003e} = 70,\n\t\tVaultStaking: staking::{Pallet, Storage, Event\u003cT\u003e} = 71,\n\n\t\tFarming: farming::{Pallet, Call, Storage, Event\u003cT\u003e} = 90,\n\n\t\t// Asset Metadata\n\t\tAssetRegistry: orml_asset_registry::{Pallet, Storage, Call, Event\u003cT\u003e, Config\u003cT\u003e} = 91,\n\n\t\tVestingManager: vesting_manager::{Pallet, Call, Event\u003cT\u003e} = 100\n\t}\n);\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!(\n\t\t[frame_benchmarking, BaselineBench::\u003cRuntime\u003e]\n\t\t[frame_system, SystemBench::\u003cRuntime\u003e]\n\t\t[pallet_balances, Balances]\n\t\t[pallet_session, SessionBench::\u003cRuntime\u003e]\n\t\t[pallet_timestamp, Timestamp]\n\t\t[cumulus_pallet_xcmp_queue, XcmpQueue]\n\n\t\t[fee, Fee]\n\t\t[issue, Issue]\n\t\t[nomination, Nomination]\n\t\t[oracle, Oracle]\n\t\t[redeem, Redeem]\n\t\t[replace, Replace]\n\t\t[stellar_relay, StellarRelay]\n\t\t[vault_registry, VaultRegistry]\n\n\t\t// Other\n\t\t[orml_asset_registry, runtime_common::benchmarking::orml_asset_registry::Pallet::\u003cRuntime\u003e]\n\t\t[pallet_xcm, PolkadotXcm]\n\t);\n}\n\nimpl_runtime_apis! {\n\timpl sp_consensus_aura::AuraApi\u003cBlock, AuraId\u003e for Runtime {\n\t\tfn slot_duration() -\u003e sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -\u003e Vec\u003cAuraId\u003e {\n\t\t\tAura::authorities().into_inner()\n\t\t}\n\t}\n\n\timpl sp_api::Core\u003cBlock\u003e for Runtime {\n\t\tfn version() -\u003e RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata\u003cBlock\u003e for Runtime {\n\t\tfn metadata() -\u003e OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder\u003cBlock\u003e for Runtime {\n\t\tfn apply_extrinsic(extrinsic: \u003cBlock as BlockT\u003e::Extrinsic) -\u003e ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -\u003e \u003cBlock as BlockT\u003e::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -\u003e Vec\u003c\u003cBlock as BlockT\u003e::Extrinsic\u003e {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(\u0026block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tblock_hash: \u003cBlock as BlockT\u003e::Hash,\n\t\t) -\u003e TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi\u003cBlock\u003e for Runtime {\n\t\tfn offchain_worker(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys\u003cBlock\u003e for Runtime {\n\t\tfn generate_session_keys(seed: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n\t\t\tSessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec\u003cu8\u003e,\n\t\t) -\u003e Option\u003cVec\u003c(Vec\u003cu8\u003e, KeyTypeId)\u003e\u003e {\n\t\t\tSessionKeys::decode_into_raw_public_keys(\u0026encoded)\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi\u003cBlock, AccountId, Index\u003e for Runtime {\n\t\tfn account_nonce(account: AccountId) -\u003e Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi\u003cBlock, Balance\u003e for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t\tfn query_fee_details(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment::FeeDetails\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t\tfn query_weight_to_fee(weight: Weight) -\u003e Balance {\n\t\t\tTransactionPayment::weight_to_fee(weight)\n\t\t}\n\t\tfn query_length_to_fee(length: u32) -\u003e Balance {\n\t\t\tTransactionPayment::length_to_fee(length)\n\t\t}\n\t}\n\n\timpl cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e for Runtime {\n\t\tfn collect_collation_info(header: \u0026\u003cBlock as BlockT\u003e::Header) -\u003e cumulus_primitives_core::CollationInfo {\n\t\t\tParachainSystem::collect_collation_info(header)\n\t\t}\n\t}\n\n\timpl parachain_staking::runtime_api::ParachainStakingApi\u003cBlock, AccountId, Balance\u003e for Runtime {\n\t\tfn get_unclaimed_staking_rewards(account: \u0026AccountId) -\u003e Balance {\n\t\t\tParachainStaking::get_unclaimed_staking_rewards(account)\n\t\t}\n\n\t\tfn get_staking_rates() -\u003e parachain_staking::runtime_api::StakingRates {\n\t\t\tParachainStaking::get_staking_rates()\n\t\t}\n\t}\n\n\timpl dia_oracle_runtime_api::DiaOracleApi\u003cBlock\u003e for Runtime{\n\t\tfn get_value(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::PriceInfo, sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_value(blockchain, symbol)\n\t\t}\n\n\t\tfn get_coin_info(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::CoinInfo,sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_coin_info(blockchain, symbol)\n\t\t}\n\t}\n\n\t// zenlink runtime outer apis\n\timpl zenlink_protocol_runtime_api::ZenlinkProtocolApi\u003cBlock, AccountId, ZenlinkAssetId\u003e for Runtime {\n\n\t\tfn get_balance(\n\t\t\tasset_id: ZenlinkAssetId,\n\t\t\towner: AccountId\n\t\t) -\u003e AssetBalance {\n\t\t\t\u003cRuntime as zenlink_protocol::Config\u003e::MultiAssetsHandler::balance_of(asset_id, \u0026owner)\n\t\t}\n\n\t\tfn get_pair_by_asset_id(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId\n\t\t) -\u003e Option\u003cPairInfo\u003cAccountId, AssetBalance, ZenlinkAssetId\u003e\u003e {\n\t\t\tZenlinkProtocol::get_pair_by_asset_id(asset_0, asset_1)\n\t\t}\n\n\t\tfn get_amount_in_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::desired_in_amount(supply, path)\n\t\t}\n\n\t\tfn get_amount_out_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::supply_out_amount(supply, path)\n\t\t}\n\n\t\tfn get_estimate_lptoken(\n\t\t\ttoken_0: ZenlinkAssetId,\n\t\t\ttoken_1: ZenlinkAssetId,\n\t\t\tamount_0_desired: AssetBalance,\n\t\t\tamount_1_desired: AssetBalance,\n\t\t\tamount_0_min: AssetBalance,\n\t\t\tamount_1_min: AssetBalance,\n\t\t) -\u003e AssetBalance{\n\t\t\tZenlinkProtocol::get_estimate_lptoken(\n\t\t\t\ttoken_0,\n\t\t\t\ttoken_1,\n\t\t\t\tamount_0_desired,\n\t\t\t\tamount_1_desired,\n\t\t\t\tamount_0_min,\n\t\t\t\tamount_1_min\n\t\t\t)\n\t\t}\n\n\t\tfn calculate_remove_liquidity(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId,\n\t\t\tamount: AssetBalance,\n\t\t) -\u003e Option\u003c(AssetBalance, AssetBalance)\u003e{\n\t\t\tZenlinkProtocol::calculate_remove_liquidity(\n\t\t\t\tasset_0,\n\t\t\t\tasset_1,\n\t\t\t\tamount,\n\t\t\t)\n\t\t}\n\t}\n\n\timpl farming_rpc_runtime_api::FarmingRuntimeApi\u003cBlock, AccountId, PoolId, CurrencyId\u003e for Runtime {\n\t\tfn get_farming_rewards(who: AccountId, pid: PoolId) -\u003e Vec\u003c(CurrencyId, Balance)\u003e {\n\t\t\tFarming::get_farming_rewards(\u0026who, pid).unwrap_or(Vec::new())\n\t\t}\n\n\t\tfn get_gauge_rewards(who: AccountId, pid: PoolId) -\u003e Vec\u003c(CurrencyId, Balance)\u003e {\n\t\t\tFarming::get_gauge_rewards(\u0026who, pid).unwrap_or(Vec::new())\n\t\t}\n\t}\n\n\n\t#[cfg(feature = \"try-runtime\")]\n\timpl frame_try_runtime::TryRuntime\u003cBlock\u003e for Runtime {\n\t\tfn on_runtime_upgrade() -\u003e (Weight, Weight) {\n\t\t\tlog::info!(\"try-runtime::on_runtime_upgrade amplitude.\");\n\t\t\tlet weight = Executive::try_runtime_upgrade().unwrap();\n\t\t\t(weight, RuntimeBlockWeights::get().max_block)\n\t\t}\n\n\t\tfn execute_block_no_check(block: Block) -\u003e Weight {\n\t\t\tExecutive::execute_block_no_check(block)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark\u003cBlock\u003e for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -\u003e (\n\t\t\tVec\u003cframe_benchmarking::BenchmarkList\u003e,\n\t\t\tVec\u003cframe_support::traits::StorageInfo\u003e,\n\t\t) {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\tlet mut list = Vec::\u003cBenchmarkList\u003e::new();\n\t\t\tlist_benchmarks!(list, extra);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -\u003e Result\u003cVec\u003cframe_benchmarking::BenchmarkBatch\u003e, sp_runtime::RuntimeString\u003e {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, TrackedStorageKey};\n\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\t\t\timpl baseline::Config for Runtime {}\n\t\t\timpl runtime_common::benchmarking::orml_asset_registry::Config for Runtime {}\n\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\timpl cumulus_pallet_session_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec\u003cTrackedStorageKey\u003e = vec![\n\t\t\t\t// Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t// Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t// Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t// Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t// System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::\u003cBenchmarkBatch\u003e::new();\n\t\t\tlet params = (\u0026config, \u0026whitelist);\n\t\t\tadd_benchmarks!(params, batches);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n\n\timpl module_issue_rpc_runtime_api::IssueApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tIssueRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_issue_requests(account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tIssue::get_issue_requests_for_account(account_id)\n\t\t}\n\t\tfn get_vault_issue_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tIssue::get_issue_requests_for_vault(vault_id)\n\t\t}\n\t}\n\timpl module_vault_registry_rpc_runtime_api::VaultRegistryApi\u003c\n\t\tBlock,\n\t\tVaultId,\n\t\tBalance,\n\t\tUnsignedFixedPoint,\n\t\tCurrencyId,\n\t\tAccountId,\n\t\u003e for Runtime {\n\t\tfn get_vault_collateral(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::compute_collateral(\u0026vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t\tfn get_vaults_by_account_id(account_id: AccountId) -\u003e Result\u003cVec\u003cVaultId\u003e, DispatchError\u003e {\n\t\t\tVaultRegistry::get_vaults_by_account_id(account_id)\n\t\t}\n\t\tfn get_vault_total_collateral(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_backing_collateral(\u0026vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t\tfn get_premium_redeem_vaults() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_premium_redeem_vaults()?;\n\t\t\tOk(result.iter().map(|v| (v.0.clone(), BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\t\tfn get_vaults_with_issuable_tokens() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_vaults_with_issuable_tokens()?;\n\t\t\tOk(result.into_iter().map(|v| (v.0, BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\t\tfn get_vaults_with_redeemable_tokens() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_vaults_with_redeemable_tokens()?;\n\t\t\tOk(result.into_iter().map(|v| (v.0, BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\t\tfn get_issuable_tokens_from_vault(vault: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_issuable_tokens_from_vault(\u0026vault)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t\tfn get_collateralization_from_vault(vault: VaultId, only_issued: bool) -\u003e Result\u003cUnsignedFixedPoint, DispatchError\u003e {\n\t\t\tVaultRegistry::get_collateralization_from_vault(vault, only_issued)\n\t\t}\n\t\tfn get_collateralization_from_vault_and_collateral(vault: VaultId, collateral: BalanceWrapper\u003cBalance\u003e, only_issued: bool) -\u003e Result\u003cUnsignedFixedPoint, DispatchError\u003e {\n\t\t\tlet amount = currency::Amount::new(collateral.amount, vault.collateral_currency());\n\t\t\tVaultRegistry::get_collateralization_from_vault_and_collateral(vault, \u0026amount, only_issued)\n\t\t}\n\t\tfn get_required_collateral_for_wrapped(amount_wrapped: BalanceWrapper\u003cBalance\u003e, wrapped_currency_id: CurrencyId, collateral_currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet amount_wrapped = currency::Amount::new(amount_wrapped.amount, wrapped_currency_id);\n\t\t\tlet result = VaultRegistry::get_required_collateral_for_wrapped(\u0026amount_wrapped, collateral_currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t\tfn get_required_collateral_for_vault(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_required_collateral_for_vault(vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t}\n\timpl module_redeem_rpc_runtime_api::RedeemApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tRedeemRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_redeem_requests(account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tRedeem::get_redeem_requests_for_account(account_id)\n\t\t}\n\t\tfn get_vault_redeem_requests(vault_account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tRedeem::get_redeem_requests_for_vault(vault_account_id)\n\t\t}\n\t}\n\timpl module_replace_rpc_runtime_api::ReplaceApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tReplaceRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_old_vault_replace_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tReplace::get_replace_requests_for_old_vault(vault_id)\n\t\t}\n\t\tfn get_new_vault_replace_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tReplace::get_replace_requests_for_new_vault(vault_id)\n\t\t}\n\t}\n\n\timpl pallet_contracts::ContractsApi\u003cBlock, AccountId, Balance, BlockNumber, Hash\u003e\n\t\tfor Runtime\n\t{\n\t\tfn call(\n\t\t\torigin: AccountId,\n\t\t\tdest: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tinput_data: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractExecResult\u003cBalance\u003e {\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_call(\n\t\t\t\torigin,\n\t\t\t\tdest,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tinput_data,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT,\n\t\t\t\tpallet_contracts::Determinism::Deterministic,\n\t\t\t)\n\t\t}\n\n\t\tfn instantiate(\n\t\t\torigin: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tcode: pallet_contracts_primitives::Code\u003cHash\u003e,\n\t\t\tdata: Vec\u003cu8\u003e,\n\t\t\tsalt: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractInstantiateResult\u003cAccountId, Balance\u003e\n\t\t{\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_instantiate(\n\t\t\t\torigin,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tcode,\n\t\t\t\tdata,\n\t\t\t\tsalt,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT\n\t\t\t)\n\t\t}\n\n\t\tfn upload_code(\n\t\t\torigin: AccountId,\n\t\t\tcode: Vec\u003cu8\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tdeterminism: pallet_contracts::Determinism,\n\t\t) -\u003e pallet_contracts_primitives::CodeUploadResult\u003cHash, Balance\u003e\n\t\t{\n\t\t\tContracts::bare_upload_code(origin, code, storage_deposit_limit, determinism)\n\t\t}\n\n\t\tfn get_storage(\n\t\t\taddress: AccountId,\n\t\t\tkey: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::GetStorageResult {\n\t\t\tContracts::get_storage(address, key)\n\t\t}\n\t}\n\n\timpl module_oracle_rpc_runtime_api::OracleApi\u003cBlock, Balance, CurrencyId\u003e for Runtime {\n\t\tfn currency_to_usd(amount:BalanceWrapper\u003cBalance\u003e, currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = Oracle::currency_to_usd(amount.amount, currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result})\n\t\t}\n\n\t\tfn usd_to_currency(amount:BalanceWrapper\u003cBalance\u003e, currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = Oracle::usd_to_currency(amount.amount, currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result})\n\t\t}\n\t}\n\n}\n\nstruct CheckInherents;\n\nimpl cumulus_pallet_parachain_system::CheckInherents\u003cBlock\u003e for CheckInherents {\n\tfn check_inherents(\n\t\tblock: \u0026Block,\n\t\trelay_state_proof: \u0026cumulus_pallet_parachain_system::RelayChainStateProof,\n\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\tlet relay_chain_slot = relay_state_proof\n\t\t\t.read_slot()\n\t\t\t.expect(\"Could not read the relay chain slot from the proof\");\n\n\t\tlet inherent_data =\n\t\t\tcumulus_primitives_timestamp::InherentDataProvider::from_relay_chain_slot_and_duration(\n\t\t\t\trelay_chain_slot,\n\t\t\t\tsp_std::time::Duration::from_secs(6),\n\t\t\t)\n\t\t\t.create_inherent_data()\n\t\t\t.expect(\"Could not create the timestamp inherent data\");\n\n\t\tinherent_data.check_extrinsics(block)\n\t}\n}\n\ncumulus_pallet_parachain_system::register_validate_block! {\n\tRuntime = Runtime,\n\tBlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::\u003cRuntime, Executive\u003e,\n\tCheckInherents = CheckInherents,\n}\n","traces":[{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1032,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1037,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":26},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","block_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Importing a block with 0 Extrinsics.\n\t\tpub const BlockExecutionWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::BlockExecutionWeight::get();\n\n\t\t\t// At least 100 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 100u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 100 µs.\"\n\t\t\t);\n\t\t\t// At most 50 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= 50u64 * constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 50 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","extrinsic_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Executing a NO-OP `System::remarks` Extrinsic.\n\t\tpub const ExtrinsicBaseWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::ExtrinsicBaseWeight::get();\n\n\t\t\t// At least 10 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 10u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 10 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","mod.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Expose the auto generated weight files.\n\npub mod block_weights;\npub mod extrinsic_weights;\npub mod orml_asset_registry;\npub mod pallet_xcm;\npub mod paritydb_weights;\npub mod rocksdb_weights;\n\npub use block_weights::constants::BlockExecutionWeight;\npub use extrinsic_weights::constants::ExtrinsicBaseWeight;\npub use paritydb_weights::constants::ParityDbWeight;\npub use rocksdb_weights::constants::RocksDbWeight;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","orml_asset_registry.rs"],"content":"\n//! Autogenerated weights for `orml_asset_registry`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-07-25, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Marcels-MBP`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"amplitude\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// amplitude\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet\n// orml-asset-registry\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// runtime/amplitude/src/weights/orml_asset_registry.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `orml_asset_registry`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e orml_asset_registry::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn register_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `104`\n\t\t//  Estimated: `7138`\n\t\t// Minimum execution time: 18_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 7138))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:2)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn update_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `745`\n\t\t//  Estimated: `8420`\n\t\t// Minimum execution time: 25_000_000 picoseconds.\n\t\tWeight::from_parts(26_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8420))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\tfn set_asset_location() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 0_000 picoseconds.\n\t\tWeight::from_parts(0, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","pallet_xcm.rs"],"content":"\n//! Autogenerated weights for `pallet_xcm`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-06-20, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Bs-MacBook-Pro.local`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"amplitude\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// amplitude\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet=pallet-xcm\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// pallet_xcm.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `pallet_xcm`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e pallet_xcm::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn send() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `212`\n\t\t//  Estimated: `10465`\n\t\t// Minimum execution time: 26_000_000 picoseconds.\n\t\tWeight::from_parts(27_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 10465))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: Benchmark Override (r:0 w:0)\n\t/// Proof Skipped: Benchmark Override (max_values: None, max_size: None, mode: Measured)\n\tfn teleport_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 18_446_744_073_709_551_000 picoseconds.\n\t\tWeight::from_parts(18_446_744_073_709_551_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: ParachainInfo ParachainId (r:1 w:0)\n\t/// Proof: ParachainInfo ParachainId (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn reserve_transfer_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 1489))\n\t\t\t.saturating_add(T::DbWeight::get().reads(1))\n\t}\n\tfn execute() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn force_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\tfn force_default_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 2_000_000 picoseconds.\n\t\tWeight::from_parts(3_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm QueryCounter (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm QueryCounter (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_subscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `212`\n\t\t//  Estimated: `16051`\n\t\t// Minimum execution time: 30_000_000 picoseconds.\n\t\tWeight::from_parts(31_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 16051))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_unsubscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `395`\n\t\t//  Estimated: `15635`\n\t\t// Minimum execution time: 31_000_000 picoseconds.\n\t\tWeight::from_parts(31_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 15635))\n\t\t\t.saturating_add(T::DbWeight::get().reads(6))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_supported_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `196`\n\t\t//  Estimated: `11086`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(17_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11086))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notifiers() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `200`\n\t\t//  Estimated: `11090`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11090))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:5 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn already_notified_target() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `207`\n\t\t//  Estimated: `13572`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 13572))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:2 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn notify_current_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `279`\n\t\t//  Estimated: `17019`\n\t\t// Minimum execution time: 29_000_000 picoseconds.\n\t\tWeight::from_parts(29_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 17019))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:3 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn notify_target_migration_fail() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `239`\n\t\t//  Estimated: `8654`\n\t\t// Minimum execution time: 10_000_000 picoseconds.\n\t\tWeight::from_parts(11_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8654))\n\t\t\t.saturating_add(T::DbWeight::get().reads(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notify_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `207`\n\t\t//  Estimated: `11097`\n\t\t// Minimum execution time: 18_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11097))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn migrate_and_notify_old_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `283`\n\t\t//  Estimated: `21993`\n\t\t// Minimum execution time: 37_000_000 picoseconds.\n\t\tWeight::from_parts(37_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 21993))\n\t\t\t.saturating_add(T::DbWeight::get().reads(9))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","paritydb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights\n\t\t/// are available for brave runtime engineers who may want to try this out as default.\n\t\tpub const ParityDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::ParityDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","weights","rocksdb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// By default, Substrate uses `RocksDB`, so this will be the weight used throughout\n\t\t/// the runtime.\n\t\tpub const RocksDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::RocksDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","xcm_config.rs"],"content":"use super::{\n\tAccountId, Balance, Balances, CurrencyId, ParachainInfo, ParachainSystem, PolkadotXcm, Runtime,\n\tRuntimeCall, RuntimeEvent, RuntimeOrigin, Tokens, WeightToFee, XcmpQueue,\n};\nuse crate::ConstU32;\nuse core::marker::PhantomData;\nuse frame_support::{\n\tlog, match_types, parameter_types,\n\ttraits::{ContainsPair, Everything, Nothing},\n};\nuse orml_traits::{\n\tlocation::{RelativeReserveProvider, Reserve},\n\tparameter_type_with_key,\n};\nuse pallet_xcm::XcmPassthrough;\nuse polkadot_parachain::primitives::Sibling;\nuse polkadot_runtime_common::impls::ToAuthor;\nuse sp_runtime::traits::Convert;\nuse xcm::latest::{prelude::*, Weight as XCMWeight};\nuse xcm_builder::{\n\tAccountId32Aliases, AllowUnpaidExecutionFrom, ConvertedConcreteId, EnsureXcmOrigin,\n\tFixedWeightBounds, FungiblesAdapter, NoChecking, ParentIsPreset, RelayChainAsNative,\n\tSiblingParachainAsNative, SiblingParachainConvertsVia, SignedAccountId32AsNative,\n\tSignedToAccountId32, SovereignSignedViaLocation, UsingComponents,\n};\nuse xcm_executor::{\n\ttraits::{JustTry, ShouldExecute},\n\tXcmExecutor,\n};\nuse runtime_common::parachains::kusama::asset_hub;\n\nconst XCM_ASSET_RELAY_KSM: u8 = 0;\nconst XCM_ASSET_ASSETHUB_USDT: u8 = 1;\n\nparameter_types! {\n\tpub const RelayLocation: MultiLocation = MultiLocation::parent();\n\tpub const RelayNetwork: NetworkId = NetworkId::Kusama;\n\tpub RelayChainOrigin: RuntimeOrigin = cumulus_pallet_xcm::Origin::Relay.into();\n\tpub CheckingAccount: AccountId = PolkadotXcm::check_account();\n\tpub UniversalLocation: InteriorMultiLocation =\n\t\tX2(GlobalConsensus(RelayNetwork::get()), Parachain(ParachainInfo::parachain_id().into()));\n\n}\n\n/// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used\n/// when determining ownership of accounts for asset transacting and when attempting to use XCM\n/// `Transact` in order to determine the dispatch Origin.\npub type LocationToAccountId = (\n\t// The parent (Relay-chain) origin converts to the parent `AccountId`.\n\tParentIsPreset\u003cAccountId\u003e,\n\t// Sibling parachain origins convert to AccountId via the `ParaId::into`.\n\tSiblingParachainConvertsVia\u003cSibling, AccountId\u003e,\n\t// Straight up local `AccountId32` origins just alias directly to `AccountId`.\n\tAccountId32Aliases\u003cRelayNetwork, AccountId\u003e,\n);\n\n/// CurrencyIdConvert\n/// This type implements conversions from our `CurrencyId` type into `MultiLocation` and vice-versa.\n/// A currency locally is identified with a `CurrencyId` variant but in the network it is identified\n/// in the form of a `MultiLocation`, in this case a pCfg (Para-Id, Currency-Id).\npub struct CurrencyIdConvert;\n\nimpl Convert\u003cCurrencyId, Option\u003cMultiLocation\u003e\u003e for CurrencyIdConvert {\n\tfn convert(id: CurrencyId) -\u003e Option\u003cMultiLocation\u003e {\n\t\tmatch id {\n\t\t\tCurrencyId::XCM(index) =\u003e match index {\n\t\t\t\tXCM_ASSET_RELAY_KSM =\u003e Some(MultiLocation::parent()),\n\t\t\t\tXCM_ASSET_ASSETHUB_USDT =\u003e Some(MultiLocation::new(\n\t\t\t\t\t1,\n\t\t\t\t\tX3(\n\t\t\t\t\t\tParachain(asset_hub::PARA_ID),\n\t\t\t\t\t\tPalletInstance(asset_hub::ASSET_PALLET_ID),\n\t\t\t\t\t\tGeneralIndex(asset_hub::USDT_ASSET_ID),\n\t\t\t\t\t),\n\t\t\t\t)),\n\t\t\t\t_ =\u003e None,\n\t\t\t},\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Option\u003cCurrencyId\u003e {\n\t\tmatch location {\n\t\t\tMultiLocation { parents: 1, interior: Here } =\u003e Some(CurrencyId::XCM(XCM_ASSET_RELAY_KSM)),\n\t\t\tMultiLocation {\n\t\t\t\tparents: 1,\n\t\t\t\tinterior:\n\t\t\t\t\tX3(\n\t\t\t\t\t\tParachain(asset_hub::PARA_ID),\n\t\t\t\t\t\tPalletInstance(asset_hub::ASSET_PALLET_ID),\n\t\t\t\t\t\tGeneralIndex(asset_hub::USDT_ASSET_ID)\n\t\t\t\t\t)\n\t\t\t} =\u003e Some(CurrencyId::XCM(XCM_ASSET_ASSETHUB_USDT)),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiAsset, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(a: MultiAsset) -\u003e Option\u003cCurrencyId\u003e {\n\t\tif let MultiAsset { id: AssetId::Concrete(id), fun: _ } = a {\n\t\t\tSelf::convert(id)\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\n/// Convert an incoming `MultiLocation` into a `CurrencyId` if possible.\n/// Here we need to know the canonical representation of all the tokens we handle in order to\n/// correctly convert their `MultiLocation` representation into our internal `CurrencyId` type.\nimpl xcm_executor::traits::Convert\u003cMultiLocation, CurrencyId\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Result\u003cCurrencyId, MultiLocation\u003e {\n\t\t\u003cCurrencyIdConvert as Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e\u003e::convert(location.clone())\n\t\t\t.ok_or(location)\n\t}\n}\n\n/// A `FilterAssetLocation` implementation. Filters multi native assets whose\n/// reserve is same with `origin`.\npub struct MultiNativeAsset\u003cReserveProvider\u003e(PhantomData\u003cReserveProvider\u003e);\nimpl\u003cReserveProvider\u003e ContainsPair\u003cMultiAsset, MultiLocation\u003e for MultiNativeAsset\u003cReserveProvider\u003e\nwhere\n\tReserveProvider: Reserve,\n{\n\tfn contains(asset: \u0026MultiAsset, origin: \u0026MultiLocation) -\u003e bool {\n\t\tif let Some(ref reserve) = ReserveProvider::reserve(asset) {\n\t\t\tif reserve == origin {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tfalse\n\t}\n}\n\n/// Means for transacting the fungibles assets of ths parachain.\npub type FungiblesTransactor = FungiblesAdapter\u003c\n\t// Use this fungibles implementation\n\tTokens,\n\t// This means that this adapter should handle any token that `CurrencyIdConvert` can convert\n\t// to `CurrencyId`, the `CurrencyId` type of `Tokens`, the fungibles implementation it uses.\n\tConvertedConcreteId\u003cCurrencyId, Balance, CurrencyIdConvert, JustTry\u003e,\n\t// Convert an XCM MultiLocation into a local account id\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly)\n\tAccountId,\n\t// We dont allow teleports.\n\tNoChecking,\n\t// The account to use for tracking teleports.\n\tCheckingAccount,\n\u003e;\n\n/// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,\n/// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can\n/// biases the kind of local `Origin` it will become.\npub type XcmOriginToTransactDispatchOrigin = (\n\t// Sovereign account converter; this attempts to derive an `AccountId` from the origin location\n\t// using `LocationToAccountId` and then turn that into the usual `Signed` origin. Useful for\n\t// foreign chains who want to have a local sovereign account on this chain which they control.\n\tSovereignSignedViaLocation\u003cLocationToAccountId, RuntimeOrigin\u003e,\n\t// Native converter for Relay-chain (Parent) location; will converts to a `Relay` origin when\n\t// recognized.\n\tRelayChainAsNative\u003cRelayChainOrigin, RuntimeOrigin\u003e,\n\t// Native converter for sibling Parachains; will convert to a `SiblingPara` origin when\n\t// recognized.\n\tSiblingParachainAsNative\u003ccumulus_pallet_xcm::Origin, RuntimeOrigin\u003e,\n\t// Native signed account converter; this just converts an `AccountId32` origin into a normal\n\t// `Origin::Signed` origin of the same 32-byte value.\n\tSignedAccountId32AsNative\u003cRelayNetwork, RuntimeOrigin\u003e,\n\t// Xcm origins can be represented natively under the Xcm pallet's Xcm origin.\n\tXcmPassthrough\u003cRuntimeOrigin\u003e,\n);\n\nparameter_types! {\n\t// One XCM operation is 1_000_000_000 weight - almost certainly a conservative estimate.\n\tpub UnitWeightCost: XCMWeight = XCMWeight::from_parts(1_000_000_000,0);\n\tpub const MaxInstructions: u32 = 100;\n\tpub SelfLocation: MultiLocation = MultiLocation::new(1, X1(Parachain(ParachainInfo::parachain_id().into())));\n\tpub const BaseXcmWeight: XCMWeight = XCMWeight::from_parts(150_000_000,0);\n\tpub const MaxAssetsForTransfer: usize = 2;\n}\n\nmatch_types! {\n\tpub type ParentOrParentsExecutivePlurality: impl Contains\u003cMultiLocation\u003e = {\n\t\tMultiLocation { parents: 1, interior: Here } |\n\t\tMultiLocation { parents: 1, interior: X1(Plurality { id: BodyId::Executive, .. }) }\n\t};\n}\n\n//TODO: move DenyThenTry to polkadot's xcm module.\n/// Deny executing the xcm message if it matches any of the Deny filter regardless of anything else.\n/// If it passes the Deny, and matches one of the Allow cases then it is let through.\npub struct DenyThenTry\u003cDeny, Allow\u003e(PhantomData\u003cDeny\u003e, PhantomData\u003cAllow\u003e)\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute;\n\nimpl\u003cDeny, Allow\u003e ShouldExecute for DenyThenTry\u003cDeny, Allow\u003e\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute,\n{\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\tmax_weight: XCMWeight,\n\t\tweight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tDeny::should_execute(origin, instructions, max_weight, weight_credit)?;\n\t\tAllow::should_execute(origin, instructions, max_weight, weight_credit)\n\t}\n}\n\n// See issue #5233\npub struct DenyReserveTransferToRelayChain;\nimpl ShouldExecute for DenyReserveTransferToRelayChain {\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\t_max_weight: XCMWeight,\n\t\t_weight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tif instructions.iter().any(|inst| {\n\t\t\tmatches!(\n\t\t\t\tinst,\n\t\t\t\tInitiateReserveWithdraw {\n\t\t\t\t\treserve: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t..\n\t\t\t\t} | DepositReserveAsset { dest: MultiLocation { parents: 1, interior: Here }, .. } |\n\t\t\t\t\tTransferReserveAsset {\n\t\t\t\t\t\tdest: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t\t..\n\t\t\t\t\t}\n\t\t\t)\n\t\t}) {\n\t\t\treturn Err(()) // Deny\n\t\t}\n\n\t\t// allow reserve transfers to arrive from relay chain\n\t\tif matches!(origin, MultiLocation { parents: 1, interior: Here }) \u0026\u0026\n\t\t\tinstructions.iter().any(|inst| matches!(inst, ReserveAssetDeposited { .. }))\n\t\t{\n\t\t\tlog::warn!(\n\t\t\t\ttarget: \"xcm::barriers\",\n\t\t\t\t\"Unexpected ReserveAssetDeposited from the relay chain\",\n\t\t\t);\n\t\t}\n\t\t// Permit everything else\n\t\tOk(())\n\t}\n}\n\npub type Barrier = AllowUnpaidExecutionFrom\u003cEverything\u003e;\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n\ttype RuntimeCall = RuntimeCall;\n\ttype XcmSender = XcmRouter;\n\t// How to withdraw and deposit an asset.\n\ttype AssetTransactor = FungiblesTransactor;\n\ttype OriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype IsReserve = MultiNativeAsset\u003cRelativeReserveProvider\u003e;\n\t// Teleporting is disabled.\n\ttype IsTeleporter = ();\n\ttype UniversalLocation = UniversalLocation;\n\ttype Barrier = Barrier;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype Trader =\n\t\tUsingComponents\u003cWeightToFee, RelayLocation, AccountId, Balances, ToAuthor\u003cRuntime\u003e\u003e;\n\ttype ResponseHandler = PolkadotXcm;\n\ttype AssetTrap = PolkadotXcm;\n\ttype AssetLocker = ();\n\ttype AssetExchanger = ();\n\ttype AssetClaims = PolkadotXcm;\n\ttype SubscriptionService = PolkadotXcm;\n\ttype PalletInstancesInfo = crate::AllPalletsWithSystem;\n\ttype MaxAssetsIntoHolding = ConstU32\u003c8\u003e;\n\ttype FeeManager = ();\n\ttype MessageExporter = ();\n\ttype UniversalAliases = Nothing;\n\ttype CallDispatcher = RuntimeCall;\n\ttype SafeCallFilter = Everything;\n}\n\n/// No local origins on this chain are allowed to dispatch XCM sends/executions.\npub type LocalOriginToLocation = SignedToAccountId32\u003cRuntimeOrigin, AccountId, RelayNetwork\u003e;\n\n/// The means for routing XCM messages which are not for local execution into the right message\n/// queues.\npub type XcmRouter = (\n\t// Two routers - use UMP to communicate with the relay chain:\n\tcumulus_primitives_utility::ParentAsUmp\u003cParachainSystem, PolkadotXcm, ()\u003e,\n\t// ..and XCMP to communicate with the sibling chains.\n\tXcmpQueue,\n);\n\nimpl pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyMatcher = ();\n\ttype SendXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmRouter = XcmRouter;\n\ttype ExecuteXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmExecuteFilter = Everything;\n\t// ^ Disable dispatchable execute on the XCM pallet.\n\t// Needs to be `Everything` for local testing.\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype XcmTeleportFilter = Nothing;\n\ttype XcmReserveTransferFilter = Everything;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype UniversalLocation = UniversalLocation;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\n\tconst VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;\n\t// ^ Override for AdvertisedXcmVersion default\n\ttype AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;\n\ttype TrustedLockers = ();\n\ttype SovereignAccountOf = LocationToAccountId;\n\ttype MaxLockers = ConstU32\u003c8\u003e;\n\ttype WeightInfo = crate::weights::pallet_xcm::WeightInfo\u003cRuntime\u003e;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype ReachableDest = ReachableDest;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nparameter_types! {\n\tpub ReachableDest: Option\u003cMultiLocation\u003e = Some(Parent.into());\n}\n\nparameter_type_with_key! {\n\tpub ParachainMinFee: |_location: MultiLocation| -\u003e Option\u003cu128\u003e {\n\t\tNone\n\t};\n}\n\nimpl orml_xtokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype CurrencyId = CurrencyId;\n\ttype CurrencyIdConvert = CurrencyIdConvert;\n\ttype AccountIdToMultiLocation = AccountIdToMultiLocation;\n\ttype SelfLocation = SelfLocation;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype BaseXcmWeight = BaseXcmWeight;\n\ttype MaxAssetsForTransfer = MaxAssetsForTransfer;\n\ttype MinXcmFee = ParachainMinFee; //TODO to support hrmp transfer beetween parachain adjust this parameter\n\ttype MultiLocationsFilter = Everything;\n\ttype ReserveProvider = RelativeReserveProvider;\n\ttype UniversalLocation = UniversalLocation;\n}\n\npub struct AccountIdToMultiLocation;\nimpl Convert\u003cAccountId, MultiLocation\u003e for AccountIdToMultiLocation {\n\tfn convert(account: AccountId) -\u003e MultiLocation {\n\t\tMultiLocation {\n\t\t\tparents: 0,\n\t\t\tinterior: X1(AccountId32 { network: None, id: account.into() }),\n\t\t}\n\t}\n}\n\nimpl cumulus_pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n}\n","traces":[{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","marcel","Documents","pendulum","runtime","amplitude","src","zenlink.rs"],"content":"use core::convert::TryInto;\n\nuse super::*;\n\nuse orml_traits::MultiCurrency;\nuse sp_runtime::{DispatchError, DispatchResult};\nuse sp_std::marker::PhantomData;\n\nuse spacewalk_primitives::CurrencyId;\n\nuse zenlink_protocol::{\n\tAssetId, Config as ZenlinkConfig, GenerateLpAssetId, LocalAssetHandler, ZenlinkMultiAssets,\n};\npub type ZenlinkAssetId = zenlink_protocol::AssetId;\n\nuse runtime_common::{zenlink, zenlink::*};\n\npub struct ZenlinkLPGenerate\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: ZenlinkConfig\u003e GenerateLpAssetId\u003cZenlinkAssetId\u003e for ZenlinkLPGenerate\u003cT\u003e {\n\tfn generate_lp_asset_id(\n\t\tasset_0: ZenlinkAssetId,\n\t\tasset_1: ZenlinkAssetId,\n\t) -\u003e Option\u003cZenlinkAssetId\u003e {\n\t\tzenlink::generate_lp_asset_id(asset_0, asset_1, ParachainInfo::parachain_id().into())\n\t}\n}\n\nparameter_types! {\n\tpub SelfParaId: u32 = ParachainInfo::parachain_id().into();\n\tpub const ZenlinkPalletId: PalletId = PalletId(*b\"/zenlink\");\n\tpub ZenlinkRegisteredParaChains: Vec\u003c(MultiLocation, u128)\u003e = vec![];\n}\nimpl ZenlinkConfig for Runtime {\n\ttype RuntimeEvent = super::RuntimeEvent;\n\ttype MultiAssetsHandler = MultiAssets;\n\ttype PalletId = ZenlinkPalletId;\n\ttype AssetId = AssetId;\n\ttype LpGenerate = ZenlinkLPGenerate\u003cSelf\u003e;\n\ttype TargetChains = ZenlinkRegisteredParaChains;\n\ttype SelfParaId = SelfParaId;\n\ttype WeightInfo = ();\n}\n\ntype MultiAssets = ZenlinkMultiAssets\u003cZenlinkProtocol, Balances, LocalAssetAdaptor\u003cTokens\u003e\u003e;\n\npub struct LocalAssetAdaptor\u003cLocal\u003e(PhantomData\u003cLocal\u003e);\n\nimpl\u003cLocal, AccountId\u003e LocalAssetHandler\u003cAccountId\u003e for LocalAssetAdaptor\u003cLocal\u003e\nwhere\n\tLocal: MultiCurrency\u003cAccountId, CurrencyId = CurrencyId\u003e,\n{\n\tfn local_balance_of(asset_id: ZenlinkAssetId, who: \u0026AccountId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::free_balance(currency_id, \u0026who))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_total_supply(asset_id: ZenlinkAssetId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::total_issuance(currency_id))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_is_exists(asset_id: ZenlinkAssetId) -\u003e bool {\n\t\tmatch zenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into()) {\n\t\t\tOk(_) =\u003e true,\n\t\t\tErr(_) =\u003e false,\n\t\t}\n\t}\n\n\tfn local_transfer(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\ttarget: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e DispatchResult {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::transfer(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\t\u0026target,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local transfer\"))?,\n\t\t\t)\n\t\t} else {\n\t\t\tErr(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\t}\n\n\tfn local_deposit(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::deposit(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local deposit\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n\n\tfn local_withdraw(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::withdraw(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local withdraw\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":44},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","asset_registry.rs"],"content":"use crate::*;\nuse frame_support::traits::AsEnsureOriginWithArg;\nuse frame_system::EnsureRoot;\nuse orml_traits::asset_registry::{AssetMetadata, AssetProcessor};\nuse parity_scale_codec::{Decode, Encode, MaxEncodedLen};\nuse scale_info::TypeInfo;\nuse sp_runtime::DispatchError;\nuse spacewalk_primitives::CurrencyId;\n\npub use spacewalk_primitives::CustomMetadata;\n\n#[derive(\n\tClone, Copy, PartialOrd, Ord, PartialEq, Eq, Debug, Encode, Decode, TypeInfo, MaxEncodedLen,\n)]\npub struct CustomAssetProcessor;\n\nimpl AssetProcessor\u003cCurrencyId, AssetMetadata\u003cBalance, CustomMetadata\u003e\u003e for CustomAssetProcessor {\n\tfn pre_register(\n\t\tid: Option\u003cCurrencyId\u003e,\n\t\tmetadata: AssetMetadata\u003cBalance, CustomMetadata\u003e,\n\t) -\u003e Result\u003c(CurrencyId, AssetMetadata\u003cBalance, CustomMetadata\u003e), DispatchError\u003e {\n\t\tmatch id {\n\t\t\tSome(id) =\u003e Ok((id, metadata)),\n\t\t\tNone =\u003e Err(DispatchError::Other(\"asset-registry: AssetId is required\")),\n\t\t}\n\t}\n\n\tfn post_register(\n\t\t_id: CurrencyId,\n\t\t_asset_metadata: AssetMetadata\u003cBalance, CustomMetadata\u003e,\n\t) -\u003e Result\u003c(), DispatchError\u003e {\n\t\tOk(())\n\t}\n}\n\npub type AssetAuthority = AsEnsureOriginWithArg\u003cEnsureRoot\u003cAccountId\u003e\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","benchmarking","mod.rs"],"content":"pub mod orml_asset_registry;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","benchmarking","orml_asset_registry.rs"],"content":"use frame_benchmarking::v2::benchmarks;\nuse frame_support::assert_ok;\nuse frame_system::RawOrigin;\nuse orml_asset_registry::AssetMetadata;\nuse sp_std::{vec, vec::Vec};\nuse spacewalk_primitives::{CurrencyId, CustomMetadata};\nuse xcm::{\n\tlatest::MultiLocation,\n\topaque::lts::{Junction::*, Junctions::*},\n};\n\npub struct Pallet\u003cT: Config\u003e(orml_asset_registry::Pallet\u003cT\u003e);\npub trait Config:\n\torml_asset_registry::Config\u003cCustomMetadata = CustomMetadata, Balance = u128, AssetId = CurrencyId\u003e\n{\n}\n\n#[benchmarks]\npub mod benchmarks {\n\tuse super::{Config, Pallet, *};\n\tuse orml_asset_registry::Call;\n\n\tfn longest_vec() -\u003e Vec\u003cu8\u003e {\n\t\t// there is no fixed upperbound, but all actions are root-only so an assumed upperbound of 128 will do\n\t\tvec![b'a', 128]\n\t}\n\n\tfn longest_multilocation() -\u003e MultiLocation {\n\t\tlet key = GeneralKey { length: 32, data: [0; 32] };\n\t\tMultiLocation::new(1, X8(key, key, key, key, key, key, key, key))\n\t}\n\n\tfn get_asset_metadata() -\u003e AssetMetadata\u003cu128, CustomMetadata\u003e {\n\t\tAssetMetadata {\n\t\t\tdecimals: 12,\n\t\t\tname: longest_vec(),\n\t\t\tsymbol: longest_vec(),\n\t\t\texistential_deposit: 0,\n\t\t\tlocation: Some(longest_multilocation().into()),\n\t\t\tadditional: CustomMetadata,\n\t\t}\n\t}\n\n\t#[benchmark]\n\tfn register_asset() {\n\t\tlet metadata = get_asset_metadata();\n\n\t\t#[extrinsic_call]\n\t\tregister_asset(RawOrigin::Root, metadata, Some(CurrencyId::Native));\n\t}\n\n\t#[benchmark]\n\tfn update_asset() {\n\t\tlet metadata = get_asset_metadata();\n\n\t\tassert_ok!(orml_asset_registry::Pallet::\u003cT\u003e::register_asset(\n\t\t\tRawOrigin::Root.into(),\n\t\t\tmetadata,\n\t\t\tSome(CurrencyId::Native),\n\t\t));\n\n\t\t// update values, and make sure to change the actual values in case there is some optimization\n\t\t// somewhere in the codepath\n\t\tlet key = GeneralKey { length: 32, data: [1; 32] };\n\t\tlet location = MultiLocation::new(1, X8(key, key, key, key, key, key, key, key));\n\t\t#[extrinsic_call]\n\t\tupdate_asset(\n\t\t\tRawOrigin::Root,\n\t\t\tCurrencyId::Native,\n\t\t\tSome(123),\n\t\t\tSome(vec![b'b', 128]),\n\t\t\tSome(vec![b'b', 128]),\n\t\t\tSome(1234),\n\t\t\tSome(Some(location.into())),\n\t\t\tSome(CustomMetadata),\n\t\t);\n\t}\n\n\t#[benchmark]\n\tfn set_asset_location() {\n\t\t#[block]\n\t\t{\n\t\t\t// todo: remove this benchmark when this unused item is removed from the weight type upstream\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","chain_ext.rs"],"content":"use crate::*;\nuse dia_oracle::dia;\nuse scale_info::prelude::vec::Vec;\nuse sp_core::{Decode, Encode, MaxEncodedLen};\nuse sp_runtime::{codec, ArithmeticError, TokenError};\n\npub use spacewalk_primitives::{Asset, CurrencyId};\n\n/// Address is a type alias for easier readability of address (accountId) communicated between contract and chain extension.\npub type Address = [u8; 32];\n/// Amount is a type alias for easier readability of amount communicated between contract and chain extension.\npub type Amount = u128;\n/// Blockchain is a type alias for easier readability of dia blockchain name communicated between contract and chain extension.\npub type Blockchain = [u8; 32];\n/// Symbol is a type alias for easier readability of dia blockchain symbol communicated between contract and chain extension.\npub type Symbol = [u8; 32];\n\n/// ChainExtensionError is almost the same as DispatchError, but with some modifications to make it compatible with being communicated between contract and chain extension. It implements the necessary From\u003cT\u003e conversions with DispatchError and other nested errors.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Encode, Decode, MaxEncodedLen)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum ChainExtensionError {\n\t/// Some error occurred.\n\tOther,\n\t/// Failed to lookup some data.\n\tCannotLookup,\n\t/// A bad origin.\n\tBadOrigin,\n\t/// A custom error in a module.\n\tModule,\n\t/// At least one consumer is remaining so the account cannot be destroyed.\n\tConsumerRemaining,\n\t/// There are no providers so the account cannot be created.\n\tNoProviders,\n\t/// There are too many consumers so the account cannot be created.\n\tTooManyConsumers,\n\t/// An error to do with tokens.\n\tToken(ChainExtensionTokenError),\n\t/// An arithmetic error.\n\tArithmetic(ChainExtensionArithmeticError),\n\t/// Unknown error\n\tUnknown,\n}\n\n/// ChainExtensionTokenError is a nested error in ChainExtensionError, similar to DispatchError's TokenError.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Encode, Decode, MaxEncodedLen)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum ChainExtensionTokenError {\n\t/// Funds are unavailable.\n\tNoFunds,\n\t/// Account that must exist would die.\n\tWouldDie,\n\t/// Account cannot exist with the funds that would be given.\n\tBelowMinimum,\n\t/// Account cannot be created.\n\tCannotCreate,\n\t/// The asset in question is unknown.\n\tUnknownAsset,\n\t/// Funds exist but are frozen.\n\tFrozen,\n\t/// Operation is not supported by the asset.\n\tUnsupported,\n\t/// Unknown error\n\tUnknown,\n}\n\n/// ChainExtensionArithmeticError is a nested error in ChainExtensionError, similar to DispatchError's ArithmeticError.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Encode, Decode, MaxEncodedLen)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum ChainExtensionArithmeticError {\n\t/// Underflow.\n\tUnderflow,\n\t/// Overflow.\n\tOverflow,\n\t/// Division by zero.\n\tDivisionByZero,\n\t/// Unknown error\n\tUnknown,\n}\n\nimpl From\u003cDispatchError\u003e for ChainExtensionError {\n\tfn from(e: DispatchError) -\u003e Self {\n\t\tmatch e {\n\t\t\tDispatchError::Other(_) =\u003e ChainExtensionError::Other,\n\t\t\tDispatchError::CannotLookup =\u003e ChainExtensionError::CannotLookup,\n\t\t\tDispatchError::BadOrigin =\u003e ChainExtensionError::BadOrigin,\n\t\t\tDispatchError::Module(_) =\u003e ChainExtensionError::Module,\n\t\t\tDispatchError::ConsumerRemaining =\u003e ChainExtensionError::ConsumerRemaining,\n\t\t\tDispatchError::NoProviders =\u003e ChainExtensionError::NoProviders,\n\t\t\tDispatchError::TooManyConsumers =\u003e ChainExtensionError::TooManyConsumers,\n\t\t\tDispatchError::Token(token_err) =\u003e\n\t\t\t\tChainExtensionError::Token(ChainExtensionTokenError::from(token_err)),\n\t\t\tDispatchError::Arithmetic(arithmetic_error) =\u003e ChainExtensionError::Arithmetic(\n\t\t\t\tChainExtensionArithmeticError::from(arithmetic_error),\n\t\t\t),\n\t\t\t_ =\u003e ChainExtensionError::Unknown,\n\t\t}\n\t}\n}\n\nimpl From\u003cTokenError\u003e for ChainExtensionTokenError {\n\tfn from(e: TokenError) -\u003e Self {\n\t\tmatch e {\n\t\t\tTokenError::NoFunds =\u003e ChainExtensionTokenError::NoFunds,\n\t\t\tTokenError::WouldDie =\u003e ChainExtensionTokenError::WouldDie,\n\t\t\tTokenError::BelowMinimum =\u003e ChainExtensionTokenError::BelowMinimum,\n\t\t\tTokenError::CannotCreate =\u003e ChainExtensionTokenError::CannotCreate,\n\t\t\tTokenError::UnknownAsset =\u003e ChainExtensionTokenError::UnknownAsset,\n\t\t\tTokenError::Frozen =\u003e ChainExtensionTokenError::Frozen,\n\t\t\tTokenError::Unsupported =\u003e ChainExtensionTokenError::Unsupported,\n\t\t}\n\t}\n}\n\nimpl From\u003cArithmeticError\u003e for ChainExtensionArithmeticError {\n\tfn from(e: ArithmeticError) -\u003e Self {\n\t\tmatch e {\n\t\t\tArithmeticError::Underflow =\u003e ChainExtensionArithmeticError::Underflow,\n\t\t\tArithmeticError::Overflow =\u003e ChainExtensionArithmeticError::Overflow,\n\t\t\tArithmeticError::DivisionByZero =\u003e ChainExtensionArithmeticError::DivisionByZero,\n\t\t}\n\t}\n}\n\n/// ToTrimmedVec is a trait implemented for [u8; 32] to allow both types Blockchain and Symbol (which are [u8; 32]) to have the trim_trailing_zeros function.\npub trait ToTrimmedVec {\n\tfn to_trimmed_vec(\u0026self) -\u003e Vec\u003cu8\u003e;\n}\nimpl ToTrimmedVec for [u8; 32] {\n\tfn to_trimmed_vec(\u0026self) -\u003e Vec\u003cu8\u003e {\n\t\ttrim_trailing_zeros(self).to_vec()\n\t}\n}\n\n/// trim_trailing_zeros takes an input slice and returns it without the trailing zeros.\nfn trim_trailing_zeros(slice: \u0026[u8]) -\u003e \u0026[u8] {\n\tlet mut trim_amount = 0;\n\tfor el in slice.iter().rev() {\n\t\tif *el == 0 {\n\t\t\ttrim_amount += 1;\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\t\u0026slice[..slice.len() - trim_amount]\n}\n\n/// CoinInfo is almost the same as Dia's CoinInfo, but with Encode, Decode, and TypeInfo which are necessary for contract to chain extension communication. Implements From\u003cdia::CoinInfo\u003e to make conversion.\n#[derive(Debug, Clone, PartialEq, Eq, codec::Encode, codec::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct CoinInfo {\n\tpub symbol: Vec\u003cu8\u003e,\n\tpub name: Vec\u003cu8\u003e,\n\tpub blockchain: Vec\u003cu8\u003e,\n\tpub supply: u128,\n\tpub last_update_timestamp: u64,\n\tpub price: u128,\n}\nimpl From\u003cdia::CoinInfo\u003e for CoinInfo {\n\tfn from(coin_info: dia::CoinInfo) -\u003e Self {\n\t\tSelf {\n\t\t\tsymbol: coin_info.symbol,\n\t\t\tname: coin_info.name,\n\t\t\tblockchain: coin_info.blockchain,\n\t\t\tsupply: coin_info.supply,\n\t\t\tlast_update_timestamp: coin_info.last_update_timestamp,\n\t\t\tprice: coin_info.price,\n\t\t}\n\t}\n}\n\n\n/// decode gets the slice from a Vec\u003cu8\u003e to decode it into its scale encoded type.\npub fn decode\u003cT: Decode\u003e(input: Vec\u003cu8\u003e) -\u003e Result\u003cT, codec::Error\u003e {\n\tlet mut input = input.as_slice();\n\tT::decode(\u0026mut input)\n}\n","traces":[{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse sp_runtime::{\n\ttraits::{IdentifyAccount, Verify},\n\tDispatchError, MultiSignature,\n};\n\npub mod asset_registry;\npub mod chain_ext;\npub mod stellar;\npub mod zenlink;\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub mod benchmarking;\n\n/// Alias to 512-bit hash when used in the context of a transaction signature on the chain.\npub type Signature = MultiSignature;\n\n/// Some way of identifying an account on the chain. We intentionally make it equivalent\n/// to the public key of our transaction signing scheme.\npub type AccountId = \u003c\u003cSignature as Verify\u003e::Signer as IdentifyAccount\u003e::AccountId;\n\n/// Type for IDs of farming pools\npub type PoolId = u32;\n\npub use sp_consensus_aura::sr25519::AuthorityId as AuraId;\n\n/// Balance of an account.\npub type Balance = u128;\npub type Amount = i128;\n\npub type ReserveIdentifier = [u8; 8];\n\n// Unit = the base number of indivisible units for balances\npub const UNIT: Balance = 1_000_000_000_000;\npub const MILLIUNIT: Balance = 1_000_000_000;\npub const MICROUNIT: Balance = 1_000_000;\npub const NANOUNIT: Balance = 1_000;\n\n/// The existential deposit. Set to 1/10 of the Connected Relay Chain.\npub const EXISTENTIAL_DEPOSIT: Balance = MILLIUNIT;\n\n/// An index to a block.\npub type BlockNumber = u32;\n\n/// Index of a transaction in the chain.\npub type Index = u32;\n\n/// A hash of some data used by the chain.\npub type Hash = sp_core::H256;\n\n/// Opaque types. These are used by the CLI to instantiate machinery that don't need to know\n/// the specifics of the runtime. They can then be made to be agnostic over specific formats\n/// of data like extrinsics, allowing for them to continue syncing the network through upgrades\n/// to even the core data structures.\npub mod opaque {\n\tuse super::*;\n\tuse sp_runtime::{generic, traits::BlakeTwo256};\n\n\tpub use sp_runtime::OpaqueExtrinsic as UncheckedExtrinsic;\n\t/// Opaque block header type.\n\tpub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// Opaque block type.\n\tpub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\t/// Opaque block identifier type.\n\tpub type BlockId = generic::BlockId\u003cBlock\u003e;\n}\n\npub mod parachains {\n\tpub mod polkadot {\n\t\tpub mod asset_hub {\n\t\t\tpub const PARA_ID: u32 = 1000;\n\t\t\tpub const ASSET_PALLET_ID: u8 = 50;\n\n\t\t\tpub const USDC_ASSET_ID: u128 = 1337;\n\t\t\tpub const USDT_ASSET_ID: u128 = 1984;\n\t\t}\n\t}\n\n\tpub mod kusama {\n\t\tpub mod asset_hub {\n\t\t\tpub const PARA_ID: u32 = 1000;\n\t\t\tpub const ASSET_PALLET_ID: u8 = 50;\n\n\t\t\tpub const USDC_ASSET_ID: u128 = 1337;\n\t\t\tpub const USDT_ASSET_ID: u128 = 1984;\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","stellar.rs"],"content":"// GA5ZSEJYB37JRC5AVCIA5MOP4RHTM335X2KGX3IHOJAPP5RE34K4KZVN\npub const USDC_ISSUER: [u8; 32] = [\n\t59, 153, 17, 56, 14, 254, 152, 139, 160, 168, 144, 14, 177, 207, 228, 79, 54, 111, 125, 190,\n\t148, 107, 237, 7, 114, 64, 247, 246, 36, 223, 21, 197,\n];\n\n// GDVKY2GU2DRXWTBEYJJWSFXIGBZV6AZNBVVSUHEPZI54LIS6BA7DVVSP\npub const BRL_ISSUER: [u8; 32] = [\n\t234, 172, 104, 212, 208, 227, 123, 76, 36, 194, 83, 105, 22, 232, 48, 115, 95, 3, 45, 13, 107,\n\t42, 28, 143, 202, 59, 197, 162, 94, 8, 62, 58,\n];\n\n// GA2MSSZKJOU6RNL3EJKH3S5TB5CDYTFQFWRYFGUJVIN5I6AOIRTLUHTO \npub const TZS_ISSUER: [u8; 32] = [\n\t52, 201, 75, 42, 75, 169, 232, 181, 123, 34, 84, 125, 203, 179, 15, 68, 60, 76, 176, 45, 163,\n\t130, 154, 137, 170, 27, 212, 120, 14, 68, 102, 186,\n];\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","common","src","zenlink.rs"],"content":"use crate::stellar::{BRL_ISSUER, TZS_ISSUER, USDC_ISSUER};\nuse spacewalk_primitives::{Asset, CurrencyId};\n\nuse zenlink_protocol::{LOCAL, NATIVE};\npub type ZenlinkAssetId = zenlink_protocol::AssetId;\n\nfn discriminant(currency: \u0026CurrencyId) -\u003e u8 {\n\tmatch currency {\n\t\tCurrencyId::Native =\u003e 0,\n\t\tCurrencyId::XCM(_) =\u003e 1,\n\t\tCurrencyId::Stellar(_) =\u003e 2,\n\t\tCurrencyId::ZenlinkLPToken(_, _, _, _) =\u003e 3,\n\t}\n}\n\npub fn generate_lp_asset_id(\n\tasset_0: ZenlinkAssetId,\n\tasset_1: ZenlinkAssetId,\n\tparachain_id: u32,\n) -\u003e Option\u003cZenlinkAssetId\u003e {\n\tlet currency_0 = (asset_0.asset_index \u0026 0x0000_0000_0000_ffff) \u003c\u003c 16;\n\tlet currency_1 = (asset_1.asset_index \u0026 0x0000_0000_0000_ffff) \u003c\u003c 32;\n\tlet discr = 3u64 \u003c\u003c 8;\n\tlet index = currency_0 + currency_1 + discr;\n\tSome(ZenlinkAssetId { chain_id: parachain_id, asset_type: LOCAL, asset_index: index })\n}\n\npub fn zenlink_id_to_currency_id(\n\tasset_id: ZenlinkAssetId,\n\tparachain_id: u32,\n) -\u003e Result\u003cCurrencyId, ()\u003e {\n\tif asset_id.chain_id != parachain_id {\n\t\treturn Err(())\n\t}\n\n\tlet index = asset_id.asset_index;\n\tlet asset_type = asset_id.asset_type;\n\tlet disc = ((index \u0026 0x0000_0000_0000_ff00) \u003e\u003e 8) as u8;\n\tlet symbol = (index \u0026 0x0000_0000_0000_00ff) as u8;\n\tmatch (disc, asset_type) {\n\t\t(0, NATIVE) =\u003e Ok(CurrencyId::Native),\n\t\t(1, LOCAL) =\u003e Ok(CurrencyId::XCM(symbol)),\n\t\t(2, LOCAL) =\u003e match symbol {\n\t\t\t0 =\u003e Ok(CurrencyId::Stellar(Asset::StellarNative)),\n\t\t\t1 =\u003e Ok(CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"USDC\", issuer: USDC_ISSUER })),\n\t\t\t2 =\u003e Ok(CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"TZS\\0\", issuer: TZS_ISSUER })),\n\t\t\t3 =\u003e Ok(CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"BRL\\0\", issuer: BRL_ISSUER })),\n\t\t\t_ =\u003e return Err(()),\n\t\t},\n\t\t(3, LOCAL) =\u003e {\n\t\t\tlet token1_id = ((index \u0026 0x0000_0000_00FF_0000) \u003e\u003e 16) as u8;\n\t\t\tlet token1_type = ((index \u0026 0x0000_0000_FF00_0000) \u003e\u003e 24) as u8;\n\n\t\t\tlet token2_id = ((index \u0026 0x0000_00FF_0000_0000) \u003e\u003e 32) as u8;\n\t\t\tlet token2_type = ((index \u0026 0x0000_FF00_0000_0000) \u003e\u003e 40) as u8;\n\n\t\t\tOk(CurrencyId::ZenlinkLPToken(token1_id, token1_type, token2_id, token2_type))\n\t\t},\n\t\t_ =\u003e Err(()),\n\t}\n}\n\npub fn currency_id_to_zenlink_id(\n\tcurrency_id: CurrencyId,\n\tparachain_id: u32,\n) -\u003e Result\u003cZenlinkAssetId, ()\u003e {\n\tlet disc = discriminant(\u0026currency_id) as u64;\n\tmatch currency_id {\n\t\tCurrencyId::Native =\u003e\n\t\t\tOk(ZenlinkAssetId { chain_id: parachain_id, asset_type: NATIVE, asset_index: 0 as u64 }),\n\t\tCurrencyId::XCM(token_id) =\u003e Ok(ZenlinkAssetId {\n\t\t\tchain_id: parachain_id,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: ((disc \u003c\u003c 8) + token_id as u64) as u64,\n\t\t}),\n\t\tCurrencyId::Stellar(asset) =\u003e {\n\t\t\tlet _id = match asset {\n\t\t\t\tAsset::StellarNative =\u003e 0u64,\n\t\t\t\tAsset::AlphaNum4 { code, issuer } =\u003e match (\u0026code, \u0026issuer) {\n\t\t\t\t\t(b\"USDC\", \u0026USDC_ISSUER) =\u003e 1u64,\n\t\t\t\t\t(b\"TZS\\0\", \u0026TZS_ISSUER) =\u003e 2u64,\n\t\t\t\t\t(b\"BRL\\0\", \u0026BRL_ISSUER) =\u003e 3u64,\n\t\t\t\t\t_ =\u003e return Err(()),\n\t\t\t\t},\n\t\t\t\t_ =\u003e return Err(()),\n\t\t\t};\n\t\t\tOk(ZenlinkAssetId {\n\t\t\t\tchain_id: parachain_id,\n\t\t\t\tasset_type: LOCAL,\n\t\t\t\tasset_index: ((disc \u003c\u003c 8) + _id) as u64,\n\t\t\t})\n\t\t},\n\t\tCurrencyId::ZenlinkLPToken(token1_id, token1_type, token2_id, token2_type) =\u003e {\n\t\t\tlet index = ((disc as u64) \u003c\u003c 8) +\n\t\t\t\t((token1_id as u64) \u003c\u003c 16) +\n\t\t\t\t((token1_type as u64) \u003c\u003c 24) +\n\t\t\t\t((token2_id as u64) \u003c\u003c 32) +\n\t\t\t\t((token2_type as u64) \u003c\u003c 40);\n\t\t\tOk(ZenlinkAssetId { chain_id: parachain_id, asset_type: LOCAL, asset_index: index })\n\t\t},\n\t}\n}\n\n#[cfg(test)]\nmod zenlink_tests {\n\tuse super::*;\n\n\t#[test]\n\tfn convert_zenlink_native_to_native_currency() {\n\t\t// Native ZenlinkAsset index = 0x0000_0000_0000_0000\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: NATIVE, asset_index: 0 as u64 };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(CurrencyId::Native));\n\t}\n\n\t#[test]\n\tfn convert_zenlink_xcm_to_xcm_currency() {\n\t\t// XCM(0) ZenlinkAsset index = 0x0000_0000_0000_0100\n\t\tlet index = 0x0100 as u64;\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: index };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(CurrencyId::XCM(0)));\n\t}\n\n\tfn get_stellar_asset(selector: u8) -\u003e spacewalk_primitives::CurrencyId {\n\t\tmatch selector {\n\t\t\t0 =\u003e CurrencyId::Stellar(Asset::StellarNative),\n\t\t\t1 =\u003e CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"USDC\", issuer: USDC_ISSUER }),\n\t\t\t2 =\u003e CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"TZS\\0\", issuer: TZS_ISSUER }),\n\t\t\t3 =\u003e CurrencyId::Stellar(Asset::AlphaNum4 { code: *b\"BRL\\0\", issuer: BRL_ISSUER }),\n\t\t\t_ =\u003e CurrencyId::Stellar(Asset::StellarNative),\n\t\t}\n\t}\n\n\t#[test]\n\tfn convert_zenlink_stellar_to_stellar_currency() {\n\t\t// Stellar Native ZenlinkAsset index = 0x0000_0000_0000_0200\n\t\tlet stellar_native_index = 0x0200 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: stellar_native_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(get_stellar_asset(0u8)));\n\n\t\t// Stellar USDC ZenlinkAsset index = 0x0000_0000_0000_0201\n\t\tlet usdc_index = 0x0201 as u64;\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: usdc_index };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(get_stellar_asset(1u8)));\n\n\t\t// Stellar TZS ZenlinkAsset index = 0x0000_0000_0000_0202\n\t\tlet tzs_index = 0x0202 as u64;\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: tzs_index };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(get_stellar_asset(2u8)));\n\n\t\t// Stellar BRL ZenlinkAsset index = 0x0000_0000_0000_0203\n\t\tlet brl_index = 0x0203 as u64;\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: brl_index };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Ok(get_stellar_asset(3u8)));\n\t}\n\n\t#[test]\n\tfn convert_zenlink_lp_token_to_lp_token_currency() {\n\t\t// Native and XCM(0) LP token Zenlink index = 0x0000_0100_0000_0300\n\t\tlet native_xcm_lp_token_index = 0x0000_0100_0000_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: native_xcm_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 0, 0, 1);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\n\t\t// XCM(0) and XCM(1) LP token Zenlink index = 0x0000_0101_0100_0300\n\t\tlet xcm0_xcm1_lp_token_index = 0x0000_0101_0100_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: xcm0_xcm1_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 1, 1, 1);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\n\t\t// XCM(0) and Stellar Native LP Token Zenlink index = 0x0000_0200_0100_0300\n\t\tlet xcm0_stellar_native_lp_token_index = 0x0000_0200_0100_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: xcm0_stellar_native_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 1, 0, 2);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\n\t\t// XCM(0) and Stellar USDC LP Token Zenlink index = 0x0000_0201_0100_0300\n\t\tlet xcm0_stellar_usdc_lp_token_index = 0x0000_0201_0100_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: xcm0_stellar_usdc_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 1, 1, 2);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\n\t\t// Stellar Native and Stellar USDC LP Token Zenlink index = 0x0000_0201_0200_0300\n\t\tlet stellar_native_stellar_usdc_lp_token_index = 0x0000_0201_0200_0300 as u64;\n\t\tlet fake_zenlink_asset = ZenlinkAssetId {\n\t\t\tchain_id: 1000u32,\n\t\t\tasset_type: LOCAL,\n\t\t\tasset_index: stellar_native_stellar_usdc_lp_token_index,\n\t\t};\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tlet expected_currency: CurrencyId = CurrencyId::ZenlinkLPToken(0, 2, 1, 2);\n\t\tassert_eq!(currency, Ok(expected_currency));\n\t}\n\n\t#[test]\n\tfn convert_fake_zenlink_native_to_currency_id_error() {\n\t\t// Native ZenlinkAsset index = 0x0000_0000_0000_0000\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: 0 as u64 };\n\t\tlet currency: Result\u003cCurrencyId, _\u003e =\n\t\t\tzenlink_id_to_currency_id(fake_zenlink_asset, 1000u32);\n\t\tassert_eq!(currency, Err(()));\n\t}\n\n\t#[test]\n\tfn convert_zenlink_id_to_currency_id_error() {\n\t\tlet fake_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: 0u64 };\n\t\t// We pass a parachain_id different than the asset chain_id\n\t\tassert_eq!(zenlink_id_to_currency_id(fake_zenlink_asset, 1001u32), Err(()));\n\t}\n\n\t#[test]\n\tfn convert_native_currency_to_zenlink_native() {\n\t\tlet fake_currency_id = CurrencyId::Native;\n\t\tlet expected_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: NATIVE, asset_index: 0u64 };\n\t\tassert_eq!(currency_id_to_zenlink_id(fake_currency_id, 1000), Ok(expected_zenlink_asset));\n\t}\n\n\t#[test]\n\tfn convert_xcm_currency_to_zenlink_xcm() {\n\t\tlet fake_currency_id = CurrencyId::XCM(0);\n\t\tlet expected_zenlink_asset =\n\t\t\tZenlinkAssetId { chain_id: 1000u32, asset_type: LOCAL, asset_index: 0x0100 as u64 };\n\t\tassert_eq!(currency_id_to_zenlink_id(fake_currency_id, 1000), Ok(expected_zenlink_asset));\n\t}\n\n\t#[test]\n\tfn convert_stellar_currency_to_stellar_zenlink() {\n\t\tlet stellar_assets_indexes: [u64; 4] = [0x0200u64, 0x0201u64, 0x0202u64, 0x0203u64];\n\n\t\tfor i in 0..=3usize {\n\t\t\tlet fake_currency_id = get_stellar_asset(i as u8);\n\t\t\tlet expected_zenlink_asset = ZenlinkAssetId {\n\t\t\t\tchain_id: 1000u32,\n\t\t\t\tasset_type: LOCAL,\n\t\t\t\tasset_index: stellar_assets_indexes[i],\n\t\t\t};\n\t\t\tassert_eq!(\n\t\t\t\tcurrency_id_to_zenlink_id(fake_currency_id, 1000),\n\t\t\t\tOk(expected_zenlink_asset)\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","build.rs"],"content":"use substrate_wasm_builder::WasmBuilder;\n\nfn main() {\n\tWasmBuilder::new()\n\t\t.with_current_project()\n\t\t.export_heap_base()\n\t\t.import_memory()\n\t\t.build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nmod weights;\npub mod xcm_config;\n\nuse smallvec::smallvec;\nuse sp_api::impl_runtime_apis;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{AccountIdLookup, BlakeTwo256, Block as BlockT},\n\ttransaction_validity::{TransactionSource, TransactionValidity},\n\tApplyExtrinsicResult,\n};\n\nuse sp_std::prelude::*;\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\nuse frame_support::{\n\tconstruct_runtime,\n\tdispatch::DispatchClass,\n\tparameter_types,\n\ttraits::Everything,\n\tweights::{\n\t\tconstants::WEIGHT_REF_TIME_PER_SECOND, ConstantMultiplier, Weight, WeightToFeeCoefficient,\n\t\tWeightToFeeCoefficients, WeightToFeePolynomial,\n\t},\n\tPalletId,\n};\nuse frame_system::{\n\tlimits::{BlockLength, BlockWeights},\n\tEnsureRoot,\n};\npub use sp_runtime::{MultiAddress, Perbill, Permill};\n\nuse runtime_common::{\n\topaque, AccountId, AuraId, Balance, BlockNumber, Hash, Index, Signature, EXISTENTIAL_DEPOSIT,\n\tMICROUNIT, MILLIUNIT,\n};\n\nuse cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;\n\nuse xcm_config::{XcmConfig, XcmOriginToTransactDispatchOrigin};\n\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\n\n// Polkadot imports\nuse polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};\n\nuse weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};\n\n// XCM Imports\nuse xcm::latest::prelude::BodyId;\nuse xcm_executor::XcmExecutor;\n\n/// The address format for describing accounts.\npub type Address = MultiAddress\u003cAccountId, ()\u003e;\n\n/// Block header type as expected by this runtime.\npub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\n/// Block type as expected by this runtime.\npub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock\u003cBlock\u003e;\n\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId\u003cBlock\u003e;\n\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender\u003cRuntime\u003e,\n\tframe_system::CheckSpecVersion\u003cRuntime\u003e,\n\tframe_system::CheckTxVersion\u003cRuntime\u003e,\n\tframe_system::CheckGenesis\u003cRuntime\u003e,\n\tframe_system::CheckEra\u003cRuntime\u003e,\n\tframe_system::CheckNonce\u003cRuntime\u003e,\n\tframe_system::CheckWeight\u003cRuntime\u003e,\n\tpallet_transaction_payment::ChargeTransactionPayment\u003cRuntime\u003e,\n);\n\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tgeneric::UncheckedExtrinsic\u003cAddress, RuntimeCall, Signature, SignedExtra\u003e;\n\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic\u003cAccountId, RuntimeCall, SignedExtra\u003e;\n\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive\u003c\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext\u003cRuntime\u003e,\n\tRuntime,\n\tAllPalletsWithSystem,\n\u003e;\n\n/// Handles converting a weight scalar to a fee value, based on the scale and granularity of the\n/// node's balance type.\n///\n/// This should typically create a mapping between the following ranges:\n///   - `[0, MAXIMUM_BLOCK_WEIGHT]`\n///   - `[Balance::min, Balance::max]`\n///\n/// Yet, it can be used for any other sort of change to weight-fee. Some examples being:\n///   - Setting it to `0` will essentially disable the weight fee.\n///   - Setting it to `1` will cause the literal `#[weight = x]` values to be charged.\npub struct WeightToFee;\nimpl WeightToFeePolynomial for WeightToFee {\n\ttype Balance = Balance;\n\tfn polynomial() -\u003e WeightToFeeCoefficients\u003cSelf::Balance\u003e {\n\t\tlet p = MILLIUNIT / 10;\n\t\tlet q = 100 * Balance::from(ExtrinsicBaseWeight::get().ref_time());\n\t\tsmallvec![WeightToFeeCoefficient {\n\t\t\tdegree: 1,\n\t\t\tnegative: false,\n\t\t\tcoeff_frac: Perbill::from_rational(p % q, q),\n\t\t\tcoeff_integer: p / q,\n\t\t}]\n\t}\n}\n\nimpl_opaque_keys! {\n\tpub struct SessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\n#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"pendulum-development\"),\n\timpl_name: create_runtime_str!(\"pendulum-development\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 0,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n\tstate_version: 1,\n};\n\n/// This determines the average expected block time that we are targeting.\n/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.\n/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked\n/// up by `pallet_aura` to implement `fn slot_duration()`.\n///\n/// Change this to adjust the block time.\npub const MILLISECS_PER_BLOCK: u64 = 12000;\n\n// NOTE: Currently it is not possible to change the slot duration after the chain has started.\n//       Attempting to do so will brick block production.\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\n\n/// We assume that ~5% of the block weight is consumed by `on_initialize` handlers. This is\n/// used to limit the maximal weight of a single extrinsic.\nconst AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(5);\n\n/// We allow `Normal` extrinsics to fill up the block up to 75%, the rest can be used by\n/// `Operational` extrinsics.\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\n/// We allow for 0.5 of a second of compute with a 12 second average block time.\nconst MAXIMUM_BLOCK_WEIGHT: Weight =\n\tWeight::from_parts(WEIGHT_REF_TIME_PER_SECOND.saturating_div(2), 0)\n\t\t.set_proof_size(cumulus_primitives_core::relay_chain::MAX_POV_SIZE as u64);\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -\u003e NativeVersion {\n\tNativeVersion { runtime_version: VERSION, can_author_with: Default::default() }\n}\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\n\t// This part is copied from Substrate's `bin/node/runtime/src/lib.rs`.\n\t//  The `RuntimeBlockLength` and `RuntimeBlockWeights` exist here because the\n\t// `DeletionWeightLimit` and `DeletionQueueDepth` depend on those to parameterize\n\t// the lazy contract deletion.\n\tpub RuntimeBlockLength: BlockLength =\n\t\tBlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub RuntimeBlockWeights: BlockWeights = BlockWeights::builder()\n\t\t.base_block(BlockExecutionWeight::get())\n\t\t.for_class(DispatchClass::all(), |weights| {\n\t\t\tweights.base_extrinsic = ExtrinsicBaseWeight::get();\n\t\t})\n\t\t.for_class(DispatchClass::Normal, |weights| {\n\t\t\tweights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);\n\t\t})\n\t\t.for_class(DispatchClass::Operational, |weights| {\n\t\t\tweights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);\n\t\t\t// Operational transactions have some extra reserved space, so that they\n\t\t\t// are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.\n\t\t\tweights.reserved = Some(\n\t\t\t\tMAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT\n\t\t\t);\n\t\t})\n\t\t.avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)\n\t\t.build_or_panic();\n\tpub const SS58Prefix: u16 = 42;\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype RuntimeCall = RuntimeCall;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup\u003cAccountId, ()\u003e;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\t/// The ubiquitous origin type.\n\ttype RuntimeOrigin = RuntimeOrigin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// Runtime version.\n\ttype Version = Version;\n\t/// Converts a module to an index of this module in the runtime.\n\ttype PalletInfo = PalletInfo;\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = Everything;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// Block \u0026 extrinsics weights: base values and limits.\n\ttype BlockWeights = RuntimeBlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = RuntimeBlockLength;\n\t/// This is used as an identifier of the chain. 42 is the generic substrate prefix.\n\ttype SS58Prefix = SS58Prefix;\n\t/// The action to take on a Runtime Upgrade\n\ttype OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode\u003cSelf\u003e;\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const UncleGenerations: u32 = 0;\n}\n\nimpl pallet_authorship::Config for Runtime {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = (CollatorSelection,);\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = EXISTENTIAL_DEPOSIT;\n\tpub const MaxLocks: u32 = 50;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = [u8; 8];\n}\n\nparameter_types! {\n\t/// Relay Chain `TransactionByteFee` / 10\n\tpub const TransactionByteFee: Balance = 10 * MICROUNIT;\n\tpub const OperationalFeeMultiplier: u8 = 5;\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter\u003cBalances, ()\u003e;\n\ttype WeightToFee = WeightToFee;\n\ttype LengthToFee = ConstantMultiplier\u003cBalance, TransactionByteFee\u003e;\n\ttype FeeMultiplierUpdate = SlowAdjustingFeeUpdate\u003cSelf\u003e;\n\ttype OperationalFeeMultiplier = OperationalFeeMultiplier;\n}\n\nparameter_types! {\n\tpub const ReservedXcmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n\tpub const ReservedDmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n}\n\nimpl cumulus_pallet_parachain_system::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSystemEvent = ();\n\ttype SelfParaId = parachain_info::Pallet\u003cRuntime\u003e;\n\ttype DmpMessageHandler = DmpQueue;\n\ttype ReservedDmpWeight = ReservedDmpWeight;\n\ttype OutboundXcmpMessageSource = XcmpQueue;\n\ttype XcmpMessageHandler = XcmpQueue;\n\ttype ReservedXcmpWeight = ReservedXcmpWeight;\n\ttype CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;\n}\n\nimpl parachain_info::Config for Runtime {}\n\nimpl cumulus_pallet_aura_ext::Config for Runtime {}\n\nimpl cumulus_pallet_xcmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ChannelInfo = ParachainSystem;\n\ttype VersionWrapper = ();\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype PriceForSiblingDelivery = ();\n\ttype WeightInfo = ();\n}\n\nimpl cumulus_pallet_dmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const Period: u32 = 6 * HOURS;\n\tpub const Offset: u32 = 0;\n\tpub const MaxAuthorities: u32 = 100_000;\n}\n\nimpl pallet_session::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\t// we don't have stash and controller, thus we don't need the convert as well.\n\ttype ValidatorIdOf = pallet_collator_selection::IdentityCollator;\n\ttype ShouldEndSession = pallet_session::PeriodicSessions\u003cPeriod, Offset\u003e;\n\ttype NextSessionRotation = pallet_session::PeriodicSessions\u003cPeriod, Offset\u003e;\n\ttype SessionManager = CollatorSelection;\n\t// Essentially just Aura, but lets be pedantic.\n\ttype SessionHandler = \u003cSessionKeys as sp_runtime::traits::OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = SessionKeys;\n\ttype WeightInfo = ();\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nparameter_types! {\n\tpub const PotId: PalletId = PalletId(*b\"PotStake\");\n\tpub const MaxCandidates: u32 = 1000;\n\tpub const MinCandidates: u32 = 5;\n\tpub const SessionLength: BlockNumber = 6 * HOURS;\n\tpub const MaxInvulnerables: u32 = 100;\n\tpub const ExecutiveBody: BodyId = BodyId::Executive;\n}\n\n// We allow root only to execute privileged collator selection operations.\npub type CollatorSelectionUpdateOrigin = EnsureRoot\u003cAccountId\u003e;\n\nimpl pallet_collator_selection::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype UpdateOrigin = CollatorSelectionUpdateOrigin;\n\ttype PotId = PotId;\n\ttype MaxCandidates = MaxCandidates;\n\ttype MinCandidates = MinCandidates;\n\ttype MaxInvulnerables = MaxInvulnerables;\n\t// should be a multiple of session or things will get inconsistent\n\ttype KickThreshold = Period;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\ttype ValidatorIdOf = pallet_collator_selection::IdentityCollator;\n\ttype ValidatorRegistration = Session;\n\ttype WeightInfo = ();\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\t// System support stuff.\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 0,\n\t\tParachainSystem: cumulus_pallet_parachain_system::{\n\t\t\tPallet, Call, Config, Storage, Inherent, Event\u003cT\u003e, ValidateUnsigned,\n\t\t} = 1,\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent} = 2,\n\t\tParachainInfo: parachain_info::{Pallet, Storage, Config} = 3,\n\n\t\t// Monetary stuff.\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 10,\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event\u003cT\u003e} = 11,\n\n\t\t// Collator support. The order of these 4 are important and shall not change.\n\t\tCollatorSelection: pallet_collator_selection::{Pallet, Call, Storage, Event\u003cT\u003e, Config\u003cT\u003e} = 21,\n\t\tAura: pallet_aura::{Pallet, Storage, Config\u003cT\u003e} = 23,\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e} = 22,\n\t\tAuthorship: pallet_authorship::{Pallet, Storage} = 20,\n\t\tAuraExt: cumulus_pallet_aura_ext::{Pallet, Storage, Config} = 24,\n\n\t\t// XCM helpers.\n\t\tXcmpQueue: cumulus_pallet_xcmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 30,\n\t\tPolkadotXcm: pallet_xcm::{Pallet, Call, Event\u003cT\u003e, Origin, Config} = 31,\n\t\tCumulusXcm: cumulus_pallet_xcm::{Pallet, Event\u003cT\u003e, Origin} = 32,\n\t\tDmpQueue: cumulus_pallet_dmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 33,\n\t}\n);\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!(\n\t\t[frame_system, SystemBench::\u003cRuntime\u003e]\n\t\t[pallet_balances, Balances]\n\t\t[pallet_session, SessionBench::\u003cRuntime\u003e]\n\t\t[pallet_timestamp, Timestamp]\n\t\t[pallet_collator_selection, CollatorSelection]\n\t\t[cumulus_pallet_xcmp_queue, XcmpQueue]\n\t);\n}\n\nimpl_runtime_apis! {\n\timpl sp_consensus_aura::AuraApi\u003cBlock, AuraId\u003e for Runtime {\n\t\tfn slot_duration() -\u003e sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -\u003e Vec\u003cAuraId\u003e {\n\t\t\tAura::authorities().into_inner()\n\t\t}\n\t}\n\n\timpl sp_api::Core\u003cBlock\u003e for Runtime {\n\t\tfn version() -\u003e RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata\u003cBlock\u003e for Runtime {\n\t\tfn metadata() -\u003e OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder\u003cBlock\u003e for Runtime {\n\t\tfn apply_extrinsic(extrinsic: \u003cBlock as BlockT\u003e::Extrinsic) -\u003e ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -\u003e \u003cBlock as BlockT\u003e::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -\u003e Vec\u003c\u003cBlock as BlockT\u003e::Extrinsic\u003e {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(\u0026block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tblock_hash: \u003cBlock as BlockT\u003e::Hash,\n\t\t) -\u003e TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi\u003cBlock\u003e for Runtime {\n\t\tfn offchain_worker(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys\u003cBlock\u003e for Runtime {\n\t\tfn generate_session_keys(seed: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n\t\t\tSessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec\u003cu8\u003e,\n\t\t) -\u003e Option\u003cVec\u003c(Vec\u003cu8\u003e, KeyTypeId)\u003e\u003e {\n\t\t\tSessionKeys::decode_into_raw_public_keys(\u0026encoded)\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi\u003cBlock, AccountId, Index\u003e for Runtime {\n\t\tfn account_nonce(account: AccountId) -\u003e Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi\u003cBlock, Balance\u003e for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t\tfn query_fee_details(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment::FeeDetails\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\n\t\tfn query_weight_to_fee(weight: Weight) -\u003e Balance {\n\t\t\tTransactionPayment::weight_to_fee(weight)\n\t\t}\n\n\t\tfn query_length_to_fee(length: u32) -\u003e Balance {\n\t\t\tTransactionPayment::length_to_fee(length)\n\t\t}\n\t}\n\n\timpl cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e for Runtime {\n\t\tfn collect_collation_info(header: \u0026\u003cBlock as BlockT\u003e::Header) -\u003e cumulus_primitives_core::CollationInfo {\n\t\t\tParachainSystem::collect_collation_info(header)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\timpl frame_try_runtime::TryRuntime\u003cBlock\u003e for Runtime {\n\t\tfn on_runtime_upgrade() -\u003e (Weight, Weight) {\n\t\t\tlog::info!(\"try-runtime::on_runtime_upgrade pendulum-development.\");\n\t\t\tlet weight = Executive::try_runtime_upgrade().unwrap();\n\t\t\t(weight, RuntimeBlockWeights::get().max_block)\n\t\t}\n\n\t\tfn execute_block_no_check(block: Block) -\u003e Weight {\n\t\t\tExecutive::execute_block_no_check(block)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark\u003cBlock\u003e for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -\u003e (\n\t\t\tVec\u003cframe_benchmarking::BenchmarkList\u003e,\n\t\t\tVec\u003cframe_support::traits::StorageInfo\u003e,\n\t\t) {\n\t\t\tuse frame_benchmarking::{list_benchmark as frame_list_benchmark, Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\n\t\t\tlet mut list = Vec::\u003cBenchmarkList\u003e::new();\n\t\t\tframe_list_benchmark!(list, extra,cumulus_pallet_session_benchmarking, SessionBench::\u003cRuntime\u003e);\n\t\t\tlist_benchmarks!(list, extra);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -\u003e Result\u003cVec\u003cframe_benchmarking::BenchmarkBatch\u003e, sp_runtime::RuntimeString\u003e {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, TrackedStorageKey};\n\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\t\t\timpl baseline::Config for Runtime {}\n\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\timpl cumulus_pallet_session_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec\u003cTrackedStorageKey\u003e = vec![\n\t\t\t\t// Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t// Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t// Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t// Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t// System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::\u003cBenchmarkBatch\u003e::new();\n\t\t\tlet params = (\u0026config, \u0026whitelist);\n\t\t\tadd_benchmarks!(params, batches);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n}\n\nstruct CheckInherents;\n\nimpl cumulus_pallet_parachain_system::CheckInherents\u003cBlock\u003e for CheckInherents {\n\tfn check_inherents(\n\t\tblock: \u0026Block,\n\t\trelay_state_proof: \u0026cumulus_pallet_parachain_system::RelayChainStateProof,\n\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\tlet relay_chain_slot = relay_state_proof\n\t\t\t.read_slot()\n\t\t\t.expect(\"Could not read the relay chain slot from the proof\");\n\n\t\tlet inherent_data =\n\t\t\tcumulus_primitives_timestamp::InherentDataProvider::from_relay_chain_slot_and_duration(\n\t\t\t\trelay_chain_slot,\n\t\t\t\tsp_std::time::Duration::from_secs(6),\n\t\t\t)\n\t\t\t.create_inherent_data()\n\t\t\t.expect(\"Could not create the timestamp inherent data\");\n\n\t\tinherent_data.check_extrinsics(block)\n\t}\n}\n\ncumulus_pallet_parachain_system::register_validate_block! {\n\tRuntime = Runtime,\n\tBlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::\u003cRuntime, Executive\u003e,\n\tCheckInherents = CheckInherents,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","block_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Importing a block with 0 Extrinsics.\n\t\tpub const BlockExecutionWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::BlockExecutionWeight::get();\n\n\t\t\t// At least 100 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 100u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 100 µs.\"\n\t\t\t);\n\t\t\t// At most 50 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= 50u64 * constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 50 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","extrinsic_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Executing a NO-OP `System::remarks` Extrinsic.\n\t\tpub const ExtrinsicBaseWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::ExtrinsicBaseWeight::get();\n\n\t\t\t// At least 10 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 10u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 10 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","mod.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Expose the auto generated weight files.\n\npub mod block_weights;\npub mod extrinsic_weights;\npub mod paritydb_weights;\npub mod rocksdb_weights;\n\npub use block_weights::constants::BlockExecutionWeight;\npub use extrinsic_weights::constants::ExtrinsicBaseWeight;\npub use paritydb_weights::constants::ParityDbWeight;\npub use rocksdb_weights::constants::RocksDbWeight;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","paritydb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights\n\t\t/// are available for brave runtime engineers who may want to try this out as default.\n\t\tpub const ParityDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::ParityDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","weights","rocksdb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// By default, Substrate uses `RocksDB`, so this will be the weight used throughout\n\t\t/// the runtime.\n\t\tpub const RocksDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::RocksDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","development","src","xcm_config.rs"],"content":"use super::{\n\tAccountId, AllPalletsWithSystem, Balances, ParachainInfo, ParachainSystem, PolkadotXcm,\n\tRuntime, RuntimeCall, RuntimeEvent, RuntimeOrigin, WeightToFee, XcmpQueue,\n};\nuse core::marker::PhantomData;\nuse frame_support::{\n\tlog, match_types, parameter_types,\n\ttraits::{Everything, Nothing},\n\tweights::Weight,\n};\nuse pallet_xcm::XcmPassthrough;\nuse polkadot_parachain::primitives::Sibling;\nuse polkadot_runtime_common::impls::ToAuthor;\nuse sp_core::ConstU32;\nuse xcm::latest::{prelude::*, Weight as XCMWeight};\nuse xcm_builder::{\n\tAccountId32Aliases, AllowTopLevelPaidExecutionFrom, AllowUnpaidExecutionFrom, CurrencyAdapter,\n\tEnsureXcmOrigin, FixedWeightBounds, IsConcrete, NativeAsset, ParentIsPreset,\n\tRelayChainAsNative, SiblingParachainAsNative, SiblingParachainConvertsVia,\n\tSignedAccountId32AsNative, SignedToAccountId32, SovereignSignedViaLocation, TakeWeightCredit,\n\tUsingComponents,\n};\nuse xcm_executor::{traits::ShouldExecute, XcmExecutor};\n\nparameter_types! {\n\tpub const RelayLocation: MultiLocation = MultiLocation::parent();\n\tpub const RelayNetwork: NetworkId = NetworkId::Rococo;\n\tpub RelayChainOrigin: RuntimeOrigin = cumulus_pallet_xcm::Origin::Relay.into();\n\tpub Ancestry: MultiLocation = Parachain(ParachainInfo::parachain_id().into()).into();\n\tpub UniversalLocation: InteriorMultiLocation = Parachain(ParachainInfo::parachain_id().into()).into();\n}\n\n/// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used\n/// when determining ownership of accounts for asset transacting and when attempting to use XCM\n/// `Transact` in order to determine the dispatch Origin.\npub type LocationToAccountId = (\n\t// The parent (Relay-chain) origin converts to the parent `AccountId`.\n\tParentIsPreset\u003cAccountId\u003e,\n\t// Sibling parachain origins convert to AccountId via the `ParaId::into`.\n\tSiblingParachainConvertsVia\u003cSibling, AccountId\u003e,\n\t// Straight up local `AccountId32` origins just alias directly to `AccountId`.\n\tAccountId32Aliases\u003cRelayNetwork, AccountId\u003e,\n);\n\n/// Means for transacting assets on this chain.\npub type LocalAssetTransactor = CurrencyAdapter\u003c\n\t// Use this currency:\n\tBalances,\n\t// Use this currency when it is a fungible asset matching the given location or name:\n\tIsConcrete\u003cRelayLocation\u003e,\n\t// Do a simple punn to convert an AccountId32 MultiLocation into a native chain account ID:\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly):\n\tAccountId,\n\t// We don't track any teleports.\n\t(),\n\u003e;\n\n/// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,\n/// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can\n/// biases the kind of local `Origin` it will become.\npub type XcmOriginToTransactDispatchOrigin = (\n\t// Sovereign account converter; this attempts to derive an `AccountId` from the origin location\n\t// using `LocationToAccountId` and then turn that into the usual `Signed` origin. Useful for\n\t// foreign chains who want to have a local sovereign account on this chain which they control.\n\tSovereignSignedViaLocation\u003cLocationToAccountId, RuntimeOrigin\u003e,\n\t// Native converter for Relay-chain (Parent) location; will converts to a `Relay` origin when\n\t// recognized.\n\tRelayChainAsNative\u003cRelayChainOrigin, RuntimeOrigin\u003e,\n\t// Native converter for sibling Parachains; will convert to a `SiblingPara` origin when\n\t// recognized.\n\tSiblingParachainAsNative\u003ccumulus_pallet_xcm::Origin, RuntimeOrigin\u003e,\n\t// Native signed account converter; this just converts an `AccountId32` origin into a normal\n\t// `Origin::Signed` origin of the same 32-byte value.\n\tSignedAccountId32AsNative\u003cRelayNetwork, RuntimeOrigin\u003e,\n\t// Xcm origins can be represented natively under the Xcm pallet's Xcm origin.\n\tXcmPassthrough\u003cRuntimeOrigin\u003e,\n);\n\nparameter_types! {\n\t// One XCM operation is 1_000_000_000 weight - almost certainly a conservative estimate.\n\t// The default POV size used by Polkadot/Kusama was 64 kB but that has been updated here: https://github.com/paritytech/polkadot/pull/7081\n\t// We should properly benchmark instructions and get rid of fixed weights.\n\tpub UnitWeightCost: Weight = Weight::from_parts(1_000_000_000, 1024);\n\tpub const MaxInstructions: u32 = 100;\n}\n\nmatch_types! {\n\tpub type ParentOrParentsExecutivePlurality: impl Contains\u003cMultiLocation\u003e = {\n\t\tMultiLocation { parents: 1, interior: Here } |\n\t\tMultiLocation { parents: 1, interior: X1(Plurality { id: BodyId::Executive, .. }) }\n\t};\n}\n\n//TODO: move DenyThenTry to polkadot's xcm module.\n/// Deny executing the xcm message if it matches any of the Deny filter regardless of anything else.\n/// If it passes the Deny, and matches one of the Allow cases then it is let through.\npub struct DenyThenTry\u003cDeny, Allow\u003e(PhantomData\u003cDeny\u003e, PhantomData\u003cAllow\u003e)\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute;\n\nimpl\u003cDeny, Allow\u003e ShouldExecute for DenyThenTry\u003cDeny, Allow\u003e\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute,\n{\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\tmax_weight: XCMWeight,\n\t\tweight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tDeny::should_execute(origin, instructions, max_weight, weight_credit)?;\n\t\tAllow::should_execute(origin, instructions, max_weight, weight_credit)\n\t}\n}\n\n// See issue #5233\npub struct DenyReserveTransferToRelayChain;\nimpl ShouldExecute for DenyReserveTransferToRelayChain {\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\t_max_weight: XCMWeight,\n\t\t_weight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tif instructions.iter().any(|inst| {\n\t\t\tmatches!(\n\t\t\t\tinst,\n\t\t\t\tInitiateReserveWithdraw {\n\t\t\t\t\treserve: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t..\n\t\t\t\t} | DepositReserveAsset { dest: MultiLocation { parents: 1, interior: Here }, .. } |\n\t\t\t\t\tTransferReserveAsset {\n\t\t\t\t\t\tdest: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t\t..\n\t\t\t\t\t}\n\t\t\t)\n\t\t}) {\n\t\t\treturn Err(()) // Deny\n\t\t}\n\n\t\t// allow reserve transfers to arrive from relay chain\n\t\tif matches!(origin, MultiLocation { parents: 1, interior: Here }) \u0026\u0026\n\t\t\tinstructions.iter().any(|inst| matches!(inst, ReserveAssetDeposited { .. }))\n\t\t{\n\t\t\tlog::warn!(\n\t\t\t\ttarget: \"xcm::barriers\",\n\t\t\t\t\"Unexpected ReserveAssetDeposited from the relay chain\",\n\t\t\t);\n\t\t}\n\t\t// Permit everything else\n\t\tOk(())\n\t}\n}\n\npub type Barrier = DenyThenTry\u003c\n\tDenyReserveTransferToRelayChain,\n\t(\n\t\tTakeWeightCredit,\n\t\tAllowTopLevelPaidExecutionFrom\u003cEverything\u003e,\n\t\tAllowUnpaidExecutionFrom\u003cParentOrParentsExecutivePlurality\u003e,\n\t\t// ^^^ Parent and its exec plurality get free execution\n\t),\n\u003e;\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n\ttype RuntimeCall = RuntimeCall;\n\ttype XcmSender = XcmRouter;\n\t// How to withdraw and deposit an asset.\n\ttype AssetTransactor = LocalAssetTransactor;\n\ttype OriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype IsReserve = NativeAsset;\n\t// Teleporting is disabled.\n\ttype IsTeleporter = ();\n\ttype UniversalLocation = UniversalLocation;\n\ttype Barrier = Barrier;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype Trader =\n\t\tUsingComponents\u003cWeightToFee, RelayLocation, AccountId, Balances, ToAuthor\u003cRuntime\u003e\u003e;\n\ttype ResponseHandler = PolkadotXcm;\n\ttype AssetTrap = PolkadotXcm;\n\ttype AssetLocker = ();\n\ttype AssetExchanger = ();\n\ttype AssetClaims = PolkadotXcm;\n\ttype SubscriptionService = PolkadotXcm;\n\ttype PalletInstancesInfo = AllPalletsWithSystem;\n\ttype MaxAssetsIntoHolding = ConstU32\u003c8\u003e;\n\ttype FeeManager = ();\n\ttype MessageExporter = ();\n\ttype UniversalAliases = Nothing;\n\ttype CallDispatcher = RuntimeCall;\n\ttype SafeCallFilter = Everything;\n}\n\n/// No local origins on this chain are allowed to dispatch XCM sends/executions.\npub type LocalOriginToLocation = SignedToAccountId32\u003cRuntimeOrigin, AccountId, RelayNetwork\u003e;\n\n/// The means for routing XCM messages which are not for local execution into the right message\n/// queues.\npub type XcmRouter = (\n\t// Two routers - use UMP to communicate with the relay chain:\n\tcumulus_primitives_utility::ParentAsUmp\u003cParachainSystem, PolkadotXcm, ()\u003e,\n\t// ..and XCMP to communicate with the sibling chains.\n\tXcmpQueue,\n);\n\nimpl pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyMatcher = ();\n\ttype SendXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmRouter = XcmRouter;\n\ttype ExecuteXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmExecuteFilter = Nothing;\n\t// ^ Disable dispatchable execute on the XCM pallet.\n\t// Needs to be `Everything` for local testing.\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype XcmTeleportFilter = Everything;\n\ttype XcmReserveTransferFilter = Nothing;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype UniversalLocation = UniversalLocation;\n\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\n\tconst VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;\n\t// ^ Override for AdvertisedXcmVersion default\n\ttype AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;\n\ttype TrustedLockers = ();\n\ttype SovereignAccountOf = LocationToAccountId;\n\ttype MaxLockers = ConstU32\u003c8\u003e;\n\ttype WeightInfo = pallet_xcm::TestWeightInfo;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype ReachableDest = ReachableDest;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nparameter_types! {\n\tpub ReachableDest: Option\u003cMultiLocation\u003e = Some(Parent.into());\n}\n\nimpl cumulus_pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n}\n","traces":[{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","build.rs"],"content":"use substrate_wasm_builder::WasmBuilder;\n\nfn main() {\n\tWasmBuilder::new()\n\t\t.with_current_project()\n\t\t.export_heap_base()\n\t\t.import_memory()\n\t\t.build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nmod weights;\npub mod xcm_config;\npub mod zenlink;\nuse crate::zenlink::*;\nuse xcm::v3::MultiLocation;\nuse zenlink_protocol::{AssetBalance, MultiAssetsHandler, PairInfo};\n\npub use parachain_staking::InflationInfo;\n\nuse bifrost_farming as farming;\nuse bifrost_farming_rpc_runtime_api as farming_rpc_runtime_api;\nuse orml_traits::MultiCurrency;\n\nuse codec::Encode;\n\nuse smallvec::smallvec;\nuse sp_api::impl_runtime_apis;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata, H256};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{\n\t\tAccountIdConversion, AccountIdLookup, BlakeTwo256, Block as BlockT, Convert, ConvertInto,\n\t},\n\ttransaction_validity::{TransactionSource, TransactionValidity},\n\tApplyExtrinsicResult, DispatchError, FixedPointNumber, SaturatedConversion,\n};\n\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\nuse frame_support::{\n\tconstruct_runtime,\n\tdispatch::DispatchClass,\n\tparameter_types,\n\ttraits::{\n\t\tConstBool, ConstU32, Contains, Currency as FrameCurrency, EitherOfDiverse,\n\t\tEqualPrivilegeOnly, Imbalance, OnUnbalanced, WithdrawReasons,\n\t},\n\tweights::{\n\t\tconstants::WEIGHT_REF_TIME_PER_SECOND, ConstantMultiplier, Weight, WeightToFeeCoefficient,\n\t\tWeightToFeeCoefficients, WeightToFeePolynomial,\n\t},\n\tPalletId,\n};\nuse frame_system::{\n\tlimits::{BlockLength, BlockWeights},\n\tEnsureRoot, EnsureSigned,\n};\npub use sp_runtime::{MultiAddress, Perbill, Permill, Perquintill};\n\nuse runtime_common::{\n\tasset_registry, chain_ext, opaque, AccountId, Amount, AuraId, Balance, BlockNumber, Hash,\n\tIndex, PoolId, ReserveIdentifier, Signature, EXISTENTIAL_DEPOSIT, MILLIUNIT, NANOUNIT, UNIT,\n};\n\nuse cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;\n\nuse dia_oracle::DiaOracle;\n\nuse xcm_config::{XcmConfig, XcmOriginToTransactDispatchOrigin};\n\nuse orml_currencies::BasicCurrencyAdapter;\nuse orml_traits::{currency::MutationHooks, parameter_type_with_key};\n\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\n\npub use dia_oracle::dia::AssetId;\npub use issue::{Event as IssueEvent, IssueRequest};\npub use nomination::Event as NominationEvent;\npub use redeem::{Event as RedeemEvent, RedeemRequest};\npub use replace::{Event as ReplaceEvent, ReplaceRequest};\npub use security::StatusCode;\npub use stellar_relay::traits::{FieldLength, Organization, Validator};\n\nconst CONTRACTS_DEBUG_OUTPUT: bool = true;\n\npub use module_oracle_rpc_runtime_api::BalanceWrapper;\nuse oracle::dia::{DiaOracleAdapter, XCMCurrencyConversion};\n\n// Polkadot imports\nuse polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};\n\nuse spacewalk_primitives::{\n\tself as primitives, CurrencyId, CurrencyId::XCM, Moment, SignedFixedPoint, SignedInner,\n\tUnsignedFixedPoint, UnsignedInner,\n};\n\nuse orml_currencies::WeightInfo;\nuse weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};\n\nuse orml_currencies_allowance_extension::{\n\tdefault_weights::WeightInfo as AllowanceWeightInfo, Config as AllowanceConfig,\n};\n\nuse frame_support::{\n\tlog::{error, warn},\n\tpallet_prelude::*,\n};\nuse sp_std::vec::Vec;\n\nuse pallet_contracts::chain_extension::{\n\tChainExtension, Environment, Ext, InitState, RetVal, SysConfig,\n};\nuse sp_core::crypto::UncheckedFrom;\n\n// XCM Imports\nuse xcm_executor::XcmExecutor;\n\npub type VaultId = primitives::VaultId\u003cAccountId, CurrencyId\u003e;\n\n/// The address format for describing accounts.\npub type Address = MultiAddress\u003cAccountId, ()\u003e;\n\n/// Block header type as expected by this runtime.\npub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\n/// Block type as expected by this runtime.\npub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock\u003cBlock\u003e;\n\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId\u003cBlock\u003e;\n\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender\u003cRuntime\u003e,\n\tframe_system::CheckSpecVersion\u003cRuntime\u003e,\n\tframe_system::CheckTxVersion\u003cRuntime\u003e,\n\tframe_system::CheckGenesis\u003cRuntime\u003e,\n\tframe_system::CheckEra\u003cRuntime\u003e,\n\tframe_system::CheckNonce\u003cRuntime\u003e,\n\tframe_system::CheckWeight\u003cRuntime\u003e,\n\tpallet_transaction_payment::ChargeTransactionPayment\u003cRuntime\u003e,\n);\n\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tgeneric::UncheckedExtrinsic\u003cAddress, RuntimeCall, Signature, SignedExtra\u003e;\n\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic\u003cAccountId, RuntimeCall, SignedExtra\u003e;\n\npub type SignedPayload = generic::SignedPayload\u003cRuntimeCall, SignedExtra\u003e;\n\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive\u003c\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext\u003cRuntime\u003e,\n\tRuntime,\n\tAllPalletsWithSystem,\n\u003e;\n\npub struct SpacewalkNativeCurrency;\nimpl oracle::dia::NativeCurrencyKey for SpacewalkNativeCurrency {\n\tfn native_symbol() -\u003e Vec\u003cu8\u003e {\n\t\t\"AMPE\".as_bytes().to_vec()\n\t}\n\n\tfn native_chain() -\u003e Vec\u003cu8\u003e {\n\t\t\"AMPLITUDE\".as_bytes().to_vec()\n\t}\n}\n\nimpl XCMCurrencyConversion for SpacewalkNativeCurrency {\n\tfn convert_to_dia_currency_id(token_symbol: u8) -\u003e Option\u003c(Vec\u003cu8\u003e, Vec\u003cu8\u003e)\u003e {\n\t\tmatch token_symbol {\n\t\t\t0 =\u003e Some((b\"Kusama\".to_vec(), b\"KSM\".to_vec())),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n\n\tfn convert_from_dia_currency_id(blockchain: Vec\u003cu8\u003e, symbol: Vec\u003cu8\u003e) -\u003e Option\u003cu8\u003e {\n\t\tmatch (blockchain.as_slice(), symbol.as_slice()) {\n\t\t\t(b\"Kusama\", b\"KSM\") =\u003e Some(0),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\ntype DataProviderImpl = DiaOracleAdapter\u003c\n\tDiaOracleModule,\n\tUnsignedFixedPoint,\n\tMoment,\n\toracle::dia::DiaOracleKeyConvertor\u003cSpacewalkNativeCurrency\u003e,\n\tConvertPrice,\n\tConvertMoment,\n\u003e;\n\npub struct ConvertPrice;\nimpl Convert\u003cu128, Option\u003cUnsignedFixedPoint\u003e\u003e for ConvertPrice {\n\tfn convert(price: u128) -\u003e Option\u003cUnsignedFixedPoint\u003e {\n\t\tSome(UnsignedFixedPoint::from_inner(price))\n\t}\n}\n\npub struct ConvertMoment;\nimpl Convert\u003cu64, Option\u003cMoment\u003e\u003e for ConvertMoment {\n\tfn convert(moment: u64) -\u003e Option\u003cMoment\u003e {\n\t\t// The provided moment is in seconds, but we need milliseconds\n\t\tSome(moment.saturating_mul(1000))\n\t}\n}\n\n/// Handles converting a weight scalar to a fee value, based on the scale and granularity of the\n/// node's balance type.\n///\n/// This should typically create a mapping between the following ranges:\n///   - `[0, MAXIMUM_BLOCK_WEIGHT]`\n///   - `[Balance::min, Balance::max]`\n///\n/// Yet, it can be used for any other sort of change to weight-fee. Some examples being:\n///   - Setting it to `0` will essentially disable the weight fee.\n///   - Setting it to `1` will cause the literal `#[weight = x]` values to be charged.\npub struct WeightToFee;\nimpl WeightToFeePolynomial for WeightToFee {\n\ttype Balance = Balance;\n\tfn polynomial() -\u003e WeightToFeeCoefficients\u003cSelf::Balance\u003e {\n\t\tlet p = MILLIUNIT;\n\t\tlet q = 10 * Balance::from(ExtrinsicBaseWeight::get().ref_time());\n\t\tsmallvec![WeightToFeeCoefficient {\n\t\t\tdegree: 1,\n\t\t\tnegative: false,\n\t\t\tcoeff_frac: Perbill::from_rational(p % q, q),\n\t\t\tcoeff_integer: p / q,\n\t\t}]\n\t}\n}\n\nimpl_opaque_keys! {\n\tpub struct SessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\n#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"foucoco\"),\n\timpl_name: create_runtime_str!(\"foucoco\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 0,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n\tstate_version: 1,\n};\n\n/// This determines the average expected block time that we are targeting.\n/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.\n/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked\n/// up by `pallet_aura` to implement `fn slot_duration()`.\n///\n/// Change this to adjust the block time.\npub const MILLISECS_PER_BLOCK: u64 = 12000;\n\n// NOTE: Currently it is not possible to change the slot duration after the chain has started.\n//       Attempting to do so will brick block production.\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\npub const BLOCKS_PER_YEAR: BlockNumber = DAYS * 36525 / 100;\n\n/// We assume that ~5% of the block weight is consumed by `on_initialize` handlers. This is\n/// used to limit the maximal weight of a single extrinsic.\nconst AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(5);\n\n/// We allow `Normal` extrinsics to fill up the block up to 75%, the rest can be used by\n/// `Operational` extrinsics.\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\n/// We allow for 0.5 of a second of compute with a 12 second average block time.\nconst MAXIMUM_BLOCK_WEIGHT: Weight =\n\tWeight::from_parts(WEIGHT_REF_TIME_PER_SECOND.saturating_div(2), 0)\n\t\t.set_proof_size(cumulus_primitives_core::relay_chain::MAX_POV_SIZE as u64);\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -\u003e NativeVersion {\n\tNativeVersion { runtime_version: VERSION, can_author_with: Default::default() }\n}\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\n\t// This part is copied from Substrate's `bin/node/runtime/src/lib.rs`.\n\t//  The `RuntimeBlockLength` and `RuntimeBlockWeights` exist here because the\n\t// `DeletionWeightLimit` and `DeletionQueueDepth` depend on those to parameterize\n\t// the lazy contract deletion.\n\tpub RuntimeBlockLength: BlockLength =\n\t\tBlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub RuntimeBlockWeights: BlockWeights = BlockWeights::builder()\n\t\t.base_block(BlockExecutionWeight::get())\n\t\t.for_class(DispatchClass::all(), |weights| {\n\t\t\tweights.base_extrinsic = ExtrinsicBaseWeight::get();\n\t\t})\n\t\t.for_class(DispatchClass::Normal, |weights| {\n\t\t\tweights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);\n\t\t})\n\t\t.for_class(DispatchClass::Operational, |weights| {\n\t\t\tweights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);\n\t\t\t// Operational transactions have some extra reserved space, so that they\n\t\t\t// are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.\n\t\t\tweights.reserved = Some(\n\t\t\t\tMAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT\n\t\t\t);\n\t\t})\n\t\t.avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)\n\t\t.build_or_panic();\n\tpub const SS58Prefix: u16 = 57;\n}\n\npub struct BaseFilter;\nimpl Contains\u003cRuntimeCall\u003e for BaseFilter {\n\tfn contains(call: \u0026RuntimeCall) -\u003e bool {\n\t\tmatch call {\n\t\t\t// These modules are all allowed to be called by transactions:\n\t\t\tRuntimeCall::Bounties(_) |\n\t\t\tRuntimeCall::ChildBounties(_) |\n\t\t\tRuntimeCall::Treasury(_) |\n\t\t\tRuntimeCall::Tokens(_) |\n\t\t\tRuntimeCall::Currencies(_) |\n\t\t\tRuntimeCall::ParachainStaking(_) |\n\t\t\tRuntimeCall::Democracy(_) |\n\t\t\tRuntimeCall::Council(_) |\n\t\t\tRuntimeCall::TechnicalCommittee(_) |\n\t\t\tRuntimeCall::System(_) |\n\t\t\tRuntimeCall::Scheduler(_) |\n\t\t\tRuntimeCall::Preimage(_) |\n\t\t\tRuntimeCall::Timestamp(_) |\n\t\t\tRuntimeCall::Balances(_) |\n\t\t\tRuntimeCall::Session(_) |\n\t\t\tRuntimeCall::ParachainSystem(_) |\n\t\t\tRuntimeCall::Sudo(_) |\n\t\t\tRuntimeCall::XcmpQueue(_) |\n\t\t\tRuntimeCall::PolkadotXcm(_) |\n\t\t\tRuntimeCall::DmpQueue(_) |\n\t\t\tRuntimeCall::Utility(_) |\n\t\t\tRuntimeCall::Vesting(_) |\n\t\t\tRuntimeCall::XTokens(_) |\n\t\t\tRuntimeCall::Multisig(_) |\n\t\t\tRuntimeCall::Identity(_) |\n\t\t\tRuntimeCall::Contracts(_) |\n\t\t\tRuntimeCall::ZenlinkProtocol(_) |\n\t\t\tRuntimeCall::DiaOracleModule(_) |\n\t\t\tRuntimeCall::Fee(_) |\n\t\t\tRuntimeCall::Issue(_) |\n\t\t\tRuntimeCall::Nomination(_) |\n\t\t\tRuntimeCall::Oracle(_) |\n\t\t\tRuntimeCall::Redeem(_) |\n\t\t\tRuntimeCall::Replace(_) |\n\t\t\tRuntimeCall::Security(_) |\n\t\t\tRuntimeCall::StellarRelay(_) |\n\t\t\tRuntimeCall::VaultRegistry(_) |\n\t\t\tRuntimeCall::VaultRewards(_) |\n\t\t\tRuntimeCall::Farming(_) |\n\t\t\tRuntimeCall::TokenAllowance(_) |\n\t\t\tRuntimeCall::AssetRegistry(_) =\u003e true,\n\t\t\t// All pallets are allowed, but exhaustive match is defensive\n\t\t\t// in the case of adding new pallets.\n\t\t}\n\t}\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype RuntimeCall = RuntimeCall;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup\u003cAccountId, ()\u003e;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\t/// The ubiquitous origin type.\n\ttype RuntimeOrigin = RuntimeOrigin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// Runtime version.\n\ttype Version = Version;\n\t/// Converts a module to an index of this module in the runtime.\n\ttype PalletInfo = PalletInfo;\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = BaseFilter;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// Block \u0026 extrinsics weights: base values and limits.\n\ttype BlockWeights = RuntimeBlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = RuntimeBlockLength;\n\t/// This is used as an identifier of the chain. 57 is the prefix for Foucoco\n\ttype SS58Prefix = SS58Prefix;\n\t/// The action to take on a Runtime Upgrade\n\ttype OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode\u003cSelf\u003e;\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = pallet_timestamp::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const UncleGenerations: u32 = 2;\n}\n\nimpl pallet_authorship::Config for Runtime {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = ParachainStaking;\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = EXISTENTIAL_DEPOSIT;\n\tpub const MaxLocks: u32 = 50;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 100 * NANOUNIT;\n\tpub const OperationalFeeMultiplier: u8 = 5;\n}\n\ntype NegativeImbalance = \u003cBalances as FrameCurrency\u003cAccountId\u003e\u003e::NegativeImbalance;\n\npub struct DealWithFees;\nimpl OnUnbalanced\u003cNegativeImbalance\u003e for DealWithFees {\n\tfn on_unbalanceds\u003cB\u003e(mut fees_then_tips: impl Iterator\u003cItem = NegativeImbalance\u003e) {\n\t\tif let Some(mut fees) = fees_then_tips.next() {\n\t\t\tif let Some(tips) = fees_then_tips.next() {\n\t\t\t\ttips.merge_into(\u0026mut fees);\n\t\t\t}\n\t\t\t// for fees and tips, 100% to treasury\n\t\t\tTreasury::on_unbalanced(fees);\n\t\t}\n\t}\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter\u003cBalances, DealWithFees\u003e;\n\ttype WeightToFee = WeightToFee;\n\ttype LengthToFee = ConstantMultiplier\u003cBalance, TransactionByteFee\u003e;\n\ttype FeeMultiplierUpdate = SlowAdjustingFeeUpdate\u003cSelf\u003e;\n\ttype OperationalFeeMultiplier = OperationalFeeMultiplier;\n}\n\nparameter_types! {\n\tpub const ReservedXcmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n\tpub const ReservedDmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n}\n\nimpl cumulus_pallet_parachain_system::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSystemEvent = ();\n\ttype SelfParaId = parachain_info::Pallet\u003cRuntime\u003e;\n\ttype DmpMessageHandler = DmpQueue;\n\ttype ReservedDmpWeight = ReservedDmpWeight;\n\ttype OutboundXcmpMessageSource = XcmpQueue;\n\ttype XcmpMessageHandler = XcmpQueue;\n\ttype ReservedXcmpWeight = ReservedXcmpWeight;\n\ttype CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;\n}\n\nimpl parachain_info::Config for Runtime {}\n\nimpl cumulus_pallet_aura_ext::Config for Runtime {}\n\nimpl cumulus_pallet_xcmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ChannelInfo = ParachainSystem;\n\ttype VersionWrapper = ();\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype PriceForSiblingDelivery = ();\n\ttype WeightInfo = cumulus_pallet_xcmp_queue::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl cumulus_pallet_dmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const Offset: u32 = 0;\n\tpub const MaxAuthorities: u32 = 200;\n}\n\nimpl pallet_session::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\ttype ValidatorIdOf = ConvertInto;\n\ttype ShouldEndSession = ParachainStaking;\n\ttype NextSessionRotation = ParachainStaking;\n\ttype SessionManager = ParachainStaking;\n\ttype SessionHandler = \u003cSessionKeys as sp_runtime::traits::OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = SessionKeys;\n\ttype WeightInfo = pallet_session::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nparameter_types! {\n\tpub const LaunchPeriod: BlockNumber = 4 * DAYS;\n\tpub const VotingPeriod: BlockNumber = 4 * DAYS;\n\tpub const FastTrackVotingPeriod: BlockNumber = 3 * HOURS;\n\tpub const MinimumDeposit: Balance = 1 * UNIT;\n\tpub const EnactmentPeriod: BlockNumber = 4 * DAYS;\n\tpub const CooloffPeriod: BlockNumber = 4 * DAYS;\n\tpub const MaxProposals: u32 = 100;\n}\n\nimpl pallet_democracy::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype EnactmentPeriod = EnactmentPeriod;\n\ttype LaunchPeriod = LaunchPeriod;\n\ttype VotingPeriod = VotingPeriod;\n\ttype VoteLockingPeriod = EnactmentPeriod; // Same as EnactmentPeriod\n\ttype MinimumDeposit = MinimumDeposit;\n\t/// A straight majority of the council can decide what their next motion is.\n\ttype ExternalOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A super-majority can have the next scheduled referendum be a straight majority-carries vote.\n\ttype ExternalMajorityOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A unanimous council can have the next scheduled referendum be a straight default-carries\n\t/// (NTB) vote.\n\ttype ExternalDefaultOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 1\u003e;\n\t/// Two thirds of the technical committee can have an ExternalMajority/ExternalDefault vote\n\t/// be tabled immediately and with a shorter voting/enactment period.\n\ttype FastTrackOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 2, 3\u003e;\n\ttype InstantOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e;\n\ttype InstantAllowed = frame_support::traits::ConstBool\u003ctrue\u003e;\n\ttype FastTrackVotingPeriod = FastTrackVotingPeriod;\n\t// To cancel a proposal which has been passed, 2/3 of the council must agree to it.\n\ttype CancellationOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 2, 3\u003e;\n\t// To cancel a proposal before it has been passed, the technical committee must be unanimous or\n\t// Root must agree.\n\ttype CancelProposalOrigin = EitherOfDiverse\u003c\n\t\tEnsureRoot\u003cAccountId\u003e,\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e,\n\t\u003e;\n\ttype BlacklistOrigin = EnsureRoot\u003cAccountId\u003e;\n\t// Any single technical committee member may veto a coming council proposal, however they can\n\t// only do it once and it lasts only for the cool-off period.\n\ttype VetoOrigin = pallet_collective::EnsureMember\u003cAccountId, TechnicalCollective\u003e;\n\ttype CooloffPeriod = CooloffPeriod;\n\ttype Slash = ();\n\ttype Scheduler = Scheduler;\n\ttype PalletsOrigin = OriginCaller;\n\ttype MaxVotes = ConstU32\u003c100\u003e;\n\ttype WeightInfo = pallet_democracy::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxProposals = MaxProposals;\n\ttype Preimages = Preimage;\n\ttype MaxDeposits = ConstU32\u003c100\u003e;\n\ttype MaxBlacklisted = ConstU32\u003c100\u003e;\n\ttype SubmitOrigin = EnsureSigned\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const CouncilMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const CouncilMaxProposals: u32 = 100;\n\tpub const CouncilMaxMembers: u32 = 100;\n}\n\ntype CouncilCollective = pallet_collective::Instance1;\nimpl pallet_collective::Config\u003cCouncilCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = CouncilMotionDuration;\n\ttype MaxProposals = CouncilMaxProposals;\n\ttype MaxMembers = CouncilMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const TechnicalMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const TechnicalMaxProposals: u32 = 100;\n\tpub const TechnicalMaxMembers: u32 = 100;\n}\n\ntype TechnicalCollective = pallet_collective::Instance2;\nimpl pallet_collective::Config\u003cTechnicalCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = TechnicalMotionDuration;\n\ttype MaxProposals = TechnicalMaxProposals;\n\ttype MaxMembers = TechnicalMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub MaximumSchedulerWeight: Weight = Perbill::from_percent(80) *\n\t\tRuntimeBlockWeights::get().max_block;\n}\n\nimpl pallet_scheduler::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype PalletsOrigin = OriginCaller;\n\ttype RuntimeCall = RuntimeCall;\n\ttype MaximumWeight = MaximumSchedulerWeight;\n\ttype ScheduleOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype MaxScheduledPerBlock = ConstU32\u003c50\u003e;\n\ttype WeightInfo = pallet_scheduler::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype OriginPrivilegeCmp = EqualPrivilegeOnly;\n\ttype Preimages = Preimage;\n}\n\nparameter_types! {\n\tpub const PreimageMaxSize: u32 = 4096 * 1024;\n\tpub const PreimageBaseDeposit: Balance = 1 * UNIT;\n\t// One cent: $10,000 / MB\n\tpub const PreimageByteDeposit: Balance = 10 * MILLIUNIT;\n}\n\nimpl pallet_preimage::Config for Runtime {\n\ttype WeightInfo = pallet_preimage::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype ManagerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype BaseDeposit = PreimageBaseDeposit;\n\ttype ByteDeposit = PreimageByteDeposit;\n}\n\nparameter_types! {\n\tpub const ProposalBond: Permill = Permill::from_percent(5);\n\tpub const ProposalBondMinimum: Balance = 10 * UNIT;\n\tpub const SpendPeriod: BlockNumber = 7 * DAYS;\n\tpub const Burn: Permill = Permill::from_percent(0);\n\tpub const TreasuryPalletId: PalletId = PalletId(*b\"py/trsry\");\n\tpub const MaxApprovals: u32 = 100;\n}\n\ntype TreasuryApproveOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 3, 5\u003e,\n\u003e;\n\ntype TreasuryRejectOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_treasury::Config for Runtime {\n\ttype PalletId = TreasuryPalletId;\n\ttype Currency = Balances;\n\ttype ApproveOrigin = TreasuryApproveOrigin;\n\ttype RejectOrigin = TreasuryRejectOrigin;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSlash = Treasury;\n\ttype ProposalBond = ProposalBond;\n\ttype ProposalBondMinimum = ProposalBondMinimum;\n\ttype ProposalBondMaximum = ();\n\ttype SpendPeriod = SpendPeriod;\n\ttype Burn = Burn;\n\ttype BurnDestination = ();\n\ttype SpendFunds = Bounties;\n\ttype WeightInfo = pallet_treasury::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxApprovals = MaxApprovals;\n\ttype SpendOrigin = frame_support::traits::NeverEnsureOrigin\u003cu128\u003e;\n}\n\nparameter_types! {\n\tpub const BountyCuratorDeposit: Permill = Permill::from_percent(50);\n\tpub const BountyValueMinimum: Balance = 5 * UNIT;\n\tpub const BountyDepositBase: Balance = 1 * UNIT;\n\tpub const CuratorDepositMultiplier: Permill = Permill::from_percent(50);\n\tpub const CuratorDepositMin: Balance = 1 * UNIT;\n\tpub const CuratorDepositMax: Balance = 100 * UNIT;\n\tpub const DataDepositPerByte: Balance = 30 * MILLIUNIT;\n\tpub const BountyDepositPayoutDelay: BlockNumber = 4 * DAYS;\n\tpub const BountyUpdatePeriod: BlockNumber = 20 * DAYS;\n\tpub const MaximumReasonLength: u32 = 5000;\n}\n\nimpl pallet_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BountyDepositBase = BountyDepositBase;\n\ttype BountyDepositPayoutDelay = BountyDepositPayoutDelay;\n\ttype BountyUpdatePeriod = BountyUpdatePeriod;\n\ttype CuratorDepositMultiplier = CuratorDepositMultiplier;\n\ttype CuratorDepositMin = CuratorDepositMin;\n\ttype CuratorDepositMax = CuratorDepositMax;\n\ttype BountyValueMinimum = BountyValueMinimum;\n\ttype DataDepositPerByte = DataDepositPerByte;\n\ttype MaximumReasonLength = MaximumReasonLength;\n\ttype WeightInfo = pallet_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype ChildBountyManager = ChildBounties;\n}\n\nparameter_types! {\n\tpub const ChildBountyValueMinimum: Balance = 1 * UNIT;\n}\n\nimpl pallet_child_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MaxActiveChildBountyCount = ConstU32\u003c10\u003e;\n\ttype ChildBountyValueMinimum = ChildBountyValueMinimum;\n\ttype WeightInfo = pallet_child_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_type_with_key! {\n\tpub ExistentialDeposits: |_currency_id: CurrencyId| -\u003e Balance {\n\t\tNANOUNIT\n\t};\n}\n\npub fn get_all_module_accounts() -\u003e Vec\u003cAccountId\u003e {\n\tvec![Treasury::account_id()]\n}\n\npub struct DustRemovalWhitelist;\nimpl Contains\u003cAccountId\u003e for DustRemovalWhitelist {\n\tfn contains(a: \u0026AccountId) -\u003e bool {\n\t\tget_all_module_accounts().contains(a)\n\t}\n}\n\npub struct CurrencyHooks\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: orml_tokens::Config\u003e MutationHooks\u003cT::AccountId, T::CurrencyId, T::Balance\u003e\n\tfor CurrencyHooks\u003cT\u003e\n{\n\ttype OnDust = orml_tokens::BurnDust\u003cT\u003e;\n\ttype OnSlash = ();\n\ttype PreDeposit = ();\n\ttype PostDeposit = ();\n\ttype PreTransfer = ();\n\ttype PostTransfer = ();\n\ttype OnNewTokenAccount = ();\n\ttype OnKilledTokenAccount = ();\n}\n\nimpl orml_tokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype Amount = Amount;\n\ttype CurrencyId = CurrencyId;\n\ttype WeightInfo = ();\n\ttype ExistentialDeposits = ExistentialDeposits;\n\ttype CurrencyHooks = CurrencyHooks\u003cRuntime\u003e;\n\ttype MaxLocks = ConstU32\u003c50\u003e;\n\ttype DustRemovalWhitelist = DustRemovalWhitelist;\n\ttype MaxReserves = ConstU32\u003c0\u003e;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const NativeCurrencyId: CurrencyId = CurrencyId::Native;\n}\n\nimpl orml_currencies::Config for Runtime {\n\ttype MultiCurrency = Tokens;\n\ttype NativeCurrency = BasicCurrencyAdapter\u003cRuntime, Balances, Amount, BlockNumber\u003e;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype WeightInfo = ();\n}\n\nimpl orml_asset_registry::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CustomMetadata = asset_registry::CustomMetadata;\n\ttype AssetId = CurrencyId;\n\ttype AuthorityOrigin = asset_registry::AssetAuthority;\n\ttype AssetProcessor = asset_registry::CustomAssetProcessor;\n\ttype Balance = Balance;\n\ttype WeightInfo = weights::orml_asset_registry::WeightInfo\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinBlocksPerRound: BlockNumber = HOURS;\n\tpub const DefaultBlocksPerRound: BlockNumber = 2 * HOURS;\n\tpub const StakeDuration: BlockNumber = 7 * DAYS;\n\tpub const ExitQueueDelay: u32 = 2;\n\tpub const MinCollators: u32 = 8;\n\tpub const MinRequiredCollators: u32 = 2;\n\tpub const MaxDelegationsPerRound: u32 = 1;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxDelegatorsPerCollator: u32 = 40;\n\tpub const MinCollatorStake: Balance = 5_000 * UNIT;\n\tpub const MinDelegatorStake: Balance = 10 * UNIT;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxCollatorCandidates: u32 = 40;\n\tpub const MaxUnstakeRequests: u32 = 10;\n\tpub const NetworkRewardStart: BlockNumber = BlockNumber::MAX;\n\tpub const NetworkRewardRate: Perquintill = Perquintill::from_percent(0);\n\tpub const CollatorRewardRateDecay: Perquintill = Perquintill::from_parts(936_879_853_200_000_000u64);\n}\n\nimpl parachain_staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyBalance = Balance;\n\n\ttype MinBlocksPerRound = MinBlocksPerRound;\n\ttype DefaultBlocksPerRound = DefaultBlocksPerRound;\n\ttype StakeDuration = StakeDuration;\n\ttype ExitQueueDelay = ExitQueueDelay;\n\ttype MinCollators = MinCollators;\n\ttype MinRequiredCollators = MinRequiredCollators;\n\ttype MaxDelegationsPerRound = MaxDelegationsPerRound;\n\ttype MaxDelegatorsPerCollator = MaxDelegatorsPerCollator;\n\ttype MinCollatorStake = MinCollatorStake;\n\ttype MinCollatorCandidateStake = MinCollatorStake;\n\ttype MaxTopCandidates = MaxCollatorCandidates;\n\ttype MinDelegatorStake = MinDelegatorStake;\n\ttype MaxUnstakeRequests = MaxUnstakeRequests;\n\ttype NetworkRewardRate = NetworkRewardRate;\n\ttype NetworkRewardStart = NetworkRewardStart;\n\ttype NetworkRewardBeneficiary = Treasury;\n\ttype CollatorRewardRateDecay = CollatorRewardRateDecay;\n\ttype WeightInfo = parachain_staking::default_weights::SubstrateWeight\u003cRuntime\u003e;\n\n\tconst BLOCKS_PER_YEAR: BlockNumber = BLOCKS_PER_YEAR;\n}\n\nimpl pallet_sudo::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n}\n\nparameter_types! {\n\tpub const DepositBase: Balance = 300 * MILLIUNIT;\n\tpub const DepositFactor: Balance = 50 * MILLIUNIT;\n}\n\nimpl pallet_multisig::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Currency = Balances;\n\ttype DepositBase = DepositBase;\n\ttype DepositFactor = DepositFactor;\n\ttype MaxSignatories = ConstU32\u003c20\u003e;\n\ttype WeightInfo = pallet_multisig::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_utility::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype PalletsOrigin = OriginCaller;\n\ttype WeightInfo = pallet_utility::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinVestedTransfer: Balance = 0;\n\tpub UnvestedFundsAllowedWithdrawReasons: WithdrawReasons =\n\t\tWithdrawReasons::except(WithdrawReasons::TRANSFER | WithdrawReasons::RESERVE);\n}\n\nimpl pallet_vesting::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BlockNumberToBalance = ConvertInto;\n\ttype MinVestedTransfer = MinVestedTransfer;\n\ttype UnvestedFundsAllowedWithdrawReasons = UnvestedFundsAllowedWithdrawReasons;\n\ttype WeightInfo = pallet_vesting::weights::SubstrateWeight\u003cRuntime\u003e;\n\tconst MAX_VESTING_SCHEDULES: u32 = 10;\n}\n\nconst fn deposit(items: u32, bytes: u32) -\u003e Balance {\n\t(items as Balance * UNIT + (bytes as Balance) * (5 * MILLIUNIT / 100)) / 10\n}\n\nparameter_types! {\n\tpub const DepositPerItem: Balance = deposit(1, 0);\n\tpub const DepositPerByte: Balance = deposit(0, 1);\n\tpub const DeletionQueueDepth: u32 = 128;\n\tpub DeletionWeightLimit: Weight = RuntimeBlockWeights::get()\n\t\t.per_class\n\t\t.get(DispatchClass::Normal)\n\t\t.max_total\n\t\t.unwrap_or(RuntimeBlockWeights::get().max_block);\n\tpub Schedule: pallet_contracts::Schedule\u003cRuntime\u003e = pallet_contracts::Schedule::\u003cRuntime\u003e{\n\t\tlimits: pallet_contracts::Limits{\n\t\t\tparameters: 256,\n\t\t\t..Default::default()\n\t\t},\n\t\t..Default::default()\n\t};\n}\n#[derive(Default)]\npub struct Psp22Extension;\n\nuse runtime_common::chain_ext::*;\npub(crate) type BalanceOfForChainExt\u003cT\u003e =\n\t\u003c\u003cT as orml_currencies::Config\u003e::MultiCurrency as orml_traits::MultiCurrency\u003c\n\t\t\u003cT as frame_system::Config\u003e::AccountId,\n\t\u003e\u003e::Balance;\n\nimpl\u003cT\u003e ChainExtension\u003cT\u003e for Psp22Extension\nwhere\n\tT: SysConfig\n\t\t+ orml_tokens::Config\u003cCurrencyId = CurrencyId\u003e\n\t\t+ pallet_contracts::Config\n\t\t+ orml_currencies::Config\u003cMultiCurrency = Tokens, AccountId = AccountId\u003e\n\t\t+ orml_currencies_allowance_extension::Config\n\t\t+ dia_oracle::Config,\n\t\u003cT as SysConfig\u003e::AccountId: UncheckedFrom\u003c\u003cT as SysConfig\u003e::Hash\u003e + AsRef\u003c[u8]\u003e,\n{\n\tfn call\u003cE: Ext\u003e(\u0026mut self, mut env: Environment\u003cE, InitState\u003e) -\u003e Result\u003cRetVal, DispatchError\u003e\n\twhere\n\t\tE: Ext\u003cT = T\u003e,\n\t\t\u003cE::T as SysConfig\u003e::AccountId: UncheckedFrom\u003c\u003cE::T as SysConfig\u003e::Hash\u003e + AsRef\u003c[u8]\u003e,\n\t{\n\t\tlet func_id = env.func_id();\n\n\t\twarn!(\"Calling function with ID {} from Psp22Extension\", func_id);\n\n\t\t// debug_message weight is a good approximation of the additional overhead of going\n\t\t// from contract layer to substrate layer.\n\t\tlet overhead_weight = Weight::from_parts(\n\t\t\t\u003cT as pallet_contracts::Config\u003e::Schedule::get()\n\t\t\t\t.host_fn_weights\n\t\t\t\t.debug_message\n\t\t\t\t.ref_time(),\n\t\t\t0,\n\t\t);\n\n\t\tmatch func_id {\n\t\t\t// totalSupply(currency)\n\t\t\t1101 =\u003e {\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight = \u003cT as frame_system::Config\u003e::DbWeight::get().reads(1);\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet currency_id: CurrencyId = chain_ext::decode(input)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to decode input\"))?;\n\n\t\t\t\twarn!(\"Calling totalSupply() for currency {:?}\", currency_id);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to decode input\")\n\t\t\t\t);\n\n\t\t\t\tlet total_supply =\n\t\t\t\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::total_issuance(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t);\n\n\t\t\t\tenv.write(\u0026total_supply.encode(), false, None).map_err(|_| {\n\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to call total_issuance\")\n\t\t\t\t})?;\n\t\t\t},\n\t\t\t// balanceOf(currency, account)\n\t\t\t1102 =\u003e {\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight = \u003cT as frame_system::Config\u003e::DbWeight::get().reads(1);\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (currency_id, account_id): (CurrencyId, T::AccountId) =\n\t\t\t\t\tchain_ext::decode(input).map_err(|_| {\n\t\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to decode input\")\n\t\t\t\t\t})?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling balanceOf() for currency {:?} and account {:?}\",\n\t\t\t\t\tcurrency_id, account_id\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\",)\n\t\t\t\t);\n\n\t\t\t\tlet balance =\n\t\t\t\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::free_balance(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\t\u0026account_id,\n\t\t\t\t\t);\n\n\t\t\t\tenv.write(\u0026balance.encode(), false, None)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to call balance\"))?;\n\t\t\t},\n\t\t\t// transfer(currency, recipient, amount)\n\t\t\t1103 =\u003e {\n\t\t\t\tlet ext = env.ext();\n\t\t\t\tlet caller = ext.caller().clone();\n\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\t// Here we use weights for non native currency as worst case scenario, since we can't know whether it's native or not until we've already read from contract env.\n\t\t\t\tlet base_weight =\n\t\t\t\t\t\u003cT as orml_currencies::Config\u003e::WeightInfo::transfer_non_native_currency();\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (currency_id, recipient, amount): (\n\t\t\t\t\tCurrencyId,\n\t\t\t\t\tT::AccountId,\n\t\t\t\t\tBalanceOfForChainExt\u003cT\u003e,\n\t\t\t\t) = chain_ext::decode(input)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to decode input\"))?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling transfer() sending {:?} {:?}, from {:?} to {:?}\",\n\t\t\t\t\tamount, currency_id, caller, recipient\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\",)\n\t\t\t\t);\n\n\t\t\t\t\u003corml_currencies::Pallet\u003cT\u003e as MultiCurrency\u003cT::AccountId\u003e\u003e::transfer(\n\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\u0026caller,\n\t\t\t\t\t\u0026recipient,\n\t\t\t\t\tamount,\n\t\t\t\t)?;\n\t\t\t},\n\t\t\t// allowance(currency, owner, spender)\n\t\t\t1104 =\u003e {\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight = \u003cT as frame_system::Config\u003e::DbWeight::get().reads(1);\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (currency_id, owner, spender): (CurrencyId, T::AccountId, T::AccountId) =\n\t\t\t\t\tchain_ext::decode(input).map_err(|_| {\n\t\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to decode input\")\n\t\t\t\t\t})?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling allowance() for currency {:?}, owner {:?} and spender {:?}\",\n\t\t\t\t\tcurrency_id, owner, spender\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\")\n\t\t\t\t);\n\n\t\t\t\tlet allowance = orml_currencies_allowance_extension::Pallet::\u003cT\u003e::allowance(\n\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\u0026owner,\n\t\t\t\t\t\u0026spender,\n\t\t\t\t);\n\n\t\t\t\tenv.write(\u0026allowance.encode(), false, None)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to call balance\"))?;\n\t\t\t},\n\t\t\t// approve(currency, spender, amount)\n\t\t\t1105 =\u003e {\n\t\t\t\tlet ext = env.ext();\n\t\t\t\tlet caller = ext.caller().clone();\n\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight =\n\t\t\t\t\t\u003c\u003cT as AllowanceConfig\u003e::WeightInfo as AllowanceWeightInfo\u003e::approve();\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (currency_id, spender, amount): (\n\t\t\t\t\tCurrencyId,\n\t\t\t\t\tT::AccountId,\n\t\t\t\t\tBalanceOfForChainExt\u003cT\u003e,\n\t\t\t\t) = chain_ext::decode(input)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to decode input\"))?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling approve() allowing spender {:?} to transfer {:?} {:?} from {:?}\",\n\t\t\t\t\tspender, amount, currency_id, caller\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\",)\n\t\t\t\t);\n\n\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::do_approve_transfer(\n\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\u0026caller,\n\t\t\t\t\t\u0026spender,\n\t\t\t\t\tamount,\n\t\t\t\t)?;\n\t\t\t},\n\t\t\t// transfer_from(sender, currency, recipient, amount)\n\t\t\t1106 =\u003e {\n\t\t\t\tlet ext = env.ext();\n\t\t\t\tlet caller = ext.caller().clone();\n\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight =\n\t\t\t\t\t\u003c\u003cT as AllowanceConfig\u003e::WeightInfo as AllowanceWeightInfo\u003e::transfer_from();\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet input = env.read(256)?;\n\t\t\t\tlet (owner, currency_id, recipient, amount): (\n\t\t\t\t\tT::AccountId,\n\t\t\t\t\tCurrencyId,\n\t\t\t\t\tT::AccountId,\n\t\t\t\t\tBalanceOfForChainExt\u003cT\u003e,\n\t\t\t\t) = chain_ext::decode(input)\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"ChainExtension failed to decode input\"))?;\n\n\t\t\t\twarn!(\n\t\t\t\t\t\"Calling transfer_from() for caller {:?}, sending {:?} {:?}, from {:?} to {:?}\",\n\t\t\t\t\tcaller, amount, currency_id, owner, recipient\n\t\t\t\t);\n\n\t\t\t\tensure!(\n\t\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::is_allowed_currency(\n\t\t\t\t\t\tcurrency_id,\n\t\t\t\t\t),\n\t\t\t\t\tDispatchError::Other(\"CurrencyId is not allowed for chain extension\",)\n\t\t\t\t);\n\n\t\t\t\torml_currencies_allowance_extension::Pallet::\u003cT\u003e::do_transfer_approved(\n\t\t\t\t\tcurrency_id,\n\t\t\t\t\t\u0026owner,\n\t\t\t\t\t\u0026caller,\n\t\t\t\t\t\u0026recipient,\n\t\t\t\t\tamount,\n\t\t\t\t)?;\n\t\t\t},\n\n\t\t\t// get_coin_info(blockchain, symbol)\n\t\t\t1200 =\u003e {\n\t\t\t\tlet mut env = env.buf_in_buf_out();\n\t\t\t\tlet base_weight = \u003cT as frame_system::Config\u003e::DbWeight::get().reads(1);\n\t\t\t\tenv.charge_weight(base_weight.saturating_add(overhead_weight))?;\n\t\t\t\tlet (blockchain, symbol): (Blockchain, Symbol) = env.read_as()?;\n\n\t\t\t\tlet result = \u003cdia_oracle::Pallet\u003cT\u003e as DiaOracle\u003e::get_coin_info(\n\t\t\t\t\tblockchain.to_trimmed_vec(),\n\t\t\t\t\tsymbol.to_trimmed_vec(),\n\t\t\t\t);\n\n\t\t\t\twarn!(\"Calling get_coin_info() for: {:?}:{:?}\", blockchain, symbol);\n\n\t\t\t\tlet result = match result {\n\t\t\t\t\tOk(coin_info) =\u003e\n\t\t\t\t\t\tResult::\u003cCoinInfo, ChainExtensionError\u003e::Ok(CoinInfo::from(coin_info)),\n\t\t\t\t\tErr(e) =\u003e\n\t\t\t\t\t\tResult::\u003cCoinInfo, ChainExtensionError\u003e::Err(ChainExtensionError::from(e)),\n\t\t\t\t};\n\t\t\t\tenv.write(\u0026result.encode(), false, None).map_err(|_| {\n\t\t\t\t\tDispatchError::Other(\"ChainExtension failed to call 'price feed'\")\n\t\t\t\t})?;\n\t\t\t},\n\t\t\t_ =\u003e {\n\t\t\t\terror!(\"Called an unregistered `func_id`: {:}\", func_id);\n\t\t\t\treturn Err(DispatchError::Other(\"Unimplemented func_id\"))\n\t\t\t},\n\t\t}\n\n\t\tOk(RetVal::Converging(0))\n\t}\n\n\tfn enabled() -\u003e bool {\n\t\ttrue\n\t}\n}\n\nimpl pallet_contracts::Config for Runtime {\n\ttype Time = Timestamp;\n\ttype Randomness = RandomnessCollectiveFlip;\n\ttype Currency = Balances;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype CallFilter = frame_support::traits::Nothing;\n\ttype DepositPerItem = DepositPerItem;\n\ttype DepositPerByte = DepositPerByte;\n\ttype CallStack = [pallet_contracts::Frame\u003cSelf\u003e; 5];\n\ttype WeightPrice = pallet_transaction_payment::Pallet\u003cSelf\u003e;\n\ttype WeightInfo = pallet_contracts::weights::SubstrateWeight\u003cSelf\u003e;\n\ttype ChainExtension = Psp22Extension;\n\ttype DeletionQueueDepth = DeletionQueueDepth;\n\ttype DeletionWeightLimit = DeletionWeightLimit;\n\ttype Schedule = Schedule;\n\ttype AddressGenerator = pallet_contracts::DefaultAddressGenerator;\n\ttype MaxCodeLen = ConstU32\u003c{ 123 * 1024 }\u003e;\n\ttype MaxStorageKeyLen = ConstU32\u003c128\u003e;\n\ttype UnsafeUnstableInterface = ConstBool\u003ctrue\u003e;\n\ttype MaxDebugBufferLen = ConstU32\u003c{ 2 * 1024 * 1024 }\u003e;\n}\n\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {}\n\nimpl orml_currencies_allowance_extension::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo =\n\t\torml_currencies_allowance_extension::default_weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxAllowedCurrencies = ConstU32\u003c256\u003e;\n}\n\nparameter_types! {\n\tpub const BasicDeposit: Balance = 10 * UNIT;       // 258 bytes on-chain\n\tpub const FieldDeposit: Balance = 25 * MILLIUNIT;  // 66 bytes on-chain\n\tpub const SubAccountDeposit: Balance = 2 * UNIT;   // 53 bytes on-chain\n\tpub const MaxSubAccounts: u32 = 100;\n\tpub const MaxAdditionalFields: u32 = 100;\n\tpub const MaxRegistrars: u32 = 20;\n}\n\ntype EnsureRootOrHalfCouncil = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_identity::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BasicDeposit = BasicDeposit;\n\ttype FieldDeposit = FieldDeposit;\n\ttype SubAccountDeposit = SubAccountDeposit;\n\ttype MaxSubAccounts = MaxSubAccounts;\n\ttype MaxAdditionalFields = MaxAdditionalFields;\n\ttype MaxRegistrars = MaxRegistrars;\n\ttype Slashed = Treasury;\n\ttype ForceOrigin = EnsureRootOrHalfCouncil;\n\ttype RegistrarOrigin = EnsureRootOrHalfCouncil;\n\ttype WeightInfo = pallet_identity::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl dia_oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype AuthorityId = dia_oracle::crypto::DiaAuthId;\n\ttype WeightInfo = dia_oracle::weights::DiaWeightInfo\u003cRuntime\u003e;\n}\n\nimpl frame_system::offchain::SigningTypes for Runtime {\n\ttype Public = \u003cSignature as sp_runtime::traits::Verify\u003e::Signer;\n\ttype Signature = Signature;\n}\n\nimpl\u003cLocalCall\u003e frame_system::offchain::CreateSignedTransaction\u003cLocalCall\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cLocalCall\u003e,\n{\n\tfn create_transaction\u003cC: frame_system::offchain::AppCrypto\u003cSelf::Public, Self::Signature\u003e\u003e(\n\t\tcall: RuntimeCall,\n\t\tpublic: \u003cSignature as sp_runtime::traits::Verify\u003e::Signer,\n\t\taccount: AccountId,\n\t\tindex: Index,\n\t) -\u003e Option\u003c(\n\t\tRuntimeCall,\n\t\t\u003cUncheckedExtrinsic as sp_runtime::traits::Extrinsic\u003e::SignaturePayload,\n\t)\u003e {\n\t\tlet period = BlockHashCount::get() as u64;\n\t\tlet current_block = System::block_number().saturated_into::\u003cu64\u003e().saturating_sub(1);\n\t\tlet tip = 0;\n\t\tlet extra: SignedExtra = (\n\t\t\tframe_system::CheckNonZeroSender::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckSpecVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckTxVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckGenesis::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckEra::\u003cRuntime\u003e::from(generic::Era::mortal(period, current_block)),\n\t\t\tframe_system::CheckNonce::\u003cRuntime\u003e::from(index),\n\t\t\tframe_system::CheckWeight::\u003cRuntime\u003e::new(),\n\t\t\tpallet_transaction_payment::ChargeTransactionPayment::\u003cRuntime\u003e::from(tip),\n\t\t);\n\n\t\tlet raw_payload = SignedPayload::new(call, extra).ok()?;\n\t\tlet signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;\n\t\tlet address = account;\n\t\tlet (call, extra, _) = raw_payload.deconstruct();\n\t\tSome((call, (sp_runtime::MultiAddress::Id(address), signature.into(), extra)))\n\t}\n}\n\npub struct CurrencyConvert;\nimpl currency::CurrencyConversion\u003ccurrency::Amount\u003cRuntime\u003e, CurrencyId\u003e for CurrencyConvert {\n\tfn convert(\n\t\tamount: \u0026currency::Amount\u003cRuntime\u003e,\n\t\tto: CurrencyId,\n\t) -\u003e Result\u003ccurrency::Amount\u003cRuntime\u003e, DispatchError\u003e {\n\t\tOracle::convert(amount, to)\n\t}\n}\n\nparameter_types! {\n\tpub const RelayChainCurrencyId: CurrencyId = XCM(0);\n}\nimpl currency::Config for Runtime {\n\ttype UnsignedFixedPoint = UnsignedFixedPoint;\n\ttype SignedInner = SignedInner;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype Balance = Balance;\n\ttype GetRelayChainCurrencyId = RelayChainCurrencyId;\n\ttype AssetConversion = primitives::AssetConversion;\n\ttype BalanceConversion = primitives::BalanceConversion;\n\ttype CurrencyConversion = CurrencyConvert;\n\ttype AmountCompatibility = primitives::StellarCompatibility;\n}\n\nparameter_types! {\n\tpub const FarmingKeeperPalletId: PalletId = PalletId(*b\"fo/fmkpr\");\n\tpub const FarmingRewardIssuerPalletId: PalletId = PalletId(*b\"fo/fmrir\");\n\tpub FoucocoTreasuryAccount: AccountId = TreasuryPalletId::get().into_account_truncating();\n}\n\nimpl farming::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CurrencyId = CurrencyId;\n\ttype MultiCurrency = Currencies;\n\ttype ControlOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype WeightInfo = farming::weights::BifrostWeight\u003cRuntime\u003e;\n\ttype TreasuryAccount = FoucocoTreasuryAccount;\n\ttype Keeper = FarmingKeeperPalletId;\n\ttype RewardIssuer = FarmingRewardIssuerPalletId;\n}\n\nimpl security::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = security::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype SignedInner = SignedInner;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype CurrencyId = CurrencyId;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub struct DataFeederBenchmark\u003cK, V, A\u003e(PhantomData\u003c(K, V, A)\u003e);\n\n#[cfg(feature = \"runtime-benchmarks\")]\nimpl\u003cK, V, A\u003e orml_traits::DataFeeder\u003cK, V, A\u003e for DataFeederBenchmark\u003cK, V, A\u003e {\n\tfn feed_value(_who: A, _key: K, _value: V) -\u003e DispatchResult {\n\t\tOk(())\n\t}\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nimpl\u003cK, V, A\u003e orml_traits::DataProvider\u003cK, V\u003e for DataFeederBenchmark\u003cK, V, A\u003e {\n\tfn get(_key: \u0026K) -\u003e Option\u003cV\u003e {\n\t\tNone\n\t}\n}\n\nimpl oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = oracle::SubstrateWeight\u003cRuntime\u003e;\n\ttype DataProvider = DataProviderImpl;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype DataFeedProvider = DataFeederBenchmark\u003c\n\t\toracle::OracleKey,\n\t\toracle::TimestampedValue\u003cUnsignedFixedPoint, Moment\u003e,\n\t\tSelf::AccountId,\n\t\u003e;\n}\n\nparameter_types! {\n\tpub const OrganizationLimit: u32 = 255;\n\tpub const ValidatorLimit: u32 = 255;\n\tpub const IsPublicNetwork: bool = false;\n}\n\nimpl stellar_relay::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OrganizationId = u128;\n\ttype OrganizationLimit = OrganizationLimit;\n\ttype ValidatorLimit = ValidatorLimit;\n\ttype IsPublicNetwork = IsPublicNetwork;\n\ttype WeightInfo = stellar_relay::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl reward::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype RewardId = VaultId;\n\ttype CurrencyId = CurrencyId;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n}\n\nparameter_types! {\n\tpub const FeePalletId: PalletId = PalletId(*b\"mod/fees\");\n\tpub const VaultRegistryPalletId: PalletId = PalletId(*b\"mod/vreg\");\n\n\tpub const MaxExpectedValue: UnsignedFixedPoint = UnsignedFixedPoint::from_inner(\u003cUnsignedFixedPoint as FixedPointNumber\u003e::DIV);\n\tpub FeeAccount: AccountId = FeePalletId::get().into_account_truncating();\n}\n\nimpl fee::Config for Runtime {\n\ttype FeePalletId = FeePalletId;\n\ttype WeightInfo = fee::SubstrateWeight\u003cRuntime\u003e;\n\ttype SignedFixedPoint = SignedFixedPoint;\n\ttype SignedInner = SignedInner;\n\ttype UnsignedFixedPoint = UnsignedFixedPoint;\n\ttype UnsignedInner = UnsignedInner;\n\ttype VaultRewards = VaultRewards;\n\ttype VaultStaking = VaultStaking;\n\ttype OnSweep = currency::SweepFunds\u003cRuntime, FeeAccount\u003e;\n\ttype MaxExpectedValue = MaxExpectedValue;\n}\n\nimpl vault_registry::Config for Runtime {\n\ttype PalletId = VaultRegistryPalletId;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype WeightInfo = vault_registry::SubstrateWeight\u003cRuntime\u003e;\n\ttype GetGriefingCollateralCurrencyId = NativeCurrencyId;\n}\n\nimpl redeem::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = redeem::SubstrateWeight\u003cRuntime\u003e;\n}\n\npub struct BlockNumberToBalance;\n\nimpl sp_runtime::traits::Convert\u003cBlockNumber, Balance\u003e for BlockNumberToBalance {\n\tfn convert(a: BlockNumber) -\u003e Balance {\n\t\ta.into()\n\t}\n}\n\nimpl issue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BlockNumberToBalance = BlockNumberToBalance;\n\ttype WeightInfo = issue::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl nomination::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = nomination::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl replace::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype WeightInfo = replace::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl\u003cC\u003e frame_system::offchain::SendTransactionTypes\u003cC\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cC\u003e,\n{\n\ttype Extrinsic = UncheckedExtrinsic;\n\ttype OverarchingCall = RuntimeCall;\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\t// System support stuff.\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 0,\n\t\tParachainSystem: cumulus_pallet_parachain_system::{\n\t\t\tPallet, Call, Config, Storage, Inherent, Event\u003cT\u003e, ValidateUnsigned,\n\t\t} = 1,\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent} = 2,\n\t\tParachainInfo: parachain_info::{Pallet, Storage, Config} = 3,\n\n\t\t// Monetary stuff.\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 10,\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event\u003cT\u003e} = 11,\n\n\t\t// Governance\n\t\tSudo: pallet_sudo::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 12,\n\t\tDemocracy: pallet_democracy::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 13,\n\t\tCouncil: pallet_collective::\u003cInstance1\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e, Event\u003cT\u003e} = 14,\n\t\tTechnicalCommittee: pallet_collective::\u003cInstance2\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e,  Event\u003cT\u003e} = 15,\n\t\tScheduler: pallet_scheduler::{Pallet, Call, Storage, Event\u003cT\u003e} = 16,\n\t\tPreimage: pallet_preimage::{Pallet, Call, Storage, Event\u003cT\u003e} = 17,\n\t\tMultisig: pallet_multisig::{Pallet, Call, Storage, Event\u003cT\u003e} = 18,\n\t\tTreasury: pallet_treasury::{Pallet, Call, Storage, Event\u003cT\u003e} = 19,\n\t\tBounties: pallet_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 20,\n\t\tChildBounties: pallet_child_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 21,\n\n\t\t// Consensus support.\n\t\t// The following order MUST NOT be changed: Aura -\u003e Session -\u003e Staking -\u003e Authorship -\u003e AuraExt\n\t\t// Dependencies: AuraExt on Aura, Authorship and Session on ParachainStaking\n\t\tAura: pallet_aura::{Pallet, Storage, Config\u003cT\u003e} = 33,\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e} = 32,\n\t\tParachainStaking: parachain_staking::{Pallet, Call, Storage, Event\u003cT\u003e, Config\u003cT\u003e} = 35,\n\t\tAuthorship: pallet_authorship::{Pallet, Storage} = 30,\n\t\tAuraExt: cumulus_pallet_aura_ext::{Pallet, Storage, Config} = 34,\n\n\t\t// XCM helpers.\n\t\tXcmpQueue: cumulus_pallet_xcmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 40,\n\t\tPolkadotXcm: pallet_xcm::{Pallet, Call, Event\u003cT\u003e, Origin, Config} = 41,\n\t\tCumulusXcm: cumulus_pallet_xcm::{Pallet, Event\u003cT\u003e, Origin} = 42,\n\t\tDmpQueue: cumulus_pallet_dmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 43,\n\n\t\t// Amendments\n\t\tVesting: pallet_vesting::{Pallet, Call, Storage, Event\u003cT\u003e} = 50,\n\t\tUtility: pallet_utility::{Pallet, Call, Event} = 51,\n\t\tCurrencies: orml_currencies::{Pallet, Call, Storage} = 52,\n\t\tTokens: orml_tokens::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 53,\n\t\tXTokens: orml_xtokens::{Pallet, Storage, Call, Event\u003cT\u003e} = 54,\n\t\tIdentity: pallet_identity::{Pallet, Storage, Call, Event\u003cT\u003e} = 55,\n\t\tContracts: pallet_contracts::{Pallet, Storage, Call, Event\u003cT\u003e} = 56,\n\t\tRandomnessCollectiveFlip: pallet_insecure_randomness_collective_flip::{Pallet, Storage} = 57,\n\t\tDiaOracleModule: dia_oracle::{Pallet, Storage, Call, Config\u003cT\u003e, Event\u003cT\u003e} = 58,\n\n\t\tZenlinkProtocol: zenlink_protocol::{Pallet, Call, Storage, Event\u003cT\u003e}  = 59,\n\n\t\t// Spacewalk pallets\n\t\tCurrency: currency::{Pallet} = 60,\n\t\tFee: fee::{Pallet, Call, Config\u003cT\u003e, Storage} = 61,\n\t\tIssue: issue::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 62,\n\t\tNomination: nomination::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 63,\n\t\tOracle: oracle::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 64,\n\t\tRedeem: redeem::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 65,\n\t\tReplace: replace::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 66,\n\t\tSecurity: security::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 67,\n\t\tStellarRelay: stellar_relay::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 68,\n\t\tVaultRegistry: vault_registry::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e, ValidateUnsigned} = 69,\n\t\tVaultRewards: reward::{Pallet, Call, Storage, Event\u003cT\u003e} = 70,\n\t\tVaultStaking: staking::{Pallet, Storage, Event\u003cT\u003e} = 71,\n\n\t\tTokenAllowance: orml_currencies_allowance_extension::{Pallet, Storage, Call, Event\u003cT\u003e} = 80,\n\n\t\tFarming: farming::{Pallet, Call, Storage, Event\u003cT\u003e} = 90,\n\n\t\t// Asset Metadata\n\t\tAssetRegistry: orml_asset_registry::{Pallet, Storage, Call, Event\u003cT\u003e, Config\u003cT\u003e} = 91,\n\t}\n);\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!(\n\t\t[frame_benchmarking, BaselineBench::\u003cRuntime\u003e]\n\t\t[frame_system, SystemBench::\u003cRuntime\u003e]\n\t\t[pallet_balances, Balances]\n\t\t[pallet_session, SessionBench::\u003cRuntime\u003e]\n\t\t[pallet_timestamp, Timestamp]\n\t\t[cumulus_pallet_xcmp_queue, XcmpQueue]\n\n\t\t[fee, Fee]\n\t\t[issue, Issue]\n\t\t[nomination, Nomination]\n\t\t[oracle, Oracle]\n\t\t[redeem, Redeem]\n\t\t[replace, Replace]\n\t\t[stellar_relay, StellarRelay]\n\t\t[vault_registry, VaultRegistry]\n\n\t\t// Other\n\t\t[orml_asset_registry, runtime_common::benchmarking::orml_asset_registry::Pallet::\u003cRuntime\u003e]\n\t\t[pallet_xcm, PolkadotXcm]\n\n\t\t[orml_currencies_allowance_extension, TokenAllowance]\n\t);\n}\n\nimpl_runtime_apis! {\n\timpl sp_consensus_aura::AuraApi\u003cBlock, AuraId\u003e for Runtime {\n\t\tfn slot_duration() -\u003e sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -\u003e Vec\u003cAuraId\u003e {\n\t\t\tAura::authorities().into_inner()\n\t\t}\n\t}\n\n\timpl sp_api::Core\u003cBlock\u003e for Runtime {\n\t\tfn version() -\u003e RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata\u003cBlock\u003e for Runtime {\n\t\tfn metadata() -\u003e OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder\u003cBlock\u003e for Runtime {\n\t\tfn apply_extrinsic(extrinsic: \u003cBlock as BlockT\u003e::Extrinsic) -\u003e ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -\u003e \u003cBlock as BlockT\u003e::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -\u003e Vec\u003c\u003cBlock as BlockT\u003e::Extrinsic\u003e {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(\u0026block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tblock_hash: \u003cBlock as BlockT\u003e::Hash,\n\t\t) -\u003e TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi\u003cBlock\u003e for Runtime {\n\t\tfn offchain_worker(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys\u003cBlock\u003e for Runtime {\n\t\tfn generate_session_keys(seed: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n\t\t\tSessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec\u003cu8\u003e,\n\t\t) -\u003e Option\u003cVec\u003c(Vec\u003cu8\u003e, KeyTypeId)\u003e\u003e {\n\t\t\tSessionKeys::decode_into_raw_public_keys(\u0026encoded)\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi\u003cBlock, AccountId, Index\u003e for Runtime {\n\t\tfn account_nonce(account: AccountId) -\u003e Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi\u003cBlock, Balance\u003e for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t\tfn query_fee_details(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment::FeeDetails\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t\tfn query_weight_to_fee(weight: Weight) -\u003e Balance {\n\t\t\tTransactionPayment::weight_to_fee(weight)\n\t\t}\n\t\tfn query_length_to_fee(length: u32) -\u003e Balance {\n\t\t\tTransactionPayment::length_to_fee(length)\n\t\t}\n\t}\n\n\timpl cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e for Runtime {\n\t\tfn collect_collation_info(header: \u0026\u003cBlock as BlockT\u003e::Header) -\u003e cumulus_primitives_core::CollationInfo {\n\t\t\tParachainSystem::collect_collation_info(header)\n\t\t}\n\t}\n\n\timpl parachain_staking::runtime_api::ParachainStakingApi\u003cBlock, AccountId, Balance\u003e for Runtime {\n\t\tfn get_unclaimed_staking_rewards(account: \u0026AccountId) -\u003e Balance {\n\t\t\tParachainStaking::get_unclaimed_staking_rewards(account)\n\t\t}\n\n\t\tfn get_staking_rates() -\u003e parachain_staking::runtime_api::StakingRates {\n\t\t\tParachainStaking::get_staking_rates()\n\t\t}\n\t}\n\n\timpl dia_oracle_runtime_api::DiaOracleApi\u003cBlock\u003e for Runtime{\n\t\tfn get_value(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::PriceInfo, sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_value(blockchain, symbol)\n\t\t}\n\n\t\tfn get_coin_info(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::CoinInfo,sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_coin_info(blockchain, symbol)\n\t\t}\n\t}\n\n\n\t// zenlink runtime outer apis\n\timpl zenlink_protocol_runtime_api::ZenlinkProtocolApi\u003cBlock, AccountId, ZenlinkAssetId\u003e for Runtime {\n\n\t\tfn get_balance(\n\t\t\tasset_id: ZenlinkAssetId,\n\t\t\towner: AccountId\n\t\t) -\u003e AssetBalance {\n\t\t\t\u003cRuntime as zenlink_protocol::Config\u003e::MultiAssetsHandler::balance_of(asset_id, \u0026owner)\n\t\t}\n\n\n\t\tfn get_pair_by_asset_id(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId\n\t\t) -\u003e Option\u003cPairInfo\u003cAccountId, AssetBalance, ZenlinkAssetId\u003e\u003e {\n\t\t\tZenlinkProtocol::get_pair_by_asset_id(asset_0, asset_1)\n\t\t}\n\n\t\tfn get_amount_in_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::desired_in_amount(supply, path)\n\t\t}\n\n\t\tfn get_amount_out_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::supply_out_amount(supply, path)\n\t\t}\n\n\t\tfn get_estimate_lptoken(\n\t\t\ttoken_0: ZenlinkAssetId,\n\t\t\ttoken_1: ZenlinkAssetId,\n\t\t\tamount_0_desired: AssetBalance,\n\t\t\tamount_1_desired: AssetBalance,\n\t\t\tamount_0_min: AssetBalance,\n\t\t\tamount_1_min: AssetBalance,\n\t\t) -\u003e AssetBalance{\n\t\t\tZenlinkProtocol::get_estimate_lptoken(\n\t\t\t\ttoken_0,\n\t\t\t\ttoken_1,\n\t\t\t\tamount_0_desired,\n\t\t\t\tamount_1_desired,\n\t\t\t\tamount_0_min,\n\t\t\t\tamount_1_min\n\t\t\t)\n\t\t}\n\n\t\tfn calculate_remove_liquidity(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId,\n\t\t\tamount: AssetBalance,\n\t\t) -\u003e Option\u003c(AssetBalance, AssetBalance)\u003e{\n\t\t\tZenlinkProtocol::calculate_remove_liquidity(\n\t\t\t\tasset_0,\n\t\t\t\tasset_1,\n\t\t\t\tamount,\n\t\t\t)\n\t\t}\n\t}\n\n\timpl farming_rpc_runtime_api::FarmingRuntimeApi\u003cBlock, AccountId, PoolId, CurrencyId\u003e for Runtime {\n\t\tfn get_farming_rewards(who: AccountId, pid: PoolId) -\u003e Vec\u003c(CurrencyId, Balance)\u003e {\n\t\t\tFarming::get_farming_rewards(\u0026who, pid).unwrap_or(Vec::new())\n\t\t}\n\n\t\tfn get_gauge_rewards(who: AccountId, pid: PoolId) -\u003e Vec\u003c(CurrencyId, Balance)\u003e {\n\t\t\tFarming::get_gauge_rewards(\u0026who, pid).unwrap_or(Vec::new())\n\t\t}\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\timpl frame_try_runtime::TryRuntime\u003cBlock\u003e for Runtime {\n\t\tfn on_runtime_upgrade() -\u003e (Weight, Weight) {\n\t\t\tlog::info!(\"try-runtime::on_runtime_upgrade foucoco.\");\n\t\t\tlet weight = Executive::try_runtime_upgrade().unwrap();\n\t\t\t(weight, RuntimeBlockWeights::get().max_block)\n\t\t}\n\n\t\tfn execute_block_no_check(block: Block) -\u003e Weight {\n\t\t\tExecutive::execute_block_no_check(block)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark\u003cBlock\u003e for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -\u003e (\n\t\t\tVec\u003cframe_benchmarking::BenchmarkList\u003e,\n\t\t\tVec\u003cframe_support::traits::StorageInfo\u003e,\n\t\t) {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\tlet mut list = Vec::\u003cBenchmarkList\u003e::new();\n\t\t\tlist_benchmarks!(list, extra);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -\u003e Result\u003cVec\u003cframe_benchmarking::BenchmarkBatch\u003e, sp_runtime::RuntimeString\u003e {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, TrackedStorageKey};\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\t\t\timpl baseline::Config for Runtime {}\n\t\t\timpl runtime_common::benchmarking::orml_asset_registry::Config for Runtime {}\n\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\timpl cumulus_pallet_session_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec\u003cTrackedStorageKey\u003e = vec![\n\t\t\t\t// Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t// Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t// Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t// Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t// System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::\u003cBenchmarkBatch\u003e::new();\n\t\t\tlet params = (\u0026config, \u0026whitelist);\n\t\t\tadd_benchmarks!(params, batches);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n\n\timpl module_issue_rpc_runtime_api::IssueApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tIssueRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_issue_requests(account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tIssue::get_issue_requests_for_account(account_id)\n\t\t}\n\n\t\tfn get_vault_issue_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tIssue::get_issue_requests_for_vault(vault_id)\n\t\t}\n\t}\n\n\timpl module_vault_registry_rpc_runtime_api::VaultRegistryApi\u003c\n\t\tBlock,\n\t\tVaultId,\n\t\tBalance,\n\t\tUnsignedFixedPoint,\n\t\tCurrencyId,\n\t\tAccountId,\n\t\u003e for Runtime {\n\t\tfn get_vault_collateral(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::compute_collateral(\u0026vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\n\t\tfn get_vaults_by_account_id(account_id: AccountId) -\u003e Result\u003cVec\u003cVaultId\u003e, DispatchError\u003e {\n\t\t\tVaultRegistry::get_vaults_by_account_id(account_id)\n\t\t}\n\n\t\tfn get_vault_total_collateral(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_backing_collateral(\u0026vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\n\t\tfn get_premium_redeem_vaults() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_premium_redeem_vaults()?;\n\t\t\tOk(result.iter().map(|v| (v.0.clone(), BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\n\t\tfn get_vaults_with_issuable_tokens() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_vaults_with_issuable_tokens()?;\n\t\t\tOk(result.into_iter().map(|v| (v.0, BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\n\t\tfn get_vaults_with_redeemable_tokens() -\u003e Result\u003cVec\u003c(VaultId, BalanceWrapper\u003cBalance\u003e)\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_vaults_with_redeemable_tokens()?;\n\t\t\tOk(result.into_iter().map(|v| (v.0, BalanceWrapper{amount:v.1.amount()})).collect())\n\t\t}\n\n\t\tfn get_issuable_tokens_from_vault(vault: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_issuable_tokens_from_vault(\u0026vault)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\n\t\tfn get_collateralization_from_vault(vault: VaultId, only_issued: bool) -\u003e Result\u003cUnsignedFixedPoint, DispatchError\u003e {\n\t\t\tVaultRegistry::get_collateralization_from_vault(vault, only_issued)\n\t\t}\n\n\t\tfn get_collateralization_from_vault_and_collateral(vault: VaultId, collateral: BalanceWrapper\u003cBalance\u003e, only_issued: bool) -\u003e Result\u003cUnsignedFixedPoint, DispatchError\u003e {\n\t\t\tlet amount = currency::Amount::new(collateral.amount, vault.collateral_currency());\n\t\t\tVaultRegistry::get_collateralization_from_vault_and_collateral(vault, \u0026amount, only_issued)\n\t\t}\n\n\t\tfn get_required_collateral_for_wrapped(amount_wrapped: BalanceWrapper\u003cBalance\u003e, wrapped_currency_id: CurrencyId, collateral_currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet amount_wrapped = currency::Amount::new(amount_wrapped.amount, wrapped_currency_id);\n\t\t\tlet result = VaultRegistry::get_required_collateral_for_wrapped(\u0026amount_wrapped, collateral_currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\n\t\tfn get_required_collateral_for_vault(vault_id: VaultId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = VaultRegistry::get_required_collateral_for_vault(vault_id)?;\n\t\t\tOk(BalanceWrapper{amount:result.amount()})\n\t\t}\n\t}\n\n\timpl module_redeem_rpc_runtime_api::RedeemApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tRedeemRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_redeem_requests(account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tRedeem::get_redeem_requests_for_account(account_id)\n\t\t}\n\n\t\tfn get_vault_redeem_requests(vault_account_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tRedeem::get_redeem_requests_for_vault(vault_account_id)\n\t\t}\n\t}\n\n\timpl module_replace_rpc_runtime_api::ReplaceApi\u003c\n\t\tBlock,\n\t\tAccountId,\n\t\tH256,\n\t\tReplaceRequest\u003cAccountId, BlockNumber, Balance, CurrencyId\u003e\n\t\u003e for Runtime {\n\t\tfn get_old_vault_replace_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tReplace::get_replace_requests_for_old_vault(vault_id)\n\t\t}\n\n\t\tfn get_new_vault_replace_requests(vault_id: AccountId) -\u003e Vec\u003cH256\u003e {\n\t\t\tReplace::get_replace_requests_for_new_vault(vault_id)\n\t\t}\n\t}\n\n\timpl pallet_contracts::ContractsApi\u003cBlock, AccountId, Balance, BlockNumber, Hash\u003e\n\t\tfor Runtime\n\t{\n\t\tfn call(\n\t\t\torigin: AccountId,\n\t\t\tdest: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tinput_data: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractExecResult\u003cBalance\u003e {\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_call(\n\t\t\t\torigin,\n\t\t\t\tdest,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tinput_data,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT,\n\t\t\t\tpallet_contracts::Determinism::Deterministic,\n\t\t\t)\n\t\t}\n\n\t\tfn instantiate(\n\t\t\torigin: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tcode: pallet_contracts_primitives::Code\u003cHash\u003e,\n\t\t\tdata: Vec\u003cu8\u003e,\n\t\t\tsalt: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractInstantiateResult\u003cAccountId, Balance\u003e\n\t\t{\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_instantiate(\n\t\t\t\torigin,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tcode,\n\t\t\t\tdata,\n\t\t\t\tsalt,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT\n\t\t\t)\n\t\t}\n\n\t\tfn upload_code(\n\t\t\torigin: AccountId,\n\t\t\tcode: Vec\u003cu8\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tdeterminism: pallet_contracts::Determinism,\n\t\t) -\u003e pallet_contracts_primitives::CodeUploadResult\u003cHash, Balance\u003e\n\t\t{\n\t\t\tContracts::bare_upload_code(origin, code, storage_deposit_limit, determinism)\n\t\t}\n\n\t\tfn get_storage(\n\t\t\taddress: AccountId,\n\t\t\tkey: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::GetStorageResult {\n\t\t\tContracts::get_storage(address, key)\n\t\t}\n\t}\n\n\timpl module_oracle_rpc_runtime_api::OracleApi\u003cBlock, Balance, CurrencyId\u003e for Runtime {\n\t\tfn currency_to_usd(amount:BalanceWrapper\u003cBalance\u003e, currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = Oracle::currency_to_usd(amount.amount, currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result})\n\t\t}\n\n\t\tfn usd_to_currency(amount:BalanceWrapper\u003cBalance\u003e, currency_id: CurrencyId) -\u003e Result\u003cBalanceWrapper\u003cBalance\u003e, DispatchError\u003e {\n\t\t\tlet result = Oracle::usd_to_currency(amount.amount, currency_id)?;\n\t\t\tOk(BalanceWrapper{amount:result})\n\t\t}\n\t}\n\n}\n\nstruct CheckInherents;\n\nimpl cumulus_pallet_parachain_system::CheckInherents\u003cBlock\u003e for CheckInherents {\n\tfn check_inherents(\n\t\tblock: \u0026Block,\n\t\trelay_state_proof: \u0026cumulus_pallet_parachain_system::RelayChainStateProof,\n\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\tlet relay_chain_slot = relay_state_proof\n\t\t\t.read_slot()\n\t\t\t.expect(\"Could not read the relay chain slot from the proof\");\n\n\t\tlet inherent_data =\n\t\t\tcumulus_primitives_timestamp::InherentDataProvider::from_relay_chain_slot_and_duration(\n\t\t\t\trelay_chain_slot,\n\t\t\t\tsp_std::time::Duration::from_secs(6),\n\t\t\t)\n\t\t\t.create_inherent_data()\n\t\t\t.expect(\"Could not create the timestamp inherent data\");\n\n\t\tinherent_data.check_extrinsics(block)\n\t}\n}\n\ncumulus_pallet_parachain_system::register_validate_block! {\n\tRuntime = Runtime,\n\tBlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::\u003cRuntime, Executive\u003e,\n\tCheckInherents = CheckInherents,\n}\n","traces":[{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":985,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":986,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":993,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":994,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":995,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":996,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1003,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1019,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1020,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1021,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1026,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1041,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1047,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1048,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1055,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1057,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1058,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1059,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1060,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1061,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1063,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1064,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1065,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1066,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1068,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1070,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1073,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1074,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1075,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1077,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1084,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1088,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1089,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1091,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1092,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1093,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1094,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1095,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1098,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":182},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","block_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Importing a block with 0 Extrinsics.\n\t\tpub const BlockExecutionWeight: Weight =  Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000),0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::BlockExecutionWeight::get();\n\n\t\t\t// At least 100 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 100u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 100 µs.\"\n\t\t\t);\n\t\t\t// At most 50 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= 50u64 * constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 50 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","extrinsic_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Executing a NO-OP `System::remarks` Extrinsic.\n\t\tpub const ExtrinsicBaseWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::ExtrinsicBaseWeight::get();\n\n\t\t\t// At least 10 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 10u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 10 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","mod.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Expose the auto generated weight files.\n\npub mod block_weights;\npub mod extrinsic_weights;\npub mod orml_asset_registry;\npub mod pallet_xcm;\npub mod paritydb_weights;\npub mod rocksdb_weights;\n\npub use block_weights::constants::BlockExecutionWeight;\npub use extrinsic_weights::constants::ExtrinsicBaseWeight;\npub use paritydb_weights::constants::ParityDbWeight;\npub use rocksdb_weights::constants::RocksDbWeight;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","orml_asset_registry.rs"],"content":"\n//! Autogenerated weights for `orml_asset_registry`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-07-25, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Marcels-MBP`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"foucoco\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// foucoco\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet\n// orml-asset-registry\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// runtime/foucoco/src/weights/orml_asset_registry.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `orml_asset_registry`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e orml_asset_registry::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn register_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `104`\n\t\t//  Estimated: `7138`\n\t\t// Minimum execution time: 18_000_000 picoseconds.\n\t\tWeight::from_parts(19_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 7138))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:2)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn update_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `745`\n\t\t//  Estimated: `8420`\n\t\t// Minimum execution time: 25_000_000 picoseconds.\n\t\tWeight::from_parts(26_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8420))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\tfn set_asset_location() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 0_000 picoseconds.\n\t\tWeight::from_parts(0, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","pallet_xcm.rs"],"content":"\n//! Autogenerated weights for `pallet_xcm`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-06-20, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Bs-MacBook-Pro.local`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"foucoco\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// foucoco\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet=pallet-xcm\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// pallet_xcm.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `pallet_xcm`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e pallet_xcm::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn send() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `245`\n\t\t//  Estimated: `10630`\n\t\t// Minimum execution time: 26_000_000 picoseconds.\n\t\tWeight::from_parts(27_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 10630))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: Benchmark Override (r:0 w:0)\n\t/// Proof Skipped: Benchmark Override (max_values: None, max_size: None, mode: Measured)\n\tfn teleport_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 18_446_744_073_709_551_000 picoseconds.\n\t\tWeight::from_parts(18_446_744_073_709_551_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: ParachainInfo ParachainId (r:1 w:0)\n\t/// Proof: ParachainInfo ParachainId (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn reserve_transfer_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 1489))\n\t\t\t.saturating_add(T::DbWeight::get().reads(1))\n\t}\n\tfn execute() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 8_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn force_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\tfn force_default_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 3_000_000 picoseconds.\n\t\tWeight::from_parts(3_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm QueryCounter (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm QueryCounter (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_subscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `245`\n\t\t//  Estimated: `16315`\n\t\t// Minimum execution time: 30_000_000 picoseconds.\n\t\tWeight::from_parts(31_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 16315))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_unsubscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `428`\n\t\t//  Estimated: `15866`\n\t\t// Minimum execution time: 31_000_000 picoseconds.\n\t\tWeight::from_parts(32_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 15866))\n\t\t\t.saturating_add(T::DbWeight::get().reads(6))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_supported_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `229`\n\t\t//  Estimated: `11119`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(17_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11119))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notifiers() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `233`\n\t\t//  Estimated: `11123`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11123))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:5 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn already_notified_target() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `240`\n\t\t//  Estimated: `13605`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 13605))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:2 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn notify_current_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `312`\n\t\t//  Estimated: `17217`\n\t\t// Minimum execution time: 28_000_000 picoseconds.\n\t\tWeight::from_parts(29_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 17217))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:3 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn notify_target_migration_fail() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `272`\n\t\t//  Estimated: `8687`\n\t\t// Minimum execution time: 10_000_000 picoseconds.\n\t\tWeight::from_parts(11_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8687))\n\t\t\t.saturating_add(T::DbWeight::get().reads(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notify_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `240`\n\t\t//  Estimated: `11130`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11130))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn migrate_and_notify_old_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `316`\n\t\t//  Estimated: `22191`\n\t\t// Minimum execution time: 36_000_000 picoseconds.\n\t\tWeight::from_parts(38_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 22191))\n\t\t\t.saturating_add(T::DbWeight::get().reads(9))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","paritydb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights\n\t\t/// are available for brave runtime engineers who may want to try this out as default.\n\t\tpub const ParityDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::ParityDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","weights","rocksdb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// By default, Substrate uses `RocksDB`, so this will be the weight used throughout\n\t\t/// the runtime.\n\t\tpub const RocksDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::RocksDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","xcm_config.rs"],"content":"use super::{\n\tAccountId, Balance, Balances, CurrencyId, ParachainInfo, ParachainSystem, PolkadotXcm, Runtime,\n\tRuntimeCall, RuntimeEvent, RuntimeOrigin, Tokens, WeightToFee, XcmpQueue,\n};\nuse core::marker::PhantomData;\nuse frame_support::{\n\tlog, match_types, parameter_types,\n\ttraits::{ConstU32, ContainsPair, Everything, Nothing},\n};\nuse orml_traits::{\n\tlocation::{RelativeReserveProvider, Reserve},\n\tparameter_type_with_key,\n};\nuse pallet_xcm::XcmPassthrough;\nuse polkadot_parachain::primitives::Sibling;\nuse polkadot_runtime_common::impls::ToAuthor;\nuse sp_runtime::traits::Convert;\nuse xcm::latest::{prelude::*, Weight as XCMWeight};\nuse xcm_builder::{\n\tAccountId32Aliases, AllowUnpaidExecutionFrom, ConvertedConcreteId, CurrencyAdapter,\n\tEnsureXcmOrigin, FixedWeightBounds, FungiblesAdapter, IsConcrete, NoChecking, ParentIsPreset,\n\tRelayChainAsNative, SiblingParachainAsNative, SiblingParachainConvertsVia,\n\tSignedAccountId32AsNative, SignedToAccountId32, SovereignSignedViaLocation, UsingComponents,\n};\nuse xcm_executor::{\n\ttraits::{JustTry, ShouldExecute},\n\tXcmExecutor,\n};\n\nparameter_types! {\n\tpub const RelayLocation: MultiLocation = MultiLocation::parent();\n\tpub const RelayNetwork: NetworkId = NetworkId::Rococo;\n\tpub RelayChainOrigin: RuntimeOrigin = cumulus_pallet_xcm::Origin::Relay.into();\n\tpub Ancestry: MultiLocation = Parachain(ParachainInfo::parachain_id().into()).into();\n\tpub CheckingAccount: AccountId = PolkadotXcm::check_account();\n\tpub UniversalLocation: InteriorMultiLocation =\n\t\tX2(GlobalConsensus(RelayNetwork::get()), Parachain(ParachainInfo::parachain_id().into()));\n}\n\n/// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used\n/// when determining ownership of accounts for asset transacting and when attempting to use XCM\n/// `Transact` in order to determine the dispatch Origin.\npub type LocationToAccountId = (\n\t// The parent (Relay-chain) origin converts to the parent `AccountId`.\n\tParentIsPreset\u003cAccountId\u003e,\n\t// Sibling parachain origins convert to AccountId via the `ParaId::into`.\n\tSiblingParachainConvertsVia\u003cSibling, AccountId\u003e,\n\t// Straight up local `AccountId32` origins just alias directly to `AccountId`.\n\tAccountId32Aliases\u003cRelayNetwork, AccountId\u003e,\n);\n\n/// CurrencyIdConvert\n/// This type implements conversions from our `CurrencyId` type into `MultiLocation` and vice-versa.\n/// A currency locally is identified with a `CurrencyId` variant but in the network it is identified\n/// in the form of a `MultiLocation`, in this case a pCfg (Para-Id, Currency-Id).\npub struct CurrencyIdConvert;\n\nimpl Convert\u003cCurrencyId, Option\u003cMultiLocation\u003e\u003e for CurrencyIdConvert {\n\tfn convert(id: CurrencyId) -\u003e Option\u003cMultiLocation\u003e {\n\t\tmatch id {\n\t\t\t// CurrencyId::KSM =\u003e Some(MultiLocation::parent()),\n\t\t\tCurrencyId::XCM(f) =\u003e match f {\n\t\t\t\t0 =\u003e Some(MultiLocation::parent()),\n\t\t\t\t_ =\u003e None,\n\t\t\t},\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Option\u003cCurrencyId\u003e {\n\t\tmatch location {\n\t\t\tMultiLocation { parents: 1, interior: Here } =\u003e Some(CurrencyId::XCM(0)),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiAsset, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(a: MultiAsset) -\u003e Option\u003cCurrencyId\u003e {\n\t\tif let MultiAsset { id: AssetId::Concrete(id), fun: _ } = a {\n\t\t\tSelf::convert(id)\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\n/// Convert an incoming `MultiLocation` into a `CurrencyId` if possible.\n/// Here we need to know the canonical representation of all the tokens we handle in order to\n/// correctly convert their `MultiLocation` representation into our internal `CurrencyId` type.\nimpl xcm_executor::traits::Convert\u003cMultiLocation, CurrencyId\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Result\u003cCurrencyId, MultiLocation\u003e {\n\t\tif location == MultiLocation::parent() {\n\t\t\treturn Ok(CurrencyId::XCM(0))\n\t\t}\n\t\tErr(location.clone())\n\t}\n}\n\n/// A `FilterAssetLocation` implementation. Filters multi native assets whose\n/// reserve is same with `origin`.\npub struct MultiNativeAsset\u003cReserveProvider\u003e(PhantomData\u003cReserveProvider\u003e);\nimpl\u003cReserveProvider\u003e ContainsPair\u003cMultiAsset, MultiLocation\u003e for MultiNativeAsset\u003cReserveProvider\u003e\nwhere\n\tReserveProvider: Reserve,\n{\n\tfn contains(asset: \u0026MultiAsset, origin: \u0026MultiLocation) -\u003e bool {\n\t\tif let Some(ref reserve) = ReserveProvider::reserve(asset) {\n\t\t\tif reserve == origin {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tfalse\n\t}\n}\n\n/// Means for transacting assets besides the native currency on this chain.\npub type FungiblesTransactor = FungiblesAdapter\u003c\n\t// Use this fungibles implementation\n\tTokens,\n\t// This means that this adapter should handle any token that `CurrencyIdConvert` can convert\n\t// to `CurrencyId`, the `CurrencyId` type of `Tokens`, the fungibles implementation it uses.\n\tConvertedConcreteId\u003cCurrencyId, Balance, CurrencyIdConvert, JustTry\u003e,\n\t// Convert an XCM MultiLocation into a local account id\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly)\n\tAccountId,\n\t// We dont allow teleports.\n\tNoChecking,\n\t// The account to use for tracking teleports.\n\tCheckingAccount,\n\u003e;\n\n/// Means for transacting the native currency on this chain.\npub type CurrencyTransactor = CurrencyAdapter\u003c\n\t// Use this currency:\n\tBalances,\n\t// Use this currency when it is a fungible asset matching the given location or name:\n\tIsConcrete\u003cRelayLocation\u003e,\n\t// Convert an XCM MultiLocation into a local account id:\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly):\n\tAccountId,\n\t// We don't track any teleports of `Balances`.\n\t(),\n\u003e;\n\n/// Means for transacting assets on this chain.\npub type AssetTransactors = (CurrencyTransactor, FungiblesTransactor);\n\n/// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,\n/// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can\n/// biases the kind of local `Origin` it will become.\npub type XcmOriginToTransactDispatchOrigin = (\n\t// Sovereign account converter; this attempts to derive an `AccountId` from the origin location\n\t// using `LocationToAccountId` and then turn that into the usual `Signed` origin. Useful for\n\t// foreign chains who want to have a local sovereign account on this chain which they control.\n\tSovereignSignedViaLocation\u003cLocationToAccountId, RuntimeOrigin\u003e,\n\t// Native converter for Relay-chain (Parent) location; will converts to a `Relay` origin when\n\t// recognized.\n\tRelayChainAsNative\u003cRelayChainOrigin, RuntimeOrigin\u003e,\n\t// Native converter for sibling Parachains; will convert to a `SiblingPara` origin when\n\t// recognized.\n\tSiblingParachainAsNative\u003ccumulus_pallet_xcm::Origin, RuntimeOrigin\u003e,\n\t// Native signed account converter; this just converts an `AccountId32` origin into a normal\n\t// `Origin::Signed` origin of the same 32-byte value.\n\tSignedAccountId32AsNative\u003cRelayNetwork, RuntimeOrigin\u003e,\n\t// Xcm origins can be represented natively under the Xcm pallet's Xcm origin.\n\tXcmPassthrough\u003cRuntimeOrigin\u003e,\n);\n\nparameter_types! {\n\t// One XCM operation is 1_000_000_000 weight - almost certainly a conservative estimate.\n\tpub UnitWeightCost: XCMWeight = XCMWeight::from_parts(1_000_000_000,0);\n\tpub const MaxInstructions: u32 = 100;\n\tpub SelfLocation: MultiLocation = MultiLocation::new(1, X1(Parachain(ParachainInfo::parachain_id().into())));\n\tpub const BaseXcmWeight: XCMWeight = XCMWeight::from_parts(150_000_000, 0);\n\tpub const MaxAssetsForTransfer: usize = 2;\n}\n\nmatch_types! {\n\tpub type ParentOrParentsExecutivePlurality: impl Contains\u003cMultiLocation\u003e = {\n\t\tMultiLocation { parents: 1, interior: Here } |\n\t\tMultiLocation { parents: 1, interior: X1(Plurality { id: BodyId::Executive, .. }) }\n\t};\n}\n\n//TODO: move DenyThenTry to polkadot's xcm module.\n/// Deny executing the xcm message if it matches any of the Deny filter regardless of anything else.\n/// If it passes the Deny, and matches one of the Allow cases then it is let through.\npub struct DenyThenTry\u003cDeny, Allow\u003e(PhantomData\u003cDeny\u003e, PhantomData\u003cAllow\u003e)\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute;\n\nimpl\u003cDeny, Allow\u003e ShouldExecute for DenyThenTry\u003cDeny, Allow\u003e\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute,\n{\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\tmax_weight: XCMWeight,\n\t\tweight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tDeny::should_execute(origin, instructions, max_weight, weight_credit)?;\n\t\tAllow::should_execute(origin, instructions, max_weight, weight_credit)\n\t}\n}\n\n// See issue #5233\npub struct DenyReserveTransferToRelayChain;\nimpl ShouldExecute for DenyReserveTransferToRelayChain {\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\t_max_weight: XCMWeight,\n\t\t_weight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tif instructions.iter().any(|inst| {\n\t\t\tmatches!(\n\t\t\t\tinst,\n\t\t\t\tInitiateReserveWithdraw {\n\t\t\t\t\treserve: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t..\n\t\t\t\t} | DepositReserveAsset { dest: MultiLocation { parents: 1, interior: Here }, .. } |\n\t\t\t\t\tTransferReserveAsset {\n\t\t\t\t\t\tdest: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t\t..\n\t\t\t\t\t}\n\t\t\t)\n\t\t}) {\n\t\t\treturn Err(()) // Deny\n\t\t}\n\n\t\t// allow reserve transfers to arrive from relay chain\n\t\tif matches!(origin, MultiLocation { parents: 1, interior: Here }) \u0026\u0026\n\t\t\tinstructions.iter().any(|inst| matches!(inst, ReserveAssetDeposited { .. }))\n\t\t{\n\t\t\tlog::warn!(\n\t\t\t\ttarget: \"xcm::barriers\",\n\t\t\t\t\"Unexpected ReserveAssetDeposited from the relay chain\",\n\t\t\t);\n\t\t}\n\t\t// Permit everything else\n\t\tOk(())\n\t}\n}\n\npub type Barrier = AllowUnpaidExecutionFrom\u003cEverything\u003e;\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n\ttype RuntimeCall = RuntimeCall;\n\ttype XcmSender = XcmRouter;\n\t// How to withdraw and deposit an asset.\n\ttype AssetTransactor = AssetTransactors;\n\ttype OriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype IsReserve = MultiNativeAsset\u003cRelativeReserveProvider\u003e;\n\t// Teleporting is disabled.\n\ttype IsTeleporter = ();\n\ttype UniversalLocation = UniversalLocation;\n\ttype Barrier = Barrier;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype Trader =\n\t\tUsingComponents\u003cWeightToFee, RelayLocation, AccountId, Balances, ToAuthor\u003cRuntime\u003e\u003e;\n\ttype ResponseHandler = PolkadotXcm;\n\ttype AssetTrap = PolkadotXcm;\n\ttype AssetLocker = ();\n\ttype AssetExchanger = ();\n\ttype AssetClaims = PolkadotXcm;\n\ttype SubscriptionService = PolkadotXcm;\n\ttype PalletInstancesInfo = crate::AllPalletsWithSystem;\n\ttype MaxAssetsIntoHolding = ConstU32\u003c8\u003e;\n\ttype FeeManager = ();\n\ttype MessageExporter = ();\n\ttype UniversalAliases = Nothing;\n\ttype CallDispatcher = RuntimeCall;\n\ttype SafeCallFilter = Everything;\n}\n\n/// No local origins on this chain are allowed to dispatch XCM sends/executions.\npub type LocalOriginToLocation = SignedToAccountId32\u003cRuntimeOrigin, AccountId, RelayNetwork\u003e;\n\n/// The means for routing XCM messages which are not for local execution into the right message\n/// queues.\npub type XcmRouter = (\n\t// Two routers - use UMP to communicate with the relay chain:\n\tcumulus_primitives_utility::ParentAsUmp\u003cParachainSystem, PolkadotXcm, ()\u003e,\n\t// ..and XCMP to communicate with the sibling chains.\n\tXcmpQueue,\n);\n\nimpl pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyMatcher = ();\n\ttype SendXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmRouter = XcmRouter;\n\ttype ExecuteXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmExecuteFilter = Everything;\n\t// ^ Disable dispatchable execute on the XCM pallet.\n\t// Needs to be `Everything` for local testing.\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype XcmTeleportFilter = Nothing;\n\ttype XcmReserveTransferFilter = Everything;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype UniversalLocation = UniversalLocation;\n\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\n\tconst VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;\n\t// ^ Override for AdvertisedXcmVersion default\n\ttype AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;\n\ttype TrustedLockers = ();\n\ttype SovereignAccountOf = LocationToAccountId;\n\ttype MaxLockers = ConstU32\u003c8\u003e;\n\ttype WeightInfo = crate::weights::pallet_xcm::WeightInfo\u003cRuntime\u003e;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype ReachableDest = ReachableDest;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nparameter_types! {\n\tpub ReachableDest: Option\u003cMultiLocation\u003e = Some(Parent.into());\n}\n\nparameter_type_with_key! {\n\tpub ParachainMinFee: |_location: MultiLocation| -\u003e Option\u003cu128\u003e {\n\t\tNone\n\t};\n}\n\nimpl orml_xtokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype CurrencyId = CurrencyId;\n\ttype CurrencyIdConvert = CurrencyIdConvert;\n\ttype AccountIdToMultiLocation = AccountIdToMultiLocation;\n\ttype SelfLocation = SelfLocation;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype BaseXcmWeight = BaseXcmWeight;\n\ttype MaxAssetsForTransfer = MaxAssetsForTransfer;\n\ttype MinXcmFee = ParachainMinFee; //TODO to support hrmp transfer beetween parachain adjust this parameter\n\ttype MultiLocationsFilter = Everything;\n\ttype ReserveProvider = RelativeReserveProvider;\n\ttype UniversalLocation = UniversalLocation;\n}\n\npub struct AccountIdToMultiLocation;\nimpl Convert\u003cAccountId, MultiLocation\u003e for AccountIdToMultiLocation {\n\tfn convert(account: AccountId) -\u003e MultiLocation {\n\t\tMultiLocation {\n\t\t\tparents: 0,\n\t\t\tinterior: X1(AccountId32 { network: None, id: account.into() }),\n\t\t}\n\t}\n}\n\nimpl cumulus_pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n}\n","traces":[{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","marcel","Documents","pendulum","runtime","foucoco","src","zenlink.rs"],"content":"use core::convert::TryInto;\n\nuse super::*;\n\nuse orml_traits::MultiCurrency;\nuse sp_runtime::{DispatchError, DispatchResult};\nuse sp_std::marker::PhantomData;\n\nuse spacewalk_primitives::CurrencyId;\n\nuse zenlink_protocol::{\n\tAssetId, Config as ZenlinkConfig, GenerateLpAssetId, LocalAssetHandler, ZenlinkMultiAssets,\n};\npub type ZenlinkAssetId = zenlink_protocol::AssetId;\n\nuse runtime_common::{zenlink, zenlink::*};\n\npub struct ZenlinkLPGenerate\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: ZenlinkConfig\u003e GenerateLpAssetId\u003cZenlinkAssetId\u003e for ZenlinkLPGenerate\u003cT\u003e {\n\tfn generate_lp_asset_id(\n\t\tasset_0: ZenlinkAssetId,\n\t\tasset_1: ZenlinkAssetId,\n\t) -\u003e Option\u003cZenlinkAssetId\u003e {\n\t\tzenlink::generate_lp_asset_id(asset_0, asset_1, ParachainInfo::parachain_id().into())\n\t}\n}\n\nparameter_types! {\n\tpub SelfParaId: u32 = ParachainInfo::parachain_id().into();\n\tpub const ZenlinkPalletId: PalletId = PalletId(*b\"/zenlink\");\n\tpub ZenlinkRegisteredParaChains: Vec\u003c(MultiLocation, u128)\u003e = vec![];\n}\nimpl ZenlinkConfig for Runtime {\n\ttype RuntimeEvent = super::RuntimeEvent;\n\ttype MultiAssetsHandler = MultiAssets;\n\ttype PalletId = ZenlinkPalletId;\n\ttype AssetId = AssetId;\n\ttype LpGenerate = ZenlinkLPGenerate\u003cSelf\u003e;\n\ttype TargetChains = ZenlinkRegisteredParaChains;\n\ttype SelfParaId = SelfParaId;\n\ttype WeightInfo = ();\n}\n\ntype MultiAssets = ZenlinkMultiAssets\u003cZenlinkProtocol, Balances, LocalAssetAdaptor\u003cTokens\u003e\u003e;\n\npub struct LocalAssetAdaptor\u003cLocal\u003e(PhantomData\u003cLocal\u003e);\n\nimpl\u003cLocal, AccountId\u003e LocalAssetHandler\u003cAccountId\u003e for LocalAssetAdaptor\u003cLocal\u003e\nwhere\n\tLocal: MultiCurrency\u003cAccountId, CurrencyId = CurrencyId\u003e,\n{\n\tfn local_balance_of(asset_id: ZenlinkAssetId, who: \u0026AccountId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::free_balance(currency_id, \u0026who))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_total_supply(asset_id: ZenlinkAssetId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::total_issuance(currency_id))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_is_exists(asset_id: ZenlinkAssetId) -\u003e bool {\n\t\tmatch zenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into()) {\n\t\t\tOk(_) =\u003e true,\n\t\t\tErr(_) =\u003e false,\n\t\t}\n\t}\n\n\tfn local_transfer(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\ttarget: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e DispatchResult {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::transfer(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\t\u0026target,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local transfer\"))?,\n\t\t\t)\n\t\t} else {\n\t\t\tErr(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\t}\n\n\tfn local_deposit(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::deposit(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local deposit\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n\n\tfn local_withdraw(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::withdraw(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local withdraw\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":44},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","amplitude_tests.rs"],"content":"use crate::{\n\tmock::{kusama_relay_ext, para_ext, ParachainType, USDT_ASSET_ID},\n\ttest_macros::{\n\t\tparachain1_transfer_asset_to_parachain2, parachain1_transfer_asset_to_parachain2_and_back,\n\t\tparachain1_transfer_incorrect_asset_to_parachain2_should_fail,\n\t\ttransfer_10_relay_token_from_parachain_to_relay_chain,\n\t\ttransfer_20_relay_token_from_relay_chain_to_parachain,\n\t},\n\tAMPLITUDE_ID, KUSAMA_ASSETHUB_ID,\n};\n\nuse frame_support::assert_ok;\nuse statemine_runtime as kusama_asset_hub_runtime;\nuse xcm::latest::NetworkId;\nuse xcm_emulator::{decl_test_network, decl_test_parachain, decl_test_relay_chain, TestExt};\n\nconst KSM_FEE_WHEN_TRANSFER_TO_PARACHAIN: polkadot_core_primitives::Balance = 3200000000;\n\ndecl_test_relay_chain! {\n\tpub struct KusamaRelay {\n\t\tRuntime = kusama_runtime::Runtime,\n\t\tXcmConfig = kusama_runtime::xcm_config::XcmConfig,\n\t\tnew_ext = kusama_relay_ext(),\n\t}\n}\n\ndecl_test_parachain! {\n\tpub struct AmplitudeParachain {\n\t\tRuntime = amplitude_runtime::Runtime,\n\t\tRuntimeOrigin = amplitude_runtime::RuntimeOrigin,\n\t\tXcmpMessageHandler = amplitude_runtime::XcmpQueue,\n\t\tDmpMessageHandler = amplitude_runtime::DmpQueue,\n\t\tnew_ext = para_ext(ParachainType::Amplitude),\n\t}\n}\n\ndecl_test_parachain! {\n\tpub struct AssetHubParachain {\n\t\tRuntime = kusama_asset_hub_runtime::Runtime,\n\t\tRuntimeOrigin = kusama_asset_hub_runtime::RuntimeOrigin,\n\t\tXcmpMessageHandler = kusama_asset_hub_runtime::XcmpQueue,\n\t\tDmpMessageHandler = kusama_asset_hub_runtime::DmpQueue,\n\t\tnew_ext = para_ext(ParachainType::KusamaAssetHub),\n\t}\n}\n\ndecl_test_network! {\n\tpub struct KusamaMockNet {\n\t\trelay_chain = KusamaRelay,\n\t\tparachains = vec![\n\t\t\t(1000, AssetHubParachain),\n\t\t\t(2124, AmplitudeParachain),\n\t\t],\n\t}\n}\n\n#[test]\nfn transfer_ksm_from_kusama_to_amplitude() {\n\ttransfer_20_relay_token_from_relay_chain_to_parachain!(\n\t\tKusamaMockNet,\n\t\tkusama_runtime,\n\t\tKusamaRelay,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain,\n\t\tAMPLITUDE_ID,\n\t\tKSM_FEE_WHEN_TRANSFER_TO_PARACHAIN\n\t);\n}\n\n#[test]\nfn transfer_ksm_from_amplitude_to_kusama() {\n\ttransfer_10_relay_token_from_parachain_to_relay_chain!(\n\t\tKusamaMockNet,\n\t\tkusama_runtime,\n\t\tKusamaRelay,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain\n\t);\n}\n\n#[test]\nfn assethub_transfer_incorrect_asset_to_amplitude_should_fail() {\n\tparachain1_transfer_incorrect_asset_to_parachain2_should_fail!(\n\t\tkusama_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain,\n\t\tAMPLITUDE_ID\n\t);\n}\n\n#[test]\nfn assethub_transfer_asset_to_amplitude() {\n\tparachain1_transfer_asset_to_parachain2!(\n\t\tkusama_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tUSDT_ASSET_ID,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain,\n\t\tAMPLITUDE_ID\n\t);\n}\n\n#[test]\nfn assethub_transfer_asset_to_amplitude_and_back() {\n\tlet network_id = NetworkId::Kusama;\n\n\tparachain1_transfer_asset_to_parachain2_and_back!(\n\t\tkusama_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tKUSAMA_ASSETHUB_ID,\n\t\tUSDT_ASSET_ID,\n\t\tamplitude_runtime,\n\t\tAmplitudeParachain,\n\t\tAMPLITUDE_ID,\n\t\tnetwork_id\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","lib.rs"],"content":"#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod pendulum_tests;\n\n#[cfg(test)]\nmod amplitude_tests;\n\n#[cfg(test)]\nmod test_macros;\n\npub const PENDULUM_ID: u32 = 2094;\npub const POLKADOT_ASSETHUB_ID: u32 = 1000;\n\npub const AMPLITUDE_ID: u32 = 2124;\npub const KUSAMA_ASSETHUB_ID: u32 = 1000;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","mock.rs"],"content":"use crate::{AMPLITUDE_ID, PENDULUM_ID, KUSAMA_ASSETHUB_ID, POLKADOT_ASSETHUB_ID};\nuse frame_support::traits::GenesisBuild;\nuse pendulum_runtime::CurrencyId;\nuse polkadot_core_primitives::{AccountId, Balance, BlockNumber};\nuse polkadot_parachain::primitives::Id as ParaId;\nuse polkadot_primitives::v2::{MAX_CODE_SIZE, MAX_POV_SIZE};\nuse polkadot_runtime_parachains::configuration::HostConfiguration;\nuse sp_io::TestExternalities;\nuse sp_runtime::traits::AccountIdConversion;\nuse xcm_emulator::Weight;\n\nuse statemint_runtime as polkadot_asset_hub_runtime;\nuse statemine_runtime as kusama_asset_hub_runtime;\n\npub const ALICE: [u8; 32] = [4u8; 32];\npub const BOB: [u8; 32] = [5u8; 32];\n\npub const UNIT: Balance = 1_000_000_000_000;\npub const TEN_UNITS: Balance = 10_000_000_000_000;\n\npub const USDT_ASSET_ID: u32 = 1984; //Real USDT Asset ID of both Polkadot's and Kusama's Asset Hub\npub const INCORRECT_ASSET_ID: u32 = 0; //asset id that pendulum/amplitude does NOT SUPPORT\n\npub const INITIAL_BALANCE: Balance = 1_000_000_000;\npub const ORML_INITIAL_BALANCE: Balance = 100;\n\nmacro_rules! create_test_externalities {\n\t($runtime:ty, $system:ident, $storage:ident) =\u003e {{\n\t\t\u003cpallet_xcm::GenesisConfig as GenesisBuild\u003c$runtime\u003e\u003e::assimilate_storage(\n\t\t\t\u0026pallet_xcm::GenesisConfig { safe_xcm_version: Some(2) },\n\t\t\t\u0026mut $storage,\n\t\t)\n\t\t.unwrap();\n\t\tlet mut ext = sp_io::TestExternalities::new($storage);\n\t\text.execute_with(|| $system::set_block_number(1));\n\t\text\n\t}};\n}\n\nmacro_rules! build_relaychain {\n\t($runtime:ty, $system:tt, $para_account_id: ident) =\u003e {{\n\t\tlet mut t = frame_system::GenesisConfig::default().build_storage::\u003c$runtime\u003e().unwrap();\n\t\tpallet_balances::GenesisConfig::\u003c$runtime\u003e {\n\t\t\tbalances: vec![\n\t\t\t\t(AccountId::from(ALICE), units(100000)),\n\t\t\t\t(AccountId::from(BOB), units(100)),\n\t\t\t\t(para_account_id($para_account_id), 10 * units(100000)),\n\t\t\t],\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.unwrap();\n\t\tpolkadot_runtime_parachains::configuration::GenesisConfig::\u003c$runtime\u003e {\n\t\t\tconfig: default_parachains_host_configuration(),\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.unwrap();\n\n\t\tcreate_test_externalities!($runtime, $system, t)\n\t}};\n}\n\nmacro_rules! build_parachain_with_orml {\n\t($self:ident, $runtime:ty, $system:tt, $balance:tt, $orml_balance:tt) =\u003e {{\n\t\tlet mut t = frame_system::GenesisConfig::default().build_storage::\u003c$runtime\u003e().unwrap();\n\t\tpallet_balances::GenesisConfig::\u003c$runtime\u003e {\n\t\t\tbalances: vec![(AccountId::from(ALICE), $balance), (AccountId::from(BOB), $balance)],\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.unwrap();\n\n\t\torml_tokens::GenesisConfig::\u003c$runtime\u003e {\n\t\t\tbalances: vec![(AccountId::from(BOB), CurrencyId::XCM(0), units($orml_balance))],\n\t\t}\n\t\t.assimilate_storage(\u0026mut t)\n\t\t.unwrap();\n\n\t\tbuild_parachain!($self, $runtime, $system, t)\n\t}};\n}\n\nmacro_rules! build_parachain {\n\t($self:ident, $runtime:ty, $system:tt) =\u003e {{\n\t\tlet mut t = frame_system::GenesisConfig::default().build_storage::\u003c$runtime\u003e().unwrap();\n\n\t\tpallet_balances::GenesisConfig::\u003c$runtime\u003e { balances: vec![] }\n\t\t\t.assimilate_storage(\u0026mut t)\n\t\t\t.unwrap();\n\n\t\tbuild_parachain!($self, $runtime, $system, t)\n\t}};\n\n\t($self:ident, $runtime:ty, $system:tt, $storage:ident) =\u003e {{\n\t\t\u003cparachain_info::GenesisConfig as GenesisBuild\u003c$runtime\u003e\u003e::assimilate_storage(\n\t\t\t\u0026parachain_info::GenesisConfig { parachain_id: $self.get_parachain_id().into() },\n\t\t\t\u0026mut $storage,\n\t\t)\n\t\t.unwrap();\n\n\t\tcreate_test_externalities!($runtime, $system, $storage)\n\t}};\n}\n\npub trait Builder\u003cCurrency\u003e {\n\tfn balances(self, balances: Vec\u003c(AccountId, Currency, Balance)\u003e) -\u003e Self;\n\tfn build(self) -\u003e TestExternalities;\n}\n\npub enum ParachainType {\n\tPolkadotAssetHub,\n\tKusamaAssetHub,\n\tPendulum,\n\tAmplitude,\n}\n\npub struct ExtBuilderParachain\u003cCurrency\u003e {\n\tbalances: Vec\u003c(AccountId, Currency, Balance)\u003e,\n\tchain: ParachainType,\n}\n\npub fn units(amount: Balance) -\u003e Balance {\n\tamount * 10u128.saturating_pow(9)\n}\n\npub fn para_account_id(id: u32) -\u003e polkadot_core_primitives::AccountId {\n\tParaId::from(id).into_account_truncating()\n}\n\npub fn polkadot_relay_ext() -\u003e sp_io::TestExternalities {\n\tuse polkadot_runtime::{Runtime, System};\n\tbuild_relaychain!(Runtime, System, PENDULUM_ID)\n}\n\npub fn kusama_relay_ext() -\u003e sp_io::TestExternalities {\n\tuse kusama_runtime::{Runtime, System};\n\tbuild_relaychain!(Runtime, System, AMPLITUDE_ID)\n}\n\nfn default_parachains_host_configuration() -\u003e HostConfiguration\u003cBlockNumber\u003e {\n\tHostConfiguration {\n\t\tminimum_validation_upgrade_delay: 5,\n\t\tvalidation_upgrade_cooldown: 5u32,\n\t\tvalidation_upgrade_delay: 5,\n\t\tcode_retention_period: 1200,\n\t\tmax_code_size: MAX_CODE_SIZE,\n\t\tmax_pov_size: MAX_POV_SIZE,\n\t\tmax_head_data_size: 32 * 1024,\n\t\tgroup_rotation_frequency: 20,\n\t\tchain_availability_period: 4,\n\t\tthread_availability_period: 4,\n\t\tmax_upward_queue_count: 8,\n\t\tmax_upward_queue_size: 1024 * 1024,\n\t\tmax_downward_message_size: 1024,\n\t\tump_service_total_weight: Weight::from_parts(4 * 1_000_000_000, 0),\n\t\tmax_upward_message_size: 50 * 1024,\n\t\tmax_upward_message_num_per_candidate: 5,\n\t\thrmp_sender_deposit: 0,\n\t\thrmp_recipient_deposit: 0,\n\t\thrmp_channel_max_capacity: 8,\n\t\thrmp_channel_max_total_size: 8 * 1024,\n\t\thrmp_max_parachain_inbound_channels: 4,\n\t\thrmp_max_parathread_inbound_channels: 4,\n\t\thrmp_channel_max_message_size: 1024 * 1024,\n\t\thrmp_max_parachain_outbound_channels: 4,\n\t\thrmp_max_parathread_outbound_channels: 4,\n\t\thrmp_max_message_num_per_candidate: 5,\n\t\tdispute_period: 6,\n\t\tno_show_slots: 2,\n\t\tn_delay_tranches: 25,\n\t\tneeded_approvals: 2,\n\t\trelay_vrf_modulo_samples: 2,\n\t\tzeroth_delay_tranche_width: 0,\n\t\t..Default::default()\n\t}\n}\n\npub fn para_ext(chain: ParachainType) -\u003e sp_io::TestExternalities {\n\tmatch chain {\n\t\tParachainType::PolkadotAssetHub =\u003e\n\t\t\tExtBuilderParachain::polkadot_asset_hub_default().balances(vec![]).build(),\n\t\tParachainType::KusamaAssetHub =\u003e\n\t\t\tExtBuilderParachain::kusama_asset_hub_default().balances(vec![]).build(),\n\t\tParachainType::Pendulum =\u003e ExtBuilderParachain::pendulum_default().balances(vec![]).build(),\n\t\tParachainType::Amplitude =\u003e\n\t\t\tExtBuilderParachain::amplitude_default().balances(vec![]).build(),\n\t}\n}\n\nimpl\u003cCurrency\u003e ExtBuilderParachain\u003cCurrency\u003e {\n\tfn get_parachain_id(\u0026self) -\u003e u32 {\n\t\tmatch self.chain {\n\t\t\tParachainType::PolkadotAssetHub =\u003e POLKADOT_ASSETHUB_ID,\n\t\t\tParachainType::KusamaAssetHub =\u003e KUSAMA_ASSETHUB_ID,\n\t\t\tParachainType::Pendulum =\u003e PENDULUM_ID,\n\t\t\tParachainType::Amplitude =\u003e AMPLITUDE_ID,\n\t\t}\n\t}\n}\n\n// ------------------- for Pendulum and Amplitude -------------------\nimpl ExtBuilderParachain\u003cCurrencyId\u003e {\n\tpub fn pendulum_default() -\u003e Self {\n\t\tSelf { balances: vec![], chain: ParachainType::Pendulum }\n\t}\n\n\tpub fn amplitude_default() -\u003e Self {\n\t\tSelf { balances: vec![], chain: ParachainType::Amplitude }\n\t}\n}\n\nimpl Builder\u003cCurrencyId\u003e for ExtBuilderParachain\u003cCurrencyId\u003e {\n\tfn balances(mut self, balances: Vec\u003c(AccountId, CurrencyId, Balance)\u003e) -\u003e Self {\n\t\tself.balances = balances;\n\t\tself\n\t}\n\n\tfn build(self) -\u003e TestExternalities {\n\t\tmatch self.chain {\n\t\t\tParachainType::Pendulum =\u003e {\n\t\t\t\tuse pendulum_runtime::{Runtime, System};\n\t\t\t\tbuild_parachain_with_orml!(\n\t\t\t\t\tself,\n\t\t\t\t\tRuntime,\n\t\t\t\t\tSystem,\n\t\t\t\t\tINITIAL_BALANCE,\n\t\t\t\t\tORML_INITIAL_BALANCE\n\t\t\t\t)\n\t\t\t},\n\t\t\tParachainType::Amplitude =\u003e {\n\t\t\t\tuse amplitude_runtime::{Runtime, System};\n\t\t\t\tbuild_parachain_with_orml!(\n\t\t\t\t\tself,\n\t\t\t\t\tRuntime,\n\t\t\t\t\tSystem,\n\t\t\t\t\tINITIAL_BALANCE,\n\t\t\t\t\tORML_INITIAL_BALANCE\n\t\t\t\t)\n\t\t\t},\n\t\t\t_ =\u003e panic!(\"cannot use this chain to build\"),\n\t\t}\n\t}\n}\n\n// ------------------- for Statemint and Statemine -------------------\nimpl ExtBuilderParachain\u003cu128\u003e {\n\tpub fn polkadot_asset_hub_default() -\u003e Self {\n\t\tSelf { balances: vec![], chain: ParachainType::PolkadotAssetHub }\n\t}\n\n\tpub fn kusama_asset_hub_default() -\u003e Self {\n\t\tSelf { balances: vec![], chain: ParachainType::KusamaAssetHub }\n\t}\n}\n\nimpl Builder\u003cu128\u003e for ExtBuilderParachain\u003cu128\u003e {\n\tfn balances(mut self, balances: Vec\u003c(AccountId, u128, Balance)\u003e) -\u003e Self {\n\t\tself.balances = balances;\n\t\tself\n\t}\n\n\tfn build(self) -\u003e TestExternalities {\n\t\tmatch self.chain {\n\t\t\tParachainType::PolkadotAssetHub =\u003e {\n\t\t\t\tuse polkadot_asset_hub_runtime::{Runtime, System};\n\t\t\t\tbuild_parachain!(self, Runtime, System)\n\t\t\t},\n\t\t\tParachainType::KusamaAssetHub =\u003e {\n\t\t\t\tuse kusama_asset_hub_runtime::{Runtime, System};\n\t\t\t\tbuild_parachain!(self, Runtime, System)\n\t\t\t},\n\t\t\t_ =\u003e panic!(\"cannot use this chain to build\"),\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","pendulum_tests.rs"],"content":"use crate::{\n\tmock::{para_ext, polkadot_relay_ext, ParachainType, USDT_ASSET_ID},\n\ttest_macros::{\n\t\tparachain1_transfer_asset_to_parachain2, parachain1_transfer_asset_to_parachain2_and_back,\n\t\tparachain1_transfer_incorrect_asset_to_parachain2_should_fail,\n\t\ttransfer_10_relay_token_from_parachain_to_relay_chain,\n\t\ttransfer_20_relay_token_from_relay_chain_to_parachain,\n\t},\n\tPENDULUM_ID, POLKADOT_ASSETHUB_ID,\n};\n\nuse frame_support::assert_ok;\nuse statemint_runtime as polkadot_asset_hub_runtime;\nuse xcm::latest::NetworkId;\nuse xcm_emulator::{decl_test_network, decl_test_parachain, decl_test_relay_chain, TestExt};\n\nconst DOT_FEE_WHEN_TRANSFER_TO_PARACHAIN: polkadot_core_primitives::Balance = 3200000000; //The fees that relay chain will charge when transfer DOT to parachain. sovereign account of some parachain will receive transfer_amount - DOT_FEE\n\ndecl_test_relay_chain! {\n\tpub struct PolkadotRelay {\n\t\tRuntime = polkadot_runtime::Runtime,\n\t\tXcmConfig = polkadot_runtime::xcm_config::XcmConfig,\n\t\tnew_ext = polkadot_relay_ext(),\n\t}\n}\n\ndecl_test_parachain! {\n\tpub struct PendulumParachain {\n\t\tRuntime = pendulum_runtime::Runtime,\n\t\tRuntimeOrigin = pendulum_runtime::RuntimeOrigin,\n\t\tXcmpMessageHandler = pendulum_runtime::XcmpQueue,\n\t\tDmpMessageHandler = pendulum_runtime::DmpQueue,\n\t\tnew_ext = para_ext(ParachainType::Pendulum),\n\t}\n}\n\ndecl_test_parachain! {\n\tpub struct AssetHubParachain {\n\t\tRuntime = polkadot_asset_hub_runtime::Runtime,\n\t\tRuntimeOrigin = polkadot_asset_hub_runtime::RuntimeOrigin,\n\t\tXcmpMessageHandler = polkadot_asset_hub_runtime::XcmpQueue,\n\t\tDmpMessageHandler = polkadot_asset_hub_runtime::DmpQueue,\n\t\tnew_ext = para_ext(ParachainType::PolkadotAssetHub),\n\t}\n}\n\ndecl_test_network! {\n\tpub struct PolkadotMockNet {\n\t\trelay_chain = PolkadotRelay,\n\t\tparachains = vec![\n\t\t\t(1000, AssetHubParachain),\n\t\t\t(2094, PendulumParachain),\n\t\t],\n\t}\n}\n\n#[test]\nfn transfer_dot_from_polkadot_to_pendulum() {\n\ttransfer_20_relay_token_from_relay_chain_to_parachain!(\n\t\tPolkadotMockNet,\n\t\tpolkadot_runtime,\n\t\tPolkadotRelay,\n\t\tpendulum_runtime,\n\t\tPendulumParachain,\n\t\tPENDULUM_ID,\n\t\tDOT_FEE_WHEN_TRANSFER_TO_PARACHAIN\n\t)\n}\n\n#[test]\nfn transfer_dot_from_pendulum_to_polkadot() {\n\ttransfer_10_relay_token_from_parachain_to_relay_chain!(\n\t\tPolkadotMockNet,\n\t\tpolkadot_runtime,\n\t\tPolkadotRelay,\n\t\tpendulum_runtime,\n\t\tPendulumParachain\n\t);\n}\n\n#[test]\nfn assethub_transfer_incorrect_asset_to_pendulum_should_fail() {\n\tparachain1_transfer_incorrect_asset_to_parachain2_should_fail!(\n\t\tpolkadot_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tpendulum_runtime,\n\t\tPendulumParachain,\n\t\tPENDULUM_ID\n\t);\n}\n\n#[test]\nfn assethub_transfer_asset_to_pendulum() {\n\tparachain1_transfer_asset_to_parachain2!(\n\t\tpolkadot_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tUSDT_ASSET_ID,\n\t\tpendulum_runtime,\n\t\tPendulumParachain,\n\t\tPENDULUM_ID\n\t);\n}\n\n#[test]\nfn assethub_transfer_asset_to_pendulum_and_back() {\n\tlet network_id = NetworkId::Polkadot;\n\n\tparachain1_transfer_asset_to_parachain2_and_back!(\n\t\tpolkadot_asset_hub_runtime,\n\t\tAssetHubParachain,\n\t\tPOLKADOT_ASSETHUB_ID,\n\t\tUSDT_ASSET_ID,\n\t\tpendulum_runtime,\n\t\tPendulumParachain,\n\t\tPENDULUM_ID,\n\t\tnetwork_id\n\t);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","integration-tests","src","test_macros.rs"],"content":"macro_rules! transfer_20_relay_token_from_relay_chain_to_parachain {\n\t(\n\t\t$mocknet:ident,\n\t\t$relay_runtime:ident,\n\t\t$relaychain:ident,\n\t\t$para_runtime:ident,\n\t\t$parachain: ident,\n\t\t$parachain_id:ident,\n\t\t$tx_fee:ident\n\t) =\u003e {{\n\t\tuse crate::mock::{units, ALICE};\n\t\tuse frame_support::traits::fungibles::Inspect;\n\t\tuse polkadot_core_primitives::Balance;\n\t\tuse xcm::latest::{Junction, Junction::Parachain, Junctions::Here};\n\t\tuse $para_runtime::CurrencyId;\n\n\t\t$mocknet::reset();\n\t\tlet transfer_amount: Balance = units(20);\n\t\tlet mut orml_tokens_before = 0;\n\n\t\t// get ALICE's balance before the transfer\n\t\t$parachain::execute_with(|| {\n\t\t\torml_tokens_before = $para_runtime::Tokens::balance(CurrencyId::XCM(0), \u0026ALICE.into());\n\t\t});\n\n\t\t// execute the transfer from relay chain\n\t\t$relaychain::execute_with(|| {\n\t\t\tassert_ok!($relay_runtime::XcmPallet::reserve_transfer_assets(\n\t\t\t\t$relay_runtime::RuntimeOrigin::signed(ALICE.into()),\n\t\t\t\tBox::new(Parachain($parachain_id).into_versioned()),\n\t\t\t\tBox::new(\n\t\t\t\t\tJunction::AccountId32 { network: None, id: ALICE }\n\t\t\t\t\t\t.into_location()\n\t\t\t\t\t\t.into_versioned()\n\t\t\t\t),\n\t\t\t\tBox::new((Here, transfer_amount).into()),\n\t\t\t\t0\n\t\t\t));\n\t\t});\n\n\t\t// a \"Deposited\" event occurred is proof that the transfer was successful\n\t\t$parachain::execute_with(|| {\n\t\t\tuse $para_runtime::{RuntimeEvent, System};\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::Tokens(orml_tokens::Event::Deposited { .. })\n\t\t\t)));\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::DmpQueue(cumulus_pallet_dmp_queue::Event::ExecutedDownward { .. })\n\t\t\t)));\n\t\t});\n\n\t\t$parachain::execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\t$para_runtime::Tokens::balance(CurrencyId::XCM(0), \u0026ALICE.into()),\n\t\t\t\torml_tokens_before + transfer_amount - $tx_fee\n\t\t\t);\n\t\t});\n\t}};\n}\n\nmacro_rules! transfer_10_relay_token_from_parachain_to_relay_chain {(\n\t\t$mocknet:ident,\n\t\t$relay_runtime:ident,\n\t\t$relaychain:ident,\n\t\t$para_runtime:ident,\n\t\t$parachain: ident\n\t) =\u003e {{\n\t\tuse crate::mock::{BOB, units};\n\t\tuse polkadot_core_primitives::Balance;\n\t\tuse xcm::latest::{Junction::AccountId32, Junctions::X1, MultiLocation, WeightLimit};\n\t\tuse xcm_emulator::TestExt;\n\n\t\t$mocknet::reset();\n\t\tlet transfer_amount: Balance = units(10);\n\t\tlet expected_base_balance = units(100);\n\n\t\t// get BOB's balance in the relay chain, before the transfer.\n\t\t$relaychain::execute_with(|| {\n\t\t\tlet before_bob_free_balance = $relay_runtime::Balances::free_balance(\u0026BOB.into());\n\t\t\tassert_eq!(before_bob_free_balance, expected_base_balance);\n\t\t});\n\n\t\t// execute th transfer in the parachain.\n\t\t$parachain::execute_with(|| {\n\t\t\tassert_ok!($para_runtime::XTokens::transfer(\n\t\t\t\t$para_runtime::RuntimeOrigin::signed(BOB.into()),\n\t\t\t\t$para_runtime::CurrencyId::XCM(0),\n\t\t\t\ttransfer_amount,\n\t\t\t\tBox::new(\n\t\t\t\t\tMultiLocation { parents: 1, interior: X1(AccountId32 { network: None, id: BOB }) }\n\t\t\t\t\t\t.into()\n\t\t\t\t),\n\t\t\t\tWeightLimit::Unlimited\n\t\t\t));\n\t\t});\n\n\t\t// check events in Parachain for proof of transfer\n\t\t$parachain::execute_with(|| {\n\t\t\tuse $para_runtime::{System, RuntimeEvent};\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::Tokens(orml_tokens::Event::Withdrawn { .. })\n\t\t\t)));\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::XTokens(orml_xtokens::Event::TransferredMultiAssets { .. })\n\t\t\t)));\n\t\t});\n\n\t\t// check events in the Relaychain for proof of transfer\n\t\t$relaychain::execute_with(|| {\n\t\t\tuse $relay_runtime::{RuntimeEvent, System, Balances};\n\n\t\t\tlet events = System::events();\n\t\t\tassert_eq!(events.len(), 3);\n\n\t\t\tlet withdrawn_balance = match \u0026events[0].event {\n\t\t\t\tRuntimeEvent::Balances(pallet_balances::Event::Withdraw { who: _, amount }) =\u003e amount,\n\t\t\t\tother =\u003e panic!(\"wrong event: {:#?}\", other),\n\t\t\t};\n\n\t\t\tlet deposited_balance = match \u0026events[1].event {\n\t\t\t\tRuntimeEvent::Balances(pallet_balances::Event::Deposit { who: _, amount }) =\u003e amount,\n\t\t\t\tother =\u003e panic!(\"wrong event: {:#?}\", other),\n\t\t\t};\n\n\t\t\tmatch \u0026events[2].event {\n\t\t\t\tRuntimeEvent::Ump(polkadot_runtime_parachains::ump::Event::ExecutedUpward(..)) =\u003e\n\t\t\t\t\tassert!(true),\n\t\t\t\tother =\u003e panic!(\"wrong event: {:#?}\", other),\n\t\t\t};\n\n\t\t\t//This fee will taken to transfer assets(Polkadot) from sovereign parachain account to destination user account;\n\t\t\tlet fee_when_transferring_to_relay_chain = withdrawn_balance - deposited_balance;\n\n\t\t\tlet after_bob_free_balance = Balances::free_balance(\u0026BOB.into());\n\t\t\tassert_eq!(\n\t\t\t\tafter_bob_free_balance,\n\t\t\t\texpected_base_balance + transfer_amount - fee_when_transferring_to_relay_chain\n\t\t\t);\n\t\t});\n\n\t}};\n}\n\n// the CurrencyId::XCM(1) is the representation of USDT from Statemint/Statemine on Pendulum/Amplitude chain.\n// The asset id for USDT on Statemint/Statemine is 1984, and our chain support only this asset id.\n// we are going to execute XCM call to sent incorrect Asset Id and expect to see cumulus_pallet_xcmp_queue::Event::Fail event with an error FailedToTransactAsset.\n// we want to be sure that the initial USDT balance for BOB is the same after XCM call from statemint/statemine when we tried to send wrong ASSET_ID.\nmacro_rules! parachain1_transfer_incorrect_asset_to_parachain2_should_fail {\n\t(\n\t\t$para1_runtime:ident,\n\t\t$parachain1:ident,\n\t\t$para2_runtime:ident,\n\t\t$parachain2: ident,\n\t\t$parachain2_id:ident\n\t) =\u003e {{\n\t\tuse crate::mock::{ALICE, BOB, INCORRECT_ASSET_ID, TEN_UNITS, UNIT};\n\t\tuse frame_support::traits::{fungibles::Inspect, Currency};\n\t\tuse polkadot_core_primitives::AccountId;\n\t\tuse polkadot_parachain::primitives::Sibling;\n\t\tuse sp_runtime::{traits::AccountIdConversion, MultiAddress};\n\t\tuse xcm::latest::{\n\t\t\tJunction,\n\t\t\tJunction::{GeneralIndex, PalletInstance, Parachain},\n\t\t\tJunctions::{X1, X2},\n\t\t\tMultiLocation, WeightLimit,\n\t\t};\n\t\tuse $para2_runtime::CurrencyId;\n\n\t\tlet parachain2_account: AccountId = Sibling::from($parachain2_id).into_account_truncating();\n\n\t\tlet expected_base_usdt_balance = 0;\n\t\t// make sure the account does not have any usdt.\n\t\t$parachain2::execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\t$para2_runtime::Tokens::balance(CurrencyId::XCM(1), \u0026BOB.into()),\n\t\t\t\texpected_base_usdt_balance\n\t\t\t);\n\t\t});\n\n\t\t$parachain1::execute_with(|| {\n\t\t\tuse $para1_runtime::*;\n\n\t\t\tlet origin = RuntimeOrigin::signed(ALICE.into());\n\t\t\tBalances::make_free_balance_be(\u0026ALICE.into(), TEN_UNITS);\n\t\t\tBalances::make_free_balance_be(\u0026BOB.into(), UNIT);\n\n\t\t\t// If using non root, create custom asset cost 0.1 Dot\n\t\t\t// We're using force_create here to make sure asset is sufficient.\n\t\t\tassert_ok!(Assets::force_create(\n\t\t\t\tRuntimeOrigin::root(),\n\t\t\t\tINCORRECT_ASSET_ID.into(),\n\t\t\t\tMultiAddress::Id(ALICE.into()),\n\t\t\t\ttrue,\n\t\t\t\tUNIT / 100\n\t\t\t));\n\n\t\t\tassert_ok!(Assets::mint(\n\t\t\t\torigin.clone(),\n\t\t\t\tINCORRECT_ASSET_ID.into(),\n\t\t\t\tMultiAddress::Id(ALICE.into()),\n\t\t\t\t1000 * UNIT\n\t\t\t));\n\n\t\t\t// need to have some balance to be able to receive user assets\n\t\t\tBalances::make_free_balance_be(\u0026parachain2_account, UNIT);\n\n\t\t\tassert_ok!(PolkadotXcm::limited_reserve_transfer_assets(\n\t\t\t\torigin.clone(),\n\t\t\t\tBox::new(MultiLocation::new(1, X1(Parachain($parachain2_id))).into()),\n\t\t\t\tBox::new(Junction::AccountId32 { id: BOB, network: None }.into()),\n\t\t\t\tBox::new(\n\t\t\t\t\t(X2(PalletInstance(50), GeneralIndex(INCORRECT_ASSET_ID as u128)), TEN_UNITS)\n\t\t\t\t\t\t.into()\n\t\t\t\t),\n\t\t\t\t0,\n\t\t\t\tWeightLimit::Unlimited\n\t\t\t));\n\n\t\t\tassert_eq!(990 * UNIT, Assets::balance(INCORRECT_ASSET_ID, \u0026AccountId::from(ALICE)));\n\t\t\tassert_eq!(0, Assets::balance(INCORRECT_ASSET_ID, \u0026AccountId::from(BOB)));\n\n\t\t\tassert_eq!(TEN_UNITS, Assets::balance(INCORRECT_ASSET_ID, \u0026parachain2_account));\n\t\t\t// the balance of sibling parachain sovereign account is not changed\n\t\t\tassert_eq!(UNIT, Balances::free_balance(\u0026parachain2_account));\n\t\t});\n\n\t\t// Rerun $parachain1 to actually send the egress message via XCM\n\t\t$parachain1::execute_with(|| {});\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tuse $para2_runtime::{RuntimeEvent, System};\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::XcmpQueue(cumulus_pallet_xcmp_queue::Event::Fail {\n\t\t\t\t\tmessage_hash: _,\n\t\t\t\t\terror: xcm::v3::Error::FailedToTransactAsset(..),\n\t\t\t\t\tweight: _\n\t\t\t\t})\n\t\t\t)));\n\t\t});\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tassert_eq!(\n\t\t\t\t$para2_runtime::Tokens::balance(CurrencyId::XCM(1), \u0026BOB.into()),\n\t\t\t\texpected_base_usdt_balance\n\t\t\t);\n\t\t});\n\t}};\n}\n\nmacro_rules! parachain1_transfer_asset_to_parachain2 {\n\t(\n\t\t$para1_runtime:ident,\n\t\t$parachain1:ident,\n\t\t$para1_asset_id:ident,\n\t\t$para2_runtime:ident,\n\t\t$parachain2: ident,\n\t\t$parachain2_id:ident\n\t) =\u003e {{\n\t\tuse crate::mock::{ALICE, BOB, TEN_UNITS, UNIT};\n\t\tuse frame_support::traits::{fungibles::Inspect, Currency};\n\t\tuse polkadot_core_primitives::AccountId;\n\t\tuse polkadot_parachain::primitives::Sibling;\n\t\tuse sp_runtime::{traits::AccountIdConversion, MultiAddress};\n\t\tuse xcm::latest::{\n\t\t\tJunction,\n\t\t\tJunction::{GeneralIndex, PalletInstance, Parachain},\n\t\t\tJunctions::{X1, X2},\n\t\t\tMultiLocation, WeightLimit,\n\t\t};\n\t\tuse $para2_runtime::CurrencyId;\n\n\t\tlet parachain2_account: AccountId = Sibling::from($parachain2_id).into_account_truncating();\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tassert_eq!($para2_runtime::Tokens::balance(CurrencyId::XCM(1), \u0026BOB.into()), 0);\n\t\t});\n\n\t\t$parachain1::execute_with(|| {\n\t\t\tuse $para1_runtime::*;\n\n\t\t\tlet origin = RuntimeOrigin::signed(ALICE.into());\n\t\t\tBalances::make_free_balance_be(\u0026ALICE.into(), TEN_UNITS);\n\t\t\tBalances::make_free_balance_be(\u0026BOB.into(), UNIT);\n\n\t\t\t// If using non root, create custom asset cost 0.1 Dot\n\t\t\t// We're using force_create here to make sure asset is sufficient.\n\t\t\tassert_ok!(Assets::force_create(\n\t\t\t\tRuntimeOrigin::root(),\n\t\t\t\t$para1_asset_id.into(),\n\t\t\t\tMultiAddress::Id(ALICE.into()),\n\t\t\t\ttrue,\n\t\t\t\tUNIT / 100\n\t\t\t));\n\n\t\t\tassert_ok!(Assets::mint(\n\t\t\t\torigin.clone(),\n\t\t\t\t$para1_asset_id.into(),\n\t\t\t\tMultiAddress::Id(ALICE.into()),\n\t\t\t\t1000 * UNIT\n\t\t\t));\n\n\t\t\t// need to have some KSM to be able to receive user assets\n\t\t\tBalances::make_free_balance_be(\u0026parachain2_account, UNIT);\n\n\t\t\tassert_ok!(PolkadotXcm::limited_reserve_transfer_assets(\n\t\t\t\torigin.clone(),\n\t\t\t\tBox::new(MultiLocation::new(1, X1(Parachain($parachain2_id))).into()),\n\t\t\t\tBox::new(Junction::AccountId32 { id: BOB, network: None }.into()),\n\t\t\t\tBox::new(\n\t\t\t\t\t(X2(PalletInstance(50), GeneralIndex($para1_asset_id as u128)), TEN_UNITS)\n\t\t\t\t\t\t.into()\n\t\t\t\t),\n\t\t\t\t0,\n\t\t\t\tWeightLimit::Unlimited\n\t\t\t));\n\n\t\t\tassert_eq!(990 * UNIT, Assets::balance($para1_asset_id, \u0026AccountId::from(ALICE)));\n\t\t\tassert_eq!(0, Assets::balance($para1_asset_id, \u0026AccountId::from(BOB)));\n\n\t\t\tassert_eq!(TEN_UNITS, Assets::balance($para1_asset_id, \u0026parachain2_account));\n\t\t\t// the balance of sibling parachain sovereign account is not changed\n\t\t\tassert_eq!(UNIT, Balances::free_balance(\u0026parachain2_account));\n\t\t});\n\n\t\t// Rerun the StatemintParachain::execute to actually send the egress message via XCM\n\t\t$parachain1::execute_with(|| {});\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tuse $para2_runtime::{RuntimeEvent, System};\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::Tokens(orml_tokens::Event::Endowed { .. })\n\t\t\t)));\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::Tokens(orml_tokens::Event::Deposited { .. })\n\t\t\t)));\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::XcmpQueue(cumulus_pallet_xcmp_queue::Event::Success { .. })\n\t\t\t)));\n\n\t\t\tassert_eq!(\n\t\t\t\t$para2_runtime::Tokens::balance($para2_runtime::CurrencyId::XCM(1), \u0026BOB.into()),\n\t\t\t\tTEN_UNITS\n\t\t\t);\n\t\t});\n\t}};\n}\n\nmacro_rules! parachain1_transfer_asset_to_parachain2_and_back {\n\t(\n\t\t$para1_runtime:ident,\n\t\t$parachain1:ident,\n\t\t$parachain1_id:ident,\n\t\t$para1_asset_id:ident,\n\t\t$para2_runtime:ident,\n\t\t$parachain2: ident,\n\t\t$parachain2_id:ident,\n\t\t$network_id: ident\n\t) =\u003e {{\n\t\tuse crate::mock::{BOB, TEN_UNITS, UNIT};\n\t\tuse frame_support::traits::{fungible::Mutate, fungibles::Inspect};\n\t\tuse polkadot_core_primitives::AccountId;\n\t\tuse xcm::latest::{\n\t\t\tJunction, Junction::Parachain, Junctions::X2, MultiLocation, WeightLimit,\n\t\t};\n\n\t\t//first we need to set up USDT balance on pendulum chain before to start transfer it back.\n\t\tparachain1_transfer_asset_to_parachain2!(\n\t\t\t$para1_runtime,\n\t\t\t$parachain1,\n\t\t\t$para1_asset_id,\n\t\t\t$para2_runtime,\n\t\t\t$parachain2,\n\t\t\t$parachain2_id\n\t\t);\n\n\t\t$parachain1::execute_with(|| {});\n\n\t\t$parachain2::execute_with(|| {\n\t\t\tuse $para2_runtime::{\n\t\t\t\tBalances, CurrencyId, RuntimeEvent, RuntimeOrigin, System, Tokens, XTokens,\n\t\t\t};\n\n\t\t\tassert_eq!(TEN_UNITS, Tokens::balance(CurrencyId::XCM(1), \u0026AccountId::from(BOB)));\n\t\t\t// ensure sender has enough balance to be charged as fee\n\t\t\tassert_ok!(Balances::mint_into(\u0026AccountId::from(BOB), TEN_UNITS));\n\n\t\t\tassert_ok!(XTokens::transfer(\n\t\t\t\tRuntimeOrigin::signed(BOB.into()),\n\t\t\t\tCurrencyId::XCM(1),\n\t\t\t\tUNIT * 1,\n\t\t\t\tBox::new(\n\t\t\t\t\tMultiLocation::new(\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tX2(\n\t\t\t\t\t\t\tParachain($parachain1_id),\n\t\t\t\t\t\t\tJunction::AccountId32 { network: Some($network_id), id: BOB.into() }\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t.into()\n\t\t\t\t),\n\t\t\t\tWeightLimit::Unlimited\n\t\t\t));\n\n\t\t\tassert_eq!(\n\t\t\t\tTEN_UNITS - 1 * UNIT, //initial balance - one unit\n\t\t\t\tTokens::balance(CurrencyId::XCM(1), \u0026AccountId::from(BOB))\n\t\t\t);\n\n\t\t\tassert!(System::events().iter().any(|r| matches!(\n\t\t\t\tr.event,\n\t\t\t\tRuntimeEvent::XcmpQueue(cumulus_pallet_xcmp_queue::Event::XcmpMessageSent { .. })\n\t\t\t)));\n\n\t\t\tfor i in System::events().iter() {\n\t\t\t\tprintln!(\"{}: {:?}\\n\", stringify!($para2_runtime), i);\n\t\t\t}\n\t\t});\n\n\t\t$parachain1::execute_with(|| {\n\t\t\tuse $para1_runtime::*;\n\n\t\t\tfor i in System::events().iter() {\n\t\t\t\tprintln!(\"{}: {:?}\\n\", stringify!($para1_runtime), i);\n\t\t\t}\n\n\t\t\tlet events = System::events();\n\t\t\tmatch \u0026events[events.len() - 2] {\n\t\t\t\t\u0026frame_system::EventRecord {\n\t\t\t\t\tphase: frame_system::Phase::Initialization,\n\t\t\t\t\tevent:\n\t\t\t\t\t\tRuntimeEvent::Assets(pallet_assets::Event::Issued {\n\t\t\t\t\t\t\tasset_id: $para1_asset_id,\n\t\t\t\t\t\t\towner: _,\n\t\t\t\t\t\t\tamount,\n\t\t\t\t\t\t}),\n\t\t\t\t\ttopics: _,\n\t\t\t\t} =\u003e {\n\t\t\t\t\t// https://github.com/paritytech/cumulus/pull/1278 support using self sufficient asset\n\t\t\t\t\t// for paying xcm execution fee.\n\t\t\t\t\t// 990_000_000_000 for Statemint\n\t\t\t\t\t// 988_423_297_485 for Statemine\n\t\t\t\t\tassert_eq!(amount, Assets::balance($para1_asset_id, \u0026AccountId::from(BOB)));\n\t\t\t\t},\n\t\t\t\tother =\u003e panic!(\"wrong event: {other:?}\"),\n\t\t\t}\n\t\t});\n\t}};\n}\n\n// macros defined at the bottom of this file to prevent unresolved imports\npub(super) use parachain1_transfer_asset_to_parachain2;\npub(super) use parachain1_transfer_asset_to_parachain2_and_back;\npub(super) use parachain1_transfer_incorrect_asset_to_parachain2_should_fail;\npub(super) use transfer_10_relay_token_from_parachain_to_relay_chain;\npub(super) use transfer_20_relay_token_from_relay_chain_to_parachain;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","build.rs"],"content":"use substrate_wasm_builder::WasmBuilder;\n\nfn main() {\n\tWasmBuilder::new()\n\t\t.with_current_project()\n\t\t.export_heap_base()\n\t\t.import_memory()\n\t\t.build()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","lib.rs"],"content":"#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nmod weights;\npub mod xcm_config;\npub mod zenlink;\nuse crate::zenlink::*;\nuse xcm::v3::MultiLocation;\nuse zenlink_protocol::{AssetBalance, MultiAssetsHandler, PairInfo};\n\npub use parachain_staking::InflationInfo;\n\nuse codec::Encode;\n\nuse smallvec::smallvec;\nuse sp_api::impl_runtime_apis;\nuse sp_core::{crypto::KeyTypeId, OpaqueMetadata};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{AccountIdLookup, BlakeTwo256, Block as BlockT, ConvertInto},\n\ttransaction_validity::{TransactionSource, TransactionValidity},\n\tApplyExtrinsicResult, SaturatedConversion,\n};\n\npub use spacewalk_primitives::CurrencyId;\n\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\nuse frame_support::{\n\tconstruct_runtime,\n\tdispatch::DispatchClass,\n\tparameter_types,\n\ttraits::{\n\t\tConstBool, ConstU32, Contains, Currency, EitherOfDiverse, EqualPrivilegeOnly, Imbalance,\n\t\tOnUnbalanced, WithdrawReasons,\n\t},\n\tweights::{\n\t\tconstants::WEIGHT_REF_TIME_PER_SECOND, ConstantMultiplier, Weight, WeightToFeeCoefficient,\n\t\tWeightToFeeCoefficients, WeightToFeePolynomial,\n\t},\n\tPalletId,\n};\nuse frame_system::{\n\tlimits::{BlockLength, BlockWeights},\n\tEnsureRoot, EnsureSigned,\n};\npub use sp_runtime::{traits::AccountIdConversion, MultiAddress, Perbill, Permill, Perquintill};\n\nuse runtime_common::{\n\tasset_registry, opaque, AccountId, Amount, AuraId, Balance, BlockNumber, Hash, Index,\n\tReserveIdentifier, Signature, EXISTENTIAL_DEPOSIT, MILLIUNIT, NANOUNIT, UNIT,\n};\n\nuse cumulus_pallet_parachain_system::RelayNumberStrictlyIncreases;\n\nuse dia_oracle::DiaOracle;\n\nuse xcm_config::{XcmConfig, XcmOriginToTransactDispatchOrigin};\n\nuse orml_currencies::BasicCurrencyAdapter;\nuse orml_traits::{currency::MutationHooks, parameter_type_with_key};\n\nconst CONTRACTS_DEBUG_OUTPUT: bool = true;\n\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\n\n// Polkadot imports\nuse polkadot_runtime_common::{BlockHashCount, SlowAdjustingFeeUpdate};\n\nuse weights::{BlockExecutionWeight, ExtrinsicBaseWeight, RocksDbWeight};\n\n// XCM Imports\nuse xcm_executor::XcmExecutor;\n\n/// The address format for describing accounts.\npub type Address = MultiAddress\u003cAccountId, ()\u003e;\n\n/// Block header type as expected by this runtime.\npub type Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\n/// Block type as expected by this runtime.\npub type Block = generic::Block\u003cHeader, UncheckedExtrinsic\u003e;\n\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock\u003cBlock\u003e;\n\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId\u003cBlock\u003e;\n\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender\u003cRuntime\u003e,\n\tframe_system::CheckSpecVersion\u003cRuntime\u003e,\n\tframe_system::CheckTxVersion\u003cRuntime\u003e,\n\tframe_system::CheckGenesis\u003cRuntime\u003e,\n\tframe_system::CheckEra\u003cRuntime\u003e,\n\tframe_system::CheckNonce\u003cRuntime\u003e,\n\tframe_system::CheckWeight\u003cRuntime\u003e,\n\tpallet_transaction_payment::ChargeTransactionPayment\u003cRuntime\u003e,\n);\n\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tgeneric::UncheckedExtrinsic\u003cAddress, RuntimeCall, Signature, SignedExtra\u003e;\n\npub type SignedPayload = generic::SignedPayload\u003cRuntimeCall, SignedExtra\u003e;\n\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = generic::CheckedExtrinsic\u003cAccountId, RuntimeCall, SignedExtra\u003e;\n\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive\u003c\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext\u003cRuntime\u003e,\n\tRuntime,\n\tAllPalletsWithSystem,\n\u003e;\n\n/// Handles converting a weight scalar to a fee value, based on the scale and granularity of the\n/// node's balance type.\n///\n/// This should typically create a mapping between the following ranges:\n///   - `[0, MAXIMUM_BLOCK_WEIGHT]`\n///   - `[Balance::min, Balance::max]`\n///\n/// Yet, it can be used for any other sort of change to weight-fee. Some examples being:\n///   - Setting it to `0` will essentially disable the weight fee.\n///   - Setting it to `1` will cause the literal `#[weight = x]` values to be charged.\npub struct WeightToFee;\nimpl WeightToFeePolynomial for WeightToFee {\n\ttype Balance = Balance;\n\tfn polynomial() -\u003e WeightToFeeCoefficients\u003cSelf::Balance\u003e {\n\t\tlet p = MILLIUNIT;\n\t\tlet q = 10 * Balance::from(ExtrinsicBaseWeight::get().ref_time());\n\t\tsmallvec![WeightToFeeCoefficient {\n\t\t\tdegree: 1,\n\t\t\tnegative: false,\n\t\t\tcoeff_frac: Perbill::from_rational(p % q, q),\n\t\t\tcoeff_integer: p / q,\n\t\t}]\n\t}\n}\n\nimpl_opaque_keys! {\n\tpub struct SessionKeys {\n\t\tpub aura: Aura,\n\t}\n}\n\n#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"pendulum\"),\n\timpl_name: create_runtime_str!(\"pendulum\"),\n\tauthoring_version: 1,\n\tspec_version: 8,\n\timpl_version: 0,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 8,\n\tstate_version: 1,\n};\n\n/// This determines the average expected block time that we are targeting.\n/// Blocks will be produced at a minimum duration defined by `SLOT_DURATION`.\n/// `SLOT_DURATION` is picked up by `pallet_timestamp` which is in turn picked\n/// up by `pallet_aura` to implement `fn slot_duration()`.\n///\n/// Change this to adjust the block time.\npub const MILLISECS_PER_BLOCK: u64 = 12000;\n\n// NOTE: Currently it is not possible to change the slot duration after the chain has started.\n//       Attempting to do so will brick block production.\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\npub const BLOCKS_PER_YEAR: BlockNumber = DAYS * 36525 / 100;\n\n/// We assume that ~5% of the block weight is consumed by `on_initialize` handlers. This is\n/// used to limit the maximal weight of a single extrinsic.\nconst AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(5);\n\n/// We allow `Normal` extrinsics to fill up the block up to 75%, the rest can be used by\n/// `Operational` extrinsics.\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n\n/// We allow for 0.5 of a second of compute with a 12 second average block time.\nconst MAXIMUM_BLOCK_WEIGHT: Weight =\n\tWeight::from_parts(WEIGHT_REF_TIME_PER_SECOND.saturating_div(2), 0)\n\t\t.set_proof_size(cumulus_primitives_core::relay_chain::MAX_POV_SIZE as u64);\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -\u003e NativeVersion {\n\tNativeVersion { runtime_version: VERSION, can_author_with: Default::default() }\n}\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\n\t// This part is copied from Substrate's `bin/node/runtime/src/lib.rs`.\n\t//  The `RuntimeBlockLength` and `RuntimeBlockWeights` exist here because the\n\t// `DeletionWeightLimit` and `DeletionQueueDepth` depend on those to parameterize\n\t// the lazy contract deletion.\n\tpub RuntimeBlockLength: BlockLength =\n\t\tBlockLength::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub RuntimeBlockWeights: BlockWeights = BlockWeights::builder()\n\t\t.base_block(BlockExecutionWeight::get())\n\t\t.for_class(DispatchClass::all(), |weights| {\n\t\t\tweights.base_extrinsic = ExtrinsicBaseWeight::get();\n\t\t})\n\t\t.for_class(DispatchClass::Normal, |weights| {\n\t\t\tweights.max_total = Some(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT);\n\t\t})\n\t\t.for_class(DispatchClass::Operational, |weights| {\n\t\t\tweights.max_total = Some(MAXIMUM_BLOCK_WEIGHT);\n\t\t\t// Operational transactions have some extra reserved space, so that they\n\t\t\t// are included even if block reached `MAXIMUM_BLOCK_WEIGHT`.\n\t\t\tweights.reserved = Some(\n\t\t\t\tMAXIMUM_BLOCK_WEIGHT - NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT\n\t\t\t);\n\t\t})\n\t\t.avg_block_initialization(AVERAGE_ON_INITIALIZE_RATIO)\n\t\t.build_or_panic();\n\tpub const SS58Prefix: u16 = 56;\n}\n\npub struct BaseFilter;\nimpl Contains\u003cRuntimeCall\u003e for BaseFilter {\n\tfn contains(call: \u0026RuntimeCall) -\u003e bool {\n\t\tmatch call {\n\t\t\t// These modules are all allowed to be called by transactions:\n\t\t\tRuntimeCall::Bounties(_) |\n\t\t\tRuntimeCall::ChildBounties(_) |\n\t\t\tRuntimeCall::Treasury(_) |\n\t\t\tRuntimeCall::Tokens(_) |\n\t\t\tRuntimeCall::Currencies(_) |\n\t\t\tRuntimeCall::ParachainStaking(_) |\n\t\t\tRuntimeCall::Democracy(_) |\n\t\t\tRuntimeCall::Council(_) |\n\t\t\tRuntimeCall::TechnicalCommittee(_) |\n\t\t\tRuntimeCall::System(_) |\n\t\t\tRuntimeCall::Scheduler(_) |\n\t\t\tRuntimeCall::Preimage(_) |\n\t\t\tRuntimeCall::Timestamp(_) |\n\t\t\tRuntimeCall::Balances(_) |\n\t\t\tRuntimeCall::Session(_) |\n\t\t\tRuntimeCall::ParachainSystem(_) |\n\t\t\tRuntimeCall::XcmpQueue(_) |\n\t\t\tRuntimeCall::PolkadotXcm(_) |\n\t\t\tRuntimeCall::DmpQueue(_) |\n\t\t\tRuntimeCall::Utility(_) |\n\t\t\tRuntimeCall::Vesting(_) |\n\t\t\tRuntimeCall::XTokens(_) |\n\t\t\tRuntimeCall::Multisig(_) |\n\t\t\tRuntimeCall::Identity(_) |\n\t\t\tRuntimeCall::Contracts(_) |\n\t\t\tRuntimeCall::ZenlinkProtocol(_) |\n\t\t\tRuntimeCall::DiaOracleModule(_) |\n\t\t\tRuntimeCall::VestingManager(_) |\n\t\t\tRuntimeCall::AssetRegistry(_) =\u003e true,\n\t\t\t// All pallets are allowed, but exhaustive match is defensive\n\t\t\t// in the case of adding new pallets.\n\t\t}\n\t}\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype RuntimeCall = RuntimeCall;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup\u003cAccountId, ()\u003e;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header\u003cBlockNumber, BlakeTwo256\u003e;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\t/// The ubiquitous origin type.\n\ttype RuntimeOrigin = RuntimeOrigin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// Runtime version.\n\ttype Version = Version;\n\t/// Converts a module to an index of this module in the runtime.\n\ttype PalletInfo = PalletInfo;\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData\u003cBalance\u003e;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RocksDbWeight;\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = BaseFilter;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// Block \u0026 extrinsics weights: base values and limits.\n\ttype BlockWeights = RuntimeBlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = RuntimeBlockLength;\n\t/// This is used as an identifier of the chain. 56 is the prefix for Pendulum\n\ttype SS58Prefix = SS58Prefix;\n\t/// The action to take on a Runtime Upgrade\n\ttype OnSetCode = cumulus_pallet_parachain_system::ParachainSetCode\u003cSelf\u003e;\n\ttype MaxConsumers = frame_support::traits::ConstU32\u003c16\u003e;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype OnTimestampSet = ();\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = pallet_timestamp::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const UncleGenerations: u32 = 2;\n}\n\nimpl pallet_authorship::Config for Runtime {\n\ttype FindAuthor = pallet_session::FindAccountFromAuthorIndex\u003cSelf, Aura\u003e;\n\ttype EventHandler = ParachainStaking;\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: Balance = EXISTENTIAL_DEPOSIT;\n\tpub const MaxLocks: u32 = 50;\n\tpub const MaxReserves: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype DustRemoval = Treasury;\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = pallet_balances::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxReserves = MaxReserves;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 100 * NANOUNIT;\n\tpub const OperationalFeeMultiplier: u8 = 5;\n}\n\ntype NegativeImbalance = \u003cBalances as Currency\u003cAccountId\u003e\u003e::NegativeImbalance;\n\npub struct DealWithFees;\nimpl OnUnbalanced\u003cNegativeImbalance\u003e for DealWithFees {\n\tfn on_unbalanceds\u003cB\u003e(mut fees_then_tips: impl Iterator\u003cItem = NegativeImbalance\u003e) {\n\t\tif let Some(mut fees) = fees_then_tips.next() {\n\t\t\tif let Some(tips) = fees_then_tips.next() {\n\t\t\t\ttips.merge_into(\u0026mut fees);\n\t\t\t}\n\t\t\t// for fees and tips, 100% to treasury\n\t\t\tTreasury::on_unbalanced(fees);\n\t\t}\n\t}\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnChargeTransaction = pallet_transaction_payment::CurrencyAdapter\u003cBalances, DealWithFees\u003e;\n\ttype WeightToFee = WeightToFee;\n\ttype LengthToFee = ConstantMultiplier\u003cBalance, TransactionByteFee\u003e;\n\ttype FeeMultiplierUpdate = SlowAdjustingFeeUpdate\u003cSelf\u003e;\n\ttype OperationalFeeMultiplier = OperationalFeeMultiplier;\n}\n\nparameter_types! {\n\tpub const ReservedXcmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n\tpub const ReservedDmpWeight: Weight = MAXIMUM_BLOCK_WEIGHT.saturating_div(4);\n}\n\nimpl cumulus_pallet_parachain_system::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSystemEvent = ();\n\ttype SelfParaId = parachain_info::Pallet\u003cRuntime\u003e;\n\ttype DmpMessageHandler = DmpQueue;\n\ttype ReservedDmpWeight = ReservedDmpWeight;\n\ttype OutboundXcmpMessageSource = XcmpQueue;\n\ttype XcmpMessageHandler = XcmpQueue;\n\ttype ReservedXcmpWeight = ReservedXcmpWeight;\n\ttype CheckAssociatedRelayNumber = RelayNumberStrictlyIncreases;\n}\n\nimpl parachain_info::Config for Runtime {}\n\nimpl cumulus_pallet_aura_ext::Config for Runtime {}\n\nimpl cumulus_pallet_xcmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ChannelInfo = ParachainSystem;\n\ttype VersionWrapper = ();\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype ControllerOriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype PriceForSiblingDelivery = ();\n\ttype WeightInfo = cumulus_pallet_xcmp_queue::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl cumulus_pallet_dmp_queue::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype ExecuteOverweightOrigin = EnsureRoot\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const Offset: u32 = 0;\n\tpub const MaxAuthorities: u32 = 200;\n}\n\nimpl pallet_session::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype ValidatorId = \u003cSelf as frame_system::Config\u003e::AccountId;\n\ttype ValidatorIdOf = ConvertInto;\n\ttype ShouldEndSession = ParachainStaking;\n\ttype NextSessionRotation = ParachainStaking;\n\ttype SessionManager = ParachainStaking;\n\ttype SessionHandler = \u003cSessionKeys as sp_runtime::traits::OpaqueKeys\u003e::KeyTypeIdProviders;\n\ttype Keys = SessionKeys;\n\ttype WeightInfo = pallet_session::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nparameter_types! {\n\tpub const LaunchPeriod: BlockNumber = 5 * DAYS;\n\tpub const VotingPeriod: BlockNumber = 5 * DAYS;\n\tpub const FastTrackVotingPeriod: BlockNumber = 3 * HOURS;\n\tpub const MinimumDeposit: Balance = 1 * UNIT;\n\tpub const EnactmentPeriod: BlockNumber = 2 * DAYS;\n\tpub const CooloffPeriod: BlockNumber = 7 * DAYS;\n\tpub const MaxProposals: u32 = 100;\n\tpub const VoteLockingPeriod: u32 = 7 * DAYS;\n}\n\nimpl pallet_democracy::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype EnactmentPeriod = EnactmentPeriod;\n\ttype LaunchPeriod = LaunchPeriod;\n\ttype VotingPeriod = VotingPeriod;\n\ttype VoteLockingPeriod = VoteLockingPeriod;\n\ttype MinimumDeposit = MinimumDeposit;\n\t/// A straight majority of the council can decide what their next motion is.\n\ttype ExternalOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A super-majority can have the next scheduled referendum be a straight majority-carries vote.\n\ttype ExternalMajorityOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 2\u003e;\n\t/// A unanimous council can have the next scheduled referendum be a straight default-carries\n\t/// (NTB) vote.\n\ttype ExternalDefaultOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 1, 1\u003e;\n\t/// Two thirds of the technical committee can have an ExternalMajority/ExternalDefault vote\n\t/// be tabled immediately and with a shorter voting/enactment period.\n\ttype FastTrackOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 2, 3\u003e;\n\ttype InstantOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e;\n\ttype InstantAllowed = frame_support::traits::ConstBool\u003ctrue\u003e;\n\ttype FastTrackVotingPeriod = FastTrackVotingPeriod;\n\t// To cancel a proposal which has been passed, 2/3 of the council must agree to it.\n\ttype CancellationOrigin =\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 2, 3\u003e;\n\t// To cancel a proposal before it has been passed, the technical committee must be unanimous or\n\t// Root must agree.\n\ttype CancelProposalOrigin = EitherOfDiverse\u003c\n\t\tEnsureRoot\u003cAccountId\u003e,\n\t\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, TechnicalCollective, 1, 1\u003e,\n\t\u003e;\n\ttype BlacklistOrigin = EnsureRoot\u003cAccountId\u003e;\n\t// Any single technical committee member may veto a coming council proposal, however they can\n\t// only do it once and it lasts only for the cool-off period.\n\ttype VetoOrigin = pallet_collective::EnsureMember\u003cAccountId, TechnicalCollective\u003e;\n\ttype CooloffPeriod = CooloffPeriod;\n\ttype Slash = ();\n\ttype Scheduler = Scheduler;\n\ttype PalletsOrigin = OriginCaller;\n\ttype MaxVotes = ConstU32\u003c100\u003e;\n\ttype WeightInfo = pallet_democracy::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxProposals = MaxProposals;\n\ttype Preimages = Preimage;\n\ttype MaxDeposits = ConstU32\u003c100\u003e;\n\ttype MaxBlacklisted = ConstU32\u003c100\u003e;\n\ttype SubmitOrigin = EnsureSigned\u003cAccountId\u003e;\n}\n\nparameter_types! {\n\tpub const CouncilMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const CouncilMaxProposals: u32 = 100;\n\tpub const CouncilMaxMembers: u32 = 100;\n}\n\ntype CouncilCollective = pallet_collective::Instance1;\nimpl pallet_collective::Config\u003cCouncilCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = CouncilMotionDuration;\n\ttype MaxProposals = CouncilMaxProposals;\n\ttype MaxMembers = CouncilMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cSelf::AccountId\u003e;\n}\n\nparameter_types! {\n\tpub const TechnicalMotionDuration: BlockNumber = 3 * DAYS;\n\tpub const TechnicalMaxProposals: u32 = 100;\n\tpub const TechnicalMaxMembers: u32 = 100;\n}\n\ntype TechnicalCollective = pallet_collective::Instance2;\nimpl pallet_collective::Config\u003cTechnicalCollective\u003e for Runtime {\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype Proposal = RuntimeCall;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MotionDuration = TechnicalMotionDuration;\n\ttype MaxProposals = TechnicalMaxProposals;\n\ttype MaxMembers = TechnicalMaxMembers;\n\ttype DefaultVote = pallet_collective::PrimeDefaultVote;\n\ttype WeightInfo = pallet_collective::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype SetMembersOrigin = EnsureRoot\u003cSelf::AccountId\u003e;\n}\n\nparameter_types! {\n\tpub MaximumSchedulerWeight: Weight = Perbill::from_percent(80) *\n\t\tRuntimeBlockWeights::get().max_block;\n}\n\nimpl pallet_scheduler::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype PalletsOrigin = OriginCaller;\n\ttype RuntimeCall = RuntimeCall;\n\ttype MaximumWeight = MaximumSchedulerWeight;\n\ttype ScheduleOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype MaxScheduledPerBlock = ConstU32\u003c50\u003e;\n\ttype WeightInfo = pallet_scheduler::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype OriginPrivilegeCmp = EqualPrivilegeOnly;\n\ttype Preimages = Preimage;\n}\n\nparameter_types! {\n\tpub const PreimageMaxSize: u32 = 4096 * 1024;\n\tpub const PreimageBaseDeposit: Balance = 1 * UNIT;\n\t// One cent: $10,000 / MB\n\tpub const PreimageByteDeposit: Balance = 10 * MILLIUNIT;\n}\n\nimpl pallet_preimage::Config for Runtime {\n\ttype WeightInfo = pallet_preimage::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype ManagerOrigin = EnsureRoot\u003cAccountId\u003e;\n\ttype BaseDeposit = PreimageBaseDeposit;\n\ttype ByteDeposit = PreimageByteDeposit;\n}\n\nparameter_types! {\n\tpub const ProposalBond: Permill = Permill::from_percent(5);\n\tpub const ProposalBondMinimum: Balance = 10 * UNIT;\n\tpub const SpendPeriod: BlockNumber = 7 * DAYS;\n\tpub const Burn: Permill = Permill::from_percent(0);\n\tpub const TreasuryPalletId: PalletId = PalletId(*b\"py/trsry\");\n\tpub const MaxApprovals: u32 = 100;\n}\n\ntype TreasuryApproveOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionAtLeast\u003cAccountId, CouncilCollective, 3, 5\u003e,\n\u003e;\n\ntype TreasuryRejectOrigin = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_treasury::Config for Runtime {\n\ttype PalletId = TreasuryPalletId;\n\ttype Currency = Balances;\n\ttype ApproveOrigin = TreasuryApproveOrigin;\n\ttype RejectOrigin = TreasuryRejectOrigin;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype OnSlash = Treasury;\n\ttype ProposalBond = ProposalBond;\n\ttype ProposalBondMinimum = ProposalBondMinimum;\n\ttype ProposalBondMaximum = ();\n\ttype SpendPeriod = SpendPeriod;\n\ttype Burn = Burn;\n\ttype BurnDestination = ();\n\ttype SpendFunds = Bounties;\n\ttype WeightInfo = pallet_treasury::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype MaxApprovals = MaxApprovals;\n\ttype SpendOrigin = frame_support::traits::NeverEnsureOrigin\u003cu128\u003e;\n}\n\nparameter_types! {\n\tpub const BountyCuratorDeposit: Permill = Permill::from_percent(50);\n\tpub const BountyValueMinimum: Balance = 5 * UNIT;\n\tpub const BountyDepositBase: Balance = 1 * UNIT;\n\tpub const CuratorDepositMultiplier: Permill = Permill::from_percent(50);\n\tpub const CuratorDepositMin: Balance = 1 * UNIT;\n\tpub const CuratorDepositMax: Balance = 100 * UNIT;\n\tpub const DataDepositPerByte: Balance = 30 * MILLIUNIT;\n\tpub const BountyDepositPayoutDelay: BlockNumber = 4 * DAYS;\n\tpub const BountyUpdatePeriod: BlockNumber = 20 * DAYS;\n\tpub const MaximumReasonLength: u32 = 5000;\n}\n\nimpl pallet_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype BountyDepositBase = BountyDepositBase;\n\ttype BountyDepositPayoutDelay = BountyDepositPayoutDelay;\n\ttype BountyUpdatePeriod = BountyUpdatePeriod;\n\ttype CuratorDepositMultiplier = CuratorDepositMultiplier;\n\ttype CuratorDepositMin = CuratorDepositMin;\n\ttype CuratorDepositMax = CuratorDepositMax;\n\ttype BountyValueMinimum = BountyValueMinimum;\n\ttype DataDepositPerByte = DataDepositPerByte;\n\ttype MaximumReasonLength = MaximumReasonLength;\n\ttype WeightInfo = pallet_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n\ttype ChildBountyManager = ChildBounties;\n}\n\nparameter_types! {\n\tpub const ChildBountyValueMinimum: Balance = 1 * UNIT;\n}\n\nimpl pallet_child_bounties::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype MaxActiveChildBountyCount = ConstU32\u003c10\u003e;\n\ttype ChildBountyValueMinimum = ChildBountyValueMinimum;\n\ttype WeightInfo = pallet_child_bounties::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_type_with_key! {\n\tpub ExistentialDeposits: |_currency_id: CurrencyId| -\u003e Balance {\n\t\tNANOUNIT\n\t};\n}\n\npub fn get_all_module_accounts() -\u003e Vec\u003cAccountId\u003e {\n\tvec![Treasury::account_id()]\n}\n\npub struct DustRemovalWhitelist;\nimpl Contains\u003cAccountId\u003e for DustRemovalWhitelist {\n\tfn contains(a: \u0026AccountId) -\u003e bool {\n\t\tget_all_module_accounts().contains(a)\n\t}\n}\n\npub struct CurrencyHooks\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: orml_tokens::Config\u003e MutationHooks\u003cT::AccountId, T::CurrencyId, T::Balance\u003e\n\tfor CurrencyHooks\u003cT\u003e\n{\n\ttype OnDust = orml_tokens::BurnDust\u003cT\u003e;\n\ttype OnSlash = ();\n\ttype PreDeposit = ();\n\ttype PostDeposit = ();\n\ttype PreTransfer = ();\n\ttype PostTransfer = ();\n\ttype OnNewTokenAccount = ();\n\ttype OnKilledTokenAccount = ();\n}\n\nimpl orml_tokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype Amount = Amount;\n\ttype CurrencyId = CurrencyId;\n\ttype WeightInfo = ();\n\ttype ExistentialDeposits = ExistentialDeposits;\n\ttype CurrencyHooks = CurrencyHooks\u003cRuntime\u003e;\n\ttype MaxLocks = ConstU32\u003c50\u003e;\n\ttype DustRemovalWhitelist = DustRemovalWhitelist;\n\ttype MaxReserves = ConstU32\u003c0\u003e;\n\ttype ReserveIdentifier = ReserveIdentifier;\n}\n\nparameter_types! {\n\tpub const NativeCurrencyId: CurrencyId = CurrencyId::Native;\n}\n\nimpl orml_currencies::Config for Runtime {\n\ttype MultiCurrency = Tokens;\n\ttype NativeCurrency = BasicCurrencyAdapter\u003cRuntime, Balances, Amount, BlockNumber\u003e;\n\ttype GetNativeCurrencyId = NativeCurrencyId;\n\ttype WeightInfo = ();\n}\n\nimpl orml_asset_registry::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype CustomMetadata = asset_registry::CustomMetadata;\n\ttype AssetId = CurrencyId;\n\ttype AuthorityOrigin = asset_registry::AssetAuthority;\n\ttype AssetProcessor = asset_registry::CustomAssetProcessor;\n\ttype Balance = Balance;\n\ttype WeightInfo = weights::orml_asset_registry::WeightInfo\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinBlocksPerRound: BlockNumber = HOURS;\n\tpub const DefaultBlocksPerRound: BlockNumber = 2 * HOURS;\n\tpub const StakeDuration: BlockNumber = 7 * DAYS;\n\tpub const ExitQueueDelay: u32 = 2;\n\tpub const MinCollators: u32 = 8;\n\tpub const MinRequiredCollators: u32 = 4;\n\tpub const MaxDelegationsPerRound: u32 = 1;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxDelegatorsPerCollator: u32 = 40;\n\tpub const MinCollatorStake: Balance = 5_000 * UNIT;\n\tpub const MinDelegatorStake: Balance = 10 * UNIT;\n\t#[derive(Debug, Eq, PartialEq)]\n\tpub const MaxTopCandidates: u32 = 50;\n\tpub const MaxUnstakeRequests: u32 = 10;\n\tpub const NetworkRewardStart: BlockNumber = BlockNumber::MAX;\n\tpub const NetworkRewardRate: Perquintill = Perquintill::from_percent(0);\n\tpub const CollatorRewardRateDecay: Perquintill = Perquintill::from_parts(938_252_045_000_000_000u64);\n}\n\nimpl parachain_staking::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyBalance = Balance;\n\n\ttype MinBlocksPerRound = MinBlocksPerRound;\n\ttype DefaultBlocksPerRound = DefaultBlocksPerRound;\n\ttype StakeDuration = StakeDuration;\n\ttype ExitQueueDelay = ExitQueueDelay;\n\ttype MinCollators = MinCollators;\n\ttype MinRequiredCollators = MinRequiredCollators;\n\ttype MaxDelegationsPerRound = MaxDelegationsPerRound;\n\ttype MaxDelegatorsPerCollator = MaxDelegatorsPerCollator;\n\ttype MinCollatorStake = MinCollatorStake;\n\ttype MinCollatorCandidateStake = MinCollatorStake;\n\ttype MaxTopCandidates = MaxTopCandidates;\n\ttype MinDelegatorStake = MinDelegatorStake;\n\ttype MaxUnstakeRequests = MaxUnstakeRequests;\n\ttype NetworkRewardRate = NetworkRewardRate;\n\ttype NetworkRewardStart = NetworkRewardStart;\n\ttype NetworkRewardBeneficiary = Treasury;\n\ttype CollatorRewardRateDecay = CollatorRewardRateDecay;\n\ttype WeightInfo = parachain_staking::default_weights::SubstrateWeight\u003cRuntime\u003e;\n\n\tconst BLOCKS_PER_YEAR: BlockNumber = BLOCKS_PER_YEAR;\n}\n\nparameter_types! {\n\tpub const DepositBase: Balance = 300 * MILLIUNIT;\n\tpub const DepositFactor: Balance = 50 * MILLIUNIT;\n}\n\nimpl pallet_multisig::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Currency = Balances;\n\ttype DepositBase = DepositBase;\n\ttype DepositFactor = DepositFactor;\n\ttype MaxSignatories = ConstU32\u003c20\u003e;\n\ttype WeightInfo = pallet_multisig::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl pallet_utility::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype PalletsOrigin = OriginCaller;\n\ttype WeightInfo = pallet_utility::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nparameter_types! {\n\tpub const MinVestedTransfer: Balance = 0;\n\tpub UnvestedFundsAllowedWithdrawReasons: WithdrawReasons =\n\t\tWithdrawReasons::except(WithdrawReasons::TRANSFER | WithdrawReasons::RESERVE);\n}\n\nimpl pallet_vesting::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BlockNumberToBalance = ConvertInto;\n\ttype MinVestedTransfer = MinVestedTransfer;\n\ttype UnvestedFundsAllowedWithdrawReasons = UnvestedFundsAllowedWithdrawReasons;\n\ttype WeightInfo = pallet_vesting::weights::SubstrateWeight\u003cRuntime\u003e;\n\tconst MAX_VESTING_SCHEDULES: u32 = 10;\n}\n\nimpl vesting_manager::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype VestingSchedule = Vesting;\n}\n\nconst fn deposit(items: u32, bytes: u32) -\u003e Balance {\n\t(items as Balance * UNIT + (bytes as Balance) * (5 * MILLIUNIT / 100)) / 10\n}\n\nparameter_types! {\n\tpub const DepositPerItem: Balance = deposit(1, 0);\n\tpub const DepositPerByte: Balance = deposit(0, 1);\n\tpub const DeletionQueueDepth: u32 = 128;\n\tpub DeletionWeightLimit: Weight = RuntimeBlockWeights::get()\n\t\t.per_class\n\t\t.get(DispatchClass::Normal)\n\t\t.max_total\n\t\t.unwrap_or(RuntimeBlockWeights::get().max_block);\n\tpub Schedule: pallet_contracts::Schedule\u003cRuntime\u003e = Default::default();\n}\n\nimpl pallet_contracts::Config for Runtime {\n\ttype Time = Timestamp;\n\ttype Randomness = RandomnessCollectiveFlip;\n\ttype Currency = Balances;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype CallFilter = frame_support::traits::Nothing;\n\ttype DepositPerItem = DepositPerItem;\n\ttype DepositPerByte = DepositPerByte;\n\ttype CallStack = [pallet_contracts::Frame\u003cSelf\u003e; 5];\n\ttype WeightPrice = pallet_transaction_payment::Pallet\u003cSelf\u003e;\n\ttype WeightInfo = pallet_contracts::weights::SubstrateWeight\u003cSelf\u003e;\n\ttype ChainExtension = ();\n\ttype DeletionQueueDepth = DeletionQueueDepth;\n\ttype DeletionWeightLimit = DeletionWeightLimit;\n\ttype Schedule = Schedule;\n\ttype AddressGenerator = pallet_contracts::DefaultAddressGenerator;\n\ttype MaxCodeLen = ConstU32\u003c{ 123 * 1024 }\u003e;\n\ttype MaxStorageKeyLen = ConstU32\u003c128\u003e;\n\ttype UnsafeUnstableInterface = ConstBool\u003ctrue\u003e;\n\ttype MaxDebugBufferLen = ConstU32\u003c{ 2 * 1024 * 1024 }\u003e;\n}\n\nimpl pallet_insecure_randomness_collective_flip::Config for Runtime {}\n\nparameter_types! {\n\tpub const BasicDeposit: Balance = 10 * UNIT;       // 258 bytes on-chain\n\tpub const FieldDeposit: Balance = 25 * MILLIUNIT;  // 66 bytes on-chain\n\tpub const SubAccountDeposit: Balance = 2 * UNIT;   // 53 bytes on-chain\n\tpub const MaxSubAccounts: u32 = 100;\n\tpub const MaxAdditionalFields: u32 = 100;\n\tpub const MaxRegistrars: u32 = 20;\n}\n\ntype EnsureRootOrHalfCouncil = EitherOfDiverse\u003c\n\tEnsureRoot\u003cAccountId\u003e,\n\tpallet_collective::EnsureProportionMoreThan\u003cAccountId, CouncilCollective, 1, 2\u003e,\n\u003e;\n\nimpl pallet_identity::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype BasicDeposit = BasicDeposit;\n\ttype FieldDeposit = FieldDeposit;\n\ttype SubAccountDeposit = SubAccountDeposit;\n\ttype MaxSubAccounts = MaxSubAccounts;\n\ttype MaxAdditionalFields = MaxAdditionalFields;\n\ttype MaxRegistrars = MaxRegistrars;\n\ttype Slashed = Treasury;\n\ttype ForceOrigin = EnsureRootOrHalfCouncil;\n\ttype RegistrarOrigin = EnsureRootOrHalfCouncil;\n\ttype WeightInfo = pallet_identity::weights::SubstrateWeight\u003cRuntime\u003e;\n}\n\nimpl dia_oracle::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype RuntimeCall = RuntimeCall;\n\ttype AuthorityId = dia_oracle::crypto::DiaAuthId;\n\ttype WeightInfo = dia_oracle::weights::DiaWeightInfo\u003cRuntime\u003e;\n}\n\nimpl frame_system::offchain::SigningTypes for Runtime {\n\ttype Public = \u003cSignature as sp_runtime::traits::Verify\u003e::Signer;\n\ttype Signature = Signature;\n}\n\nimpl\u003cC\u003e frame_system::offchain::SendTransactionTypes\u003cC\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cC\u003e,\n{\n\ttype OverarchingCall = RuntimeCall;\n\ttype Extrinsic = UncheckedExtrinsic;\n}\n\nimpl\u003cLocalCall\u003e frame_system::offchain::CreateSignedTransaction\u003cLocalCall\u003e for Runtime\nwhere\n\tRuntimeCall: From\u003cLocalCall\u003e,\n{\n\tfn create_transaction\u003cC: frame_system::offchain::AppCrypto\u003cSelf::Public, Self::Signature\u003e\u003e(\n\t\tcall: RuntimeCall,\n\t\tpublic: \u003cSignature as sp_runtime::traits::Verify\u003e::Signer,\n\t\taccount: AccountId,\n\t\tindex: Index,\n\t) -\u003e Option\u003c(\n\t\tRuntimeCall,\n\t\t\u003cUncheckedExtrinsic as sp_runtime::traits::Extrinsic\u003e::SignaturePayload,\n\t)\u003e {\n\t\tlet period = BlockHashCount::get() as u64;\n\t\tlet current_block = System::block_number().saturated_into::\u003cu64\u003e().saturating_sub(1);\n\t\tlet tip = 0;\n\t\tlet extra: SignedExtra = (\n\t\t\tframe_system::CheckNonZeroSender::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckSpecVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckTxVersion::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckGenesis::\u003cRuntime\u003e::new(),\n\t\t\tframe_system::CheckEra::\u003cRuntime\u003e::from(generic::Era::mortal(period, current_block)),\n\t\t\tframe_system::CheckNonce::\u003cRuntime\u003e::from(index),\n\t\t\tframe_system::CheckWeight::\u003cRuntime\u003e::new(),\n\t\t\tpallet_transaction_payment::ChargeTransactionPayment::\u003cRuntime\u003e::from(tip),\n\t\t);\n\n\t\tlet raw_payload = SignedPayload::new(call, extra).ok()?;\n\t\tlet signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;\n\t\tlet address = account;\n\t\tlet (call, extra, _) = raw_payload.deconstruct();\n\t\tSome((call, (sp_runtime::MultiAddress::Id(address), signature.into(), extra)))\n\t}\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic,\n\t{\n\t\t// System support stuff.\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event\u003cT\u003e} = 0,\n\t\tParachainSystem: cumulus_pallet_parachain_system::{\n\t\t\tPallet, Call, Config, Storage, Inherent, Event\u003cT\u003e, ValidateUnsigned,\n\t\t} = 1,\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent} = 2,\n\t\tParachainInfo: parachain_info::{Pallet, Storage, Config} = 3,\n\n\t\t// Monetary stuff.\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 10,\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage, Event\u003cT\u003e} = 11,\n\n\t\t// Governance\n\t\tDemocracy: pallet_democracy::{Pallet, Call, Storage, Config\u003cT\u003e, Event\u003cT\u003e} = 13,\n\t\tCouncil: pallet_collective::\u003cInstance1\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e, Event\u003cT\u003e} = 14,\n\t\tTechnicalCommittee: pallet_collective::\u003cInstance2\u003e::{Pallet, Call, Storage, Config\u003cT\u003e, Origin\u003cT\u003e,  Event\u003cT\u003e} = 15,\n\t\tScheduler: pallet_scheduler::{Pallet, Call, Storage, Event\u003cT\u003e} = 16,\n\t\tPreimage: pallet_preimage::{Pallet, Call, Storage, Event\u003cT\u003e} = 17,\n\t\tMultisig: pallet_multisig::{Pallet, Call, Storage, Event\u003cT\u003e} = 18,\n\t\tTreasury: pallet_treasury::{Pallet, Call, Storage, Event\u003cT\u003e} = 19,\n\t\tBounties: pallet_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 20,\n\t\tChildBounties: pallet_child_bounties::{Pallet, Call, Storage, Event\u003cT\u003e} = 21,\n\n\t\t// Consensus support.\n\t\t// The following order MUST NOT be changed: Aura -\u003e Session -\u003e Staking -\u003e Authorship -\u003e AuraExt\n\t\t// Dependencies: AuraExt on Aura, Authorship and Session on ParachainStaking\n\t\tAura: pallet_aura::{Pallet, Storage, Config\u003cT\u003e} = 33,\n\t\tSession: pallet_session::{Pallet, Call, Storage, Event, Config\u003cT\u003e} = 32,\n\t\tParachainStaking: parachain_staking::{Pallet, Call, Storage, Event\u003cT\u003e, Config\u003cT\u003e} = 35,\n\t\tAuthorship: pallet_authorship::{Pallet, Storage} = 30,\n\t\tAuraExt: cumulus_pallet_aura_ext::{Pallet, Storage, Config} = 34,\n\n\t\t// XCM helpers.\n\t\tXcmpQueue: cumulus_pallet_xcmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 40,\n\t\tPolkadotXcm: pallet_xcm::{Pallet, Call, Event\u003cT\u003e, Origin, Config} = 41,\n\t\tCumulusXcm: cumulus_pallet_xcm::{Pallet, Event\u003cT\u003e, Origin} = 42,\n\t\tDmpQueue: cumulus_pallet_dmp_queue::{Pallet, Call, Storage, Event\u003cT\u003e} = 43,\n\n\t\t// Amendments\n\t\tVesting: pallet_vesting::{Pallet, Call, Config\u003cT\u003e, Storage, Event\u003cT\u003e} = 50,\n\t\tUtility: pallet_utility::{Pallet, Call, Event} = 51,\n\t\tCurrencies: orml_currencies::{Pallet, Call, Storage} = 52,\n\t\tTokens: orml_tokens::{Pallet, Call, Storage, Event\u003cT\u003e} = 53,\n\t\tXTokens: orml_xtokens::{Pallet, Storage, Call, Event\u003cT\u003e} = 54,\n\t\tIdentity: pallet_identity::{Pallet, Storage, Call, Event\u003cT\u003e} = 55,\n\t\tContracts: pallet_contracts::{Pallet, Storage, Call, Event\u003cT\u003e} = 56,\n\t\tRandomnessCollectiveFlip: pallet_insecure_randomness_collective_flip::{Pallet, Storage} = 57,\n\t\tDiaOracleModule: dia_oracle::{Pallet, Storage, Call, Event\u003cT\u003e} = 58,\n\n\t\tZenlinkProtocol: zenlink_protocol::{Pallet, Call, Storage, Event\u003cT\u003e}  = 59,\n\n\t\t// Asset Metadata\n\t\tAssetRegistry: orml_asset_registry::{Pallet, Storage, Call, Event\u003cT\u003e, Config\u003cT\u003e} = 91,\n\n\t\tVestingManager: vesting_manager::{Pallet, Call, Event\u003cT\u003e} = 100\n\t}\n);\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!(\n\t\t[frame_benchmarking, BaselineBench::\u003cRuntime\u003e]\n\t\t[frame_system, SystemBench::\u003cRuntime\u003e]\n\t\t[pallet_balances, Balances]\n\t\t[pallet_session, SessionBench::\u003cRuntime\u003e]\n\t\t[pallet_timestamp, Timestamp]\n\t\t[cumulus_pallet_xcmp_queue, XcmpQueue]\n\n\t\t// Other\n\t\t[orml_asset_registry, runtime_common::benchmarking::orml_asset_registry::Pallet::\u003cRuntime\u003e]\n\t\t[pallet_xcm, PolkadotXcm]\n\t);\n}\n\nimpl_runtime_apis! {\n\timpl sp_consensus_aura::AuraApi\u003cBlock, AuraId\u003e for Runtime {\n\t\tfn slot_duration() -\u003e sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -\u003e Vec\u003cAuraId\u003e {\n\t\t\tAura::authorities().into_inner()\n\t\t}\n\t}\n\n\timpl sp_api::Core\u003cBlock\u003e for Runtime {\n\t\tfn version() -\u003e RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata\u003cBlock\u003e for Runtime {\n\t\tfn metadata() -\u003e OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder\u003cBlock\u003e for Runtime {\n\t\tfn apply_extrinsic(extrinsic: \u003cBlock as BlockT\u003e::Extrinsic) -\u003e ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -\u003e \u003cBlock as BlockT\u003e::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -\u003e Vec\u003c\u003cBlock as BlockT\u003e::Extrinsic\u003e {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(\u0026block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue\u003cBlock\u003e for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tblock_hash: \u003cBlock as BlockT\u003e::Hash,\n\t\t) -\u003e TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi\u003cBlock\u003e for Runtime {\n\t\tfn offchain_worker(header: \u0026\u003cBlock as BlockT\u003e::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys\u003cBlock\u003e for Runtime {\n\t\tfn generate_session_keys(seed: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Vec\u003cu8\u003e {\n\t\t\tSessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec\u003cu8\u003e,\n\t\t) -\u003e Option\u003cVec\u003c(Vec\u003cu8\u003e, KeyTypeId)\u003e\u003e {\n\t\t\tSessionKeys::decode_into_raw_public_keys(\u0026encoded)\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi\u003cBlock, AccountId, Index\u003e for Runtime {\n\t\tfn account_nonce(account: AccountId) -\u003e Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi\u003cBlock, Balance\u003e for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\t\tfn query_fee_details(\n\t\t\tuxt: \u003cBlock as BlockT\u003e::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -\u003e pallet_transaction_payment::FeeDetails\u003cBalance\u003e {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t\tfn query_weight_to_fee(weight: Weight) -\u003e Balance {\n\t\t\tTransactionPayment::weight_to_fee(weight)\n\t\t}\n\t\tfn query_length_to_fee(length: u32) -\u003e Balance {\n\t\t\tTransactionPayment::length_to_fee(length)\n\t\t}\n\t}\n\n\timpl cumulus_primitives_core::CollectCollationInfo\u003cBlock\u003e for Runtime {\n\t\tfn collect_collation_info(header: \u0026\u003cBlock as BlockT\u003e::Header) -\u003e cumulus_primitives_core::CollationInfo {\n\t\t\tParachainSystem::collect_collation_info(header)\n\t\t}\n\t}\n\n\timpl parachain_staking::runtime_api::ParachainStakingApi\u003cBlock, AccountId, Balance\u003e for Runtime {\n\t\tfn get_unclaimed_staking_rewards(account: \u0026AccountId) -\u003e Balance {\n\t\t\tParachainStaking::get_unclaimed_staking_rewards(account)\n\t\t}\n\n\t\tfn get_staking_rates() -\u003e parachain_staking::runtime_api::StakingRates {\n\t\t\tParachainStaking::get_staking_rates()\n\t\t}\n\t}\n\n\timpl dia_oracle_runtime_api::DiaOracleApi\u003cBlock\u003e for Runtime{\n\t\tfn get_value(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::PriceInfo, sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_value(blockchain, symbol)\n\t\t}\n\n\t\tfn get_coin_info(blockchain: frame_support::sp_std::vec::Vec\u003cu8\u003e, symbol: frame_support::sp_std::vec::Vec\u003cu8\u003e)-\u003e Result\u003cdia_oracle_runtime_api::CoinInfo,sp_runtime::DispatchError\u003e{\n\t\t\tDiaOracleModule::get_coin_info(blockchain, symbol)\n\t\t}\n\t}\n\n\t// zenlink runtime outer apis\n\timpl zenlink_protocol_runtime_api::ZenlinkProtocolApi\u003cBlock, AccountId, ZenlinkAssetId\u003e for Runtime {\n\n\t\tfn get_balance(\n\t\t\tasset_id: ZenlinkAssetId,\n\t\t\towner: AccountId\n\t\t) -\u003e AssetBalance {\n\t\t\t\u003cRuntime as zenlink_protocol::Config\u003e::MultiAssetsHandler::balance_of(asset_id, \u0026owner)\n\t\t}\n\n\t\tfn get_pair_by_asset_id(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId\n\t\t) -\u003e Option\u003cPairInfo\u003cAccountId, AssetBalance, ZenlinkAssetId\u003e\u003e {\n\t\t\tZenlinkProtocol::get_pair_by_asset_id(asset_0, asset_1)\n\t\t}\n\n\t\tfn get_amount_in_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::desired_in_amount(supply, path)\n\t\t}\n\n\t\tfn get_amount_out_price(\n\t\t\tsupply: AssetBalance,\n\t\t\tpath: Vec\u003cZenlinkAssetId\u003e\n\t\t) -\u003e AssetBalance {\n\t\t\tZenlinkProtocol::supply_out_amount(supply, path)\n\t\t}\n\n\t\tfn get_estimate_lptoken(\n\t\t\ttoken_0: ZenlinkAssetId,\n\t\t\ttoken_1: ZenlinkAssetId,\n\t\t\tamount_0_desired: AssetBalance,\n\t\t\tamount_1_desired: AssetBalance,\n\t\t\tamount_0_min: AssetBalance,\n\t\t\tamount_1_min: AssetBalance,\n\t\t) -\u003e AssetBalance{\n\t\t\tZenlinkProtocol::get_estimate_lptoken(\n\t\t\t\ttoken_0,\n\t\t\t\ttoken_1,\n\t\t\t\tamount_0_desired,\n\t\t\t\tamount_1_desired,\n\t\t\t\tamount_0_min,\n\t\t\t\tamount_1_min\n\t\t\t)\n\t\t}\n\n\t\tfn calculate_remove_liquidity(\n\t\t\tasset_0: ZenlinkAssetId,\n\t\t\tasset_1: ZenlinkAssetId,\n\t\t\tamount: AssetBalance,\n\t\t) -\u003e Option\u003c(AssetBalance, AssetBalance)\u003e{\n\t\t\tZenlinkProtocol::calculate_remove_liquidity(\n\t\t\t\tasset_0,\n\t\t\t\tasset_1,\n\t\t\t\tamount,\n\t\t\t)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\timpl frame_try_runtime::TryRuntime\u003cBlock\u003e for Runtime {\n\t\tfn on_runtime_upgrade() -\u003e (Weight, Weight) {\n\t\t\tlog::info!(\"try-runtime::on_runtime_upgrade pendulum.\");\n\t\t\tlet weight = Executive::try_runtime_upgrade().unwrap();\n\t\t\t(weight, RuntimeBlockWeights::get().max_block)\n\t\t}\n\n\t\tfn execute_block_no_check(block: Block) -\u003e Weight {\n\t\t\tExecutive::execute_block_no_check(block)\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark\u003cBlock\u003e for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -\u003e (\n\t\t\tVec\u003cframe_benchmarking::BenchmarkList\u003e,\n\t\t\tVec\u003cframe_support::traits::StorageInfo\u003e,\n\t\t) {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\tlet mut list = Vec::\u003cBenchmarkList\u003e::new();\n\t\t\tlist_benchmarks!(list, extra);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -\u003e Result\u003cVec\u003cframe_benchmarking::BenchmarkBatch\u003e, sp_runtime::RuntimeString\u003e {\n\t\t\tuse frame_benchmarking::{baseline, Benchmarking, BenchmarkBatch, TrackedStorageKey};\n\n\t\t\tuse frame_system_benchmarking::Pallet as SystemBench;\n\t\t\tuse baseline::Pallet as BaselineBench;\n\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\t\t\timpl baseline::Config for Runtime {}\n\t\t\timpl runtime_common::benchmarking::orml_asset_registry::Config for Runtime {}\n\n\t\t\tuse cumulus_pallet_session_benchmarking::Pallet as SessionBench;\n\t\t\timpl cumulus_pallet_session_benchmarking::Config for Runtime {}\n\n\n\t\t\tlet whitelist: Vec\u003cTrackedStorageKey\u003e = vec![\n\t\t\t\t// Block Number\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\").to_vec().into(),\n\t\t\t\t// Total Issuance\n\t\t\t\thex_literal::hex!(\"c2261276cc9d1f8598ea4b6a74b15c2f57c875e4cff74148e4628f264b974c80\").to_vec().into(),\n\t\t\t\t// Execution Phase\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\").to_vec().into(),\n\t\t\t\t// Event Count\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\").to_vec().into(),\n\t\t\t\t// System Events\n\t\t\t\thex_literal::hex!(\"26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\").to_vec().into(),\n\t\t\t];\n\n\t\t\tlet mut batches = Vec::\u003cBenchmarkBatch\u003e::new();\n\t\t\tlet params = (\u0026config, \u0026whitelist);\n\t\t\tadd_benchmarks!(params, batches);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n\n\timpl pallet_contracts::ContractsApi\u003cBlock, AccountId, Balance, BlockNumber, Hash\u003e\n\t\tfor Runtime\n\t{\n\t\tfn call(\n\t\t\torigin: AccountId,\n\t\t\tdest: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tinput_data: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractExecResult\u003cBalance\u003e {\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_call(\n\t\t\t\torigin,\n\t\t\t\tdest,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tinput_data,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT,\n\t\t\t\tpallet_contracts::Determinism::Deterministic,\n\t\t\t)\n\t\t}\n\n\t\tfn instantiate(\n\t\t\torigin: AccountId,\n\t\t\tvalue: Balance,\n\t\t\tgas_limit: Option\u003cWeight\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tcode: pallet_contracts_primitives::Code\u003cHash\u003e,\n\t\t\tdata: Vec\u003cu8\u003e,\n\t\t\tsalt: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::ContractInstantiateResult\u003cAccountId, Balance\u003e\n\t\t{\n\t\t\tlet gas_limit = gas_limit.unwrap_or(RuntimeBlockWeights::get().max_block);\n\t\t\tContracts::bare_instantiate(\n\t\t\t\torigin,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tstorage_deposit_limit,\n\t\t\t\tcode,\n\t\t\t\tdata,\n\t\t\t\tsalt,\n\t\t\t\tCONTRACTS_DEBUG_OUTPUT\n\t\t\t)\n\t\t}\n\n\t\tfn upload_code(\n\t\t\torigin: AccountId,\n\t\t\tcode: Vec\u003cu8\u003e,\n\t\t\tstorage_deposit_limit: Option\u003cBalance\u003e,\n\t\t\tdeterminism: pallet_contracts::Determinism,\n\t\t) -\u003e pallet_contracts_primitives::CodeUploadResult\u003cHash, Balance\u003e\n\t\t{\n\t\t\tContracts::bare_upload_code(origin, code, storage_deposit_limit, determinism)\n\t\t}\n\n\t\tfn get_storage(\n\t\t\taddress: AccountId,\n\t\t\tkey: Vec\u003cu8\u003e,\n\t\t) -\u003e pallet_contracts_primitives::GetStorageResult {\n\t\t\tContracts::get_storage(address, key)\n\t\t}\n\t}\n\n}\n\nstruct CheckInherents;\n\nimpl cumulus_pallet_parachain_system::CheckInherents\u003cBlock\u003e for CheckInherents {\n\tfn check_inherents(\n\t\tblock: \u0026Block,\n\t\trelay_state_proof: \u0026cumulus_pallet_parachain_system::RelayChainStateProof,\n\t) -\u003e sp_inherents::CheckInherentsResult {\n\t\tlet relay_chain_slot = relay_state_proof\n\t\t\t.read_slot()\n\t\t\t.expect(\"Could not read the relay chain slot from the proof\");\n\n\t\tlet inherent_data =\n\t\t\tcumulus_primitives_timestamp::InherentDataProvider::from_relay_chain_slot_and_duration(\n\t\t\t\trelay_chain_slot,\n\t\t\t\tsp_std::time::Duration::from_secs(6),\n\t\t\t)\n\t\t\t.create_inherent_data()\n\t\t\t.expect(\"Could not create the timestamp inherent data\");\n\n\t\tinherent_data.check_extrinsics(block)\n\t}\n}\n\ncumulus_pallet_parachain_system::register_validate_block! {\n\tRuntime = Runtime,\n\tBlockExecutor = cumulus_pallet_aura_ext::BlockExecutor::\u003cRuntime, Executive\u003e,\n\tCheckInherents = CheckInherents,\n}\n","traces":[{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":944,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":948,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":949,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","block_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Importing a block with 0 Extrinsics.\n\t\tpub const BlockExecutionWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(5_000_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::BlockExecutionWeight::get();\n\n\t\t\t// At least 100 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 100u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 100 µs.\"\n\t\t\t);\n\t\t\t// At most 50 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= 50u64 * constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 50 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","extrinsic_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, Weight},\n\t};\n\n\tparameter_types! {\n\t\t/// Executing a NO-OP `System::remarks` Extrinsic.\n\t\tpub const ExtrinsicBaseWeight: Weight = Weight::from_parts(constants::WEIGHT_REF_TIME_PER_NANOS.saturating_mul(125_000), 0);\n\t}\n\n\t#[cfg(test)]\n\tmod test_weights {\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that the weight exists and is sane.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\tlet w = super::constants::ExtrinsicBaseWeight::get();\n\n\t\t\t// At least 10 µs.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003e= 10u64 * constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Weight should be at least 10 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tw.ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","mod.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! Expose the auto generated weight files.\n\npub mod block_weights;\npub mod extrinsic_weights;\npub mod orml_asset_registry;\npub mod pallet_xcm;\npub mod paritydb_weights;\npub mod rocksdb_weights;\n\npub use block_weights::constants::BlockExecutionWeight;\npub use extrinsic_weights::constants::ExtrinsicBaseWeight;\npub use paritydb_weights::constants::ParityDbWeight;\npub use rocksdb_weights::constants::RocksDbWeight;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","orml_asset_registry.rs"],"content":"\n//! Autogenerated weights for `orml_asset_registry`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-07-25, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Marcels-MBP`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"pendulum\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// pendulum\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet\n// *\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// runtime/pendulum/src/weights/\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `orml_asset_registry`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e orml_asset_registry::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn register_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `66`\n\t\t//  Estimated: `7062`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 7062))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: AssetRegistry Metadata (r:1 w:1)\n\t/// Proof Skipped: AssetRegistry Metadata (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: AssetRegistry LocationToAssetId (r:1 w:2)\n\t/// Proof Skipped: AssetRegistry LocationToAssetId (max_values: None, max_size: None, mode: Measured)\n\tfn update_asset() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `707`\n\t\t//  Estimated: `8344`\n\t\t// Minimum execution time: 25_000_000 picoseconds.\n\t\tWeight::from_parts(26_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8344))\n\t\t\t.saturating_add(T::DbWeight::get().reads(2))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\tfn set_asset_location() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 0_000 picoseconds.\n\t\tWeight::from_parts(0, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","pallet_xcm.rs"],"content":"\n//! Autogenerated weights for `pallet_xcm`\n//!\n//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION 4.0.0-dev\n//! DATE: 2023-06-20, STEPS: `50`, REPEAT: `20`, LOW RANGE: `[]`, HIGH RANGE: `[]`\n//! WORST CASE MAP SIZE: `1000000`\n//! HOSTNAME: `Bs-MacBook-Pro.local`, CPU: `\u003cUNKNOWN\u003e`\n//! EXECUTION: Some(Wasm), WASM-EXECUTION: Compiled, CHAIN: Some(\"pendulum\"), DB CACHE: 1024\n\n// Executed Command:\n// ./target/production/pendulum-node\n// benchmark\n// pallet\n// --chain\n// pendulum\n// --execution=wasm\n// --wasm-execution=compiled\n// --pallet=pallet-xcm\n// --extrinsic\n// *\n// --steps\n// 50\n// --repeat\n// 20\n// --output\n// pallet_xcm.rs\n\n#![cfg_attr(rustfmt, rustfmt_skip)]\n#![allow(unused_parens)]\n#![allow(unused_imports)]\n\nuse frame_support::{traits::Get, weights::Weight};\nuse sp_std::marker::PhantomData;\n\n/// Weight functions for `pallet_xcm`.\npub struct WeightInfo\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: frame_system::Config\u003e pallet_xcm::WeightInfo for WeightInfo\u003cT\u003e {\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn send() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `145`\n\t\t//  Estimated: `10130`\n\t\t// Minimum execution time: 25_000_000 picoseconds.\n\t\tWeight::from_parts(26_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 10130))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: Benchmark Override (r:0 w:0)\n\t/// Proof Skipped: Benchmark Override (max_values: None, max_size: None, mode: Measured)\n\tfn teleport_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 18_446_744_073_709_551_000 picoseconds.\n\t\tWeight::from_parts(18_446_744_073_709_551_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: ParachainInfo ParachainId (r:1 w:0)\n\t/// Proof: ParachainInfo ParachainId (max_values: Some(1), max_size: Some(4), added: 499, mode: MaxEncodedLen)\n\tfn reserve_transfer_assets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `32`\n\t\t//  Estimated: `1489`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(19_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 1489))\n\t\t\t.saturating_add(T::DbWeight::get().reads(1))\n\t}\n\tfn execute() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn force_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 9_000_000 picoseconds.\n\t\tWeight::from_parts(9_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\tfn force_default_xcm_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `0`\n\t\t//  Estimated: `0`\n\t\t// Minimum execution time: 3_000_000 picoseconds.\n\t\tWeight::from_parts(3_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 0))\n\t\t\t.saturating_add(T::DbWeight::get().writes(1))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm QueryCounter (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm QueryCounter (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_subscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `145`\n\t\t//  Estimated: `15515`\n\t\t// Minimum execution time: 29_000_000 picoseconds.\n\t\tWeight::from_parts(30_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 15515))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm Queries (r:0 w:1)\n\t/// Proof Skipped: PolkadotXcm Queries (max_values: None, max_size: None, mode: Measured)\n\tfn force_unsubscribe_version_notify() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `328`\n\t\t//  Estimated: `15166`\n\t\t// Minimum execution time: 30_000_000 picoseconds.\n\t\tWeight::from_parts(31_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 15166))\n\t\t\t.saturating_add(T::DbWeight::get().reads(6))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n\t/// Storage: PolkadotXcm SupportedVersion (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_supported_version() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `162`\n\t\t//  Estimated: `11052`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11052))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifiers (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifiers (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notifiers() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `166`\n\t\t//  Estimated: `11056`\n\t\t// Minimum execution time: 17_000_000 picoseconds.\n\t\tWeight::from_parts(18_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11056))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:5 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn already_notified_target() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `173`\n\t\t//  Estimated: `13538`\n\t\t// Minimum execution time: 19_000_000 picoseconds.\n\t\tWeight::from_parts(20_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 13538))\n\t\t\t.saturating_add(T::DbWeight::get().reads(5))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:2 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn notify_current_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `212`\n\t\t//  Estimated: `16617`\n\t\t// Minimum execution time: 28_000_000 picoseconds.\n\t\tWeight::from_parts(28_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 16617))\n\t\t\t.saturating_add(T::DbWeight::get().reads(7))\n\t\t\t.saturating_add(T::DbWeight::get().writes(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:3 w:0)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn notify_target_migration_fail() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `206`\n\t\t//  Estimated: `8621`\n\t\t// Minimum execution time: 10_000_000 picoseconds.\n\t\tWeight::from_parts(11_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 8621))\n\t\t\t.saturating_add(T::DbWeight::get().reads(3))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\tfn migrate_version_notify_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `173`\n\t\t//  Estimated: `11063`\n\t\t// Minimum execution time: 18_000_000 picoseconds.\n\t\tWeight::from_parts(19_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 11063))\n\t\t\t.saturating_add(T::DbWeight::get().reads(4))\n\t\t\t.saturating_add(T::DbWeight::get().writes(2))\n\t}\n\t/// Storage: PolkadotXcm VersionNotifyTargets (r:4 w:2)\n\t/// Proof Skipped: PolkadotXcm VersionNotifyTargets (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SupportedVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SupportedVersion (max_values: None, max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm VersionDiscoveryQueue (r:1 w:1)\n\t/// Proof Skipped: PolkadotXcm VersionDiscoveryQueue (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: PolkadotXcm SafeXcmVersion (r:1 w:0)\n\t/// Proof Skipped: PolkadotXcm SafeXcmVersion (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem HostConfiguration (r:1 w:0)\n\t/// Proof Skipped: ParachainSystem HostConfiguration (max_values: Some(1), max_size: None, mode: Measured)\n\t/// Storage: ParachainSystem PendingUpwardMessages (r:1 w:1)\n\t/// Proof Skipped: ParachainSystem PendingUpwardMessages (max_values: Some(1), max_size: None, mode: Measured)\n\tfn migrate_and_notify_old_targets() -\u003e Weight {\n\t\t// Proof Size summary in bytes:\n\t\t//  Measured:  `215`\n\t\t//  Estimated: `21585`\n\t\t// Minimum execution time: 36_000_000 picoseconds.\n\t\tWeight::from_parts(37_000_000, 0)\n\t\t\t.saturating_add(Weight::from_parts(0, 21585))\n\t\t\t.saturating_add(T::DbWeight::get().reads(9))\n\t\t\t.saturating_add(T::DbWeight::get().writes(4))\n\t}\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":66},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","paritydb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// `ParityDB` can be enabled with a feature flag, but is still experimental. These weights\n\t\t/// are available for brave runtime engineers who may want to try this out as default.\n\t\tpub const ParityDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 8_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 50_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::ParityDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_MICROS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","weights","rocksdb_weights.rs"],"content":"// This file is part of Substrate.\n\n// Copyright (C) 2022 Parity Technologies (UK) Ltd.\n// SPDX-License-Identifier: Apache-2.0\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npub mod constants {\n\tuse frame_support::{\n\t\tparameter_types,\n\t\tweights::{constants, RuntimeDbWeight},\n\t};\n\n\tparameter_types! {\n\t\t/// By default, Substrate uses `RocksDB`, so this will be the weight used throughout\n\t\t/// the runtime.\n\t\tpub const RocksDbWeight: RuntimeDbWeight = RuntimeDbWeight {\n\t\t\tread: 25_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\twrite: 100_000 * constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t};\n\t}\n\n\t#[cfg(test)]\n\tmod test_db_weights {\n\t\tuse super::constants::RocksDbWeight as W;\n\t\tuse frame_support::weights::constants;\n\n\t\t/// Checks that all weights exist and have sane values.\n\t\t// NOTE: If this test fails but you are sure that the generated values are fine,\n\t\t// you can delete it.\n\t\t#[test]\n\t\tfn sane() {\n\t\t\t// At least 1 µs.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\t\t\"Read weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003e= constants::WEIGHT_REF_TIME_PER_NANOS,\n\t\t\t\t\"Write weight should be at least 1 µs.\"\n\t\t\t);\n\t\t\t// At most 1 ms.\n\t\t\tassert!(\n\t\t\t\tW::get().reads(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Read weight should be at most 1 ms.\"\n\t\t\t);\n\t\t\tassert!(\n\t\t\t\tW::get().writes(1).ref_time() \u003c= constants::WEIGHT_REF_TIME_PER_MILLIS,\n\t\t\t\t\"Write weight should be at most 1 ms.\"\n\t\t\t);\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","xcm_config.rs"],"content":"use super::{\n\tAccountId, Balance, Balances, CurrencyId, ParachainInfo, ParachainSystem, PolkadotXcm, Runtime,\n\tRuntimeCall, RuntimeEvent, RuntimeOrigin, Tokens, WeightToFee, XcmpQueue,\n};\nuse crate::ConstU32;\nuse core::marker::PhantomData;\nuse frame_support::{\n\tlog, match_types, parameter_types,\n\ttraits::{ContainsPair, Everything, Nothing},\n};\nuse orml_traits::{\n\tlocation::{RelativeReserveProvider, Reserve},\n\tparameter_type_with_key,\n};\nuse pallet_xcm::XcmPassthrough;\nuse polkadot_parachain::primitives::Sibling;\nuse polkadot_runtime_common::impls::ToAuthor;\nuse runtime_common::parachains::polkadot::asset_hub;\nuse sp_runtime::traits::Convert;\nuse xcm::latest::{prelude::*, Weight as XCMWeight};\nuse xcm_builder::{\n\tAccountId32Aliases, AllowUnpaidExecutionFrom, ConvertedConcreteId, EnsureXcmOrigin,\n\tFixedWeightBounds, FungiblesAdapter, NoChecking, ParentIsPreset, RelayChainAsNative,\n\tSiblingParachainAsNative, SiblingParachainConvertsVia, SignedAccountId32AsNative,\n\tSignedToAccountId32, SovereignSignedViaLocation, UsingComponents,\n};\nuse xcm_executor::{\n\ttraits::{JustTry, ShouldExecute},\n\tXcmExecutor,\n};\n\nconst XCM_ASSET_RELAY_DOT: u8 = 0;\nconst XCM_ASSET_ASSETHUB_USDT: u8 = 1;\n\nparameter_types! {\n\tpub const RelayLocation: MultiLocation = MultiLocation::parent();\n\tpub const RelayNetwork: NetworkId = NetworkId::Polkadot;\n\tpub RelayChainOrigin: RuntimeOrigin = cumulus_pallet_xcm::Origin::Relay.into();\n\tpub CheckingAccount: AccountId = PolkadotXcm::check_account();\n\tpub UniversalLocation: InteriorMultiLocation =\n\t\tX2(GlobalConsensus(RelayNetwork::get()), Parachain(ParachainInfo::parachain_id().into()));\n\n}\n\n/// Type for specifying how a `MultiLocation` can be converted into an `AccountId`. This is used\n/// when determining ownership of accounts for asset transacting and when attempting to use XCM\n/// `Transact` in order to determine the dispatch Origin.\npub type LocationToAccountId = (\n\t// The parent (Relay-chain) origin converts to the parent `AccountId`.\n\tParentIsPreset\u003cAccountId\u003e,\n\t// Sibling parachain origins convert to AccountId via the `ParaId::into`.\n\tSiblingParachainConvertsVia\u003cSibling, AccountId\u003e,\n\t// Straight up local `AccountId32` origins just alias directly to `AccountId`.\n\tAccountId32Aliases\u003cRelayNetwork, AccountId\u003e,\n);\n\n/// CurrencyIdConvert\n/// This type implements conversions from our `CurrencyId` type into `MultiLocation` and vice-versa.\n/// A currency locally is identified with a `CurrencyId` variant but in the network it is identified\n/// in the form of a `MultiLocation`, in this case a pCfg (Para-Id, Currency-Id).\npub struct CurrencyIdConvert;\n\nimpl Convert\u003cCurrencyId, Option\u003cMultiLocation\u003e\u003e for CurrencyIdConvert {\n\tfn convert(id: CurrencyId) -\u003e Option\u003cMultiLocation\u003e {\n\t\tmatch id {\n\t\t\t// CurrencyId::KSM =\u003e Some(MultiLocation::parent()),\n\t\t\tCurrencyId::XCM(f) =\u003e match f {\n\t\t\t\tXCM_ASSET_RELAY_DOT =\u003e Some(MultiLocation::parent()),\n\t\t\t\tXCM_ASSET_ASSETHUB_USDT =\u003e Some(MultiLocation::new(\n\t\t\t\t\t1,\n\t\t\t\t\tX3(\n\t\t\t\t\t\tParachain(asset_hub::PARA_ID),\n\t\t\t\t\t\tPalletInstance(asset_hub::ASSET_PALLET_ID),\n\t\t\t\t\t\tGeneralIndex(asset_hub::USDT_ASSET_ID),\n\t\t\t\t\t),\n\t\t\t\t)),\n\t\t\t\t_ =\u003e None,\n\t\t\t},\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Option\u003cCurrencyId\u003e {\n\t\tmatch location {\n\t\t\tMultiLocation { parents: 1, interior: Here } =\u003e\n\t\t\t\tSome(CurrencyId::XCM(XCM_ASSET_RELAY_DOT)),\n\t\t\tMultiLocation {\n\t\t\t\tparents: 1,\n\t\t\t\tinterior:\n\t\t\t\t\tX3(\n\t\t\t\t\t\tParachain(asset_hub::PARA_ID),\n\t\t\t\t\t\tPalletInstance(asset_hub::ASSET_PALLET_ID),\n\t\t\t\t\t\tGeneralIndex(asset_hub::USDT_ASSET_ID),\n\t\t\t\t\t),\n\t\t\t} =\u003e Some(CurrencyId::XCM(XCM_ASSET_ASSETHUB_USDT)),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n}\n\nimpl Convert\u003cMultiAsset, Option\u003cCurrencyId\u003e\u003e for CurrencyIdConvert {\n\tfn convert(a: MultiAsset) -\u003e Option\u003cCurrencyId\u003e {\n\t\tif let MultiAsset { id: AssetId::Concrete(id), fun: _ } = a {\n\t\t\tSelf::convert(id)\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\n/// Convert an incoming `MultiLocation` into a `CurrencyId` if possible.\n/// Here we need to know the canonical representation of all the tokens we handle in order to\n/// correctly convert their `MultiLocation` representation into our internal `CurrencyId` type.\nimpl xcm_executor::traits::Convert\u003cMultiLocation, CurrencyId\u003e for CurrencyIdConvert {\n\tfn convert(location: MultiLocation) -\u003e Result\u003cCurrencyId, MultiLocation\u003e {\n\t\t\u003cCurrencyIdConvert as Convert\u003cMultiLocation, Option\u003cCurrencyId\u003e\u003e\u003e::convert(location.clone())\n\t\t\t.ok_or(location)\n\t}\n}\n\n/// A `FilterAssetLocation` implementation. Filters multi native assets whose\n/// reserve is same with `origin`.\npub struct MultiNativeAsset\u003cReserveProvider\u003e(PhantomData\u003cReserveProvider\u003e);\nimpl\u003cReserveProvider\u003e ContainsPair\u003cMultiAsset, MultiLocation\u003e for MultiNativeAsset\u003cReserveProvider\u003e\nwhere\n\tReserveProvider: Reserve,\n{\n\tfn contains(asset: \u0026MultiAsset, origin: \u0026MultiLocation) -\u003e bool {\n\t\tif let Some(ref reserve) = ReserveProvider::reserve(asset) {\n\t\t\tif reserve == origin {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tfalse\n\t}\n}\n\n/// Means for transacting the fungibles assets of ths parachain.\npub type FungiblesTransactor = FungiblesAdapter\u003c\n\t// Use this fungibles implementation\n\tTokens,\n\t// This means that this adapter should handle any token that `CurrencyIdConvert` can convert\n\t// to `CurrencyId`, the `CurrencyId` type of `Tokens`, the fungibles implementation it uses.\n\tConvertedConcreteId\u003cCurrencyId, Balance, CurrencyIdConvert, JustTry\u003e,\n\t// Convert an XCM MultiLocation into a local account id\n\tLocationToAccountId,\n\t// Our chain's account ID type (we can't get away without mentioning it explicitly)\n\tAccountId,\n\t// We dont allow teleports.\n\tNoChecking,\n\t// The account to use for tracking teleports.\n\tCheckingAccount,\n\u003e;\n\n/// This is the type we use to convert an (incoming) XCM origin into a local `Origin` instance,\n/// ready for dispatching a transaction with Xcm's `Transact`. There is an `OriginKind` which can\n/// biases the kind of local `Origin` it will become.\npub type XcmOriginToTransactDispatchOrigin = (\n\t// Sovereign account converter; this attempts to derive an `AccountId` from the origin location\n\t// using `LocationToAccountId` and then turn that into the usual `Signed` origin. Useful for\n\t// foreign chains who want to have a local sovereign account on this chain which they control.\n\tSovereignSignedViaLocation\u003cLocationToAccountId, RuntimeOrigin\u003e,\n\t// Native converter for Relay-chain (Parent) location; will converts to a `Relay` origin when\n\t// recognized.\n\tRelayChainAsNative\u003cRelayChainOrigin, RuntimeOrigin\u003e,\n\t// Native converter for sibling Parachains; will convert to a `SiblingPara` origin when\n\t// recognized.\n\tSiblingParachainAsNative\u003ccumulus_pallet_xcm::Origin, RuntimeOrigin\u003e,\n\t// Native signed account converter; this just converts an `AccountId32` origin into a normal\n\t// `Origin::Signed` origin of the same 32-byte value.\n\tSignedAccountId32AsNative\u003cRelayNetwork, RuntimeOrigin\u003e,\n\t// Xcm origins can be represented natively under the Xcm pallet's Xcm origin.\n\tXcmPassthrough\u003cRuntimeOrigin\u003e,\n);\n\nparameter_types! {\n\t// One XCM operation is 1_000_000_000 weight - almost certainly a conservative estimate.\n\tpub UnitWeightCost: XCMWeight = XCMWeight::from_parts(1_000_000_000, 0);\n\tpub const MaxInstructions: u32 = 100;\n\tpub SelfLocation: MultiLocation = MultiLocation::new(1, X1(Parachain(ParachainInfo::parachain_id().into())));\n\tpub const BaseXcmWeight: XCMWeight = XCMWeight::from_parts(150_000_000, 0);\n\tpub const MaxAssetsForTransfer: usize = 2;\n}\n\nmatch_types! {\n\tpub type ParentOrParentsExecutivePlurality: impl Contains\u003cMultiLocation\u003e = {\n\t\tMultiLocation { parents: 1, interior: Here } |\n\t\tMultiLocation { parents: 1, interior: X1(Plurality { id: BodyId::Executive, .. }) }\n\t};\n}\n\n//TODO: move DenyThenTry to polkadot's xcm module.\n/// Deny executing the xcm message if it matches any of the Deny filter regardless of anything else.\n/// If it passes the Deny, and matches one of the Allow cases then it is let through.\npub struct DenyThenTry\u003cDeny, Allow\u003e(PhantomData\u003cDeny\u003e, PhantomData\u003cAllow\u003e)\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute;\n\nimpl\u003cDeny, Allow\u003e ShouldExecute for DenyThenTry\u003cDeny, Allow\u003e\nwhere\n\tDeny: ShouldExecute,\n\tAllow: ShouldExecute,\n{\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\tmax_weight: XCMWeight,\n\t\tweight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tDeny::should_execute(origin, instructions, max_weight, weight_credit)?;\n\t\tAllow::should_execute(origin, instructions, max_weight, weight_credit)\n\t}\n}\n\n// See issue #5233\npub struct DenyReserveTransferToRelayChain;\nimpl ShouldExecute for DenyReserveTransferToRelayChain {\n\tfn should_execute\u003cRuntimeCall\u003e(\n\t\torigin: \u0026MultiLocation,\n\t\tinstructions: \u0026mut [Instruction\u003cRuntimeCall\u003e],\n\t\t_max_weight: XCMWeight,\n\t\t_weight_credit: \u0026mut XCMWeight,\n\t) -\u003e Result\u003c(), ()\u003e {\n\t\tif instructions.iter().any(|inst| {\n\t\t\tmatches!(\n\t\t\t\tinst,\n\t\t\t\tInitiateReserveWithdraw {\n\t\t\t\t\treserve: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t..\n\t\t\t\t} | DepositReserveAsset { dest: MultiLocation { parents: 1, interior: Here }, .. } |\n\t\t\t\t\tTransferReserveAsset {\n\t\t\t\t\t\tdest: MultiLocation { parents: 1, interior: Here },\n\t\t\t\t\t\t..\n\t\t\t\t\t}\n\t\t\t)\n\t\t}) {\n\t\t\treturn Err(()) // Deny\n\t\t}\n\n\t\t// allow reserve transfers to arrive from relay chain\n\t\tif matches!(origin, MultiLocation { parents: 1, interior: Here }) \u0026\u0026\n\t\t\tinstructions.iter().any(|inst| matches!(inst, ReserveAssetDeposited { .. }))\n\t\t{\n\t\t\tlog::warn!(\n\t\t\t\ttarget: \"xcm::barriers\",\n\t\t\t\t\"Unexpected ReserveAssetDeposited from the relay chain\",\n\t\t\t);\n\t\t}\n\t\t// Permit everything else\n\t\tOk(())\n\t}\n}\n\npub type Barrier = AllowUnpaidExecutionFrom\u003cEverything\u003e;\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n\ttype RuntimeCall = RuntimeCall;\n\ttype XcmSender = XcmRouter;\n\t// How to withdraw and deposit an asset.\n\ttype AssetTransactor = FungiblesTransactor;\n\ttype OriginConverter = XcmOriginToTransactDispatchOrigin;\n\ttype IsReserve = MultiNativeAsset\u003cRelativeReserveProvider\u003e;\n\t// Teleporting is disabled.\n\ttype IsTeleporter = ();\n\ttype UniversalLocation = UniversalLocation;\n\ttype Barrier = Barrier;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype Trader =\n\t\tUsingComponents\u003cWeightToFee, RelayLocation, AccountId, Balances, ToAuthor\u003cRuntime\u003e\u003e;\n\ttype ResponseHandler = PolkadotXcm;\n\ttype AssetTrap = PolkadotXcm;\n\ttype AssetLocker = ();\n\ttype AssetExchanger = ();\n\ttype AssetClaims = PolkadotXcm;\n\ttype SubscriptionService = PolkadotXcm;\n\ttype PalletInstancesInfo = crate::AllPalletsWithSystem;\n\ttype MaxAssetsIntoHolding = ConstU32\u003c8\u003e;\n\ttype FeeManager = ();\n\ttype MessageExporter = ();\n\ttype UniversalAliases = Nothing;\n\ttype CallDispatcher = RuntimeCall;\n\ttype SafeCallFilter = Everything;\n}\n\n/// No local origins on this chain are allowed to dispatch XCM sends/executions.\npub type LocalOriginToLocation = SignedToAccountId32\u003cRuntimeOrigin, AccountId, RelayNetwork\u003e;\n\n/// The means for routing XCM messages which are not for local execution into the right message\n/// queues.\npub type XcmRouter = (\n\t// Two routers - use UMP to communicate with the relay chain:\n\tcumulus_primitives_utility::ParentAsUmp\u003cParachainSystem, PolkadotXcm, ()\u003e,\n\t// ..and XCMP to communicate with the sibling chains.\n\tXcmpQueue,\n);\n\nimpl pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Currency = Balances;\n\ttype CurrencyMatcher = ();\n\ttype SendXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmRouter = XcmRouter;\n\ttype ExecuteXcmOrigin = EnsureXcmOrigin\u003cRuntimeOrigin, LocalOriginToLocation\u003e;\n\ttype XcmExecuteFilter = Everything;\n\t// ^ Disable dispatchable execute on the XCM pallet.\n\t// Needs to be `Everything` for local testing.\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype XcmTeleportFilter = Nothing;\n\ttype XcmReserveTransferFilter = Everything;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype UniversalLocation = UniversalLocation;\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\n\tconst VERSION_DISCOVERY_QUEUE_SIZE: u32 = 100;\n\t// ^ Override for AdvertisedXcmVersion default\n\ttype AdvertisedXcmVersion = pallet_xcm::CurrentXcmVersion;\n\ttype TrustedLockers = ();\n\ttype SovereignAccountOf = LocationToAccountId;\n\ttype MaxLockers = ConstU32\u003c8\u003e;\n\ttype WeightInfo = crate::weights::pallet_xcm::WeightInfo\u003cRuntime\u003e;\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\ttype ReachableDest = ReachableDest;\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\nparameter_types! {\n\tpub ReachableDest: Option\u003cMultiLocation\u003e = Some(Parent.into());\n}\n\nparameter_type_with_key! {\n\tpub ParachainMinFee: |_location: MultiLocation| -\u003e Option\u003cu128\u003e {\n\t\tNone\n\t};\n}\n\nimpl orml_xtokens::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Balance = Balance;\n\ttype CurrencyId = CurrencyId;\n\ttype CurrencyIdConvert = CurrencyIdConvert;\n\ttype AccountIdToMultiLocation = AccountIdToMultiLocation;\n\ttype SelfLocation = SelfLocation;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n\ttype Weigher = FixedWeightBounds\u003cUnitWeightCost, RuntimeCall, MaxInstructions\u003e;\n\ttype BaseXcmWeight = BaseXcmWeight;\n\ttype MaxAssetsForTransfer = MaxAssetsForTransfer;\n\ttype MinXcmFee = ParachainMinFee; //TODO to support hrmp transfer beetween parachain adjust this parameter\n\ttype MultiLocationsFilter = Everything;\n\ttype ReserveProvider = RelativeReserveProvider;\n\ttype UniversalLocation = UniversalLocation;\n}\n\npub struct AccountIdToMultiLocation;\nimpl Convert\u003cAccountId, MultiLocation\u003e for AccountIdToMultiLocation {\n\tfn convert(account: AccountId) -\u003e MultiLocation {\n\t\tMultiLocation {\n\t\t\tparents: 0,\n\t\t\tinterior: X1(AccountId32 { network: None, id: account.into() }),\n\t\t}\n\t}\n}\n\nimpl cumulus_pallet_xcm::Config for Runtime {\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype XcmExecutor = XcmExecutor\u003cXcmConfig\u003e;\n}\n","traces":[{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":22},{"path":["/","Users","marcel","Documents","pendulum","runtime","pendulum","src","zenlink.rs"],"content":"use core::convert::TryInto;\n\nuse super::*;\n\nuse orml_traits::MultiCurrency;\nuse sp_runtime::{DispatchError, DispatchResult};\nuse sp_std::marker::PhantomData;\n\nuse spacewalk_primitives::CurrencyId;\n\nuse zenlink_protocol::{\n\tAssetId, Config as ZenlinkConfig, GenerateLpAssetId, LocalAssetHandler, ZenlinkMultiAssets,\n};\npub type ZenlinkAssetId = zenlink_protocol::AssetId;\n\nuse runtime_common::{zenlink, zenlink::*};\n\npub struct ZenlinkLPGenerate\u003cT\u003e(PhantomData\u003cT\u003e);\nimpl\u003cT: ZenlinkConfig\u003e GenerateLpAssetId\u003cZenlinkAssetId\u003e for ZenlinkLPGenerate\u003cT\u003e {\n\tfn generate_lp_asset_id(\n\t\tasset_0: ZenlinkAssetId,\n\t\tasset_1: ZenlinkAssetId,\n\t) -\u003e Option\u003cZenlinkAssetId\u003e {\n\t\tzenlink::generate_lp_asset_id(asset_0, asset_1, ParachainInfo::parachain_id().into())\n\t}\n}\n\nparameter_types! {\n\tpub SelfParaId: u32 = ParachainInfo::parachain_id().into();\n\tpub const ZenlinkPalletId: PalletId = PalletId(*b\"/zenlink\");\n\tpub ZenlinkRegisteredParaChains: Vec\u003c(MultiLocation, u128)\u003e = vec![];\n}\nimpl ZenlinkConfig for Runtime {\n\ttype RuntimeEvent = super::RuntimeEvent;\n\ttype MultiAssetsHandler = MultiAssets;\n\ttype PalletId = ZenlinkPalletId;\n\ttype AssetId = AssetId;\n\ttype LpGenerate = ZenlinkLPGenerate\u003cSelf\u003e;\n\ttype TargetChains = ZenlinkRegisteredParaChains;\n\ttype SelfParaId = SelfParaId;\n\ttype WeightInfo = ();\n}\n\ntype MultiAssets = ZenlinkMultiAssets\u003cZenlinkProtocol, Balances, LocalAssetAdaptor\u003cTokens\u003e\u003e;\n\npub struct LocalAssetAdaptor\u003cLocal\u003e(PhantomData\u003cLocal\u003e);\n\nimpl\u003cLocal, AccountId\u003e LocalAssetHandler\u003cAccountId\u003e for LocalAssetAdaptor\u003cLocal\u003e\nwhere\n\tLocal: MultiCurrency\u003cAccountId, CurrencyId = CurrencyId\u003e,\n{\n\tfn local_balance_of(asset_id: ZenlinkAssetId, who: \u0026AccountId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::free_balance(currency_id, \u0026who))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_total_supply(asset_id: ZenlinkAssetId) -\u003e AssetBalance {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\treturn TryInto::\u003cAssetBalance\u003e::try_into(Local::total_issuance(currency_id))\n\t\t\t\t.unwrap_or_default()\n\t\t}\n\t\tAssetBalance::default()\n\t}\n\n\tfn local_is_exists(asset_id: ZenlinkAssetId) -\u003e bool {\n\t\tmatch zenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into()) {\n\t\t\tOk(_) =\u003e true,\n\t\t\tErr(_) =\u003e false,\n\t\t}\n\t}\n\n\tfn local_transfer(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\ttarget: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e DispatchResult {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::transfer(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\t\u0026target,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local transfer\"))?,\n\t\t\t)\n\t\t} else {\n\t\t\tErr(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\t}\n\n\tfn local_deposit(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::deposit(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local deposit\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n\n\tfn local_withdraw(\n\t\tasset_id: ZenlinkAssetId,\n\t\torigin: \u0026AccountId,\n\t\tamount: AssetBalance,\n\t) -\u003e Result\u003cAssetBalance, DispatchError\u003e {\n\t\tif let Ok(currency_id) =\n\t\t\tzenlink_id_to_currency_id(asset_id, ParachainInfo::parachain_id().into())\n\t\t{\n\t\t\tLocal::withdraw(\n\t\t\t\tcurrency_id,\n\t\t\t\t\u0026origin,\n\t\t\t\tamount\n\t\t\t\t\t.try_into()\n\t\t\t\t\t.map_err(|_| DispatchError::Other(\"convert amount in local withdraw\"))?,\n\t\t\t)?;\n\t\t} else {\n\t\t\treturn Err(DispatchError::Other(\"unknown asset in local transfer\"))\n\t\t}\n\n\t\tOk(amount)\n\t}\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":44}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>